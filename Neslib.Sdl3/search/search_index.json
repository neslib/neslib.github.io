{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Neslib.Sdl3","text":"<p>Delphi bindings and OOP-like wrappers for SDL3.</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>Neslib.Sdl3 is supported on these platforms:</p> <ul> <li>Windows (32-bit and 64-bit).</li> <li>macOS (currently 64-bit Intel only. ARM support will be added later).</li> <li>iOS (64-bit device only).</li> <li>Android (32-bit and 64-bit)/</li> </ul> <p>We provide the static and dynamic libraries for these platforms, so everything you need is contained in this repository. For Windows, you need to deploy the SDL3.dll file with your application. You can find this is the \"Deploy\\Win32\" or \"Deploy\\Win64\" directory. For the other platforms, a static library is used that is linked directly into the application, so there is no need to deploy anything.</p>"},{"location":"#api-levels","title":"API Levels","text":"<p>We provide 2 API levels:</p> <ul> <li>A low level API that uses the C API directly. This API is contained in a single unit called <code>Neslib.Sdl3.Api.pas</code>, which contains the SDL C header translations (which have been generated using Chet and cleaned up by hand).</li> <li>A higher level OOP-like API, that can be found in the other <code>Neslib.Sdl3.*.pas</code> units. These form a very lightweight (often zero-overhead) layer on top of the SDL3 C API's. These OOP-like APIs are more type-safe and are more natural to use for Delphi developers. Since these API's are very lightweight, it is recommended to use them instead of the C APIs.</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>Like SDL3 itself, Neslib.Sdl3 is very well documented.</p> <p>If you plan to use the C API, you can use the official SDL3 Wiki documentation.</p> <p>For the OOP-like API, use the API by category page as a starting point, or the API Reference pages for complete documentation by unit. This documentation is extracted from the source code, so you can use the (XML) documentation in the source code as well. Delphi's CodeInsight will also show this documentation when you hover the mouse over an SDL declaration.</p>"},{"location":"#examples","title":"Examples","text":"<p>The Examples directory contains Delphi versions of some SDL3 examples. These all use the OOP-like Delphi API instead of the C API. </p> <p>These examples should give you a good head start. The easiest way to create your own SDL3 application is to copy and rename one of these examples and work from there.</p>"},{"location":"#platform-specifics","title":"Platform Specifics","text":"<p>Some platforms require some additional setup.</p>"},{"location":"#windows","title":"Windows","text":"<p>There are no additional requirements other than deploying the 32-bit or 64-bit version of SDL3.dll with your application.</p>"},{"location":"#macos","title":"macOS","text":"<p>Only Intel macOS is currently supported (since I don't have an ARM Mac to test on).</p> <p>You don't need to deploy any files. The SDL library is linked into the application.</p> <p>You may need to add the following frameworks to the SDK manager if you haven't done so already:</p> <ul> <li>AudioToolbox</li> <li>CoreHaptics</li> <li>ForceFeedback</li> <li>GameController</li> <li>UniformTypeIdentifiers</li> </ul> <p>To add these in Delphi:</p> <ul> <li>Choose \"Tools | Options... | Deployment | SDK Manager\".</li> <li>Select the desired macOS SDK in the \"SDK versions\" list.</li> <li>Click the \"Add a new path item\" glyph button near the top-right. In the window that appears, enter:</li> <li>Path on remote machine: $(SDKROOT)/System/Library/Frameworks</li> <li>Framework name: the name of the framework (from the list above)</li> <li>Set Path type to Framework.</li> <li>Don't forget to click the \"Update Local File Cache\" button once you have added these frameworks.</li> </ul>"},{"location":"#ios","title":"iOS","text":"<p>Only deploying to an actual iOS device is supported. The simulator is not supported since it is not supported by the underlying SDL library.</p> <p>You don't need to deploy any files. The SDL library is linked into the application.</p> <p>You may need to add the following frameworks to the SDK manager if you haven't sone so already (see above under macOS for instructions on how to add them):</p> <ul> <li>CoreHaptics</li> <li>CoreMotion</li> <li>GameController</li> </ul>"},{"location":"#android","title":"Android","text":"<p>You don't need to deploy any files. The SDL library is linked into the application.</p> <p>You need to add the \"sdl3.jar\" Java archive to your applications though (for both 32-bit and 64-bit build):</p> <ul> <li>In the project window, open the \"Android 32-bit\" or (\"Android 64-bit\") target.</li> <li>Right-click on the \"Libraries\" node and choose \"Add...\"</li> <li>Add the \"sdl3.jar\" file, which you can find in the \"Neslib.Sdl3\\Deploy\" directory.</li> </ul> <p>Future Delphi versions may change the list of .jar files, leading to compilation errors. When that happens, right-click the \"Libraries\" node and select \"Revert System Files to Default\". This should keep the \"sdl3.jar\" file, but you can always re-add it if it doesn't.</p>"},{"location":"#license","title":"License","text":"<p>Both SDL3 and Neslib.Sdl3 are released under the zlib license. See LICENSE.txt for details.</p>"},{"location":"APIByCategory/","title":"Neslib.Sdl3 API by Category","text":"<p>Every Neslib.Sdl3 unit roughly represents a category of SDL3 APIs:</p> Unit Description Neslib.Sdl3 Defines the <code>TSdlApp</code> class, which is the entry point for all SDL applications. Neslib.Sdl3.Basics Provides basic functionality such as initializing SDL subsystems, configuration variables (called Hints), a property bag, error handling, logging and version information. Neslib.Sdl3.Video Takes care of display, surface and window management, accelerated rendering and webcam access. Neslib.Sdl3.Input Handles input from various devices such as mouse, keyboard, touch, pen, joysticks, gamepads and sensors. Neslib.Sdl3.Events For handling all sorts of events, from events coming from input devices, windows and clipboard to custom user events. Neslib.Sdl3.Haptic Force Feedback (haptic) support. Neslib.Sdl3.Audio Audio playback, recording and mixing. Neslib.Sdl3.Gpu 3D rendering and GPU Compute functionality. Neslib.Sdl3.Time Timer support. Neslib.Sdl3.IO I/O streams, async I/O and storage abstraction. Neslib.Sdl3.Additional Various additional features such as clipboard access, CPU information, file dialogs, message boxes and tray menus."},{"location":"APIByCategory/Neslib.Sdl3.Additional/","title":"Neslib.Sdl3.Additional","text":"<p>Reference</p> <p>Neslib.Sdl3.Additional</p>"},{"location":"APIByCategory/Neslib.Sdl3.Additional/#cpu-feature-detection","title":"CPU Feature Detection","text":"<p>These functions are largely concerned with reporting if the system has access to various SIMD instruction sets, but also has other important info to share, such as system RAM size and number of logical CPU cores.</p> <p>CPU instruction set checks, like TSdlCpu.HasSse and TSdlCpu.HasNeon, are available on all platforms, even if they don't make sense (an ARM processor will never have SSE and an x86 processor will never have NEON, for example, but these functions still exist and will simply return False in these cases).</p>"},{"location":"APIByCategory/Neslib.Sdl3.Additional/#process-control","title":"Process Control","text":"<p>These functions provide a cross-platform way to spawn and manage OS-level processes.</p> <p>You can create a new subprocess with TSdlProcess and optionally read and write to it using TSdlProcess.Read or TSdlProcess.Input and TSdlProcess.Output. If more advanced functionality like chaining input between processes is necessary, you can use the TSdlProcess.Create constructor that takes a set of properties.</p> <p>You can get the status of a created process with TSdlProcess.Wait, or terminate the process with TSdlProcess.Kill.</p> <p>Don't forget to call TSdlProcess.Free to clean up, whether the process process was killed, terminated on its own, or is still running!</p>"},{"location":"APIByCategory/Neslib.Sdl3.Additional/#power-management-status","title":"Power Management Status","text":"<p>There is a single function in this category: SdlGetPowerInfo.</p> <p>This function is useful for games on the go. This allows an app to know if it's running on a draining battery, which can be useful if the app wants to reduce processing, or perhaps framerate, to extend the duration of the battery's charge. Perhaps the app just wants to show a battery meter when fullscreen, or alert the user when the power is getting extremely low, so they can save their game.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Additional/#message-boxes","title":"Message Boxes","text":"<p>SDL offers a simple message box API, which is useful for simple alerts, such as informing the user when something fatal happens at startup without the need to build a UI for it (or informing the user before your UI is ready).</p> <p>These message boxes are native system dialogs where possible.</p> <p>There is both a customizable function (SdlShowMessageBox) that offers lots of options for what to display and reports on what choice the user made, and also a much-simplified version (SdlShowSimpleMessageBox), merely takes a text message and title, and waits until the user presses a single \"OK\" UI button. Often, this is all that is necessary.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Additional/#file-dialogs","title":"File Dialogs","text":"<p>SDL offers file dialogs, to let users select files with native GUI interfaces. There are \"open\" dialogs, \"save\" dialogs, and folder selection dialogs. All are centered around then TSdlDialog record. The app can control some details, such as filtering to specific files, or whether multiple files can be selected by the user.</p> <p>Note that launching a file dialog is a non-blocking operation; control returns to the app immediately, and a callback is called later (possibly in another thread) when the user makes a choice.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Additional/#system-tray","title":"System Tray","text":"<p>SDL offers a way to add items to the \"system tray\" (more correctly called the \"notification area\" on Windows). On platforms that offer this concept, an SDL app can add a tray icon (TSdlTray), submenus (TSdlTrayMenu), checkboxes and clickable entries (TSdlTrayEntry), and register a callback that is fired when the user clicks on these pieces.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Additional/#locale-info","title":"Locale Info","text":"<p>This provides a way to get a list of preferred locales (language plus country) for the user. The property TSdlLocale.PreferredLocales handles all the heavy lifting, and offers documentation on all the strange ways humans might have configured their language settings.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Additional/#platform-specific-functionality","title":"Platform-specific Functionality","text":"<p>Platform-specific SDL API functions. These are functions that deal with needs of specific operating systems, that didn't make sense to offer as platform-independent, generic APIs.</p> <p>Most apps can make do without these functions, but they can be useful for integrating with other parts of a specific system, adding platform-specific polish to an app, or solving problems that only affect one target.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Additional/#runtime-library","title":"Runtime Library","text":"<p>SDL provides its own implementation of some of the most important C and Delphi runtime functions. The SDL implementations work identically across platforms.</p> <p>SDL also offers other runtime-adjacent functionality in this unit that either isn't, strictly speaking, part of any runtime standards, like SdlCrc32 etc.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Audio/","title":"Neslib.Sdl3.Audio","text":"<p>Reference</p> <p>Neslib.Sdl3.Audio</p> <p>All audio in SDL3 revolves around TSdlAudioStream. Whether you want to play or record audio, convert it, stream it, buffer it, or mix it, you're going to be passing it through an audio stream.</p> <p>Audio streams are quite flexible; they can accept any amount of data at a time, in any supported format, and output it as needed in any other format, even if the data format changes on either side halfway through.</p> <p>An app opens an audio device and binds any number of audio streams to it, feeding more data to the streams as available. When the device needs more data, it will pull it from all bound streams and mix them together for playback.</p> <p>Audio streams can also use an app-provided callback to supply data on-demand, which maps pretty closely to the SDL2 audio model.</p> <p>SDL also provides a simple .WAV loader with TSdlAudioBuffer.CreateFromWav as a basic means to load sound data into your program. This constructor can load a WAV file from a file or from a TSdlIOStream.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Audio/#logical-audio-devices","title":"Logical audio devices","text":"<p>In SDL3, opening a physical device (like a SoundBlaster 16 Pro) gives you a logical device ID that you can bind audio streams to. In almost all cases, logical devices can be used anywhere in the API that a physical device is normally used. However, since each device opening generates a new logical device, different parts of the program (say, a VoIP library, or text-to-speech framework, or maybe some other sort of mixer on top of SDL) can have their own device opens that do not interfere with each other; each logical device will mix its separate audio down to a single buffer, fed to the physical device, behind the scenes. As many logical devices as you like can come and go; SDL will only have to open the physical device at the OS level once, and will manage all the logical devices on top of it internally.</p> <p>One other benefit of logical devices: if you don't open a specific physical device, instead opting for the default, SDL can automatically migrate those logical devices to different hardware as circumstances change: a user plugged in headphones? The system default changed? SDL can transparently migrate the logical devices to the correct physical device seamlessly and keep playing; the app doesn't even have to know it happened if it doesn't want to.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Audio/#simplified-audio","title":"Simplified audio","text":"<p>As a simplified model for when a single source of audio is all that's needed, an app can use a version of TSdlAudioStream.Create that opens an audio device, creates an audio stream, binds that stream to the newly-opened device, and (optionally) provides a callback for obtaining audio data. When using this constructor, the primary interface is the TSdlAudioStream and the device handle is mostly hidden away; destroying a stream created through this constructor will also close the device, stream bindings cannot be changed, etc. One other quirk of this is that the device is started in a paused state and must be explicitly resumed; this is partially to offer a clean migration for SDL2 apps and partially because the app might have to do more setup before playback begins; in the non-simplified form, nothing will play until a stream is bound to a device, so they start unpaused.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Audio/#channel-layouts","title":"Channel layouts","text":"<p>Audio data passing through SDL is uncompressed PCM data, interleaved. One can provide their own decompression through an MP3, etc, decoder, but SDL does not provide this directly. Each interleaved channel of data is meant to be in a specific order.</p> <p>Abbreviations:</p> <ul> <li>FRONT = single mono speaker</li> <li>FL = front left speaker</li> <li>FR = front right speaker</li> <li>FC = front center speaker</li> <li>BL = back left speaker</li> <li>BR = back right speaker</li> <li>SR = surround right speaker</li> <li>SL = surround left speaker</li> <li>BC = back center speaker</li> <li>LFE = low-frequency speaker</li> </ul> <p>These are listed in the order they are laid out in memory, so \"FL, FR\" means \"the front left speaker is laid out in memory first, then the front right, then it repeats for the next audio frame\".</p> <ul> <li>1 channel (mono) layout: FRONT</li> <li>2 channels (stereo) layout: FL, FR</li> <li>3 channels (2.1) layout: FL, FR, LFE</li> <li>4 channels (quad) layout: FL, FR, BL, BR</li> <li>5 channels (4.1) layout: FL, FR, LFE, BL, BR</li> <li>6 channels (5.1) layout: FL, FR, FC, LFE, BL, BR (last two can also be SL, SR)</li> <li>7 channels (6.1) layout: FL, FR, FC, LFE, BC, SL, SR</li> <li>8 channels (7.1) layout: FL, FR, FC, LFE, BL, BR, SL, SR</li> </ul> <p>This is the same order as DirectSound expects, but applied to all platforms; SDL will swizzle the channels as necessary if a platform expects something different.</p> <p>TSdlAudioStream can also be provided channel maps to change this ordering to whatever is necessary, in other audio processing scenarios.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Basics/","title":"Neslib.Sdl3.Basics","text":"<p>Reference</p> <p>Neslib.Sdl3.Basics</p>"},{"location":"APIByCategory/Neslib.Sdl3.Basics/#initialization-and-shutdown","title":"Initialization and Shutdown","text":"<p>All SDL programs need to initialize the library before starting to work with it.</p> <p>Almost everything can simply call SdlInit near startup, with a handful of flags to specify subsystems to touch. These are here to make sure SDL does not even attempt to touch low-level pieces of the operating system that you don't intend to use. For example, you might be using SDL for video and input but chose an external library for audio, and in this case you would just need to leave off the <code>TSdlInitFlag.Audio</code> flag to make sure that external library has complete control.</p> <p>Most apps, when terminating, should call SdlQuit. This will clean up (nearly) everything that SDL might have allocated, and crucially, it'll make sure that the display's resolution is back to what the user expects if you had previously changed it for your game.</p> <p>SDL3 apps are strongly encouraged to call SdlSetAppMetadata(AAppName, AAppVersion, AAppIdentifier: String) at startup to fill in details about the program. This is completely optional, but it helps in small ways (we can provide an About dialog box for the macOS menu, we can name the app in the system's audio mixer, etc). Those that want to provide a lot of information should look at the more-detailed SdlSetAppMetadata(AName, AValue: String).</p>"},{"location":"APIByCategory/Neslib.Sdl3.Basics/#configuration-variables","title":"Configuration Variables","text":"<p>TSdlHints contains functions to set and get configuration hints, as well as listing each of them alphabetically.</p> <p>In general these hints are just that - they may or may not be supported or applicable on any given platform, but they provide a way for an application or user to give the library a hint as to how they would like the library to work.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Basics/#properties","title":"Properties","text":"<p>A property is a variable that can be created and retrieved by name at runtime.</p> <p>All properties are part of a property bag (or property group) called TSdlProperties. A list of available properties is available as constants in the TSdlProperty record, and these key by of various types, such as strings, integer numbers, floating point numbers and Booleans (see TSdlPropertyType).</p>"},{"location":"APIByCategory/Neslib.Sdl3.Basics/#error-handling","title":"Error Handling","text":"<p>When an SDL API returns an error, the TSdlApp.HandleError method is called. By default, this method raises an exception of type ESdlError, but you can override this method perform some other action, such as logging the error instead.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Basics/#log-handling","title":"Log Handling","text":"<p>TSdlLog enables simple log messages with priorities and categories. A message's TSdlLogPriority signifies how important the message is. A message's TSdlLogCategory signifies from what domain it belongs to. Every category has a minimum priority specified: when a message belongs to that category, it will only be sent out if it has that minimum priority or higher.</p> <p>SDL's own logs are sent below the default priority threshold, so they are quiet by default.</p> <p>You can change the log verbosity programmatically using TSdlLog.Priorities or with TSdlHints.Logging, or with the <code>SDL_LOGGING</code> environment variable. This variable is a comma separated set of category=level tokens that define the default logging levels for SDL applications.</p> <p>The category can be a numeric category, one of \"app\", \"error\", \"assert\", \"system\", \"audio\", \"video\", \"render\", \"input\", \"test\", or * for any unspecified category.</p> <p>The level can be a numeric level, one of \"trace\", \"verbose\", \"debug\", \"info\", \"warn\", \"error\", \"critical\", or \"quiet\" to disable that category.</p> <p>You can omit the category if you want to set the logging level for all categories.</p> <p>If this hint isn't set, the default log levels are equivalent to:</p> <p><code>app=info,assert=warn,test=verbose,*=error</code></p> <p>Here's where the messages go on different platforms:</p> <ul> <li>Windows: debug output stream</li> <li>Android: log output</li> <li>Others: standard error output (stderr)</li> </ul> <p>You don't need to have a newline (#10) on the end of messages, the functions will do that for you. For consistent behavior cross-platform, you shouldn't have any newlines in messages, such as to log multiple lines in one call; unusual platform-specific behavior can be observed in such usage. Do one log call per line instead, with no newlines in messages.</p> <p>Each log call is atomic, so you won't see log messages cut off one another when logging from multiple threads.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Basics/#version-information","title":"Version Information","text":"<p>TSdlVersion provides functionality to query the current SDL version, both as headers the app was compiled against, and a library the app is linked to.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Events/","title":"Neslib.Sdl3.Events","text":"<p>Reference</p> <p>Neslib.Sdl3.Events</p> <p>Event queue management.</p> <p>It's extremely common--often required--that an app deal with SDL's event queue. Almost all useful information about interactions with the real world flow through here: the user interacting with the computer and app, hardware coming and going, the system changing in some way, etc.</p> <p>An app generally takes a moment, perhaps at the start of a new frame, to examine any events that have occurred since the last time and process or ignore them. This is generally done by overriding TSdlApp.Event (which is called for each event, just before TSdlApp.Iterate is called).</p> <p>There is other forms of control, too: TSdlEvents.Peep has more functionality at the cost of more complexity, and TSdlEvents.Wait can block the process until something interesting happens, which might be beneficial for certain types of programs on low-power hardware. One may also call TSdlEvents.AddWatch to set a callback when new events arrive.</p> <p>The app is free to generate their own events, too: TSdlEvents.Push allows the app to put events onto the queue for later retrieval; TSdlEvents.Register can guarantee that these events have a type that isn't in use by other parts of the system.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Gpu/","title":"Neslib.Sdl3.Gpu","text":"<p>Reference</p> <p>Neslib.Sdl3.Gpu</p> <p>The GPU API offers a cross-platform way for apps to talk to modern graphics hardware. It offers both 3D graphics and compute support, in the style of Metal, Vulkan, and Direct3D 12.</p> <p>A basic workflow might be something like this:</p> <p>The app creates a TSdlGpuDevice and assigns it to a window with TSdlGpuDevice.ClaimWindow--although strictly speaking you can render offscreen entirely, perhaps for image processing, and not use a window at all.</p> <p>Next the app prepares static data (things that are created once and used over and over). For example:</p> <ul> <li>Shaders (programs that run on the GPU): use TSdlGpuShader.</li> <li>Vertex buffers (arrays of geometry data) and other data rendering will need: use TSdlGpuCopyPass.UploadToBuffer.</li> <li>Textures (images): use TSdlGpuCopyPass.UploadToTexture.</li> <li>Samplers (how textures should be read from): use TSdlGpuSampler.</li> <li>Render pipelines (precalculated rendering state): use TSdlGpuGraphicsPipeline.</li> </ul> <p>To render, the app creates one or more command buffers, with TSdlGpuDevice.AcquireCommandBuffer. Command buffers collect rendering instructions that will be submitted to the GPU in batch. Complex scenes can use multiple command buffers, maybe configured across multiple threads in parallel, as long as they are submitted in the correct order, but many apps will just need one command buffer per frame.</p> <p>Rendering can happen to a texture (what other APIs call a \"render target\") or it can happen to the swapchain texture (which is just a special texture that represents a window's contents). The app can use TSdlGpuCommandBuffer.WaitAndAcquireSwapchainTexture to render to the window.</p> <p>Rendering actually happens in a Render Pass, which is encoded into a command buffer. One can encode multiple render passes (or alternate between render and compute passes) in a single command buffer, but many apps might simply need a single render pass in a single command buffer. Render Passes can render to up to four color textures and one depth texture simultaneously. If the set of textures being rendered to needs to change, the Render Pass must be ended and a new one must be begun.</p> <p>The app calls TSdlGpuCommandBuffer.BeginRenderPass. Then it sets states it needs for each draw:</p> <ul> <li>TSdlGpuRenderPass.BindPipeline</li> <li>TSdlGpuRenderPass.SetViewport</li> <li>TSdlGpuRenderPass.BindVertexBuffers</li> <li>TSdlGpuRenderPass.BindVertexSamplers</li> <li>etc</li> </ul> <p>Then, make the actual draw commands with these states:</p> <ul> <li>TSdlGpuRenderPass.DrawPrimitives</li> <li>TSdlGpuRenderPass.DrawIndexedPrimitives</li> <li>etc</li> </ul> <p>After all the drawing commands for a pass are complete, the app should call TSdlGpuRenderPass.Finish. Once a render pass ends all render-related state is reset.</p> <p>The app can begin new Render Passes and make new draws in the same command buffer until the entire scene is rendered.</p> <p>Once all of the render commands for the scene are complete, the app calls TSdlGpuCommandBuffer.Submit to send it to the GPU for processing.</p> <p>If the app needs to read back data from texture or buffers, the API has an efficient way of doing this, provided that the app is willing to tolerate some latency. When the app uses TSdlGpuCopyPass.DownloadFromTexture or TSdlGpuCopyPass.DownloadFromBuffer, submitting the command buffer with TSdlGpuCommandBuffer.SubmitAndAcquireFence will return a fence handle that the app can poll or wait on in a thread. Once the fence indicates that the command buffer is done processing, it is safe to read the downloaded data. Make sure to call TSdlGpuDevice.ReleaseFence when done with the fence.</p> <p>The API also has \"compute\" support. The app calls TSdlGpuCommandBuffer.BeginComputePass with compute-writeable textures and/or buffers, which can be written to in a compute shader. Then it sets states it needs for the compute dispatches:</p> <ul> <li>TSdlGpuComputePass.BindPipeline</li> <li>TSdlGpuComputePass.BindStorageBuffers</li> <li>TSdlGpuComputePass.BindStorageTextures</li> </ul> <p>Then, dispatch compute work:</p> <ul> <li>TSdlGpuComputePass.Dispatch</li> </ul> <p>For advanced users, this opens up powerful GPU-driven workflows.</p> <p>Graphics and compute pipelines require the use of shaders, which as mentioned above are small programs executed on the GPU. Each backend (Vulkan, Metal, D3D12) requires a different shader format. When the app creates the GPU device, the app lets the device know which shader formats the app can provide. It will then select the appropriate backend depending on the available shader formats and the backends available on the platform. When creating shaders, the app must provide the correct shader format for the selected backend. If you would like to learn more about why the API works this way, there is a detailed blog post explaining this situation.</p> <p>It is optimal for apps to pre-compile the shader formats they might use, but for ease of use SDL provides a separate project, SDL_shadercross (Github), for performing runtime shader cross-compilation. It also has a CLI interface for offline precompilation as well.</p> <p>This is an extremely quick overview that leaves out several important details. Already, though, one can see that GPU programming can be quite complex! If you just need simple 2D graphics, the Render API is much easier to use but still hardware-accelerated. That said, even for 2D applications the performance benefits and expressiveness of the GPU API are significant.</p> <p>The GPU API targets a feature set with a wide range of hardware support and ease of portability. It is designed so that the app won't have to branch itself by querying feature support. If you need cutting-edge features with limited hardware support, this API is probably not for you.</p> <p>Examples demonstrating proper usage of this API can be found here .</p>"},{"location":"APIByCategory/Neslib.Sdl3.Gpu/#performance-considerations","title":"Performance considerations","text":"<p>Here are some basic tips for maximizing your rendering performance.</p> <ul> <li>Beginning a new render pass is relatively expensive. Use as few render passes as you can.</li> <li>Minimize the amount of state changes. For example, binding a pipeline is relatively cheap, but doing it hundreds of times when you don't need to will slow the performance significantly.</li> <li>Perform your data uploads as early as possible in the frame.</li> <li>Don't churn resources. Creating and releasing resources is expensive. It's better to create what you need up front and cache it.</li> <li>Don't use uniform buffers for large amounts of data (more than a matrix or so). Use a storage buffer instead.</li> <li>Use cycling correctly. There is a detailed explanation of cycling further below.</li> <li>Use culling techniques to minimize pixel writes. The less writing the GPU has to do the better. Culling can be a very advanced topic but even simple culling techniques can boost performance significantly.</li> </ul> <p>In general try to remember the golden rule of performance: doing things is more expensive than not doing things. Don't Touch The Driver!</p>"},{"location":"APIByCategory/Neslib.Sdl3.Gpu/#faq","title":"FAQ","text":"<p>Question: When are you adding more advanced features, like ray tracing or mesh shaders?</p> <p>Answer: We don't have immediate plans to add more bleeding-edge features, but we certainly might in the future, when these features prove worthwhile, and reasonable to implement across several platforms and underlying APIs. So while these things are not in the \"never\" category, they are definitely not \"near future\" items either.</p> <p>Question: Why is my shader not working?</p> <p>Answer: A common oversight when using shaders is not properly laying out the shader resources/registers correctly. The GPU API is very strict with how it wants resources to be laid out and it's difficult for the API to automatically validate shaders to see if they have a compatible layout. See the documentation for TSdlGpuShader and TSdlGpuComputePipeline for information on the expected layout.</p> <p>Another common issue is not setting the correct number of samplers, textures, and buffers in TSdlGpuShaderCreateInfo. If possible use shader reflection to extract the required information from the shader automatically instead of manually filling in the record's values.</p> <p>Question: My application isn't performing very well. Is this the GPU API's fault?</p> <p>Answer: No. Long answer: The GPU API is a relatively thin layer over the underlying graphics API. While it's possible that we have done something inefficiently, it's very unlikely especially if you are relatively inexperienced with GPU rendering. Please see the performance tips above and make sure you are following them. Additionally, tools like RenderDoc can be very helpful for diagnosing incorrect behavior and performance issues.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Gpu/#system-requirements","title":"System Requirements","text":"<p>Vulkan: Supported on Windows, Linux and certain Android devices. Requires Vulkan 1.0 with the following extensions and device features:</p> <ul> <li><code>VK_KHR_swapchain</code></li> <li><code>VK_KHR_maintenance1</code></li> <li><code>independentBlend</code></li> <li><code>imageCubeArray</code></li> <li><code>depthClamp</code></li> <li><code>shaderClipDistance</code></li> <li><code>drawIndirectFirstInstance</code></li> </ul> <p>D3D12: Supported on Windows 10 or newer. Requires a GPU that supports DirectX 12 Feature Level 11_1.</p> <p>Metal: Supported on macOS 10.14+ and iOS/tvOS 13.0+. Hardware requirements vary by operating system:</p> <ul> <li>iOS/tvOS requires an A9 GPU or newer</li> <li>iOS Simulator and tvOS Simulator are unsupported</li> </ul>"},{"location":"APIByCategory/Neslib.Sdl3.Gpu/#uniform-data","title":"Uniform Data","text":"<p>Uniforms are for passing data to shaders. The uniform data will be constant across all executions of the shader.</p> <p>There are 4 available uniform slots per shader stage (where the stages are vertex, fragment, and compute). Uniform data pushed to a slot on a stage keeps its value throughout the command buffer until you call the relevant Push function on that slot again.</p> <p>For example, you could write your vertex shaders to read a camera matrix from uniform binding slot 0, push the camera matrix at the start of the command buffer, and that data will be used for every subsequent draw call.</p> <p>It is valid to push uniform data during a render or compute pass.</p> <p>Uniforms are best for pushing small amounts of data. If you are pushing more than a matrix or two per call you should consider using a storage buffer instead.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Gpu/#a-note-on-cycling","title":"A Note On Cycling","text":"<p>When using a command buffer, operations do not occur immediately - they occur some time after the command buffer is submitted.</p> <p>When a resource is used in a pending or active command buffer, it is considered to be \"bound\". When a resource is no longer used in any pending or active command buffers, it is considered to be \"unbound\".</p> <p>If data resources are bound, it is unspecified when that data will be unbound unless you acquire a fence when submitting the command buffer and wait on it. However, this doesn't mean you need to track resource usage manually.</p> <p>All of the functions and records that involve writing to a resource have a <code>ACycle</code> boolean. TSdlGpuTransferBuffer, TSdlGpuBuffer, and TSdlGpuTexture all effectively function as ring buffers on internal resources. When <code>ACycle</code> is True, if the resource is bound, the cycle rotates to the next unbound internal resource, or if none are available, a new one is created. This means you don't have to worry about complex state tracking and synchronization as long as cycling is correctly employed.</p> <p>For example: you can call TSdlGpuDevice.MapTransferBuffer, write texture data, TSdlGpuDevice.UnmapTransferBuffer, and then TSdlGpuCopyPass.UploadToTexture. The next time you write texture data to the transfer buffer, if you set the <code>ACycle</code> param to True, you don't have to worry about overwriting any data that is not yet uploaded.</p> <p>Another example: If you are using a texture in a render pass every frame, this can cause a data dependency between frames. If you set <code>Cycle</code> to True in the TSdlGpuColorTargetInfo record, you can prevent this data dependency.</p> <p>Cycling will never undefine already bound data. When cycling, all data in the resource is considered to be undefined for subsequent commands until that data is written again. You must take care not to read undefined data.</p> <p>Note that when cycling a texture, the entire texture will be cycled, even if only part of the texture is used in the call, so you must consider the entire texture to contain undefined data after cycling.</p> <p>You must also take care not to overwrite a section of data that has been referenced in a command without cycling first. It is OK to overwrite unreferenced data in a bound resource without cycling, but overwriting a section of data that has already been referenced will produce unexpected results.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Haptic/","title":"Neslib.Sdl3.Haptic","text":"<p>Reference</p> <p>Neslib.Sdl3.Haptic</p> <p>The SDL haptic subsystem manages haptic (force feedback) devices.</p> <p>The basic usage is as follows:</p> <ul> <li>Initialize the subsystem (TSdlInitFlag.Haptic).</li> <li>Open a haptic device.</li> <li>TSdlHaptic.Open to open from index.</li> <li>TSdlHaptic.OpenFromJoystick to open from an existing joystick.</li> <li>Create an effect (TSdlHapticEffect).</li> <li>Upload the effect with TSdlHaptic.CreateEffect.</li> <li>Run the effect with TSdlHaptic.RunEffect.</li> <li>(Optionally) free the effect with TSdlHaptic.FreeEffect (it is also automatically freed when the haptic device is closed).</li> <li>Close the haptic device with TSdlHaptic.Close.</li> </ul> <p>Simple rumble example:</p> <pre><code>{ Open the device }\nvar Devices := TSdlHapticID.Devices;\nif (Devices = nil) then\n  Exit;\n\nvar Haptic := TSdlHaptic.Open(Devices[0]);\ntry\n  { Initialize simple rumble }\n  Haptic.InitRumble;\n\n  { Play effect at 50% strength for 2 seconds }\n  Haptic.PlayRumble(0.5, 2000);\n\n  SdlDelay(2000);\nfinally\n  Haptic.Close;\nend;\n</code></pre> <p>Complete example:</p> <pre><code>function TestHaptic(const AJoystick: TSdlJoystick)\nbegin\n  { Open the device }\n  var Haptic := TSdlHaptic.OpenFromJoystick(AJoystick);\n  try\n    { See if it can do sine waves }\n    if (not (TSdlHapticFeature.Sine in Haptic.Features)) then\n      Exit(False);\n\n    { Create the effect }\n    var Effect: TSdlHapticEffect;\n    FillChar(Effect, SizeOf(Effect), 0);\n    Effect.Kind := TSdlHapticKind.Sine;\n\n    { Use polar coordinates }\n    Effect.Periodic.Direction.Kind := TSdlHapticDirectionKind.Polar;\n\n    { Force comes from south }\n    Effect.Periodic.Direction.Dir[0] := 18000;\n\n    { Repeats every 1 second }\n    Effect.Periodic.Period := 1000; \n\n    { 20000/32767 strength }\n    Effect.Periodic.Magnitude := 20000; \n\n    { 5 seconds long }\n    Effect.Periodic.Length := 5000; \n\n    { Takes 1 second to get max strength }\n    Effect.Periodic.AttackLength := 1000; \n\n    { Takes 1 second to fade away }\n    Effect.Periodic.FadeLength := 1000; \n\n    { Upload the effect }\n    var EffectID := Haptic.CreateEffect(Effect);\n\n    { Test the effect }\n    Haptic.RunEffect(EffectID, 1);\n\n    { Wait for the effect to finish }\n    SdlDelay(5000);\n\n    { We destroy the effect, although closing\n      the device also does this. }\n    Haptic.FreeEffect(EffectID);\n  finally\n    { Close the device }\n    Haptic.Close;\n  end;\n\n  { Success }\n  Result := True;\nend;\n</code></pre> <p>Note that the SDL haptic subsystem is not thread-safe.</p>"},{"location":"APIByCategory/Neslib.Sdl3.IO/","title":"Neslib.Sdl3.IO","text":"<p>Reference</p> <p>Neslib.Sdl3.IO</p>"},{"location":"APIByCategory/Neslib.Sdl3.IO/#storage-abstraction","title":"Storage Abstraction","text":"<p>The storage API is a high-level API designed to abstract away the portability issues that come up when using something lower-level (in SDL's case, this sits on top of the filesystem and IOStream subsystems). It is significantly more restrictive than a typical filesystem API, for a number of reasons:</p> <ol> <li>What to Access: A common pitfall with existing filesystem APIs is the assumption that all storage is monolithic. However, many other platforms (game consoles in particular) are more strict about what type of filesystem is being accessed; for example, game content and user data are usually two separate storage devices with entirely different characteristics (and possibly different low-level APIs altogether!).</li> <li>How to Access: Another common mistake is applications assuming that all storage is universally writeable - again, many platforms treat game content and user data as two separate storage devices, and only user data is writeable while game content is read-only.</li> <li>When to Access: The most common portability issue with filesystem access is timing - you cannot always assume that the storage device is always accessible all of the time, nor can you assume that there are no limits to how long you have access to a particular device.</li> </ol> <p>Consider the following example:</p> <pre><code>procedure ReadGameData(const AFilenames: TArray&lt;String&gt;);\nbegin\n  for var Filename in AFilenames do\n  begin\n    try\n      var Stream := TFileStream.Create(Filename,\n        fmOpenRead or fmShareDenyWrite);\n      try\n        // A bunch of stuff happens here\n      finally\n        Stream.Free;\n      end;\n    except\n      // Something bad happened\n    end;\n  end;\nend;\n\nprocedure ReadSave;\nbegin\n  try\n    var Save := TFileStream.Create('saves/save0.sav',\n      fmOpenRead or fmShareDenyWrite);\n    try\n      // A bunch of stuff happens here\n    finally\n      Stream.Free;\n    end;\n  except\n    // Something bad happened\n  end;\nend;\n\nprocedure WriteSave;\nbegin\n  try\n    var Save := TFileStream.Create('saves/save0.sav', \n      fmCreate or fmShareDenyWrite);\n    try\n      // A bunch of stuff happens here\n    finally\n      Stream.Free;\n    end;\n  except\n    // Something bad happened\n  end;\nend;\n</code></pre> <p>Going over the bullet points again:</p> <ol> <li>What to Access: This code accesses a global filesystem; game data and saves are all presumed to be in the current working directory (which may or may not be the game's installation folder!).</li> <li>How to Access: This code assumes that content paths are writeable, and that save data is also writeable despite being in the same location as the game data.</li> <li>When to Access: This code assumes that they can be called at any time, since the filesystem is always accessible and has no limits on how long the filesystem is being accessed.</li> </ol> <p>Due to these assumptions, the filesystem code is not portable and will fail under these common scenarios:</p> <ul> <li>The game is installed on a device that is read-only, both content loading and game saves will fail or crash outright</li> <li>Game/User storage is not implicitly mounted, so no files will be found for either scenario when a platform requires explicitly mounting filesystems</li> <li>Save data may not be safe since the I/O is not being flushed or validated, so an error occurring elsewhere in the program may result in missing/corrupted save data</li> </ul> <p>When using TSdlStorage, these types of problems are virtually impossible to trip over:</p> <pre><code>procedure ReadGameData(const AFilenames: TArray&lt;String&gt;);\nbegin\n  var Title := TSdlStorage.OpenTitle;\n  try\n    while (not Title.IsReady) do\n      SdlDelay(1);\n\n    for var Filename in AFilenames do\n    begin\n      var Data := Title.ReadFile(Filename);\n      // A bunch of stuff happens here\n    end;\n  finally\n    Title.Free;\n  end;\nend;\n\nprocedure ReadSave;\nbegin\n  var User := TSdlStorage.OpenUser('libsdl', 'Storage Example');\n  try\n    while (not User.IsReady) do\n      SdlDelay(1);\n\n    var Data := User.ReadFile('save0.sav');\n    // A bunch of stuff happens here\n  finally\n    User.Free;\n  end;\nend;\n\nprocedure WriteSave(const AData: TBytes);\nbegin\n  var User := TSdlStorage.OpenUser('libsdl', 'Storage Example');\n  try\n    while (not User.IsReady) do\n      SdlDelay(1);\n\n    // A bunch of stuff happens here\n    User.WriteFile('save0.sav', AData);\n  finally\n    User.Free;\n  end;\nend;\n</code></pre> <p>Note the improvements that TSdlStorage makes:</p> <ol> <li>What to Access: This code explicitly reads from a title or user storage device based on the context of the function.</li> <li>How to Access: This code explicitly uses either a read or write function based on the context of the function.</li> <li>When to Access: This code explicitly opens the device when it needs to, and closes it when it is finished working with the filesystem.</li> </ol> <p>The result is an application that is significantly more robust against the increasing demands of platforms and their filesystems!</p> <p>A publicly available example of an TSdlStorage backend is the Steam Cloud backend - you can initialize Steamworks when starting the program, and then SDL will recognize that Steamworks is initialized and automatically use ISteamRemoteStorage when the application opens user storage. More importantly, when you open storage it knows to begin a \"batch\" of filesystem operations, and when you close storage it knows to end and flush the batch. This is used by Steam to support Dynamic Cloud Sync ; users can save data on one PC, put the device to sleep, and then continue playing on another PC (and vice versa) with the save data fully synchronized across all devices, allowing for a seamless experience without having to do full restarts of the program.</p>"},{"location":"APIByCategory/Neslib.Sdl3.IO/#notes-on-valid-paths","title":"Notes on valid paths","text":"<p>All paths in the Storage API use Unix-style path separators ('/'). Using a different path separator will not work, even if the underlying platform would otherwise accept it. This is to keep code using the Storage API portable between platforms and Storage implementations and simplify app code.</p> <p>Paths with relative directories (\".\" and \"..\") are forbidden by the Storage API.</p> <p>All valid Unicode strings (discounting the '/' path separator) are usable for filenames, however, an underlying Storage implementation may not support particularly strange sequences and refuse to create files with those names, etc.</p>"},{"location":"APIByCategory/Neslib.Sdl3.IO/#io-streams","title":"I/O Streams","text":"<p>SDL provides an abstract interface for reading and writing data streams. It offers implementations for files, memory, etc, and the app can provide their own implementations, too.</p> <p>TSdlIOStream is not related to the standard Delphi stream classes, other than both are abstract interfaces to read/write data.</p>"},{"location":"APIByCategory/Neslib.Sdl3.IO/#async-io","title":"Async I/O","text":"<p>SDL offers a way to perform I/O asynchronously. This allows an app to read or write files without waiting for data to actually transfer; the functions that request I/O never block while the request is fulfilled.</p> <p>Instead, the data moves in the background and the app can check for results at their leisure.</p> <p>This is more complicated than just reading and writing files in a synchronous way, but it can allow for more efficiency, and never having framerate drops as the hard drive catches up, etc.</p> <p>The general usage pattern for async I/O is:</p> <ul> <li>Create one or more TSdlAsyncIOQueue objects.</li> <li>Open files with TSdlAsyncIO.Create.</li> <li>Start I/O tasks to the files with TSdlAsyncIO.Read or TSdlAsyncIO.Write, putting those tasks into one of the queues.</li> <li>Later on, use TSdlAsyncIOQueue.GetResult on a queue to see if any task is finished without blocking. Tasks might finish in any order with success or failure.</li> <li>When all your tasks are done, close the file with TSdlAsyncIO.Free. This also generates a task, since it might flush data to disk!</li> </ul> <p>This all works, without blocking, in a single thread, but one can also wait on a queue in a background thread, sleeping until new results have arrived:</p> <ul> <li>Call TSdlAsyncIOQueue.WaitResult from one or more threads to efficiently block until new tasks complete.</li> <li>When shutting down, call TSdlAsyncIOQueue.Signal to unblock any sleeping threads despite there being no new tasks completed.</li> </ul> <p>And, of course, to match the synchronous SdlLoad, we offer SdlLoadAsync as a convenience routine. This will handle allocating a buffer, slurping in the file data, and null-terminating it; you still check for results later.</p> <p>Behind the scenes, SDL will use newer, efficient APIs on platforms that support them: Linux's io_uring and Windows 11's IoRing, for example. If those technologies aren't available, SDL will offload the work to a thread pool that will manage otherwise-synchronous loads without blocking the app.</p>"},{"location":"APIByCategory/Neslib.Sdl3.IO/#best-practices","title":"Best Practices","text":"<p>Simple non-blocking I/O--for an app that just wants to pick up data whenever it's ready without losing framerate waiting on disks to spin--can use whatever pattern works well for the program. In this case, simply call TSdlAsyncIO.Read, or maybe SdlLoadAsync, as needed. Once a frame, call TSdlAsyncIOQueue.GetResult to check for any completed tasks and deal with the data as it arrives.</p> <p>If two separate pieces of the same program need their own I/O, it is legal for each to create their own queue. This will prevent either piece from accidentally consuming the other's completed tasks. Each queue does require some amount of resources, but it is not an overwhelming cost. Do not make a queue for each task, however. It is better to put many tasks into a single queue. They will be reported in order of completion, not in the order they were submitted, so it doesn't generally matter what order tasks are started.</p> <p>One async I/O queue can be shared by multiple threads, or one thread can have more than one queue, but the most efficient way--if ruthless efficiency is the goal--is to have one queue per thread, with multiple threads working in parallel, and attempt to keep each queue loaded with tasks that are both started by and consumed by the same thread. On modern platforms that can use newer interfaces, this can keep data flowing as efficiently as possible all the way from storage hardware to the app, with no contention between threads for access to the same queue.</p> <p>Written data is not guaranteed to make it to physical media by the time a closing task is completed, unless TSdlAsyncIO.Free is called with its <code>AFlush</code> parameter set to True, which is to say that a successful result here can still result in lost data during an unfortunately-timed power outage if not flushed. However, flushing will take longer and may be unnecessary, depending on the app's needs.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Input/","title":"Neslib.Sdl3.Input","text":"<p>Reference</p> <p>Neslib.Sdl3.Input</p>"},{"location":"APIByCategory/Neslib.Sdl3.Input/#keyboard-support","title":"Keyboard Support","text":"<p>Please refer to the Best Keyboard Practices document for details on how best to accept keyboard input in various types of programs.</p> <p>Keyboard support revolves around the TSdlKeyboard record and the enumerated types TSdlScancode, TSdlKeycode and TSdlKeyMod.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Input/#mouse-support","title":"Mouse Support","text":"<p>Any GUI application has to deal with the mouse, and SDL provides functions to manage mouse input and the displayed cursor.</p> <p>Most interactions with the mouse will come through the event subsystem. Moving a mouse generates an <code>TSdlEventKind.MouseMotion</code> event, pushing a button generates <code>TSdlEventKind.MouseButtonDown</code>, etc, but one can also query the current state of the mouse at any time with TSdlMouse.GetState.</p> <p>For certain games, it's useful to disassociate the mouse cursor from mouse input. An FPS, for example, would not want the player's motion to stop as the mouse hits the edge of the window. For these scenarios, use TSdlWindow.IsRelativeMouseMode, which hides the cursor, grabs mouse input to the window, and reads mouse input no matter how far it moves.</p> <p>Games that want the system to track the mouse but want to draw their own cursor can use TSdlCursor.Hide and TSdlCursor.Show. It might be more efficient to let the system manage the cursor, if possible, using TSdlCursor.Active with a custom image made through TSdlCursor.Create, or perhaps just a specific system cursor from another version of TSdlCursor.Create.</p> <p>SDL can, on many platforms, differentiate between multiple connected mice, allowing for interesting input scenarios and multiplayer games. They can be enumerated with TSdlMouse.Mice, and SDL will send <code>TSdlEventKind.MouseAdded</code> and <code>TSdlEventKind.MouseRemoved</code> events as they are connected and unplugged.</p> <p>Since many apps only care about basic mouse input, SDL offers a virtual mouse device for touch and pen input, which often can make a desktop application work on a touchscreen phone without any code changes. </p>"},{"location":"APIByCategory/Neslib.Sdl3.Input/#joystick-support","title":"Joystick Support","text":"<p>This is the lower-level joystick handling. If you want the simpler option, where what each button does is well-defined, you should use the gamepad API instead.</p> <p>The term \"InstanceID\" is the current instantiation of a joystick device in the system, if the joystick is removed and then re-inserted then it will get a new InstanceID, InstanceID's are monotonically increasing identifiers of a joystick plugged in.</p> <p>The term \"PlayerIndex\" is the number assigned to a player on a specific controller. For XInput controllers this returns the XInput user index. Many joysticks will not be able to supply this information.</p> <p>A joystick device has a stable GUID identifier that does not change over time. It identifies class of the device (a X360 wired controller for example). This identifier is platform dependent.</p> <p>In order to use these functions, SdlInit must have been called with the TSdlInitFlag.Joystick flag. This causes SDL to scan the system for joysticks, and load appropriate drivers.</p> <p>If you would like to receive joystick updates while the application is in the background, you should set the following hint before calling SdlInit: TSdlHints.JoystickAllowBackgroundEvents.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Input/#gamepad-support","title":"Gamepad Support","text":"<p>SDL provides a low-level joystick API, which just treats joysticks as an arbitrary pile of buttons, axes, and hat switches. If you're planning to write your own control configuration screen, this can give you a lot of flexibility, but that's a lot of work, and most things that we consider \"joysticks\" now are actually console-style gamepads. So SDL provides the gamepad API on top of the lower-level joystick functionality.</p> <p>The difference between a joystick and a gamepad is that a gamepad tells you where a button or axis is on the device. You don't speak to gamepads in terms of arbitrary numbers like \"button 3\" or \"axis 2\" but in standard locations: the d-pad, the shoulder buttons, triggers, A/B/X/Y (or X/O/Square/Triangle, if you will).</p> <p>One turns a joystick into a gamepad by providing a magic configuration string, which tells SDL the details of a specific device: when you see this specific hardware, if button 2 gets pressed, this is actually D-Pad Up, etc.</p> <p>SDL has many popular controllers configured out of the box, and users can add their own controller details through an environment variable if it's otherwise unknown to SDL.</p> <p>In order to use these functions, SdlInit must have been called with the TSdlInitFlag.Gamepad flag. This causes SDL to scan the system for gamepads, and load appropriate drivers.</p> <p>If you would like to receive gamepad updates while the application is in the background, you should set the following hint before calling SdlInit: TSdlHints.JoystickAllowBackgroundEvents.</p> <p>Gamepads support various optional features such as rumble, color LEDs, touchpad, gyro, etc. The support for these features varies depending on the controller and OS support available. You can check for LED and rumble capabilities at runtime by using TSdlGamepad.Properties and checking the various capability properties. You can check for touchpad by using TSdlGamepad.NumTouchpads and check for gyro and accelerometer by calling TSdlGamepad.HasSensor.</p> <p>By default SDL will try to use the most capable driver available, but you can tune which OS drivers to use with the various joystick hints in TSdlHints.</p> <p>Your application should always support gamepad hotplugging. On some platforms like Xbox, Steam Deck, etc., this is a requirement for certification. On other platforms, like macOS and Windows when using Windows.Gaming.Input, controllers may not be available at startup and will come in at some point after you've started processing events.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Input/#touch-support","title":"Touch Support","text":"<p>SDL offers touch input, on platforms that support it. It can manage multiple touch devices and track multiple fingers on those devices.</p> <p>Touches are mostly dealt with through the event system, in the <code>TSdlEventKind.FingerDown</code>, <code>TSdlEventKind.FingerMotion</code> and <code>TSdlEventKind.FingerUp</code> events, but there are also functions to query for hardware details, etc.</p> <p>The touch system, by default, will also send virtual mouse events; this can be useful for making a some desktop apps work on a phone without significant changes. </p>"},{"location":"APIByCategory/Neslib.Sdl3.Input/#pen-support","title":"Pen Support","text":"<p>SDL provides an API for pressure-sensitive pen (stylus and/or eraser) handling, e.g., for input and drawing tablets or suitably equipped mobile / tablet devices.</p> <p>To get started with pens, simply handle <code>TSdlEventKind.Pen*</code> events. When a pen starts providing input, SDL will assign it a unique TSdlPenID, which will remain for the life of the process, as long as the pen stays connected.</p> <p>Pens may provide more than simple touch input; they might have other axes, such as pressure, tilt, rotation, etc.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Input/#sensors","title":"Sensors","text":"<p>These APIs grant access to gyros and accelerometers on various platforms.</p> <p>In order to use these functions, SdlInit must have been called with the TSdlInitFlag.Sensor flag. This causes SDL to scan the system for sensors, and load appropriate drivers.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Time/","title":"Neslib.Sdl3.Time","text":"<p>Reference</p> <p>Neslib.Sdl3.Time</p> <p>SDL provides time management functionality. It is useful for dealing with (usually) small durations of time.</p> <p>This category covers measuring time elapsed (SdlGetTicks, SdlGetPerformanceCounter), putting a thread to sleep for a certain amount of time (SdlDelay, SdlDelayNS, SdlDelayPrecise), and firing a callback function after a certain amount of time has elasped (SdlAddTimer, etc).</p> <p>There are also useful functions to convert between time units, like SdlSecondsToNS and such.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Video/","title":"Neslib.Sdl3.Video","text":"<p>Reference</p> <p>Neslib.Sdl3.Video</p>"},{"location":"APIByCategory/Neslib.Sdl3.Video/#display-and-window-management","title":"Display and Window Management","text":"<p>SDL's video subsystem is largely interested in abstracting window management from the underlying operating system. You can create windows, manage them in various ways, set them fullscreen, and get events when interesting things happen with them, such as the mouse or keyboard interacting with a window.</p> <p>The video subsystem is also interested in abstracting away some platform-specific differences in OpenGL: context creation, swapping buffers, etc. This may be crucial to your app, but also you are not required to use OpenGL at all. In fact, SDL can provide rendering to those windows as well, either with an easy-to-use 2D API or with a more-powerful GPU API . Of course, it can simply get out of your way and give you the window handles you need to use Vulkan, Direct3D, Metal, or whatever else you like directly, too.</p> <p>The video subsystem covers a lot of functionality, out of necessity, so it is worth perusing the list of functions just to see what's available, but most apps can get by with simply creating a window and listening for events, so start with TSdlWindow and TSdlApp.Event.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Video/#api2d","title":"2D Accelerated Rendering","text":"<p>TSdlRenderer and related APIs supports the following features:</p> <ul> <li>single pixel points</li> <li>single pixel lines</li> <li>filled rectangles</li> <li>texture images</li> <li>2D polygons</li> </ul> <p>The primitives may be drawn in opaque, blended, or additive modes.</p> <p>The texture images may be drawn in opaque, blended, or additive modes. They can have an additional color tint or alpha modulation applied to them, and may also be stretched with linear interpolation.</p> <p>This API is designed to accelerate simple 2D operations. You may want more functionality such as polygons and particle effects and in that case you should use SDL's OpenGL/Direct3D support, the SDL3 GPU API, or one of the many good 3D engines.</p> <p>These functions must be called from the main thread. See this bug for details.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Video/#pixel-formats-and-conversion-routines","title":"Pixel Formats and Conversion Routines","text":"<p>SDL offers facilities for pixel management.</p> <p>Largely these facilities deal with pixel format (see TSdlPixelFormat).</p> <p>If you mostly want to think of a pixel as some combination of red, green, blue, and maybe alpha intensities, this is all pretty straightforward, and in many cases, is enough information to build a perfectly fine game. See TSdlColor and TSdlColorF.</p> <p>However, the actual definition of a pixel is more complex than that:</p> <p>Pixels are a representation of a color in a particular color space (see TSdlColorspace).</p> <p>The first characteristic of a color space is the color type. SDL understands two different color types, RGB and YCbCr, or in SDL also referred to as YUV.</p> <p>RGB colors consist of red, green, and blue channels of color that are added together to represent the colors we see on the screen.</p> <p>YCbCr colors represent colors as a Y luma brightness component and red and blue chroma color offsets. This color representation takes advantage of the fact that the human eye is more sensitive to brightness than the color in an image. The Cb and Cr components are often compressed and have lower resolution than the luma component.</p> <p>When the color information in YCbCr is compressed, the Y pixels are left at full resolution and each Cr and Cb pixel represents an average of the color information in a block of Y pixels. The chroma location determines where in that block of pixels the color information is coming from.</p> <p>The color range defines how much of the pixel to use when converting a pixel into a color on the display. When the full color range is used, the entire numeric range of the pixel bits is significant. When narrow color range is used, for historical reasons, the pixel uses only a portion of the numeric range to represent colors.</p> <p>The color primaries and white point are a definition of the colors in the color space relative to the standard XYZ color space.</p> <p>The transfer characteristic, or opto-electrical transfer function (OETF), is the way a color is converted from mathematically linear space into a non-linear output signals.</p> <p>The matrix coefficients are used to convert between YCbCr and RGB colors.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Video/#blend-modes","title":"Blend Modes","text":"<p>Blend modes decide how two colors will mix together. There are both standard modes for basic needs and a means to create custom modes, dictating what sort of math to do on what color components. </p> <p>Standard blend modes are defined in TSdlBlendMode, but you can also define custom blend modes using TSdlBlendMode.Compose.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Video/#points-and-rectangles","title":"Points and Rectangles","text":"<p>Some helper APIs for managing rectangles (TSdlRect and TSdlRectF), 2D points (TSdlPoint and TSdlPointF) and 2D sizes (TSdlSize and TSdlSizeF), in both integer and floating point versions.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Video/#surfaces","title":"Surfaces","text":"<p>SDL surfaces are buffers of pixels in system RAM. These are useful for passing around and manipulating images that are not stored in GPU memory.</p> <p>TSdlSurface makes serious efforts to manage images in various formats, and provides a reasonable toolbox for transforming the data, including copying between surfaces, filling rectangles in the image data, etc.</p> <p>There is also a simple .bmp loader, TSdlSurface.LoadBmp. SDL itself does not provide loaders for various other file formats, but there are several excellent external libraries that do, including its own satellite library, SDL_image.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Video/#vulkan-support","title":"Vulkan Support","text":"<p>APS's for creating Vulkan surfaces on SDL windows.</p> <p>For the most part, Vulkan operates independent of SDL, but it benefits from a little support during setup.</p> <p>Use SdlVulkanGetInstanceExtensions to get platform-specific bits for creating a VkInstance, then SdlVulkanGetVkGetInstanceProcAddr to get the appropriate function for querying Vulkan entry points. Then SdlVulkanCreateSurface will get you the final pieces you need to prepare for rendering into an TSdlWindow with Vulkan.</p> <p>Unlike OpenGL, most of the details of \"context\" creation and window buffer swapping are handled by the Vulkan API directly, so SDL doesn't provide Vulkan equivalents of TSdlGL.SwapWindow, etc; they aren't necessary.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Video/#metal-support","title":"Metal Support","text":"<p>API's for creating Metal layers and views (see TSdlMetalView) on SDL windows.</p> <p>This provides some platform-specific glue for Apple platforms. Most macOS and iOS apps can use SDL without these functions, but this API they can be useful for specific OS-level integration tasks.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Video/#camera-support","title":"Camera Support","text":"<p>Video capture for the SDL library.</p> <p>This API lets apps read input from video sources, like webcams. TSdlCamera devices can be enumerated, queried, and opened. Once opened, it will provide TSdlSurface objects as new frames of video come in. These surfaces can be uploaded to an TSdlTexture or processed as pixels in memory.</p> <p>Several platforms will alert the user if an app tries to access a camera, and some will present a UI asking the user if your application should be allowed to obtain images at all, which they can deny. A successfully opened camera will not provide images until permission is granted. Applications, after opening a camera device, can see if they were granted access by either polling with the TSdlCamera.PermissionState property, or waiting for an TSdlEventKind.CameraDeviceApproved or <code>TSdlEventKind.CameraDeviceDenied</code> event. Platforms that don't have any user approval process will report approval immediately.</p> <p>Note that SDL cameras only provide video as individual frames; they will not provide full-motion video encoded in a movie file format, although an app is free to encode the acquired frames into any format it likes. It also does not provide audio from the camera hardware through this API; not only do many webcams not have microphones at all, many people--from streamers to people on Zoom calls--will want to use a separate microphone regardless of the camera. In any case, recorded audio will be available through SDL's audio API no matter what hardware provides the microphone.</p>"},{"location":"APIByCategory/Neslib.Sdl3.Video/#camera-gotchas","title":"Camera gotchas","text":"<p>Consumer-level camera hardware tends to take a little while to warm up, once the device has been opened. Generally most camera apps have some sort of UI to take a picture (a button to snap a pic while a preview is showing, some sort of multi-second countdown for the user to pose, like a photo booth), which puts control in the users' hands, or they are intended to stay on for long times (Pokemon Go, etc).</p> <p>It's not uncommon that a newly-opened camera will provide a couple of completely black frames, maybe followed by some under-exposed images. If taking a single frame automatically, or recording video from a camera's input without the user initiating it from a preview, it could be wise to drop the first several frames (if not the first several seconds worth of frames!) before using images from a camera.</p>"},{"location":"APIByCategory/Neslib.Sdl3/","title":"Neslib.Sdl3","text":"<p>Reference</p> <p>Neslib.Sdl3</p> <p>This unit defines the TSdlApp class, which is the entry point for any SDL application.</p> <p>You need to derive your own application class from this class, and then run that application in your project file by calling RunApp.</p> <p>In your application class, you can override up to 5 methods to customize your application:</p> <ul> <li>Init: This method is called by SDL once, at startup. The method should initialize whatever is necessary, possibly create windows and open audio devices, etc.</li> <li>Iterate: This method is called repeatedly by SDL. The method should operate as a single iteration the program's primary loop; it should update whatever state it needs and draw a new frame of video, usually.</li> <li>Event: This method is called as needed by SDL. It is called once for each new event.</li> <li>Quit: This method is called once by SDL before terminating the program.</li> <li>HandleError: This method is called when an SDL API returned an error. By default, it raises an exception (of type <code>ESdlError</code>) but you can override it to perform some other action, such as logging the error instead.</li> </ul> <p>Below follows an example taken from the Clear example project:</p> <pre><code>program Clear;\n\n{$R *.res}\n\nuses\n  System.SysUtils,\n  Neslib.Sdl3.Api,\n  Neslib.Sdl3.Time,\n  Neslib.Sdl3.Basics,\n  Neslib.Sdl3.Video,\n  Neslib.Sdl3;\n\ntype\n  TApp = class(TSdlApp)\n  private\n    FWindow: TSdlWindow;\n    FRenderer: TSdlRenderer;\n  protected\n    function Init: TSdlAppResult; override;\n    function Iterate: TSdlAppResult; override;\n  end;\n\n{ TApp }\n\nfunction TApp.Init: TSdlAppResult;\n{ This function runs once at startup }\nbegin\n  ReportMemoryLeaksOnShutdown := True;\n\n  SdlSetAppMetadata('Example Renderer Clear', '1.0', 'com.example.renderer-clear');\n\n  SdlInit([TSdlInitFlag.Video]);\n\n  FRenderer := TSdlRenderer.Create('Examples/Renderer/Clear', 640, 480, [], FWindow);\n\n  { Carry on with the program! }\n  Result := TSdlAppResult.Continue;\nend;\n\nfunction TApp.Iterate: TSdlAppResult;\n{ This method runs once per frame, and is the heart of the program. }\nbegin\n  { Convert from milliseconds to seconds. }\n  var Now: Double := SdlGetTicks / 1000;\n\n  { Choose the color for the frame we will draw.\n    The sine wave trick makes it fade between colors smoothly. }\n  var Red: Single := 0.5 + 0.5 * Sin(Now);\n  var Green: Single := 0.5 + 0.5 * Sin(Now + PI * 2 / 3);\n  var Blue: Single := 0.5 + 0.5 * Sin(Now + PI * 4 / 3);\n\n  { New color, full alpha. }\n  FRenderer.SetDrawColorFloat(Red, Green, Blue);\n\n  { Clear the window to the draw color.  }\n  FRenderer.Clear;\n\n  { Put the newly-cleared rendering on the screen. }\n  FRenderer.Present;\n\n  { Carry on with the program! }\n  Result := TSdlAppResult.Continue;\nend;\n\nbegin\n  RunApp(TApp);\nend.\n</code></pre>"},{"location":"Misc/KeyboardBestPractices/","title":"Best keyboard practices in SDL3","text":""},{"location":"Misc/KeyboardBestPractices/#first-things-first","title":"First things first","text":"<p>Keyboard input is a surprisingly complicated topic after you step outside of your usual country and language (and sometimes before you do, too).</p> <p>Almost any game, no matter what approach it is taking, should probably offer a means for users to configure key bindings; not only will this solve concerns about what kind of keyboard a user is typing on, it will also make your game flexible to whatever is most comfortable for a user. This is not just a question of keyboard layouts, but being kind to those that don't have full motion of their hands and would benefit from moving keys to accessible locations that don't make obvious sense to an outside observer. At least offer a config file, if not a user interface; people you've never met will thank you for it!</p>"},{"location":"Misc/KeyboardBestPractices/#the-four-approaches","title":"The four approaches","text":"<p>There are, as far as we can tell, four common ways that apps want to use keyboard input. Sometimes they want different approaches at different moments, too.</p>"},{"location":"Misc/KeyboardBestPractices/#the-101-button-joystick","title":"The 101-Button Joystick","text":"<p>Many games just want to treat a keyboard not as a way to input text, but just as a joystick that has a lot of buttons. The well-known \"WASD\" key pattern for FPS games is a fine example of this: you want the physical location of a key, regardless of what symbol is printed on the key. After all, on a French keyboard, instead of \"WASD\", you'd press \"ZQSD\", and on a Hiragana keyboard \"\u3066\u3061\u3068\u3057\". Same locations on the keyboard, totally different symbols.</p> <p>For these, you want TSdlScancodes: these are guaranteed to reference the physical location on the keyboard and not what is printed on it.</p> <p>Specifically, they assume a US English QWERTY keyboard layout, no matter what the keyboard in use actually has at that location, but that's okay because here we just want physical location of the key, not its meaning.</p> <p>Simply grab the TSdlKeyboardEvent.Scancode field from <code>TSdlEventKind.KeyDown</code> and <code>TSdlEventKind.KeyUp</code> events.</p> <pre><code>{ Returns 1 if moving forward with this keypress, \n  -1 if moving backward, 0 if not moving. }\nfunction DirectionUserShouldMove(const AEvent: TSdlEvent)\nbegin\n  { Just checking key presses here... }\n  Assert(AEvent.Kind = TSdlEventKind.KeyDown);\n  if (AEvent.Key.Scancode = TSdlScancode.W) then\n    { Pressed what would be \"W\" on a US QWERTY keyboard. Move forward! }\n    Result := 1\n  else if (AEvent.Key.Scancode = TSdlScancode.S) then\n    { Pressed what would be \"s\" on a US QWERTY keyboard. Move backward! }\n    Result := -1\n  else\n    { Wasn't key in W or S location, don't move. }\n    Result := 0;\nend;\n</code></pre>"},{"location":"Misc/KeyboardBestPractices/#the-specific-key","title":"The Specific Key","text":"<p>Some games might want to know the symbol on a key. This tends to be a \"press 'I' to open your inventory\" thing, and you don't really care where the 'I' key is on the keyboard.</p> <p>(But, again: offer keybindings, because some keyboards don't have an 'I' key!)</p> <p>This is also useful for looking for the ESC key to cancel an operation, or Enter to confirm, etc; it doesn't matter where the key is, you still want that key.</p> <p>These are TSdlKeycodes. They name specific keys and don't care where on the user's keyboard they actually are. Like scancodes, you also get these from <code>TSdlEventKind.KeyDown</code> and <code>TSdlEventKind.KeyUp</code> events.</p> <pre><code>{ Sit in a loop forever until the user presses Escape. }\nvar QuitTheApp := False;\nwhile (not QuitTheApp) do\nbegin\n  var E: TSdlEvent;\n  TSdlEvents.Wait(E);\n\n  { User has pressed a key? }\n  if (E.Kind = TSdlEventKind.KeyDown) then\n  begin\n    { The pressed key was Escape? }\n    if (E.Key.Key = TSdlKeycode.Escape) then\n      QuitTheApp := True;\n  end;\nend;\n</code></pre>"},{"location":"Misc/KeyboardBestPractices/#the-chat-box","title":"The Chat Box","text":"<p>Unicode is hard! If you are composing text a string at a time (\"Enter your name, adventurer!\" screens or accepting sentences for a chat interface, etc) you should not be using key press events! This will never do the right thing across various keyboards and human languages around the world.</p> <p>One should instead call TSdlWindow.StartTextInput, and listen for <code>TSdlEventKind.TextInput</code> events. When done accepting input, call TSdlWindow.StopTextInput. This approach will let the system provide input interfaces that are familiar to the user (including popping up a virtual keyboard on mobile devices, and other UI for composing in various languages). Then the event will provide Unicode strings, which might be complete lines of text or a single character, depending on the system. You will not be able to replicate these interfaces in your application for everyone in the world, do not try to build this yourself on top of individual keypress events.</p> <p>The downside of this is that a virtual keyboard, etc, might be disruptive to your game, so you need to design accordingly.</p> <pre><code>{ Set the text area and start text input }\nvar TextInputComplete := False;\nvar Area := SdlRect(TextField.X, TextField.Y, TextField.W, TextField.H);\nvar Cursor := 0;\nvar Text := '';\nWindow.SetTextInputArea(Area, Cursor);\nWindow.StartTextInput;\n\nwhile (not TextInputComplete) do\nbegin\n  var E: TSdlEvent;\n  while (TSdlEvents.Poll(E)) do\n  begin\n    { User has pressed a key? }\n    if (E.Kind = TSdlEventKind.KeyDown) then\n    begin\n      { The key pressed was Escape or Return? }\n      if (E.Key.Key = TSdlKeycode.Escape) or (E.Key.Key = TSdlKeyCode.Return) then\n      begin\n        Window.StopTextInput;\n        TextInputComplete := True;\n      end;\n\n      { Handle arrow keys, etc. }\n    end\n    else if (E.Kind = TSdlEventKind.TextInput) then\n      Text := Text + E.Text.Text;\n  end;\n\n  { Render the text, adjusting cursor to the offset \n    in pixels from the left edge of the textfield }\n  ...\n\n  { Update the text input area, adjusting the cursor \n    so IME UI shows up at the correct location. }\n  Window.SetTextInputArea(Area, Cursor);\nend;\n</code></pre> <p>If you're writing a fullscreen game, you might want to render IME UI yourself, so you'd set <code>TSdlHints.ImeImplementedUI</code> appropriately and handle the <code>TSdlEventKind.TextEditing</code> and <code>TSdlEventKind.TextEditingCandidates</code> events.</p>"},{"location":"Misc/KeyboardBestPractices/#the-text-editor","title":"The Text Editor","text":"<p>This is a special case, and if you think your game fits here, you should think very hard about how to change that before thinking about how to go this route, because often times you are just on a path to build The Chat Box, incorrectly, from scratch.</p> <p>If you were writing an SDL frontend for Vim, you would need to know what keypresses-plus-modifiers produce: hitting shift-Z twice produces a different result than pressing z twice, but also you want arrow keys to do the right thing on the numpad, unless NumLock is pressed, when they should produce numbers. On top of all this, it's difficult to correlate between keypress and proper text input events and untangle them to get correct results.</p> <p>In this case, you would need to handle both key events and input events as above, in addition you might want to know what the modified keycode for the event is:</p> <pre><code>var QuitTheApp := False;\nwhile (not QuitTheApp) do\nbegin\n  var E: TSdlEvent;\n  TSdlEvents.Wait(E);\n\n  { User has pressed a key? }\n  if (E.Kind = TSdlEventKind.KeyDown) then\n  begin\n    { Was the pressed key '$', possibly generated by Shift+4 on a \n      US keyboard or the '$' key on the French keyboard? }\n    var Keycode := TSdlKeycode.FromScancode(\n      E.Key.Scancode, E.Key.Mods, False);\n\n    if (Keycode = TSdlKeycode.Dollar) then\n    begin\n      { Show me the money! }\n    end;\n  end;\nend;\n</code></pre> <p>Obviously there are many keys that don't generate a character, or characters that are composed by pressing multiple keys (or navigating through IME interfaces that don't map to specific keypresses at all), so this is niche functionality and not how one should accept input in a general sense.</p>"},{"location":"Misc/KeyboardBestPractices/#showing-key-names-to-users","title":"Showing key names to users","text":"<p>So you've made your game, and now you're taking the original advice about adding user-configurable keybindings, and you need to know how to show the user the key's name in your config UI, and maybe also in a \"press [current keybinding] to jump\" tutorial message.</p> <p>For this, use TSdlKeycode.Name with the TSdlKeycode you get from an event:</p> <pre><code>var QuitTheApp := false;\nwhile (not QuitTheApp) do\nbegin\n  var E: TSdlEvent;\n  TSdlEvents.Wait(E);\n\n  { User has pressed a key? }\n  if (E.Kind = TSdlEventKind.KeyDown) then\n  begin\n    TSdlLog.Info('Wow, you just pressed the %s key!', \n      [E.Key.Key.Name]);\n  end;\nend;\n</code></pre> <p>Note that TSdlKeycode.Name only returns uppercase characters, which is appropriate for showing a user a \"press the button with this symbol on it\" message.</p>"},{"location":"Reference/Neslib.Sdl3/","title":"Neslib.Sdl3","text":"<p>Lightweight, very low-overhead, type-safe, object-oriented wrapper for SDL3.</p> <p>Wraps most of SDL into a class library (but using records instead of classes to reduce overhead). However, some functionality is not wrapped, in particular functionality that is not applicable to Delphi, or that the Delphi RTL already provides.</p> <p>In addition, errors are forwarded to the virtual TSdlApp.HandleError method (from the thread that caused the error). Be default, this method raises an exception of type ESdlError, but you can override to perform some other action, such as logging it instead. However, if you choose to not raise an exception, then the flow of execution will not be interrupted and you will have to use TSdlApp.HasError and TSdlApp.ErrorMessage to check for errors. Also, when the construction of an object (eg. a Texture, Window, Audio stream etc.) fails, and an exception is not raised, then you will have to check if the object is not nil before using it. </p>"},{"location":"Reference/Neslib.Sdl3/#classes-records","title":"Classes &amp; Records","text":"Name Description TSdlApp Entry point class for all SDL applications. You must override this class and its methods where appropriate."},{"location":"Reference/Neslib.Sdl3/#types","title":"Types","text":"Name Description TSdlAppClass A class reference to the TSdlApp class. TSdlAppResult Return values for the main callback methods in TSdlApp."},{"location":"Reference/Neslib.Sdl3/#routines","title":"Routines","text":"Name Description RunApp Starts an SDL application. You must use this method to start the application, otherwise your application will fail."},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/","title":"TSdlApp","text":"<p>Entry point class for all SDL applications. You must override this class and its methods where appropriate. </p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3</p> <pre><code>type TSdlApp = class abstract ... end\n</code></pre>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#inheritance","title":"Inheritance","text":""},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#properties","title":"Properties","text":"Name Description ErrorMessage The last SDL error message. It is possible for multiple errors to occur checking this property. HasError Whether an SDL API returned an error. Instance The singleton application instance."},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#constructors","title":"Constructors","text":"Name Description Create Destroy"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#methods","title":"Methods","text":"Name Description Event This method is called as needed by SDL after the Init method returns TSdlAppResult.Continue. It is called once for each new event. HandleError This method is called when an SDL API returned an error. It is called from the thread that caused the error. Init This method is called by SDL once, at startup. The method should initialize whatever is necessary, possibly create windows and open audio devices, etc. Iterate This method is called repeatedly by SDL after the Init method returns TSdlAppResult.Continue. The method should operate as a single iteration the program's primary loop; it should update whatever state it needs and draw a new frame of video, usually. Quit This method is called once by SDL before terminating the program."},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#ErrorMessage","title":"ErrorMessage","text":"<p>The last SDL error message. It is possible for multiple errors to occur checking this property.</p> <p>You usually only need to use this property if you override HandleError and decide not to raise an exception. In that case, you can use HasError to check if an error has occurred, and if so, use this property to retrieve the error message.</p> <p>Reading this property will not clear the error message. You need to use HasError at a later point again to check for errors. </p> <p><code>class property ErrorMessage: String read GetErrorMessage</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#see-also","title":"See Also","text":"<ul> <li>HandleError</li> <li>HasError</li> </ul>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#remarks","title":"Remarks","text":"<p>This property will return the error message that was specific to the thread that caused it. </p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#HasError","title":"HasError","text":"<p>Whether an SDL API returned an error.</p> <p>You usually only need to use this property if you override HandleError and decide not to raise an exception. In that case, you can use this property to check if an error has occurred.</p> <p>It doesn't tell you what API caused the error, just that any SDL API that was used since the last check of this property caused an error. It will only be reset to False once this property has been read. </p> <p><code>class property HasError: Boolean read GetHasError write FHasError</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#see-also_1","title":"See Also","text":"<ul> <li>HandleError</li> <li>ErrorMessage</li> </ul>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#remarks_1","title":"Remarks","text":"<p>This property is not specific to the thread that caused the error. Any thread that causes an error will set this global property. </p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#Instance","title":"Instance","text":"<p>The singleton application instance. </p> <p><code>class property Instance: TSdlApp read FInstance</code></p> <p>Type: <code>TSdlApp</code></p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#Create","title":"<code>Create</code>","text":"<p><code>constructor Create</code></p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#Destroy","title":"<code>Destroy</code>","text":"<p><code>destructor Destroy; override</code></p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#Event","title":"Event(TSdlEvent)","text":"<p>This method is called as needed by SDL after the Init method returns TSdlAppResult.Continue. It is called once for each new event.</p> <p>There is (currently) no guarantee about what thread this will be called from; whatever thread pushes an event onto SDL's queue will trigger this method. SDL is responsible for pumping the event queue between each call to Iterate, so in normal operation one should only get events in a serial fashion, but be careful if you have a thread that explicitly calls TSdlEvents.Push. SDL itself will push events to the queue on the main thread.</p> <p>Events sent to this method are not owned by the app; if you need to save the data, you should copy it.</p> <p>This method should not go into an infinite mainloop; it should handle the provided event appropriately and return.</p> <p>If this method returns TSdlAppResult.Continue, the app will continue normal operation, receiving repeated calls to Iterate and Event for the life of the program. If this method returns TSdlAppResult.Failure, SDL will call Quit and terminate the process with an exit code that reports an error to the platform. If it returns TSdlAppResult.Success, SDL calls Quit and terminates with an exit code that reports success to the platform.</p> <p>By default this method returns TSdlAppResult.Continue, unless a Quit event is received, in which case it returns TSdlAppResult.Success. </p> <p><code>function Event(const AEvent: TSdlEvent): TSdlAppResult; virtual</code></p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#parameters","title":"Parameters","text":"<p><code>AEvent</code>: <code>TSdlEvent</code> : The new event for the app to examine.</p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#returns","title":"Returns","text":"<p><code>TSdlAppResult</code>: Your should return TSdlAppResult.Failure to terminate with an error, TSdlAppResult.Success to terminate with success or TSdlAppResult.Continue to continue. </p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#remarks_2","title":"Remarks","text":"<p>This method may get called concurrently with Iterate or Quit for events not pushed from the main thread. </p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#HandleError","title":"HandleError(String)","text":"<p>This method is called when an SDL API returned an error. It is called from the thread that caused the error.</p> <p>By default, this method raises an exception of type ESdlError, but you can override this method perform some other action, such as logging the error instead. However, if you choose to not raise an exception, then the flow of execution will not be interrupted and you will have to use HasError and ErrorMessage to check for errors. Also, when the construction of an object (eg. a Texture, Window, Audio stream etc.) fails, and an exception is not raised, then you will have to check if the object is not nil before using it. </p> <p><code>procedure HandleError(const AMessage: String); virtual</code></p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#parameters_1","title":"Parameters","text":"<p><code>AMessage</code>: <code>String</code> : The error message.</p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#see-also_2","title":"See Also","text":"<ul> <li>HasError</li> <li>ErrorMessage</li> </ul>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#remarks_3","title":"Remarks","text":"<p>This method is called from the thread that caused the error. </p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#Init","title":"Init","text":"<p>This method is called by SDL once, at startup. The method should initialize whatever is necessary, possibly create windows and open audio devices, etc.</p> <p>This method should not go into an infinite mainloop; it should do any one-time setup it requires and then return.</p> <p>If this method returns TSdlAppResult.Continue, the app will proceed to normal operation, and will begin receiving repeated calls to the Iterate and Event methods for the life of the program. If this method returns TSdlAppResult.Failure, SDL will call the Quit method and terminate the process with an exit code that reports an error to the platform. If it returns TSdlAppResult.Success, SDL calls the Quit method and terminates with an exit code that reports success to the platform.</p> <p>This method is called by SDL on the main thread.</p> <p>Can be overridden to initialize the application, for example to create a window and renderer.</p> <p>By default this method just returns TSdlAppResult.Continue. </p> <p><code>function Init: TSdlAppResult; virtual</code></p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#returns_1","title":"Returns","text":"<p><code>TSdlAppResult</code>: Your should return TSdlAppResult.Failure to terminate with an error, TSdlAppResult.Success to terminate with success or TSdlAppResult.Continue to continue. </p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#Iterate","title":"Iterate","text":"<p>This method is called repeatedly by SDL after the Init method returns TSdlAppResult.Continue. The method should operate as a single iteration the program's primary loop; it should update whatever state it needs and draw a new frame of video, usually.</p> <p>On some platforms, this method will be called at the refresh rate of the display (which might change during the life of your app!). There are no promises made about what frequency this function might run at. You should use SDL's timer functions if you need to see how much time has passed since the last iteration.</p> <p>There is no need to process the SDL event queue during this method; SDL will send events as they arrive in the Event method, and in most cases the event queue will be empty when this method runs anyhow.</p> <p>This method should not go into an infinite mainloop; it should do one iteration of whatever the program does and return.</p> <p>If this method returns TSdlAppResult.Continue, the app will continue normal operation, receiving repeated calls to Iterate and Event for the life of the program. If this method returns TSdlAppResult.Failure, SDL will call Quit and terminate the process with an exit code that reports an error to the platform. If it returns TSdlAppResult.Success, SDL calls Quit and terminates with an exit code that reports success to the platform.</p> <p>This method is called by SDL on the main thread.</p> <p>By default this method just returns TSdlAppResult.Continue. </p> <p><code>function Iterate: TSdlAppResult; virtual</code></p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#returns_2","title":"Returns","text":"<p><code>TSdlAppResult</code>: Your should return TSdlAppResult.Failure to terminate with an error, TSdlAppResult.Success to terminate with success or TSdlAppResult.Continue to continue. </p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#remarks_4","title":"Remarks","text":"<p>This method may get called concurrently with the Event method for events not pushed on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#Quit","title":"Quit(TSdlAppResult)","text":"<p>This method is called once by SDL before terminating the program.</p> <p>This method will be called no matter what, even if the Init method requests termination.</p> <p>This method should not go into an infinite mainloop; it should deinitialize any resources necessary, perform whatever shutdown activities, and return.</p> <p>You do not need to call SdlQuit in this method, as SDL will call it after this method returns and before the process terminates, but it is safe to do so.</p> <p>This method is called by SDL on the main thread.</p> <p>Does nothing by default. </p> <p><code>procedure Quit(const AResult: TSdlAppResult); virtual</code></p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#parameters_2","title":"Parameters","text":"<p><code>AResult</code>: <code>TSdlAppResult</code> : the result code that terminated the app (success or failure).</p>"},{"location":"Reference/Neslib.Sdl3/classes/TSdlApp/#remarks_5","title":"Remarks","text":"<p>The Event method may get called concurrently with this method if other threads that push events are still active. </p>"},{"location":"Reference/Neslib.Sdl3/routines/RunApp/","title":"RunApp","text":"<p>Starts an SDL application. You must use this method to start the application, otherwise your application will fail. </p>"},{"location":"Reference/Neslib.Sdl3/routines/RunApp/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3</p> <pre><code>procedure RunApp(const AAppClass: TSdlAppClass)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3/routines/RunApp/#parameters","title":"Parameters","text":"<p><code>AAppClass</code>: <code>TSdlAppClass</code> : Your application class (derived from TSdlApp). This is the main entry point of your app.</p>"},{"location":"Reference/Neslib.Sdl3/types/TSdlAppClass/","title":"TSdlAppClass","text":"<p>A class reference to the TSdlApp class. </p>"},{"location":"Reference/Neslib.Sdl3/types/TSdlAppClass/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3</p> <pre><code>type TSdlAppClass = class of TSdlApp\n</code></pre>"},{"location":"Reference/Neslib.Sdl3/types/TSdlAppResult/","title":"TSdlAppResult","text":"<p>Return values for the main callback methods in TSdlApp.</p> <p>Returning TSdlAppResult.Success or TSdlAppResult.Failure from TSdlApp.Init, TSdlApp.Event, or TSdlApp.Iterate will terminate the program and report success/failure to the operating system. What that means is platform-dependent.</p> <p>Returning TSdlAppResult.Continue from these callbacks will let the app continue to run. </p>"},{"location":"Reference/Neslib.Sdl3/types/TSdlAppResult/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3</p> <pre><code>type TSdlAppResult = (Continue, Success, Failure)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3/types/TSdlAppResult/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3/types/TSdlAppResult/#continue-sdl_app_continue","title":"<code>Continue = SDL_APP_CONTINUE</code>","text":"<p>Value that requests that the app continue from the main callbacks.</p>"},{"location":"Reference/Neslib.Sdl3/types/TSdlAppResult/#success-sdl_app_success","title":"<code>Success = SDL_APP_SUCCESS</code>","text":"<p>Value that requests termination with success from the main callbacks.</p>"},{"location":"Reference/Neslib.Sdl3/types/TSdlAppResult/#failure-sdl_app_failure","title":"<code>Failure = SDL_APP_FAILURE</code>","text":"<p>Value that requests termination with error from the main callbacks.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/","title":"Neslib.Sdl3.Additional","text":""},{"location":"Reference/Neslib.Sdl3.Additional/#interfaces","title":"Interfaces","text":"Name Description ISdlClipboardDataProvider Implement this interface to provide (non-text) data for the clipboard."},{"location":"Reference/Neslib.Sdl3.Additional/#classes-records","title":"Classes &amp; Records","text":"Name Description TSdlClipboard SDL provides access to the system clipboard, both for reading information from other processes and publishing information of its own. TSdlCpu CPU feature detection for SDL. TSdlDialog Provides (file) dialog functionality TSdlDialogFileFilter An entry for filters for file dialogs. TSdlEnvironment A thread-safe set of environment variables TSdlLocale A record to provide locale data. TSdlMemoryManager To customize SDL's memory manager TSdlMessageBoxButtonData Individual button data. TSdlMessageBoxColor RGB value used in a message box color scheme TSdlMessageBoxColorScheme A set of colors to use for message box dialogs TSdlMessageBoxData MessageBox structure containing title, text, window, etc. TSdlProcess A system process. TSdlTray A toplevel system tray object. TSdlTrayEntry An entry on a system tray object. TSdlTrayMenu A menu/submenu on a system tray object."},{"location":"Reference/Neslib.Sdl3.Additional/#types","title":"Types","text":"Name Description PSdlMessageBoxButtonData PSdlMessageBoxColorScheme TSdlCAllocFunc A callback used to implement SdlCAlloc. TSdlDialogFileCallback Callback used by file dialog functions. TSdlFreeFunc A callback used to implement SdlFree. TSdlMAllocFunc A callback used to implement SdlMAlloc. TSdlMessageBoxButtonFlag Message box button flags. TSdlMessageBoxButtonFlags A set of message box button flags. TSdlMessageBoxColorType An enumeration of indices inside the colors array of TSdlMessageBoxColorScheme. TSdlMessageBoxFlag Message box flags. TSdlMessageBoxFlags A set of message box flags. TSdlPowerState The basic state for the system's power supply. TSdlProcessIO Description of where standard I/O should be directed when creating a process. TSdlReallocFunc A callback used to implement SdlRealloc. TSdlSandbox Application sandbox environment. TSdlTrayCallback A callback that is invoked when a tray entry is selected. TSdlTrayEntryFlag Flags that control the creation of system tray entries. TSdlTrayEntryFlags A set of tray entry flags."},{"location":"Reference/Neslib.Sdl3.Additional/#routines","title":"Routines","text":"Name Description SdlAlignedAlloc Allocate memory aligned to a specific alignment. SdlAlignedFree Free memory allocated by SdlAlignedAlloc. SdlCAlloc Allocate a zero-initialized array using SDL's memory manager. SdlCrc16 Calculate a CRC-16 value. SdlCrc32 Calculate a CRC-32 value. SdlFillChar4 Initialize all 32-bit words of buffer of memory to a specific value. SdlFree Free allocated memory using SDL's memory manager. SdlGetDirect3D9AdapterIndex Get the D3D9 adapter index that matches the specified display. SdlGetDxgiOutputInfo Get the DXGI Adapter and Output indices for the specified display. SdlGetPowerInfo Get the current power supply details. SdlGetSandbox Get the application sandbox environment, if any. SdlIsTablet Query if the current device is a tablet. SdlIsTV Query if the current device is a TV. SdlMAlloc Allocate uninitialized memory using SDL's memory manager. SdlMurmur3 Calculate a 32-bit MurmurHash3 value for a block of data. SdlNumAllocations Get the number of outstanding (unfreed) allocations. SdlOpenUrl Open a URL/URI in the browser or other appropriate external application. SdlRealloc Change the size of allocated memory using SDL's memory manager. SdlShowMessageBox Create a modal message box. SdlShowSimpleMessageBox(TSdlMessageBoxFlags, String, String, TSdlWindow) Display a simple modal message box. SdlShowSimpleMessageBox(TSdlMessageBoxFlags, String, String) Display a simple modal message box."},{"location":"Reference/Neslib.Sdl3.Additional/#constants","title":"Constants","text":"Name Description SDL_CACHELINE_SIZE A guess for the cacheline size used for padding. SDL_SINGLE_EPSILON Epsilon constant, used for comparing floating-point numbers."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/","title":"TSdlClipboard","text":"<p>SDL provides access to the system clipboard, both for reading information from other processes and publishing information of its own.</p> <p>This is not just text! SDL apps can access and publish data by mimetype.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#basic-use-text","title":"Basic use (text)","text":"<p>Obtaining and publishing simple text to the system clipboard is as easy as using the Text property. Data transmission and encoding conversion is completely managed by SDL.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#clipboard-data-provider-data-other-than-text","title":"Clipboard data provider (data other than text)","text":"<p>Things get more complicated when the clipboard contains something other than text. Not only can the system clipboard contain data of any type, in some cases it can contain the same data in different formats! For example, an image painting app might let the user copy a graphic to the clipboard, and offers it in .BMP, .JPG, or .PNG format for other apps to consume.</p> <p>Obtaining clipboard data (\"pasting\") like this is a matter of calling GetData and telling it the mime type of the data you want. But how does one know if that format is available? HasData can report if a specific mimetype is offered, and MimeTypes can provide the entire list of mimetypes available, so the app can decide what to do with the data and what formats it can support.</p> <p>Setting the clipboard (\"copying\") to arbitrary data is done with SetData. The app does not provide the data in this call, but rather the mime types it is willing to provide and a ISdlClipboardDataProvider interface that will be called when needed. During the ISdlClipboardDataProvider.Data callback, the app will generate the data. This allows massive data sets to be provided to the clipboard, without any data being copied before it is explicitly requested. More specifically, it allows an app to offer data in multiple formats without providing a copy of all of them upfront. If the app has an image that it could provide in PNG or JPG format, it doesn't have to encode it to either of those unless and until something tries to paste it. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlClipboard = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#properties","title":"Properties","text":"Name Description HasText Whether the clipboard exists and contains a non-empty text string. MimeTypes The list of mime types available in the clipboard. Text The text on the clipboard."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#constructors","title":"Constructors","text":"Name Description Create Destroy"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#methods","title":"Methods","text":"Name Description ClearData Clear the clipboard data. GetData Get data from the clipboard for a given mime type. HasData Query whether there is data in the clipboard for the provided mime type. SetData Offer clipboard data to the OS."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#HasText","title":"HasText","text":"<p>Whether the clipboard exists and contains a non-empty text string. </p> <p><code>class property HasText: Boolean read GetHasText</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#see-also","title":"See Also","text":"<ul> <li>Text</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#remarks","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#MimeTypes","title":"MimeTypes","text":"<p>The list of mime types available in the clipboard. </p> <p><code>class property MimeTypes: TArray&lt;String&gt; read GetMimeTypes</code></p> <p>Type: <code>TArray&lt;String&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#see-also_1","title":"See Also","text":"<ul> <li>SetData</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#remarks_1","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#Text","title":"Text","text":"<p>The text on the clipboard. </p> <p><code>class property Text: String read GetText write SetText</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#see-also_2","title":"See Also","text":"<ul> <li>HasText</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#remarks_2","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#Create","title":"<code>Create</code>","text":"<p><code>class constructor Create</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#Destroy","title":"<code>Destroy</code>","text":"<p><code>class destructor Destroy</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#ClearData","title":"ClearData","text":"<p>Clear the clipboard data. </p> <p><code>class procedure ClearData; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#see-also_3","title":"See Also","text":"<ul> <li>SetData</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#remarks_3","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#GetData","title":"GetData(String)","text":"<p>Get data from the clipboard for a given mime type. </p> <p><code>class function GetData(const AMimeType: String): TBytes; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#parameters","title":"Parameters","text":"<p><code>AMimeType</code>: <code>String</code> : The mime type to read from the clipboard.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#returns","title":"Returns","text":"<p><code>TBytes</code>: The retrieved data buffer or nil if there is none.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#see-also_4","title":"See Also","text":"<ul> <li>HasData</li> <li>SetData</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#remarks_4","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#HasData","title":"HasData(String)","text":"<p>Query whether there is data in the clipboard for the provided mime type. </p> <p><code>class function HasData(const AMimeType: String): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#parameters_1","title":"Parameters","text":"<p><code>AMimeType</code>: <code>String</code> : The mime type to check for data for.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#returns_1","title":"Returns","text":"<p><code>Boolean</code>: True if there exists data in clipboard for the provided mime type, False if it does not.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#see-also_5","title":"See Also","text":"<ul> <li>SetData</li> <li>GetData</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#remarks_5","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#SetData","title":"SetData(ISdlClipboardDataProvider, TArray&lt;String&gt;)","text":"<p>Offer clipboard data to the OS.</p> <p>Tell the operating system that the application is offering clipboard data for each of the provided mime types. Once another application requests the data the ISdlClipboardDataProvider.Data callback method will be called, allowing it to generate and respond with the data for the requested mime type. </p> <p><code>class procedure SetData(const AProvider: ISdlClipboardDataProvider; const AMimeTypes: TArray&lt;String&gt;); static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#parameters_2","title":"Parameters","text":"<p><code>AProvider</code>: <code>ISdlClipboardDataProvider</code> : A ISdlClipboardDataProvider interface that provides the clipboard data. Cannot be nil.</p> <p><code>AMimeTypes</code>: <code>TArray&lt;String&gt;</code> : A list of mime-types that are being offered.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#see-also_6","title":"See Also","text":"<ul> <li>ClearData</li> <li>GetData</li> <li>HasData</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlClipboard/#remarks_6","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/","title":"TSdlCpu","text":"<p>CPU feature detection for SDL.</p> <p>These functions are largely concerned with reporting if the system has access to various SIMD instruction sets, but also has other important info to share, such as system RAM size and number of logical CPU cores.</p> <p>CPU instruction set checks, like HasSse and HasNeon, are available on all platforms, even if they don't make sense (an ARM processor will never have SSE and an x86 processor will never have NEON, for example, but these properties still exist and will simply return False in these). </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlCpu = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#properties","title":"Properties","text":"Name Description CacheLineSize Determine the L1 cache line size of the CPU. HasAltiVec Whether the CPU has AltiVec features. HasArmSimd Determine whether the CPU has ARM SIMD (ARMv6) features. HasAvx Determine whether the CPU has AVX features. HasAvx2 Determine whether the CPU has AVX2 features. HasAvx512F Determine whether the CPU has AVX-512F (foundation) features. HasLasx Determine whether the CPU has LASX (LOONGARCH SIMD) features. HasLsx Determine whether the CPU has LSX (LOONGARCH SIMD) features. HasMmx Whether the CPU has MMX features. HasNeon Determine whether the CPU has NEON (ARM SIMD) features. HasSse Determine whether the CPU has SSE features. HasSse2 Determine whether the CPU has SSE2 features. HasSse3 Determine whether the CPU has SSE3 features. HasSse41 Determine whether the CPU has SSE4.1 features. HasSse42 Determine whether the CPU has SSE4.2 features. NumLogicalCores The number of logical CPU cores available. SimdAlignment Report the alignment this system needs for SIMD allocations. SystemRamMiB Get the amount of RAM configured in the system in MiB."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#CacheLineSize","title":"CacheLineSize","text":"<p>Determine the L1 cache line size of the CPU.</p> <p>This is useful for determining multi-threaded structure padding or SIMD prefetch sizes. </p> <p><code>class property CacheLineSize: Integer read GetCacheLineSize</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#HasAltiVec","title":"HasAltiVec","text":"<p>Whether the CPU has AltiVec features.</p> <p>This always returns False on CPUs that aren't using PowerPC instruction sets. </p> <p><code>class property HasAltiVec: Boolean read GetHasAltiVec</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_1","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#HasArmSimd","title":"HasArmSimd","text":"<p>Determine whether the CPU has ARM SIMD (ARMv6) features.</p> <p>This is different from ARM NEON, which is a different instruction set.</p> <p>This always returns False on CPUs that aren't using ARM instruction sets. </p> <p><code>class property HasArmSimd: Boolean read GetHasArmSimd</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#see-also","title":"See Also","text":"<ul> <li>HasNeon</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_2","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#HasAvx","title":"HasAvx","text":"<p>Determine whether the CPU has AVX features.</p> <p>This always returns False on CPUs that aren't using Intel instruction sets. </p> <p><code>class property HasAvx: Boolean read GetHasAvx</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#see-also_1","title":"See Also","text":"<ul> <li>HasAvx2</li> <li>HasAvx512F</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_3","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#HasAvx2","title":"HasAvx2","text":"<p>Determine whether the CPU has AVX2 features.</p> <p>This always returns False on CPUs that aren't using Intel instruction sets. </p> <p><code>class property HasAvx2: Boolean read GetHasAvx2</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#see-also_2","title":"See Also","text":"<ul> <li>HasAvx</li> <li>HasAvx512F</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_4","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#HasAvx512F","title":"HasAvx512F","text":"<p>Determine whether the CPU has AVX-512F (foundation) features.</p> <p>This always returns False on CPUs that aren't using Intel instruction sets. </p> <p><code>class property HasAvx512F: Boolean read GetHasAvx512F</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#see-also_3","title":"See Also","text":"<ul> <li>HasAvx</li> <li>HasAvx2</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_5","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#HasLasx","title":"HasLasx","text":"<p>Determine whether the CPU has LASX (LOONGARCH SIMD) features.</p> <p>This always returns False on CPUs that aren't using LOONGARCH instruction sets. </p> <p><code>class property HasLasx: Boolean read GetHasLasx</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_6","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#HasLsx","title":"HasLsx","text":"<p>Determine whether the CPU has LSX (LOONGARCH SIMD) features.</p> <p>This always returns False on CPUs that aren't using LOONGARCH instruction sets. </p> <p><code>class property HasLsx: Boolean read GetHasLsx</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_7","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#HasMmx","title":"HasMmx","text":"<p>Whether the CPU has MMX features.</p> <p>This always returns False on CPUs that aren't using Intel instruction sets. </p> <p><code>class property HasMmx: Boolean read GetHasMmx</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_8","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#HasNeon","title":"HasNeon","text":"<p>Determine whether the CPU has NEON (ARM SIMD) features.</p> <p>This always returns False on CPUs that aren't using ARM instruction sets. </p> <p><code>class property HasNeon: Boolean read GetHasNeon</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_9","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#HasSse","title":"HasSse","text":"<p>Determine whether the CPU has SSE features.</p> <p>This always returns False on CPUs that aren't using Intel instruction sets. </p> <p><code>class property HasSse: Boolean read GetHasSse</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#see-also_4","title":"See Also","text":"<ul> <li>HasSse2</li> <li>HasSse3</li> <li>HasSse41</li> <li>HasSse42</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_10","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#HasSse2","title":"HasSse2","text":"<p>Determine whether the CPU has SSE2 features.</p> <p>This always returns False on CPUs that aren't using Intel instruction sets. </p> <p><code>class property HasSse2: Boolean read GetHasSse2</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#see-also_5","title":"See Also","text":"<ul> <li>HasSse</li> <li>HasSse3</li> <li>HasSse41</li> <li>HasSse42</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_11","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#HasSse3","title":"HasSse3","text":"<p>Determine whether the CPU has SSE3 features.</p> <p>This always returns False on CPUs that aren't using Intel instruction sets. </p> <p><code>class property HasSse3: Boolean read GetHasSse3</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#see-also_6","title":"See Also","text":"<ul> <li>HasSse</li> <li>HasSse2</li> <li>HasSse41</li> <li>HasSse42</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_12","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#HasSse41","title":"HasSse41","text":"<p>Determine whether the CPU has SSE4.1 features.</p> <p>This always returns False on CPUs that aren't using Intel instruction sets. </p> <p><code>class property HasSse41: Boolean read GetHasSse41</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#see-also_7","title":"See Also","text":"<ul> <li>HasSse</li> <li>HasSse2</li> <li>HasSse3</li> <li>HasSse42</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_13","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#HasSse42","title":"HasSse42","text":"<p>Determine whether the CPU has SSE4.2 features.</p> <p>This always returns false on CPUs that aren't using Intel instruction sets. </p> <p><code>class property HasSse42: Boolean read GetHasSse42</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#see-also_8","title":"See Also","text":"<ul> <li>HasSse</li> <li>HasSse2</li> <li>HasSse3</li> <li>HasSse41</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_14","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#NumLogicalCores","title":"NumLogicalCores","text":"<p>The number of logical CPU cores available.</p> <p>On CPUs that include technologies such as hyperthreading, the number of logical cores may be more than the number of physical cores. </p> <p><code>class property NumLogicalCores: Integer read GetNumLogicalCores</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_15","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#SimdAlignment","title":"SimdAlignment","text":"<p>Report the alignment this system needs for SIMD allocations.</p> <p>This will return the minimum number of bytes to which a pointer must be aligned to be compatible with SIMD instructions on the current machine. For example, if the machine supports SSE only, it will return 16, but if it supports AVX-512F, it'll return 64 (etc). This only reports values for instruction sets SDL knows about, so if your SDL build doesn't have HasAvx512F( then it might return 16 for the SSE support it sees and not 64 for the AVX-512 instructions that exist but SDL doesn't know about. Plan accordingly. </p> <p><code>class property SimdAlignment: Integer read GetSimdAlignment</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#see-also_9","title":"See Also","text":"<ul> <li>SdlAlignedAlloc</li> <li>SdlAlignedFree</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_16","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#SystemRamMiB","title":"SystemRamMiB","text":"<p>Get the amount of RAM configured in the system in MiB.</p> <p>One MiB (Mebibyte) is 1,048,576 bytes. </p> <p><code>class property SystemRamMiB: Integer read GetSystemRamMiB</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlCpu/#remarks_17","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialog/","title":"TSdlDialog","text":"<p>Provides (file) dialog functionality </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialog/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlDialog = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialog/#methods","title":"Methods","text":"Name Description ShowOpenFile Displays a dialog that lets the user select a file on their filesystem to open a file from. ShowOpenFolder Displays a dialog that lets the user select a folder on their filesystem. ShowSaveFile Displays a dialog that lets the user choose a new or existing file on their filesystem to save a file to."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialog/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialog/#ShowOpenFile","title":"ShowOpenFile(TSdlDialogFileCallback, TSdlWindow, TArray&lt;TSdlDialogFileFilter&gt;, String, Boolean)","text":"<p>Displays a dialog that lets the user select a file on their filesystem to open a file from.</p> <p>This is an asynchronous function; it will return immediately, and the result will be passed to the callback.</p> <p>The callback will be invoked with a list of files the user chose. The list will be nil (empty) if the user canceled the dialog.</p> <p>Note that the callback may be called from a different thread than the one the function was invoked on.</p> <p>Depending on the platform, the user may be allowed to input paths that don't yet exist. </p> <p><code>class procedure ShowOpenFile(const ACallback: TSdlDialogFileCallback; const AWindow: TSdlWindow; const AFilters: TArray&lt;TSdlDialogFileFilter&gt; = nil; const ADefaultLocation: String = ''; const AAllowMany: Boolean = False); static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialog/#parameters","title":"Parameters","text":"<p><code>ACallback</code>: <code>TSdlDialogFileCallback</code> : The callback to be invoked when the user selects one or more files and accepts, or cancels the dialog, or an error occurs.</p> <p><code>AWindow</code>: <code>TSdlWindow</code> : The window that the dialog should be modal for, may be nil. Not all platforms support this option.</p> <p><code>AFilters</code>: <code>TArray&lt;TSdlDialogFileFilter&gt; = nil</code> : (Optional) list of filters. Not all platforms support this option, and platforms that do support it may allow the user to ignore the filters.</p> <p><code>ADefaultLocation</code>: <code>String = ''</code> : (Optional) default folder or file to start the dialog at. Not all platforms support this option.</p> <p><code>AAllowMany</code>: <code>Boolean = False</code> : (Optional) whether the user will be allowed to select multiple entries. Defaults to False. Not all platforms support this option.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialog/#see-also","title":"See Also","text":"<ul> <li>TSdlDialogFileCallback</li> <li>TSdlDialogFileFilter</li> <li>ShowSaveFile</li> <li>ShowOpenFolder</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialog/#remarks","title":"Remarks","text":"<p>This method should be called only from the main thread. The callback may be invoked from the same thread or from a different one, depending on the OS's constraints. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialog/#ShowOpenFolder","title":"ShowOpenFolder(TSdlDialogFileCallback, TSdlWindow, String, Boolean)","text":"<p>Displays a dialog that lets the user select a folder on their filesystem.</p> <p>This is an asynchronous function; it will return immediately, and the result will be passed to the callback.</p> <p>The callback will be invoked with a list with the folder the user chose. The list will be empty if the user canceled the dialog.</p> <p>Note that the callback may be called from a different thread than the one the function was invoked on.</p> <p>Depending on the platform, the user may be allowed to input paths that don't yet exist. </p> <p><code>class procedure ShowOpenFolder(const ACallback: TSdlDialogFileCallback; const AWindow: TSdlWindow; const ADefaultLocation: String = ''; const AAllowMany: Boolean = False); static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialog/#parameters_1","title":"Parameters","text":"<p><code>ACallback</code>: <code>TSdlDialogFileCallback</code> : The callback to be invoked when the user selects a folder and accepts, or cancels the dialog, or an error occurs.</p> <p><code>AWindow</code>: <code>TSdlWindow</code> : The window that the dialog should be modal for, may be nil. Not all platforms support this option.</p> <p><code>ADefaultLocation</code>: <code>String = ''</code> : (Optional) default folder or file to start the dialog at. Not all platforms support this option.</p> <p><code>AAllowMany</code>: <code>Boolean = False</code> : (Optional) whether the user will be allowed to select multiple entries. Defaults to False. Not all platforms support this option.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialog/#see-also_1","title":"See Also","text":"<ul> <li>TSdlDialogFileCallback</li> <li>ShowOpenFile</li> <li>ShowSaveFile</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialog/#remarks_1","title":"Remarks","text":"<p>This method should be called only from the main thread. The callback may be invoked from the same thread or from a different one, depending on the OS's constraints. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialog/#ShowSaveFile","title":"ShowSaveFile(TSdlDialogFileCallback, TSdlWindow, TArray&lt;TSdlDialogFileFilter&gt;, String)","text":"<p>Displays a dialog that lets the user choose a new or existing file on their filesystem to save a file to.</p> <p>This is an asynchronous function; it will return immediately, and the result will be passed to the callback.</p> <p>The callback will be invoked with a list with the file the user chose. The list will be empty if the user canceled the dialog.</p> <p>Note that the callback may be called from a different thread than the one the function was invoked on.</p> <p>The chosen file may or may not already exist. </p> <p><code>class procedure ShowSaveFile(const ACallback: TSdlDialogFileCallback; const AWindow: TSdlWindow; const AFilters: TArray&lt;TSdlDialogFileFilter&gt; = nil; const ADefaultLocation: String = ''); static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialog/#parameters_2","title":"Parameters","text":"<p><code>ACallback</code>: <code>TSdlDialogFileCallback</code> : The callback to be invoked when the user selects a file and accepts, or cancels the dialog, or an error occurs.</p> <p><code>AWindow</code>: <code>TSdlWindow</code> : The window that the dialog should be modal for, may be nil. Not all platforms support this option.</p> <p><code>AFilters</code>: <code>TArray&lt;TSdlDialogFileFilter&gt; = nil</code> : (Optional) list of filters. Not all platforms support this option, and platforms that do support it may allow the user to ignore the filters.</p> <p><code>ADefaultLocation</code>: <code>String = ''</code> : (Optional) default folder or file to start the dialog at. Not all platforms support this option.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialog/#see-also_2","title":"See Also","text":"<ul> <li>TSdlDialogFileCallback</li> <li>TSdlDialogFileFilter</li> <li>ShowOpenFile</li> <li>ShowOpenFolder</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialog/#remarks_2","title":"Remarks","text":"<p>This method should be called only from the main thread. The callback may be invoked from the same thread or from a different one, depending on the OS's constraints. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialogFileFilter/","title":"TSdlDialogFileFilter","text":"<p>An entry for filters for file dialogs.</p> <p><code>AName</code> is a user-readable label for the filter (for example, \"Office document\").</p> <p><code>APattern</code> is a semicolon-separated list of file extensions (for example, \"doc;docx\"). File extensions may only contain alphanumeric characters, hyphens, underscores and periods. Alternatively, the whole string can be a single asterisk (\"*\"), which serves as an \"All files\" filter. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialogFileFilter/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlDialogFileFilter = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialogFileFilter/#see-also","title":"See Also","text":"<ul> <li>TSdlDialogFileCallback</li> <li>TSdlDialog.ShowOpenFile</li> <li>TSdlDialog.ShowSaveFile</li> <li>TSdlDialog.ShowOpenFolder</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialogFileFilter/#fields","title":"Fields","text":"Name Description Name A user-readable label for the filter (for example, \"Office document\"). Pattern Semicolon-separated list of file extensions (for example, \"doc;docx\")."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialogFileFilter/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialogFileFilter/#Name","title":"Name","text":"<p>A user-readable label for the filter (for example, \"Office document\"). </p> <p><code>var Name: String</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlDialogFileFilter/#Pattern","title":"Pattern","text":"<p>Semicolon-separated list of file extensions (for example, \"doc;docx\").</p> <p>File extensions may only contain alphanumeric characters, hyphens, underscores and periods. Alternatively, the whole string can be a single asterisk (\"*\"), which serves as an \"All files\" filter. </p> <p><code>var Pattern: String</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/","title":"TSdlEnvironment","text":"<p>A thread-safe set of environment variables </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlEnvironment = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#properties","title":"Properties","text":"Name Description Process The process environment."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#constructors","title":"Constructors","text":"Name Description Create Create a set of environment variables"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#methods","title":"Methods","text":"Name Description Free Free the set of environment variables. GetUnsafe Get the value of a variable in the environment. GetVariable Get the value of a variable in the environment. GetVariables Get all variables in the environment. SetUnsafe Set the value of a variable in the environment. SetVariable Set the value of a variable in the environment. UnsetUnsafe Clear a variable from the environment. UnsetVariable Clear a variable from the environment."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#Process","title":"Process","text":"<p>The process environment.</p> <p>This is initialized at application start and is not affected by any changes to the environment variables after that point. Use SetVariable and UnsetVariable if you want to modify this environment, or SetUnsafe UnsetUnsafe if you want changes to persist to the runtime environment after SdlQuit. </p> <p><code>class property Process: TSdlEnvironment read GetProcess</code></p> <p>Type: <code>TSdlEnvironment</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#remarks","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#Create","title":"<code>Create</code>","text":"<p>Create a set of environment variables </p> <p><code>constructor Create(const APopulated: Boolean)</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#parameters","title":"Parameters","text":"<p><code>APopulated</code>: <code>Boolean</code> : True to initialize it from the runtime environment, False to create an empty environment.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#see-also","title":"See Also","text":"<ul> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#remarks_1","title":"Remarks","text":"<p>If <code>APopulated</code> is false, it is safe to call this constructor from any thread, otherwise it is safe if no other threads are changing the environment. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#Equal","title":"Equal(TSdlEnvironment, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlEnvironment; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#parameters_1","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlEnvironment</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlEnvironment; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#parameters_2","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#returns_1","title":"Returns","text":"<p><code>TSdlEnvironment</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#NotEqual","title":"NotEqual(TSdlEnvironment, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlEnvironment; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#parameters_3","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlEnvironment</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#Free","title":"Free","text":"<p>Free the set of environment variables. </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#see-also_1","title":"See Also","text":"<ul> <li>Create</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#remarks_2","title":"Remarks","text":"<p>It is safe to call this method from any thread, as long as the environment is no longer in use. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#GetUnsafe","title":"GetUnsafe(String)","text":"<p>Get the value of a variable in the environment.</p> <p>This method bypasses SDL's cached copy of the environment and is not thread-safe. </p> <p><code>class function GetUnsafe(const AName: String): String; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#parameters_4","title":"Parameters","text":"<p><code>AName</code>: <code>String</code> : The name of the variable to get.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#returns_3","title":"Returns","text":"<p><code>String</code>: The value of the variable or an empty string if it can't be found.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#see-also_2","title":"See Also","text":"<ul> <li>SetUnsafe</li> <li>GetVariable</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#remarks_3","title":"Remarks","text":"<p>This function is not thread safe, consider using GetVariable instead. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#GetVariable","title":"GetVariable(String)","text":"<p>Get the value of a variable in the environment. </p> <p><code>function GetVariable(const AName: String): String; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#parameters_5","title":"Parameters","text":"<p><code>AName</code>: <code>String</code> : The name of the variable to get.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#returns_4","title":"Returns","text":"<p><code>String</code>: The value of the variable or an empty string if it can't be found.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#see-also_3","title":"See Also","text":"<ul> <li>GetVariables</li> <li>SetVariable</li> <li>UnsetVariable</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#remarks_4","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#GetVariables","title":"GetVariables","text":"<p>Get all variables in the environment. </p> <p><code>function GetVariables: TArray&lt;String&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#returns_5","title":"Returns","text":"<p><code>TArray&lt;String&gt;</code>: An array of pointers to environment variables in the form 'variable=value'.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#see-also_4","title":"See Also","text":"<ul> <li>GetVariable</li> <li>SetVariable</li> <li>UnsetVariable</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#remarks_5","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#SetUnsafe","title":"SetUnsafe(String, String, Boolean)","text":"<p>Set the value of a variable in the environment. </p> <p><code>class procedure SetUnsafe(const AName, AValue: String; const AOverwrite: Boolean); inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#parameters_6","title":"Parameters","text":"<p><code>AName</code>: <code>String</code> : The name of the variable to set.</p> <p><code>AValue</code>: <code>String</code> : The value of the variable to set.</p> <p><code>AOverwrite</code>: <code>Boolean</code> : True to overwrite the variable if it exists, False to return success without setting the variable if it already exists.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#see-also_5","title":"See Also","text":"<ul> <li>GetUnsafe</li> <li>SetVariable</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#remarks_6","title":"Remarks","text":"<p>This function is not thread safe, consider using SetVariable instead. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#SetVariable","title":"SetVariable(String, String, Boolean)","text":"<p>Set the value of a variable in the environment. </p> <p><code>procedure SetVariable(const AName, AValue: String; const AOverwrite: Boolean); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#parameters_7","title":"Parameters","text":"<p><code>AName</code>: <code>String</code> : The name of the variable to set.</p> <p><code>AValue</code>: <code>String</code> : The value of the variable to set.</p> <p><code>AOverwrite</code>: <code>Boolean</code> : True to overwrite the variable if it exists, False to return success without setting the variable if it already exists.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#see-also_6","title":"See Also","text":"<ul> <li>GetVariable</li> <li>GetVariables</li> <li>UnsetVariable</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#remarks_7","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#UnsetUnsafe","title":"UnsetUnsafe(String)","text":"<p>Clear a variable from the environment. </p> <p><code>class procedure UnsetUnsafe(const AName: String); inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#parameters_8","title":"Parameters","text":"<p><code>AName</code>: <code>String</code> : The name of the variable to unset.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#see-also_7","title":"See Also","text":"<ul> <li>UnsetVariable</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#remarks_8","title":"Remarks","text":"<p>This function is not thread safe, consider using UnsetVariable instead. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#UnsetVariable","title":"UnsetVariable(String)","text":"<p>Clear a variable from the environment. </p> <p><code>procedure UnsetVariable(const AName: String); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#parameters_9","title":"Parameters","text":"<p><code>AName</code>: <code>String</code> : The name of the variable to unset.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#see-also_8","title":"See Also","text":"<ul> <li>GetVariable</li> <li>GetVariables</li> <li>SetVariable</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlEnvironment/#remarks_9","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlLocale/","title":"TSdlLocale","text":"<p>A record to provide locale data.</p> <p>Locale data is split into a spoken language, like English, and an optional country, like Canada. The language will be in ISO-639 format (so English would be 'en'), and the country, if not empty, will be an ISO-3166 country code (so Canada would be 'CA'). </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlLocale/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlLocale = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlLocale/#properties","title":"Properties","text":"Name Description Country A country, like 'US' for America. Can be empty. Language A language name, like 'en' for English. PreferredLocales Report the user's preferred locales."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlLocale/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlLocale/#Country","title":"Country","text":"<p>A country, like 'US' for America. Can be empty. </p> <p><code>property Country: String read FCountry</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlLocale/#Language","title":"Language","text":"<p>A language name, like 'en' for English. </p> <p><code>property Language: String read FLanguage</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlLocale/#PreferredLocales","title":"PreferredLocales","text":"<p>Report the user's preferred locales.</p> <p>Language strings are (lowercase) ISO-639 language specifiers (such as 'en' for English, 'de' for German, etc). Country strings are (uppercase) ISO-3166 country codes (such as 'US' for the United States, 'CA' for Canada, etc). Country might be empty if there's no specific guidance on them (so you might get {'en', 'US'} for American English, but {'en', ''} means \"English language, generically\"). Language strings are never empty.</p> <p>Please note that not all of these strings are 2 characters; some are three or more.</p> <p>The returned list of locales are in the order of the user's preference. For example, a German citizen that is fluent in US English and knows enough Japanese to navigate around Tokyo might have a list like: [ {'de', ''}, {'en', 'US'}, {'jp', ''} ]. Someone from England might prefer British English (where \"color\" is spelled \"colour\", etc), but will settle for anything like it: [ {'en', 'GB'}, {'en', ''} ].</p> <p>This property returns an empty array when the platform does not supply this information at all.</p> <p>This might be a \"slow\" call that has to query the operating system. It's best to ask for this once and save the results. However, this list can change, usually because the user has changed a system preference outside of your program; SDL will send an TSdlEventKind.LocaleChanged event in this case, if possible, and you can call this function again to get an updated copy of preferred locales. </p> <p><code>class property PreferredLocales: TArray&lt;TSdlLocale&gt; read GetPreferredLocales</code></p> <p>Type: <code>TArray&lt;TSdlLocale&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/","title":"TSdlMemoryManager","text":"<p>To customize SDL's memory manager </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlMemoryManager = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#fields","title":"Fields","text":"Name Description CAlloc The callback used to implement SdlCAlloc. Free The callback used to implement SdlFree. MAlloc The callback used to implement SdlMAlloc. Realloc The callback used to implement SdlRealloc."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#properties","title":"Properties","text":"Name Description Current The current set of SDL memory functions. Original The original set of SDL memory functions."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#methods","title":"Methods","text":"Name Description UseDelphis Sets the memory functions to use Delphi's built-in functions (like GetMem and FreeMem) instead."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#CAlloc","title":"CAlloc","text":"<p>The callback used to implement SdlCAlloc. </p> <p><code>var CAlloc: TSdlCAllocFunc</code></p> <p>Type: <code>TSdlCAllocFunc</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#Free","title":"Free","text":"<p>The callback used to implement SdlFree. </p> <p><code>var Free: TSdlFreeFunc</code></p> <p>Type: <code>TSdlFreeFunc</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#MAlloc","title":"MAlloc","text":"<p>The callback used to implement SdlMAlloc. </p> <p><code>var MAlloc: TSdlMAllocFunc</code></p> <p>Type: <code>TSdlMAllocFunc</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#Realloc","title":"Realloc","text":"<p>The callback used to implement SdlRealloc. </p> <p><code>var Realloc: TSdlReallocFunc</code></p> <p>Type: <code>TSdlReallocFunc</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#Current","title":"Current","text":"<p>The current set of SDL memory functions.</p> <p>It is not safe to change the memory functions once any allocations have been made, as future calls to SdlFree will use the new allocator, even if they came from an SdlMAlloc made with the old one!</p> <p>If set, usually this needs to be the first call made into the SDL library, if not the very first thing done at program startup time. </p> <p><code>class property Current: TSdlMemoryManager read GetCurrent write SetCurrent</code></p> <p>Type: <code>TSdlMemoryManager</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#see-also","title":"See Also","text":"<ul> <li>Original</li> <li>UseDelphis</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#remarks","title":"Remarks","text":"<p>This does not hold a lock, so do not use this in the unlikely event of a background thread setting this simultaneously. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#Original","title":"Original","text":"<p>The original set of SDL memory functions.</p> <p>This is what SdlMAlloc and friends will use by default, if no custom memory manager has been set (using Current). This is not necessarily using the C runtime's <code>malloc</code> functions behind the scenes! Different platforms and build configurations might do any number of unexpected things. </p> <p><code>class property Original: TSdlMemoryManager read GetOriginal</code></p> <p>Type: <code>TSdlMemoryManager</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#see-also_1","title":"See Also","text":"<ul> <li>Current</li> <li>UseDelphis</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#remarks_1","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#UseDelphis","title":"UseDelphis","text":"<p>Sets the memory functions to use Delphi's built-in functions (like GetMem and FreeMem) instead.</p> <p>This enables you to use a single set of memory management functions, as well as enable features like ReportMemoryLeaksOnShutdown.</p> <p>It is not safe to change the memory functions once any allocations have been made, as future calls to SdlFree will use the new allocator, even if they came from an SdlMAlloc made with the old one!</p> <p>Uusually this needs to be the first call made into the SDL library, if not the very first thing done at program startup time. </p> <p><code>class procedure UseDelphis; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#see-also_2","title":"See Also","text":"<ul> <li>Original</li> <li>Current</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMemoryManager/#remarks_2","title":"Remarks","text":"<p>This does not hold a lock, so do not use this in the unlikely event of a background thread setting this simultaneously. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxButtonData/","title":"TSdlMessageBoxButtonData","text":"<p>Individual button data. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxButtonData/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlMessageBoxButtonData = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxButtonData/#fields","title":"Fields","text":"Name Description ButtonID User defined button ID (value returned via SdlShowMessageBox) Flags Button flags Text The button text"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxButtonData/#constructors","title":"Constructors","text":"Name Description Create Creates data for a button."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxButtonData/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxButtonData/#ButtonID","title":"ButtonID","text":"<p>User defined button ID (value returned via SdlShowMessageBox) </p> <p><code>var ButtonID: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxButtonData/#Flags","title":"Flags","text":"<p>Button flags </p> <p><code>var Flags: TSdlMessageBoxButtonFlags</code></p> <p>Type: <code>TSdlMessageBoxButtonFlags</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxButtonData/#Text","title":"Text","text":"<p>The button text </p> <p><code>var Text: String</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxButtonData/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxButtonData/#Create","title":"<code>Create</code>","text":"<p>Creates data for a button. </p> <p><code>constructor Create(const AText: String; const AID: Integer = 0; const AFlags: TSdlMessageBoxButtonFlags = [])</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxButtonData/#parameters","title":"Parameters","text":"<p><code>AText</code>: <code>String</code> : The button text.</p> <p><code>AID</code>: <code>Integer = 0</code> : (Optional) button ID. Defaults to 0.</p> <p><code>AFlags</code>: <code>TSdlMessageBoxButtonFlags = []</code> : (Optional) button flags. Defaults to [].</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxColor/","title":"TSdlMessageBoxColor","text":"<p>RGB value used in a message box color scheme </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxColor/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlMessageBoxColor = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxColor/#fields","title":"Fields","text":"Name Description B Blue value G Green value R Red value"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxColor/#constructors","title":"Constructors","text":"Name Description Create Creates a messages box color."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxColor/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxColor/#B","title":"B","text":"<p>Blue value </p> <p><code>var B: Byte</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxColor/#G","title":"G","text":"<p>Green value </p> <p><code>var G: Byte</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxColor/#R","title":"R","text":"<p>Red value </p> <p><code>var R: Byte</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxColor/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxColor/#Create","title":"<code>Create</code>","text":"<p>Creates a messages box color. </p> <p><code>constructor Create(const ARed, AGreen, ABlue: Byte)</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxColor/#parameters","title":"Parameters","text":"<p><code>ARed</code>: <code>Byte</code> : The red value.</p> <p><code>AGreen</code>: <code>Byte</code> : The red value.</p> <p><code>ABlue</code>: <code>Byte</code> : The red value.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxColorScheme/","title":"TSdlMessageBoxColorScheme","text":"<p>A set of colors to use for message box dialogs </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxColorScheme/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlMessageBoxColorScheme = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxColorScheme/#fields","title":"Fields","text":"Name Description Colors The colors in the scheme"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxColorScheme/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxColorScheme/#Colors","title":"Colors","text":"<p>The colors in the scheme </p> <p><code>var Colors: array [TSdlMessageBoxColorType] of TSdlMessageBoxColor</code></p> <p>Type: <code>array [TSdlMessageBoxColorType] of TSdlMessageBoxColor</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxData/","title":"TSdlMessageBoxData","text":"<p>MessageBox structure containing title, text, window, etc. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxData/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlMessageBoxData = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxData/#fields","title":"Fields","text":"Name Description Buttons Array of buttons ColorScheme Pointer ta TSdlMessageBoxColorScheme. Can be nil to use system settings Flags Message box flags Text Message text Title Title Window Parent window, can be nil"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxData/#constructors","title":"Constructors","text":"Name Description Create Creates a messages box color."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxData/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxData/#Buttons","title":"Buttons","text":"<p>Array of buttons </p> <p><code>var Buttons: TArray&lt;TSdlMessageBoxButtonData&gt;</code></p> <p>Type: <code>TArray&lt;TSdlMessageBoxButtonData&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxData/#ColorScheme","title":"ColorScheme","text":"<p>Pointer ta TSdlMessageBoxColorScheme. Can be nil to use system settings </p> <p><code>var ColorScheme: PSdlMessageBoxColorScheme</code></p> <p>Type: <code>PSdlMessageBoxColorScheme</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxData/#Flags","title":"Flags","text":"<p>Message box flags </p> <p><code>var Flags: TSdlMessageBoxFlags</code></p> <p>Type: <code>TSdlMessageBoxFlags</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxData/#Text","title":"Text","text":"<p>Message text </p> <p><code>var Text: String</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxData/#Title","title":"Title","text":"<p>Title </p> <p><code>var Title: String</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxData/#Window","title":"Window","text":"<p>Parent window, can be nil </p> <p><code>var Window: TSdlWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxData/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxData/#Create","title":"<code>Create</code>","text":"<p>Creates a messages box color. </p> <p><code>constructor Create(const AFlags: TSdlMessageBoxFlags; const ATitle, AMessage: String)</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlMessageBoxData/#parameters","title":"Parameters","text":"<p><code>AFlags</code>: <code>TSdlMessageBoxFlags</code> : Message box flags.</p> <p><code>ATitle</code>: <code>String</code> : The title.</p> <p><code>AMessage</code>: <code>String</code> : The message text.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/","title":"TSdlProcess","text":"<p>A system process. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlProcess = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#properties","title":"Properties","text":"Name Description Input The TSdlIOStream associated with process standard input. Output The TSdlIOStream associated with process standard output. Properties The properties associated with a process."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#constructors","title":"Constructors","text":"Name Description Create(TSdlProperties) Create a new process with the specified properties. Create(String, TArray&lt;String&gt;, Boolean) Create a new process."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#methods","title":"Methods","text":"Name Description Free Destroy the previously created process object. Kill Stop the process. Read(Integer) Read all the output from a process. Read Read all the output from a process. Wait(Boolean, Integer) Wait for the process to finish. Wait(Boolean) Wait for the process to finish."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#Input","title":"Input","text":"<p>The TSdlIOStream associated with process standard input.</p> <p>The process must have been created with APipeStdIO set to True, or with <code>TSdlProperty.ProcessCreateStdIn</code> set to <code>TSdlProcessStdIO.App</code>.</p> <p>Writing to this stream can return less data than expected if the process hasn't read its input. It may be blocked waiting for its output to be read, if so you may need to use Output and read the output in parallel with writing input. </p> <p><code>property Input: TSdlIOStream read GetInput</code></p> <p>Type: <code>TSdlIOStream</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#see-also","title":"See Also","text":"<ul> <li>Output</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#remarks","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#Output","title":"Output","text":"<p>The TSdlIOStream associated with process standard output.</p> <p>The process must have been created with APipeStdIO set to True, or with <code>TSdlProperty.ProcessCreateStdOut</code> set to <code>TSdlProcessStdIO.App</code>.</p> <p>Reading from this stream can return 0 with TSdlIOStream.Status returning TSdlIOStatus.NotReady if no output is available yet. </p> <p><code>property Output: TSdlIOStream read GetOutput</code></p> <p>Type: <code>TSdlIOStream</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#see-also_1","title":"See Also","text":"<ul> <li>Input</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#remarks_1","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#Properties","title":"Properties","text":"<p>The properties associated with a process.</p> <p>The following read-only properties are provided by SDL:</p> <ul> <li><code>TSdlProperty.ProcessPid</code>: the process ID of the process.</li> <li><code>TSdlProperty.ProcessStdIn</code>: a TSdlIOStream that can be used to write input to the process, if it was created with <code>TSdlProperty.ProcessCreateStdIn</code> set to <code>TSdlProcessIO.App</code>.</li> <li><code>TSdlProperty.ProcessStdOut</code>: a non-blocking TSdlIOStream that can be used to read output from the process, if it was created with <code>TSdlProperty.ProcessCreateStdOut</code> set to <code>TSdlProcessIO.App</code>.</li> <li><code>TSdlProperty.ProcessStdErr</code>: a non-blocking TSdlIOStream that can be used to read error output from the process, if it was created with <code>TSdlProperty.ProcessCreateStdErr</code> set to <code>TSdlProcessIO.App</code>.</li> <li><code>TSdlProperty.ProcessBackground</code>: True if the process is running in the background. </li> </ul> <p><code>property Properties: TSdlProperties read GetProperties</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#remarks_2","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#Create_0","title":"<code>Create</code>","text":"<p>Create a new process with the specified properties.</p> <p>These are the supported properties:</p> <ul> <li><code>TSdlProperty.ProcessCreateArgs</code>: an array of strings (PUTF8Char) containing the program to run, any arguments, and a nil pointer. This is a required property.</li> <li><code>TSdlProperty.ProcessCreateEnvironment</code>: a TSdlEnvironment pointer. If this property is set, it will be the entire environment for the process, otherwise the current environment is used.</li> <li><code>TSdlProperty.ProcessCreateStdIn</code>: a TSdlProcessIO value describing where standard input for the process comes from, defaults to <code>TSdlProcessStdIO.Null</code>.</li> <li><code>TSdlProperty.ProcessCreateStdInStream</code>: a TSdlIOStream pointer used for standard input when <code>TSdlProperty.ProcessCreateStdIn</code> is set to <code>TSdlProcessStdIO.Redirect</code>.</li> <li><code>TSdlProperty.ProcessCreateStdOut</code>: a TSdlProcessIO value describing where standard output for the process goes go, defaults to <code>TSdlProcessStdIO.Inherited</code>.</li> <li><code>TSdlProperty.ProcessCreateStdOutStream</code>: a TSdlIOStream pointer used for standard output when <code>TSdlProperty.ProcessCreateStdOut</code> is set <code>TSdlProcessStdIO.Redirect</code>.</li> <li><code>TSdlProperty.ProcessCreateStdErr</code>: a TSdlProcessIO value describing where standard error for the process goes go, defaults to <code>TSdlProcessStdIO.Inherited</code>.</li> <li><code>TSdlProperty.ProcessCreateStdErrStream</code>: a TSdlIOStream pointer used for standard error when <code>TSdlProperty.ProcessCreateStdErr</code> is set to <code>TSdlProcessStdIO.Redirect</code>.</li> <li><code>TSdlProperty.ProcessCreateStdErrToStdOut</code>: True if the error output of the process should be redirected into the standard output of the process. This property has no effect if <code>TSdlProperty.ProcessCreateStdErr</code> is set.</li> <li><code>TSdlProperty.ProcessCreateBackground</code>: True if the process should run in the background. In this case the default input and output is <code>TSdlProcessStdIO.Null</code> and the exitcode of the process is not available, and will always be 0.</li> </ul> <p>On POSIX platforms, wait() and waitpid(-1, ...) should not be called, and SIGCHLD should not be ignored or handled because those would prevent SDL from properly tracking the lifetime of the underlying process. You should use Wait instead. </p> <p><code>constructor Create(const AProps: TSdlProperties); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#parameters","title":"Parameters","text":"<p><code>AProps</code>: <code>TSdlProperties</code> : The properties to use.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#see-also_2","title":"See Also","text":"<ul> <li>Properties</li> <li>Read</li> <li>Input</li> <li>Output</li> <li>Kill</li> <li>Wait</li> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#remarks_3","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#Create_1","title":"<code>Create</code>","text":"<p>Create a new process.</p> <p>The path to the executable is supplied in AExePath. AArgs are additional arguments passed on the command line of the new process.</p> <p>Setting APipeStdIO to True is equivalent to setting <code>TSdlProperty.ProcessCreateStdIn</code> and <code>TSdlProperty.ProcessCreateStdOut</code> to <code>TSdlProcessStrIO.App</code>, and will allow the use of Read or Input and Output.</p> <p>See the other constructor for more details. </p> <p><code>constructor Create(const AExePath: String; const AArgs: TArray&lt;String&gt;; const APipeStdIO: Boolean); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#parameters_1","title":"Parameters","text":"<p><code>AExePath</code>: <code>String</code> : Path to the executable.</p> <p><code>AArgs</code>: <code>TArray&lt;String&gt;</code> : Arguments for the new process.</p> <p><code>APipeStdIO</code>: <code>Boolean</code> : True to create pipes to the process's standard input and from the process's standard output, False for the process to have no input and inherit the application's standard output.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#see-also_3","title":"See Also","text":"<ul> <li>Properties</li> <li>Read</li> <li>Input</li> <li>Output</li> <li>Kill</li> <li>Wait</li> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#remarks_4","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#Equal","title":"Equal(TSdlProcess, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlProcess; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlProcess</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlProcess; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#parameters_3","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#returns_1","title":"Returns","text":"<p><code>TSdlProcess</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#NotEqual","title":"NotEqual(TSdlProcess, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlProcess; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#parameters_4","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlProcess</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#Free","title":"Free","text":"<p>Destroy the previously created process object.</p> <p>Note that this does not stop the process, just destroys the SDL object used to track it. If you want to stop the process you should use Kill. </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#see-also_4","title":"See Also","text":"<ul> <li>Kill</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#remarks_5","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#Kill","title":"Kill(Boolean)","text":"<p>Stop the process. </p> <p><code>procedure Kill(const AForce: Boolean = False); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#parameters_5","title":"Parameters","text":"<p><code>AForce</code>: <code>Boolean = False</code> : (Optional) True to terminate the process immediately, False (Default) to try to stop the process gracefully. In general you should try to stop the process gracefully first as terminating a process may leave it with half-written data or in some other unstable state.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#see-also_5","title":"See Also","text":"<ul> <li>Wait</li> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#remarks_6","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#Read_0","title":"Read(Integer)","text":"<p>Read all the output from a process.</p> <p>If a process was created with I/O enabled, you can use this function to read the output. This function blocks until the process is complete, capturing all output, and providing the process exit code. </p> <p><code>function Read(out AExitCode: Integer): TBytes; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#parameters_6","title":"Parameters","text":"<p><code>AExitCode</code>: <code>Integer</code> : Is set to the process exit code if the process has exited.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#returns_3","title":"Returns","text":"<p><code>TBytes</code>: The data.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#remarks_7","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#Read_1","title":"Read","text":"<p>Read all the output from a process.</p> <p>If a process was created with I/O enabled, you can use this function to read the output. This function blocks until the process is complete, capturing all output, and providing the process exit code. </p> <p><code>function Read: TBytes; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#returns_4","title":"Returns","text":"<p><code>TBytes</code>: The data.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#remarks_8","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#Wait_0","title":"Wait(Boolean, Integer)","text":"<p>Wait for the process to finish.</p> <p>This can be called multiple times to get the status of a process.</p> <p>The exit code will be the exit code of the process if it terminates normally, a negative signal if it terminated due to a signal, or -255 otherwise. It will not be changed if the process is still running.</p> <p>If you create a process with standard output piped to the application (<code>APipeStdIO</code> being True) then you should read all of the process output before calling Wait. If you don't do this the process might be blocked indefinitely waiting for output to be read and Wait will never return True. </p> <p><code>function Wait(const ABlock: Boolean; out AExitCode: Integer): Boolean; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#parameters_7","title":"Parameters","text":"<p><code>ABlock</code>: <code>Boolean</code> : If True, block until the process finishes; otherwise, report on the process' status.</p> <p><code>AExitCode</code>: <code>Integer</code> : Is set to the process exit code if the process has exited.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#returns_5","title":"Returns","text":"<p><code>Boolean</code>: True if the process exited, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#see-also_6","title":"See Also","text":"<ul> <li>Kill</li> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#remarks_9","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#Wait_1","title":"Wait(Boolean)","text":"<p>Wait for the process to finish.</p> <p>This can be called multiple times to get the status of a process.</p> <p>If you create a process with standard output piped to the application (<code>APipeStdIO</code> being True) then you should read all of the process output before calling Wait. If you don't do this the process might be blocked indefinitely waiting for output to be read and Wait will never return True. </p> <p><code>function Wait(const ABlock: Boolean): Boolean; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#parameters_8","title":"Parameters","text":"<p><code>ABlock</code>: <code>Boolean</code> : If True, block until the process finishes; otherwise, report on the process' status.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#returns_6","title":"Returns","text":"<p><code>Boolean</code>: True if the process exited, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#see-also_7","title":"See Also","text":"<ul> <li>Kill</li> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlProcess/#remarks_10","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/","title":"TSdlTray","text":"<p>A toplevel system tray object. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlTray = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#properties","title":"Properties","text":"Name Description Menu The previously created tray menu."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#constructors","title":"Constructors","text":"Name Description Create Create an icon to be placed in the operating system's tray, or equivalent."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#methods","title":"Methods","text":"Name Description CreateMenu Create a menu for the system tray. Free Destroys the tray object. SetIcon Updates the system tray icon's icon. SetTooltip Updates the system tray icon's tooltip. Update Update the trays."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#Menu","title":"Menu","text":"<p>The previously created tray menu.</p> <p>You should have called CreateMenu. This property allows you to fetch it again later.</p> <p>This property does the same thing as TSdlTrayEntry.Submenu, except that it works on a TSdlTray instead of a TSdlTrayEntry.</p> <p>A menu does not need to be destroyed; it will be destroyed with the tray. </p> <p><code>property Menu: TSdlTrayMenu read GetMenu</code></p> <p>Type: <code>TSdlTrayMenu</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#see-also","title":"See Also","text":"<ul> <li>CreateMenu</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#remarks","title":"Remarks","text":"<p>This property should be used on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#Create","title":"<code>Create</code>","text":"<p>Create an icon to be placed in the operating system's tray, or equivalent.</p> <p>Many platforms advise not using a system tray unless persistence is a necessary feature. Avoid needlessly creating a tray icon, as the user may feel like it clutters their interface.</p> <p>Using tray icons require the video subsystem. </p> <p><code>constructor Create(const AIcon: TSdlSurface; const ATooltip: String = '')</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#parameters","title":"Parameters","text":"<p><code>AIcon</code>: <code>TSdlSurface</code> : A surface to be used as icon. May be nil.</p> <p><code>ATooltip</code>: <code>String = ''</code> : (Optional) tooltip to be displayed when the mouse hovers the icon. Not supported on all platforms.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#see-also_1","title":"See Also","text":"<ul> <li>TSdlTrayMenu</li> <li>Menu</li> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#remarks_1","title":"Remarks","text":"<p>This constructor should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#Equal","title":"Equal(TSdlTray, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlTray; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#parameters_1","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlTray</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlTray; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#parameters_2","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#returns_1","title":"Returns","text":"<p><code>TSdlTray</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#NotEqual","title":"NotEqual(TSdlTray, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlTray; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#parameters_3","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlTray</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#CreateMenu","title":"CreateMenu","text":"<p>Create a menu for the system tray.</p> <p>This should be called at most once per tray icon.</p> <p>This function does the same thing as TSdlTrayEntry.CreateSubMenu, except that it works on a TSdlTray instead of a TSdlTrayEntry.</p> <p>A menu does not need to be destroyed; it will be destroyed with the tray. </p> <p><code>function CreateMenu: TSdlTrayMenu; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#returns_3","title":"Returns","text":"<p><code>TSdlTrayMenu</code>: The newly created menu.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#see-also_2","title":"See Also","text":"<ul> <li>Menu</li> <li>TSdlTrayMenu.Parent</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#remarks_2","title":"Remarks","text":"<p>This method should be called on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#Free","title":"Free","text":"<p>Destroys the tray object.</p> <p>This also destroys all associated menus and entries. </p> <p><code>procedure Free</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#remarks_3","title":"Remarks","text":"<p>This method should be called on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#SetIcon","title":"SetIcon(TSdlSurface)","text":"<p>Updates the system tray icon's icon. </p> <p><code>procedure SetIcon(const AIcon: TSdlSurface); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#parameters_4","title":"Parameters","text":"<p><code>AIcon</code>: <code>TSdlSurface</code> : The new icon. May be nil.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#remarks_4","title":"Remarks","text":"<p>This method should be called on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#SetTooltip","title":"SetTooltip(String)","text":"<p>Updates the system tray icon's tooltip. </p> <p><code>procedure SetTooltip(const ATooltip: String); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#parameters_5","title":"Parameters","text":"<p><code>ATooltip</code>: <code>String</code> : The new tooltip.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#remarks_5","title":"Remarks","text":"<p>This method should be called on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#Update","title":"Update","text":"<p>Update the trays.</p> <p>This is called automatically by the event loop and is only needed if you're using trays but aren't handling SDL events. </p> <p><code>class procedure Update; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTray/#remarks_6","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/","title":"TSdlTrayEntry","text":"<p>An entry on a system tray object. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlTrayEntry = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#properties","title":"Properties","text":"Name Description Caption The caption of the entry, or empty if the entry is a separator. IsChecked Whether or not the entry is checked. IsEnabled Whether or not an entry is enabled. Parent The menu containing the tray entry. Submenu Gets a previously created tray entry submenu."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#events","title":"Events","text":"Name Description OnSelect A callback to be invoked when the entry is selected."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#methods","title":"Methods","text":"Name Description Click Simulate a click on the tray entry. CreateSubmenu Create a submenu for the system tray entry. Remove Removes this tray entry."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#Caption","title":"Caption","text":"<p>The caption of the entry, or empty if the entry is a separator.</p> <p>An entry cannot change between a separator and an ordinary entry; that is, it is not possible to set a non-empty caption on an entry that has an empty caption (separators), or to set an empty caption to an entry that has a non-empty caption. It will silently fail if that happens. </p> <p><code>property Caption: String read GetCaption write SetCaption</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#see-also","title":"See Also","text":"<ul> <li>TSdlTrayMenu.Entries</li> <li>TSdlTrayMenu.Insert</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#remarks","title":"Remarks","text":"<p>This property should be used on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#IsChecked","title":"IsChecked","text":"<p>Whether or not the entry is checked.</p> <p>The entry must have been created with TSdlTrayEntryFlag.Checkbox. </p> <p><code>property IsChecked: Boolean read GetIsChecked write SetIsChecked</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#see-also_1","title":"See Also","text":"<ul> <li>TSdlTrayMenu.Entries</li> <li>TSdlTrayMenu.Insert</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#remarks_1","title":"Remarks","text":"<p>This property should be used on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#IsEnabled","title":"IsEnabled","text":"<p>Whether or not an entry is enabled. </p> <p><code>property IsEnabled: Boolean read GetIsEnabled write SetIsEnabled</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#see-also_2","title":"See Also","text":"<ul> <li>TSdlTrayMenu.Entries</li> <li>TSdlTrayMenu.Insert</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#remarks_2","title":"Remarks","text":"<p>This property should be used on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#Parent","title":"Parent","text":"<p>The menu containing the tray entry. </p> <p><code>property Parent: TSdlTrayMenu read GetParent</code></p> <p>Type: <code>TSdlTrayMenu</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#see-also_3","title":"See Also","text":"<ul> <li>TSdlTrayMenu.Insert</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#remarks_3","title":"Remarks","text":"<p>This property should be used on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#Submenu","title":"Submenu","text":"<p>Gets a previously created tray entry submenu.</p> <p>You should have called CreateSubmenu. This property allows you to fetch it again later.</p> <p>This property does the same thing as TSdlTray.Menu, except that it works on a TSdlTrayEntry instead of a TSdlTray.</p> <p>A menu does not need to be destroyed; it will be destroyed with the tray. </p> <p><code>property Submenu: TSdlTrayMenu read GetSubmenu</code></p> <p>Type: <code>TSdlTrayMenu</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#see-also_4","title":"See Also","text":"<ul> <li>TSdlTrayMenu.Insert</li> <li>CreateSubmenu</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#remarks_4","title":"Remarks","text":"<p>This property should be used on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#event-descriptions","title":"Event Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#OnSelect","title":"OnSelect","text":"<p>A callback to be invoked when the entry is selected. </p> <p><code>property OnSelect: TSdlTrayCallback write SetOnSelect</code></p> <p>Type: <code>TSdlTrayCallback</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#see-also_5","title":"See Also","text":"<ul> <li>TSdlTrayMenu.Entries</li> <li>TSdlTrayMenu.Insert</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#remarks_5","title":"Remarks","text":"<p>This property should be used on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#Equal","title":"Equal(TSdlTrayEntry, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlTrayEntry; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlTrayEntry</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlTrayEntry; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#returns_1","title":"Returns","text":"<p><code>TSdlTrayEntry</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#NotEqual","title":"NotEqual(TSdlTrayEntry, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlTrayEntry; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlTrayEntry</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#Click","title":"Click","text":"<p>Simulate a click on the tray entry. </p> <p><code>procedure Click; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#remarks_6","title":"Remarks","text":"<p>This method should be called on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#CreateSubmenu","title":"CreateSubmenu","text":"<p>Create a submenu for the system tray entry.</p> <p>This should be called at most once per tray entry.</p> <p>This function does the same thing as TSdlTray.CreateMenu, except that works on a TSdlTrayEntry instead of a TSdlTray.</p> <p>A menu does not need to be destroyed; it will be destroyed with the tray. </p> <p><code>function CreateSubmenu: TSdlTrayMenu; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#returns_3","title":"Returns","text":"<p><code>TSdlTrayMenu</code>: The newly created menu.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#see-also_6","title":"See Also","text":"<ul> <li>TSdlTrayMenu.Insert</li> <li>Submenu</li> <li>TSdlTrayMenu.ParentEntry</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#remarks_7","title":"Remarks","text":"<p>This method should be called on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#Remove","title":"Remove","text":"<p>Removes this tray entry. </p> <p><code>procedure Remove; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#see-also_7","title":"See Also","text":"<ul> <li>TSdlTrayMenu.Entries</li> <li>TSdlTrayMenu.Insert</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayEntry/#remarks_8","title":"Remarks","text":"<p>This method should be called on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/","title":"TSdlTrayMenu","text":"<p>A menu/submenu on a system tray object. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlTrayMenu = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#properties","title":"Properties","text":"Name Description Entries A list of entries in the menu, in order. Parent The tray for which this menu is the first-level menu, if the current menu isn't a submenu. ParentEntry The entry for which this menu is a submenu, if the current menu is a submenu."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#methods","title":"Methods","text":"Name Description Insert Insert a tray entry at a given position."},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#Entries","title":"Entries","text":"<p>A list of entries in the menu, in order. </p> <p><code>property Entries: TArray&lt;TSdlTrayEntry&gt; read GetEntries</code></p> <p>Type: <code>TArray&lt;TSdlTrayEntry&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#see-also","title":"See Also","text":"<ul> <li>TSdlTrayEntry.Remove</li> <li>Insert</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#remarks","title":"Remarks","text":"<p>This property should be used on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#Parent","title":"Parent","text":"<p>The tray for which this menu is the first-level menu, if the current menu isn't a submenu.</p> <p>Either this property or ParentEntry will return non-nil for any given menu. </p> <p><code>property Parent: TSdlTray read GetParent</code></p> <p>Type: <code>TSdlTray</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#see-also_1","title":"See Also","text":"<ul> <li>TSdlTray.CreateMenu</li> <li>ParentEntry</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#remarks_1","title":"Remarks","text":"<p>This property should be used on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#ParentEntry","title":"ParentEntry","text":"<p>The entry for which this menu is a submenu, if the current menu is a submenu.</p> <p>Either this property or Parent will return non-nil for any given menu. </p> <p><code>property ParentEntry: TSdlTrayEntry read GetParentEntry</code></p> <p>Type: <code>TSdlTrayEntry</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#see-also_2","title":"See Also","text":"<ul> <li>TSdlTrayEntry.CreateSubmenu</li> <li>TSdlTrayEntry.Parent</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#remarks_2","title":"Remarks","text":"<p>This property should be used on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#Equal","title":"Equal(TSdlTrayMenu, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlTrayMenu; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlTrayMenu</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlTrayMenu; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#returns_1","title":"Returns","text":"<p><code>TSdlTrayMenu</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#NotEqual","title":"NotEqual(TSdlTrayMenu, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlTrayMenu; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlTrayMenu</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#Insert","title":"Insert(Integer, String, TSdlTrayEntryFlags)","text":"<p>Insert a tray entry at a given position.</p> <p>If ACaption is empty, the entry will be a separator. Many functions won't work for an entry that is a separator.</p> <p>An entry does not need to be destroyed; it will be destroyed with the tray. </p> <p><code>function Insert(const APos: Integer; const ACaption: String; const AFlags: TSdlTrayEntryFlags): TSdlTrayEntry; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure (e.g. when APos is out of bounds).</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#parameters_3","title":"Parameters","text":"<p><code>APos</code>: <code>Integer</code> : The desired position for the new entry. Entries at or following this place will be moved. If APos is -1, the entry is appended.</p> <p><code>ACaption</code>: <code>String</code> : The text to be displayed on the entry, or empty for a separator.</p> <p><code>AFlags</code>: <code>TSdlTrayEntryFlags</code> : A combination of flags, some of which are mandatory.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#returns_3","title":"Returns","text":"<p><code>TSdlTrayEntry</code>: The newly created entry.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#see-also_3","title":"See Also","text":"<ul> <li>TSdlTrayEntryFlags</li> <li>Entries</li> <li>TSdlTrayEntry.Remove</li> <li>TSdlTrayEntry.Parent</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/classes/TSdlTrayMenu/#remarks_3","title":"Remarks","text":"<p>This method should be called on the thread that created the tray. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/constants/SDL_CACHELINE_SIZE/","title":"SDL_CACHELINE_SIZE","text":"<p>A guess for the cacheline size used for padding.</p> <p>Most x86 processors have a 64 byte cache line. The 64-bit PowerPC processors have a 128 byte cache line. We use the larger value to be generally safe. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/constants/SDL_CACHELINE_SIZE/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>const SDL_CACHELINE_SIZE = Neslib.Sdl3.Api.SDL_CACHELINE_SIZE\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/constants/SDL_SINGLE_EPSILON/","title":"SDL_SINGLE_EPSILON","text":"<p>Epsilon constant, used for comparing floating-point numbers.</p> <p>Equals to 1.1920928955078125e-07 </p>"},{"location":"Reference/Neslib.Sdl3.Additional/constants/SDL_SINGLE_EPSILON/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>const SDL_SINGLE_EPSILON = SDL_FLT_EPSILON\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/constants/SDL_SINGLE_EPSILON/#remarks","title":"Remarks","text":"<p>Note that this is different from Delphi's Single.Epsilon value. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/interfaces/ISdlClipboardDataProvider/","title":"ISdlClipboardDataProvider","text":"<p>Implement this interface to provide (non-text) data for the clipboard. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/interfaces/ISdlClipboardDataProvider/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type ISdlClipboardDataProvider = interface ... end\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/interfaces/ISdlClipboardDataProvider/#inheritance","title":"Inheritance","text":""},{"location":"Reference/Neslib.Sdl3.Additional/interfaces/ISdlClipboardDataProvider/#see-also","title":"See Also","text":"<ul> <li>TSdlClipboard.SetData</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/interfaces/ISdlClipboardDataProvider/#methods","title":"Methods","text":"Name Description Cleanup Will be called when the clipboard is cleared, or new data is set. Data Will be called when data for the specified mime-type is requested by the OS."},{"location":"Reference/Neslib.Sdl3.Additional/interfaces/ISdlClipboardDataProvider/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Additional/interfaces/ISdlClipboardDataProvider/#Cleanup","title":"Cleanup","text":"<p>Will be called when the clipboard is cleared, or new data is set. </p> <p><code>procedure Cleanup</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/interfaces/ISdlClipboardDataProvider/#see-also_1","title":"See Also","text":"<ul> <li>TSdlClipboard.SetData</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/interfaces/ISdlClipboardDataProvider/#Data","title":"Data(String, NativeInt)","text":"<p>Will be called when data for the specified mime-type is requested by the OS.</p> <p>This method is called with an empty string as the mime_type when the clipboard is cleared or new data is set. The clipboard is automatically cleared in SdlQuit. </p> <p><code>function Data(const AMimeType: String; out ASize: NativeInt): Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/interfaces/ISdlClipboardDataProvider/#parameters","title":"Parameters","text":"<p><code>AMimeType</code>: <code>String</code> : The requested mime-type.</p> <p><code>ASize</code>: <code>NativeInt</code> : You should set this to the size of the returned data.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/interfaces/ISdlClipboardDataProvider/#returns","title":"Returns","text":"<p><code>Pointer</code>: You should return a pointer to the data for the provided mime-type. Returning nil or setting ASize to 0 will cause no data to be sent to the \"receiver\". It is up to the receiver to handle this. Essentially returning no data is more or less undefined behavior and may cause breakage in receiving applications. The returned data will not be freed so it needs to be retained and dealt with internally.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/interfaces/ISdlClipboardDataProvider/#see-also_2","title":"See Also","text":"<ul> <li>TSdlClipboard.SetData</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlAlignedAlloc/","title":"SdlAlignedAlloc","text":"<p>Allocate memory aligned to a specific alignment.</p> <p>The memory returned by this function must be freed with SdlAlignedFree, not SdlFree.</p> <p>If <code>AAlignment</code> is less than the size of a pointer, it will be increased to match that.</p> <p>The returned memory address will be a multiple of the alignment value, and the size of the memory allocated will be a multiple of the alignment value. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlAlignedAlloc/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>function SdlAlignedAlloc(const AAlignment, ASize: NativeInt): Pointer; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlAlignedAlloc/#parameters","title":"Parameters","text":"<p><code>AAlignment</code>: <code>NativeInt</code> : The alignment of the memory.</p> <p><code>ASize</code>: <code>NativeInt</code> : The size to allocate.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlAlignedAlloc/#returns","title":"Returns","text":"<p><code>Pointer</code>: A pointer to the aligned memory, or nil if allocation failed.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlAlignedAlloc/#see-also","title":"See Also","text":"<ul> <li>SdlAlignedFree</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlAlignedAlloc/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlAlignedFree/","title":"SdlAlignedFree","text":"<p>Free memory allocated by SdlAlignedAlloc.</p> <p>The pointer is no longer valid after this call and cannot be dereferenced anymore.</p> <p>If <code>AMem</code> is nil, this function does nothing. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlAlignedFree/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>procedure SdlAlignedFree(const AMem: Pointer); inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlAlignedFree/#parameters","title":"Parameters","text":"<p><code>AMem</code>: <code>Pointer</code> : A pointer previously returned by SdlAlignedAlloc, or nil.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlAlignedFree/#see-also","title":"See Also","text":"<ul> <li>SdlAlignedAlloc</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlAlignedFree/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlCAlloc/","title":"SdlCAlloc","text":"<p>Allocate a zero-initialized array using SDL's memory manager.</p> <p>The memory returned by this function must be freed with SdlFree and not with Delphi's FreeMem.</p> <p>If either of <code>ANumElements</code> or <code>AElementSize</code> is 0, they will both be set to 1. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlCAlloc/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>function SdlCAlloc(const ANumElements, AElementSize: NativeInt): Pointer; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlCAlloc/#parameters","title":"Parameters","text":"<p><code>ANumElements</code>: <code>NativeInt</code> : The number of elements in the array.</p> <p><code>AElementSize</code>: <code>NativeInt</code> : The size of each element of the array.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlCAlloc/#returns","title":"Returns","text":"<p><code>Pointer</code>: A pointer to the allocated array, or nil if allocation failed.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlCAlloc/#see-also","title":"See Also","text":"<ul> <li>SdlFree</li> <li>SdlMAlloc</li> <li>SdlRealloc</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlCAlloc/#remarks","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlCrc16/","title":"SdlCrc16","text":"<p>Calculate a CRC-16 value.</p> <p>See  Cyclic Redundancy Check.</p> <p>This function can be called multiple times, to stream data to be checksummed in blocks. Each call must provide the previous CRC-16 return value to be updated with the next block. The first call to this function for a set of blocks should pass in a zero CRC value. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlCrc16/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>function SdlCrc16(const ACrc: Word; const AData: Pointer; \n  const ASize: NativeInt): Word; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlCrc16/#parameters","title":"Parameters","text":"<p><code>ACrc</code>: <code>Word</code> : The current checksum for this data set, or 0 for a new data set.</p> <p><code>AData</code>: <code>Pointer</code> : A new block of data to add to the checksum.</p> <p><code>ASize</code>: <code>NativeInt</code> : The size, in bytes, of the new block of data.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlCrc16/#returns","title":"Returns","text":"<p><code>Word</code>: A CRC-16 checksum value of all blocks in the data set.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlCrc16/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlCrc32/","title":"SdlCrc32","text":"<p>Calculate a CRC-32 value.</p> <p>See  Cyclic Redundancy Check.</p> <p>This function can be called multiple times, to stream data to be checksummed in blocks. Each call must provide the previous CRC-32 return value to be updated with the next block. The first call to this function for a set of blocks should pass in a zero CRC value. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlCrc32/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>function SdlCrc32(const ACrc: Cardinal; const AData: Pointer; \n  const ASize: NativeInt): Cardinal; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlCrc32/#parameters","title":"Parameters","text":"<p><code>ACrc</code>: <code>Cardinal</code> : The current checksum for this data set, or 0 for a new data set.</p> <p><code>AData</code>: <code>Pointer</code></p> <p><code>ASize</code>: <code>NativeInt</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlCrc32/#returns","title":"Returns","text":"<p><code>Cardinal</code>: A CRC-32 checksum value of all blocks in the data set.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlCrc32/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlFillChar4/","title":"SdlFillChar4","text":"<p>Initialize all 32-bit words of buffer of memory to a specific value.</p> <p>This function will set a buffer of <code>ACount</code> UInt32 values, pointed to by <code>ADst</code>, to the value specified in <code>AVal</code>.</p> <p>Unlike FillChar, this sets 32-bit values, not bytes, so it's not limited to a range of 0-255. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlFillChar4/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>function SdlFillChar4(var ADst; const ACount: NativeInt; \n  const AVal: Cardinal): Pointer; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlFillChar4/#parameters","title":"Parameters","text":"<p><code>ADst</code>:  : The destination memory region.</p> <p><code>ACount</code>: <code>NativeInt</code> : The number of UInt32 values to set in <code>ADst</code>.</p> <p><code>AVal</code>: <code>Cardinal</code> : The UInt32 value to set.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlFillChar4/#returns","title":"Returns","text":"<p><code>Pointer</code>: The pointer to <code>ADst</code>.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlFillChar4/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlFree/","title":"SdlFree","text":"<p>Free allocated memory using SDL's memory manager.</p> <p>This should (and must) only be used for freeing memory allocated by SDL's memory manager function (like SdlMAlloc). Do not use it to free memory allocated by Delphi's memory manager functions (like GetMem).</p> <p>The pointer is no longer valid after this call and cannot be dereferenced anymore.</p> <p>If <code>AMem</code> is nil, this routine does nothing. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlFree/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>procedure SdlFree(const AMem: Pointer); inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlFree/#parameters","title":"Parameters","text":"<p><code>AMem</code>: <code>Pointer</code> : A pointer to allocated memory, or nil.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlFree/#see-also","title":"See Also","text":"<ul> <li>SdlMAlloc</li> <li>SdlCAlloc</li> <li>SdlRealloc</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlFree/#remarks","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetDirect3D9AdapterIndex/","title":"SdlGetDirect3D9AdapterIndex","text":"<p>Get the D3D9 adapter index that matches the specified display.</p> <p>The returned adapter index can be passed to <code>IDirect3D9.CreateDevice</code> and controls on which monitor a full screen application will appear. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetDirect3D9AdapterIndex/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>function SdlGetDirect3D9AdapterIndex(const ADisplayID: TSdlDisplayID): Integer; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetDirect3D9AdapterIndex/#parameters","title":"Parameters","text":"<p><code>ADisplayID</code>: <code>TSdlDisplayID</code> : The instance of the display to query.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetDirect3D9AdapterIndex/#returns","title":"Returns","text":"<p><code>Integer</code>: The D3D9 adapter index.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetDirect3D9AdapterIndex/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetDxgiOutputInfo/","title":"SdlGetDxgiOutputInfo","text":"<p>Get the DXGI Adapter and Output indices for the specified display.</p> <p>The DXGI Adapter and Output indices can be passed to <code>EnumAdapters</code> and <code>EnumOutputs</code> respectively to get the objects required to create a DX10 or DX11 device and swap chain. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetDxgiOutputInfo/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>procedure SdlGetDxgiOutputInfo(const ADisplayID: TSdlDisplayID; \n  out AAdapterIndex, AOutputIndex: Integer); inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetDxgiOutputInfo/#parameters","title":"Parameters","text":"<p><code>ADisplayID</code>: <code>TSdlDisplayID</code> : The instance of the display to query.</p> <p><code>AAdapterIndex</code>: <code>Integer</code> : Is set to the adapter index.</p> <p><code>AOutputIndex</code>: <code>Integer</code> : Is set to the output index.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetDxgiOutputInfo/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetPowerInfo/","title":"SdlGetPowerInfo","text":"<p>Get the current power supply details.</p> <p>You should never take a battery status as absolute truth. Batteries (especially failing batteries) are delicate hardware, and the values reported here are best estimates based on what that hardware reports. It's not uncommon for older batteries to lose stored power much faster than it reports, or completely drain when reporting it has 20 percent left, etc.</p> <p>Battery status can change at any time; if you are concerned with power state, you should call this function frequently, and perhaps ignore changes until they seem to be stable for a few seconds.</p> <p>It's possible a platform can only report battery percentage or time left but not both. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetPowerInfo/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>function SdlGetPowerInfo(out ASeconds, APercent: Integer): TSdlPowerState; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetPowerInfo/#parameters","title":"Parameters","text":"<p><code>ASeconds</code>: <code>Integer</code> : Set to the seconds of battery life left. This will be set to -1 if we can't determine a value or there is no battery.</p> <p><code>APercent</code>: <code>Integer</code> : Set to the percentage of battery life left, between 0 and 100. This will be set to -1 if we can't determine a value or there is no battery.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetPowerInfo/#returns","title":"Returns","text":"<p><code>TSdlPowerState</code>: The current battery state.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetPowerInfo/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetSandbox/","title":"SdlGetSandbox","text":"<p>Get the application sandbox environment, if any. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetSandbox/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>function SdlGetSandbox: TSdlSandbox; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlGetSandbox/#returns","title":"Returns","text":"<p><code>TSdlSandbox</code>: The application sandbox environment or TSdlSandbox.None if the application is not running in a sandbox environment.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlIsTV/","title":"SdlIsTV","text":"<p>Query if the current device is a TV.</p> <p>If SDL can't determine this, it will return False. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlIsTV/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>function SdlIsTV: Boolean; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlIsTV/#returns","title":"Returns","text":"<p><code>Boolean</code>: True if the device is a TV, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlIsTablet/","title":"SdlIsTablet","text":"<p>Query if the current device is a tablet.</p> <p>If SDL can't determine this, it will return False. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlIsTablet/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>function SdlIsTablet: Boolean; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlIsTablet/#returns","title":"Returns","text":"<p><code>Boolean</code>: True if the device is a tablet, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlMAlloc/","title":"SdlMAlloc","text":"<p>Allocate uninitialized memory using SDL's memory manager.</p> <p>The allocated memory returned by this function must be freed with SdlFree and not with Delphi's FreeMem.</p> <p>If <code>ASize</code> is 0, it will be set to 1.</p> <p>If you want to allocate memory aligned to a specific alignment, consider using SdlAlignedAlloc. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlMAlloc/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>function SdlMAlloc(const ASize: NativeInt): Pointer; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlMAlloc/#parameters","title":"Parameters","text":"<p><code>ASize</code>: <code>NativeInt</code> : The size to allocate.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlMAlloc/#returns","title":"Returns","text":"<p><code>Pointer</code>: A pointer to the allocated memory, or nil if allocation failed.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlMAlloc/#see-also","title":"See Also","text":"<ul> <li>SdlFree</li> <li>SdlCAlloc</li> <li>SdlRealloc</li> <li>SdlAlignedAlloc</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlMAlloc/#remarks","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlMurmur3/","title":"SdlMurmur3","text":"<p>Calculate a 32-bit MurmurHash3 value for a block of data.</p> <p>See  MurmurHash.</p> <p>A seed may be specified, which changes the final results consistently, but this does not work like SdlCrc16 and SdlCrc32: you can't feed a previous result from this function back into itself as the next seed value to calculate a hash in chunks; it won't produce the same hash as it would if the same data was provided in a single call.</p> <p>If you aren't sure what to provide for a seed, zero is fine. Murmur3 is not cryptographically secure, so it shouldn't be used for hashing top-secret data. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlMurmur3/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>function SdlMurmur3(const AData: Pointer; const ASize: NativeInt; \n  const ASeed: Cardinal = 0): Cardinal; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlMurmur3/#parameters","title":"Parameters","text":"<p><code>AData</code>: <code>Pointer</code> : The data to be hashed.</p> <p><code>ASize</code>: <code>NativeInt</code></p> <p><code>ASeed</code>: <code>Cardinal = 0</code> : (Optional) value that alters the final hash value.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlMurmur3/#returns","title":"Returns","text":"<p><code>Cardinal</code>: A Murmur3 32-bit hash value.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlMurmur3/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlNumAllocations/","title":"SdlNumAllocations","text":"<p>Get the number of outstanding (unfreed) allocations. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlNumAllocations/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>function SdlNumAllocations: Integer; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlNumAllocations/#returns","title":"Returns","text":"<p><code>Integer</code>: The number of allocations or -1 if allocation counting is disabled.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlNumAllocations/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread.</p> <p>This only counts the number of allocations made with SDL's memory functions. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlOpenUrl/","title":"SdlOpenUrl","text":"<p>Open a URL/URI in the browser or other appropriate external application.</p> <p>Open a URL in a separate, system-provided application. How this works will vary wildly depending on the platform. This will likely launch what makes sense to handle a specific URL's protocol (a web browser for <code>http://</code>, etc), but it might also be able to launch file managers for directories and other things.</p> <p>What happens when you open a URL varies wildly as well: your game window may lose focus (and may or may not lose focus if your game was fullscreen or grabbing input at the time). On mobile devices, your app will likely move to the background or your process might be paused. Any given platform may or may not handle a given URL.</p> <p>If this is unimplemented (or simply unavailable) for a platform, this will fail with an error. A successful result does not mean the URL loaded, just that we launched something to handle it (or at least believe we did).</p> <p>All this to say: this function can be useful, but you should definitely test it on every platform you target. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlOpenUrl/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>procedure SdlOpenUrl(const AUrl: String); inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlOpenUrl/#parameters","title":"Parameters","text":"<p><code>AUrl</code>: <code>String</code> : A valid URL/URI to open. Use <code>file:///full/path/to/file</code> for local files, if supported.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlOpenUrl/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlRealloc/","title":"SdlRealloc","text":"<p>Change the size of allocated memory using SDL's memory manager.</p> <p>The memory returned by this function must be freed with SdlFree and not Delphi's FreeMem.</p> <p>If <code>ASize</code> is 0, it will be set to 1.</p> <p>If <code>AMem</code> is nil, the behavior of this function is equivalent to SdlMAlloc. Otherwise, the function can have one of three possible outcomes:</p> <ul> <li>If it returns the same pointer as <code>AMem</code>, it means that <code>AMem</code> was resized in place without freeing.</li> <li>If it returns a different non-nil pointer, it means that <code>AMem</code> was freed and cannot be dereferenced anymore.</li> <li>If it returns nil (indicating failure), then <code>AMem</code> will remain valid and must still be freed with SdlFree. </li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlRealloc/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>function SdlRealloc(const AMem: Pointer; const ASize: NativeInt): Pointer; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlRealloc/#parameters","title":"Parameters","text":"<p><code>AMem</code>: <code>Pointer</code> : A pointer to allocated memory to reallocate, or nil.</p> <p><code>ASize</code>: <code>NativeInt</code> : The new size of the memory.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlRealloc/#returns","title":"Returns","text":"<p><code>Pointer</code>: A pointer to the newly allocated memory, or nil if allocation failed.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlRealloc/#see-also","title":"See Also","text":"<ul> <li>SdlFree</li> <li>SdlMAlloc</li> <li>SdlCAlloc</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlRealloc/#remarks","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlShowMessageBox/","title":"SdlShowMessageBox","text":"<p>Create a modal message box.</p> <p>If your needs aren't complex, it might be easier to use SdlShowSimpleMessageBox.</p> <p>This function should be called on the thread that created the parent window, or on the main thread if the messagebox has no parent. It will block execution of that thread until the user clicks a button or closes the messagebox.</p> <p>This function may be called at any time, even before SdlInit. This makes it useful for reporting errors like a failure to create a renderer or OpenGL context.</p> <p>On X11, SDL rolls its own dialog box with X11 primitives instead of a formal toolkit like GTK+ or Qt.</p> <p>Note that if SdlInit would fail because there isn't any available video target, this function is likely to fail for the same reasons. If this is a concern, check the return value from this function and fall back to writing to stderr if you can. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlShowMessageBox/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>function SdlShowMessageBox(const AData: TSdlMessageBoxData): Integer\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlShowMessageBox/#parameters","title":"Parameters","text":"<p><code>AData</code>: <code>TSdlMessageBoxData</code> : The TSdlMessageBoxData record with title, text and other options.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlShowMessageBox/#returns","title":"Returns","text":"<p><code>Integer</code>: The ID of the button the user pressed.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlShowMessageBox/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlShowMessageBox/#see-also","title":"See Also","text":"<ul> <li>SdlShowSimpleMessageBox</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlShowSimpleMessageBox_0/","title":"SdlShowSimpleMessageBox","text":"<p>Display a simple modal message box.</p> <p>If your needs aren't complex, this function is preferred over SdlShowMessageBox.</p> <p>This function should be called on the thread that created the parent window, or on the main thread if the messagebox has no parent. It will block execution of that thread until the user clicks a button or closes the messagebox.</p> <p>This function may be called at any time, even before SdlInit. This makes it useful for reporting errors like a failure to create a renderer or OpenGL context.</p> <p>On X11, SDL rolls its own dialog box with X11 primitives instead of a formal toolkit like GTK+ or Qt.</p> <p>Note that if SdlInit would fail because there isn't any available video target, this function is likely to fail for the same reasons. If this is a concern, check the return value from this function and fall back to writing to stderr if you can. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlShowSimpleMessageBox_0/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>procedure SdlShowSimpleMessageBox(const AFlags: TSdlMessageBoxFlags; \n  const ATitle, AMessage: String; const AWindow: TSdlWindow); overload\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlShowSimpleMessageBox_0/#parameters","title":"Parameters","text":"<p><code>AFlags</code>: <code>TSdlMessageBoxFlags</code> : Message box flags.</p> <p><code>ATitle</code>: <code>String</code> : Title.</p> <p><code>AMessage</code>: <code>String</code> : Message text.</p> <p><code>AWindow</code>: <code>TSdlWindow</code> : The parent window, or nil for no parent.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlShowSimpleMessageBox_0/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlShowSimpleMessageBox_0/#see-also","title":"See Also","text":"<ul> <li>SdlShowMessageBox</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlShowSimpleMessageBox_1/","title":"SdlShowSimpleMessageBox","text":"<p>Display a simple modal message box.</p> <p>If your needs aren't complex, this function is preferred over SdlShowMessageBox.</p> <p>This function should be called on the thread that created the parent window, or on the main thread if the messagebox has no parent. It will block execution of that thread until the user clicks a button or closes the messagebox.</p> <p>This function may be called at any time, even before SdlInit. This makes it useful for reporting errors like a failure to create a renderer or OpenGL context.</p> <p>On X11, SDL rolls its own dialog box with X11 primitives instead of a formal toolkit like GTK+ or Qt.</p> <p>Note that if SdlInit would fail because there isn't any available video target, this function is likely to fail for the same reasons. If this is a concern, check the return value from this function and fall back to writing to stderr if you can. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlShowSimpleMessageBox_1/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>procedure SdlShowSimpleMessageBox(const AFlags: TSdlMessageBoxFlags; \n  const ATitle, AMessage: String); overload\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlShowSimpleMessageBox_1/#parameters","title":"Parameters","text":"<p><code>AFlags</code>: <code>TSdlMessageBoxFlags</code> : Message box flags.</p> <p><code>ATitle</code>: <code>String</code> : Title.</p> <p><code>AMessage</code>: <code>String</code> : Message text.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlShowSimpleMessageBox_1/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/routines/SdlShowSimpleMessageBox_1/#see-also","title":"See Also","text":"<ul> <li>SdlShowMessageBox</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/types/PSdlMessageBoxButtonData/","title":"PSdlMessageBoxButtonData","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/PSdlMessageBoxButtonData/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type PSdlMessageBoxButtonData = ^TSdlMessageBoxButtonData\n</code></pre> <p>Base type: <code>TSdlMessageBoxButtonData</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/PSdlMessageBoxColorScheme/","title":"PSdlMessageBoxColorScheme","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/PSdlMessageBoxColorScheme/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type PSdlMessageBoxColorScheme = ^TSdlMessageBoxColorScheme\n</code></pre> <p>Base type: <code>TSdlMessageBoxColorScheme</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlCAllocFunc/","title":"TSdlCAllocFunc","text":"<p>A callback used to implement SdlCAlloc.</p> <p>SDL will always ensure that the passed <code>ANumElements</code> and <code>AElementSize</code> are both greater than 0. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlCAllocFunc/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlCAllocFunc = function(ANumElements, AElementSize: NativeInt): Pointer; cdecl\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlCAllocFunc/#parameters","title":"Parameters","text":"<p><code>ANumElements</code>: <code>NativeInt</code> : The number of elements in the array.</p> <p><code>AElementSize</code>: <code>NativeInt</code> : The size of each element of the array.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlCAllocFunc/#returns","title":"Returns","text":"<p><code>Pointer</code>: A pointer to the allocated array, or nil if allocation failed.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlCAllocFunc/#see-also","title":"See Also","text":"<ul> <li>SdlCAlloc</li> <li>TSdlMemoryManager.Original</li> <li>TSdlMemoryManager.Current</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlCAllocFunc/#remarks","title":"Remarks","text":"<p>It should be safe to call this callback from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlDialogFileCallback/","title":"TSdlDialogFileCallback","text":"<p>Callback used by file dialog functions.</p> <p>The specific usage is described in each function.</p> <p>If <code>AFilelist</code> is:</p> <ul> <li>nil: an error occurred, or the user didn't choose any file or canceled the dialog.</li> <li>non-nil: the user chose one or more files.</li> </ul> <p>The filter argument is the index of the filter that was selected, or -1 if no filter was selected or if the platform or method doesn't support fetching the selected filter.</p> <p>In Android, the <code>AFilelist</code> are <code>content://</code> URIs. They should be opened using TSdlIOStream.Create with appropriate modes. This applies both to open and save file dialog. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlDialogFileCallback/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlDialogFileCallback = procedure(const AFileList: TArray&lt;String&gt;; \n  const AFilter: Integer) of object\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlDialogFileCallback/#parameters","title":"Parameters","text":"<p><code>AFileList</code>: <code>TArray&lt;String&gt;</code> : The file(s) chosen by the user.</p> <p><code>AFilter</code>: <code>Integer</code> : Index of the selected filter.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlDialogFileCallback/#see-also","title":"See Also","text":"<ul> <li>TSdlDialogFileFilter</li> <li>TSdlDialog.ShowOpenFile</li> <li>TSdlDialog.ShowSaveFile</li> <li>TSdlDialog.ShowOpenFolder</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlFreeFunc/","title":"TSdlFreeFunc","text":"<p>A callback used to implement SdlFree.</p> <p>SDL will always ensure that the passed <code>AMem</code> is a non-nil pointer. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlFreeFunc/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlFreeFunc = procedure(AMem: Pointer); cdecl\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlFreeFunc/#parameters","title":"Parameters","text":"<p><code>AMem</code>: <code>Pointer</code> : A pointer to allocated memory.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlFreeFunc/#see-also","title":"See Also","text":"<ul> <li>SdlFree</li> <li>TSdlMemoryManager.Original</li> <li>TSdlMemoryManager.Current</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlFreeFunc/#remarks","title":"Remarks","text":"<p>It should be safe to call this callback from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMAllocFunc/","title":"TSdlMAllocFunc","text":"<p>A callback used to implement SdlMAlloc.</p> <p>SDL will always ensure that the passed <code>ASize</code> is greater than 0. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMAllocFunc/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlMAllocFunc = function(ASize: NativeInt): Pointer; cdecl\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMAllocFunc/#parameters","title":"Parameters","text":"<p><code>ASize</code>: <code>NativeInt</code> : The size to allocate.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMAllocFunc/#returns","title":"Returns","text":"<p><code>Pointer</code>: A pointer to the allocated memory, or nil if allocation failed.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMAllocFunc/#see-also","title":"See Also","text":"<ul> <li>SdlMAlloc</li> <li>TSdlMemoryManager.Original</li> <li>TSdlMemoryManager.Current</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMAllocFunc/#remarks","title":"Remarks","text":"<p>It should be safe to call this callback from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxButtonFlag/","title":"TSdlMessageBoxButtonFlag","text":"<p>Message box button flags. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxButtonFlag/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlMessageBoxButtonFlag = (ReturnKeyDefault, EscapeKeyDefault)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxButtonFlag/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxButtonFlag/#returnkeydefault-0","title":"<code>ReturnKeyDefault = 0</code>","text":"<p>Marks the default button when return is hit </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxButtonFlag/#escapekeydefault-1","title":"<code>EscapeKeyDefault = 1</code>","text":"<p>Marks the default button when escape is hit </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxButtonFlags/","title":"TSdlMessageBoxButtonFlags","text":"<p>A set of message box button flags. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxButtonFlags/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlMessageBoxButtonFlags = set of TSdlMessageBoxButtonFlag\n</code></pre> <p>Base type: <code>TSdlMessageBoxButtonFlag</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxColorType/","title":"TSdlMessageBoxColorType","text":"<p>An enumeration of indices inside the colors array of TSdlMessageBoxColorScheme. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxColorType/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlMessageBoxColorType = (Background, Text, ButtonBorder, ButtonBackground, ButtonSelected)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxColorType/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxColorType/#background-sdl_messagebox_color_background","title":"<code>Background = SDL_MESSAGEBOX_COLOR_BACKGROUND</code>","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxColorType/#text-sdl_messagebox_color_text","title":"<code>Text = SDL_MESSAGEBOX_COLOR_TEXT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxColorType/#buttonborder-sdl_messagebox_color_button_border","title":"<code>ButtonBorder = SDL_MESSAGEBOX_COLOR_BUTTON_BORDER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxColorType/#buttonbackground-sdl_messagebox_color_button_background","title":"<code>ButtonBackground = SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND</code>","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxColorType/#buttonselected-sdl_messagebox_color_button_selected","title":"<code>ButtonSelected = SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED</code>","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxFlag/","title":"TSdlMessageBoxFlag","text":"<p>Message box flags.</p> <p>If supported will display warning icon, etc. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxFlag/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlMessageBoxFlag = (Error, Warning, Information, ButtonsLeftToRight, ButtonsRightToLeft)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxFlag/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxFlag/#error-4","title":"<code>Error = 4</code>","text":"<p>Error dialog </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxFlag/#warning-5","title":"<code>Warning = 5</code>","text":"<p>Warning dialog </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxFlag/#information-6","title":"<code>Information = 6</code>","text":"<p>Information dialog </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxFlag/#buttonslefttoright-7","title":"<code>ButtonsLeftToRight = 7</code>","text":"<p>Buttons placed left to right </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxFlag/#buttonsrighttoleft-8","title":"<code>ButtonsRightToLeft = 8</code>","text":"<p>Buttons placed right to left </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxFlags/","title":"TSdlMessageBoxFlags","text":"<p>A set of message box flags. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlMessageBoxFlags/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlMessageBoxFlags = set of TSdlMessageBoxFlag\n</code></pre> <p>Base type: <code>TSdlMessageBoxFlag</code></p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlPowerState/","title":"TSdlPowerState","text":"<p>The basic state for the system's power supply.</p> <p>These are results returned by SdlGetPowerInfo. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlPowerState/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlPowerState = (Error, Unknown, OnBattery, NoBattery, Charging, Charged)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlPowerState/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlPowerState/#error-sdl_powerstate_error","title":"<code>Error = SDL_POWERSTATE_ERROR</code>","text":"<p>Error determining power status </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlPowerState/#unknown-sdl_powerstate_unknown","title":"<code>Unknown = SDL_POWERSTATE_UNKNOWN</code>","text":"<p>Cannot determine power status </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlPowerState/#onbattery-sdl_powerstate_on_battery","title":"<code>OnBattery = SDL_POWERSTATE_ON_BATTERY</code>","text":"<p>Not plugged in, running on the battery </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlPowerState/#nobattery-sdl_powerstate_no_battery","title":"<code>NoBattery = SDL_POWERSTATE_NO_BATTERY</code>","text":"<p>Plugged in, no battery available </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlPowerState/#charging-sdl_powerstate_charging","title":"<code>Charging = SDL_POWERSTATE_CHARGING</code>","text":"<p>Plugged in, charging battery </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlPowerState/#charged-sdl_powerstate_charged","title":"<code>Charged = SDL_POWERSTATE_CHARGED</code>","text":"<p>Plugged in, battery charged </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlProcessIO/","title":"TSdlProcessIO","text":"<p>Description of where standard I/O should be directed when creating a process.</p> <p>If a standard I/O stream is set to Inherited, it will go to the same place as the application's I/O stream. This is the default for standard output and standard error.</p> <p>If a standard I/O stream is set to Null, it is connected to <code>NUL:</code> on Windows and <code>/dev/null</code> on POSIX systems. This is the default for standard input.</p> <p>If a standard I/O stream is set to App, it is connected to a new TSdlIOStream that is available to the application. Standard input will be available as <code>TSdlProperty.ProcessStdIn</code> and allows TSdlProcess.Input, standard output will be available as <code>TSdlProperty.ProcessStdOut</code> and allows TSdlProcess.Read and TSdlProcess.Output, and standard error will be available as <code>TSdlProperty.ProcessStdErr</code> in the properties for the created process.</p> <p>If a standard I/O stream is set to Redirect, it is connected to an existing TSdlIOStream provided by the application. Standard input is provided using <code>TSdlProperty.ProcessCreateStdIn</code>, standard output is provided using <code>TSdlProperty.ProcessCreateStdOut</code>, and standard error is provided using <code>TSdlProperty.ProcessCreateStdErr</code> in the creation properties. These existing streams should be closed by the application once the new process is created.</p> <p>In order to use an TSdlIOStream with Redirect, it must have <code>TSdlProperty.IOStreamWindowHandle</code> or <code>TSdlProperty.IOStreamFileDescriptor</code> set. This is True for streams representing files and process I/O. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlProcessIO/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlProcessIO = (&amp;Inherited, Null, App, Redirect)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlProcessIO/#see-also","title":"See Also","text":"<ul> <li>TSdlProcess</li> <li>TSdlProcess.Properties</li> <li>TSdlProcess.Read</li> <li>TSdlProcess.Input</li> <li>TSdlProcess.Output</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlProcessIO/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlProcessIO/#inherited-sdl_process_stdio_inherited","title":"<code>&amp;Inherited = SDL_PROCESS_STDIO_INHERITED</code>","text":"<p>The I/O stream is inherited from the application. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlProcessIO/#null-sdl_process_stdio_null","title":"<code>Null = SDL_PROCESS_STDIO_NULL</code>","text":"<p>The I/O stream is ignored. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlProcessIO/#app-sdl_process_stdio_app","title":"<code>App = SDL_PROCESS_STDIO_APP</code>","text":"<p>The I/O stream is connected to a new TSdlIOStream that the application can read or write </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlProcessIO/#redirect-sdl_process_stdio_redirect","title":"<code>Redirect = SDL_PROCESS_STDIO_REDIRECT</code>","text":"<p>The I/O stream is redirected to an existing TSdlIOStream. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlReallocFunc/","title":"TSdlReallocFunc","text":"<p>A callback used to implement SdlRealloc.</p> <p>SDL will always ensure that the passed <code>ASize</code> is greater than 0. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlReallocFunc/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlReallocFunc = function(AMem: Pointer; ASize: NativeInt): Pointer; cdecl\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlReallocFunc/#parameters","title":"Parameters","text":"<p><code>AMem</code>: <code>Pointer</code> : A pointer to allocated memory to reallocate, or nil.</p> <p><code>ASize</code>: <code>NativeInt</code> : The new size of the memory.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlReallocFunc/#returns","title":"Returns","text":"<p><code>Pointer</code>: A pointer to the newly allocated memory, or nil if allocation failed.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlReallocFunc/#see-also","title":"See Also","text":"<ul> <li>SdlRealloc</li> <li>TSdlMemoryManager.Original</li> <li>TSdlMemoryManager.Current</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlReallocFunc/#remarks","title":"Remarks","text":"<p>It should be safe to call this callback from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlSandbox/","title":"TSdlSandbox","text":"<p>Application sandbox environment. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlSandbox/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlSandbox = (None, UnknownContainer, FlatPak, Snap, MacOS)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlSandbox/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlSandbox/#none-sdl_sandbox_none","title":"<code>None = SDL_SANDBOX_NONE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlSandbox/#unknowncontainer-sdl_sandbox_unknown_container","title":"<code>UnknownContainer = SDL_SANDBOX_UNKNOWN_CONTAINER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlSandbox/#flatpak-sdl_sandbox_flatpak","title":"<code>FlatPak = SDL_SANDBOX_FLATPAK</code>","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlSandbox/#snap-sdl_sandbox_snap","title":"<code>Snap = SDL_SANDBOX_SNAP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlSandbox/#macos-sdl_sandbox_macos","title":"<code>MacOS = SDL_SANDBOX_MACOS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlTrayCallback/","title":"TSdlTrayCallback","text":"<p>A callback that is invoked when a tray entry is selected. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlTrayCallback/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlTrayCallback = procedure(const AEntry: TSdlTrayEntry) of object\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlTrayCallback/#parameters","title":"Parameters","text":"<p><code>AEntry</code>: <code>TSdlTrayEntry</code> : The tray entry that was selected.</p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlTrayCallback/#see-also","title":"See Also","text":"<ul> <li>TSdlTrayEntry.OnSelect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlTrayEntryFlag/","title":"TSdlTrayEntryFlag","text":"<p>Flags that control the creation of system tray entries.</p> <p>Some of these flags are required; exactly one of them must be specified at the time a tray entry is created. Other flags are optional. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlTrayEntryFlag/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlTrayEntryFlag = (Button, Checkbox, SubMenu, Checked, Disabled)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlTrayEntryFlag/#see-also","title":"See Also","text":"<ul> <li>TSdlTrayMenu.Insert</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlTrayEntryFlag/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlTrayEntryFlag/#button-0","title":"<code>Button = 0</code>","text":"<p>Make the entry a simple button. Required. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlTrayEntryFlag/#checkbox-1","title":"<code>Checkbox = 1</code>","text":"<p>Make the entry a checkbox. Required. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlTrayEntryFlag/#submenu-2","title":"<code>SubMenu = 2</code>","text":"<p>Prepare the entry to have a submenu. Required. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlTrayEntryFlag/#checked-30","title":"<code>Checked = 30</code>","text":"<p>Make the entry checked. This is valid only for checkboxes. Optional. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlTrayEntryFlag/#disabled-31","title":"<code>Disabled = 31</code>","text":"<p>Make the entry disabled. Optional. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlTrayEntryFlags/","title":"TSdlTrayEntryFlags","text":"<p>A set of tray entry flags. </p>"},{"location":"Reference/Neslib.Sdl3.Additional/types/TSdlTrayEntryFlags/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Additional</p> <pre><code>type TSdlTrayEntryFlags = set of TSdlTrayEntryFlag\n</code></pre> <p>Base type: <code>TSdlTrayEntryFlag</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/","title":"Neslib.Sdl3.Audio","text":"<p>Audio functionality for the SDL library.</p> <p>All audio in SDL3 revolves around TSdlAudioStream. Whether you want to play or record audio, convert it, stream it, buffer it, or mix it, you're going to be passing it through an audio stream.</p> <p>Audio streams are quite flexible; they can accept any amount of data at a time, in any supported format, and output it as needed in any other format, even if the data format changes on either side halfway through.</p> <p>An app opens an audio device and binds any number of audio streams to it, feeding more data to the streams as available. When the device needs more data, it will pull it from all bound streams and mix them together for playback.</p> <p>Audio streams can also use an app-provided callback to supply data on-demand, which maps pretty closely to the SDL2 audio model.</p> <p>SDL also provides a simple .WAV loader in TSdlAudioBuffer.CreateFromWav as a basic means to load sound data into your program.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/#logical-audio-devices","title":"Logical audio devices","text":"<p>In SDL3, opening a physical device (like a SoundBlaster 16 Pro) gives you a logical device ID that you can bind audio streams to. In almost all cases, logical devices can be used anywhere in the API that a physical device is normally used. However, since each device opening generates a new logical device, different parts of the program (say, a VoIP library, or text-to-speech framework, or maybe some other sort of mixer on top of SDL) can have their own device opens that do not interfere with each other; each logical device will mix its separate audio down to a single buffer, fed to the physical device, behind the scenes. As many logical devices as you like can come and go; SDL will only have to open the physical device at the OS level once, and will manage all the logical devices on top of it internally.</p> <p>One other benefit of logical devices: if you don't open a specific physical device, instead opting for the default, SDL can automatically migrate those logical devices to different hardware as circumstances change: a user plugged in headphones? The system default changed? SDL can transparently migrate the logical devices to the correct physical device seamlessly and keep playing; the app doesn't even have to know it happened if it doesn't want to.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/#simplified-audio","title":"Simplified audio","text":"<p>As a simplified model for when a single source of audio is all that's needed, an app can use TSdlAudioStream.Open, which is a single function to open an audio device, create an audio stream, bind that stream to the newly-opened device, and (optionally) provide a callback for obtaining audio data. When using this function, the primary interface is the TSdlAudioStream and the device handle is mostly hidden away; destroying a stream created through this function will also close the device, stream bindings cannot be changed, etc. One other quirk of this is that the device is started in a paused state and must be explicitly resumed; this is partially to offer a clean migration for SDL2 apps and partially because the app might have to do more setup before playback begins; in the non-simplified form, nothing will play until a stream is bound to a device, so they start unpaused.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/#channel-layouts","title":"Channel layouts","text":"<p>Audio data passing through SDL is uncompressed PCM data, interleaved. One can provide their own decompression through an MP3, etc, decoder, but SDL does not provide this directly. Each interleaved channel of data is meant to be in a specific order.</p> <p>Abbreviations:</p> <ul> <li>FRONT = single mono speaker</li> <li>FL = front left speaker</li> <li>FR = front right speaker</li> <li>FC = front center speaker</li> <li>BL = back left speaker</li> <li>BR = back right speaker</li> <li>SR = surround right speaker</li> <li>SL = surround left speaker</li> <li>BC = back center speaker</li> <li>LFE = low-frequency speaker</li> </ul> <p>These are listed in the order they are laid out in memory, so \"FL, FR\" means \"the front left speaker is laid out in memory first, then the front right, then it repeats for the next audio frame\".</p> <ul> <li>1 channel (mono) layout: FRONT</li> <li>2 channels (stereo) layout: FL, FR</li> <li>3 channels (2.1) layout: FL, FR, LFE</li> <li>4 channels (quad) layout: FL, FR, BL, BR</li> <li>5 channels (4.1) layout: FL, FR, LFE, BL, BR</li> <li>6 channels (5.1) layout: FL, FR, FC, LFE, BL, BR (last two can also be SL, SR)</li> <li>7 channels (6.1) layout: FL, FR, FC, LFE, BC, SL, SR</li> <li>8 channels (7.1) layout: FL, FR, FC, LFE, BL, BR, SL, SR</li> </ul> <p>This is the same order as DirectSound expects, but applied to all platforms; SDL will swizzle the channels as necessary if a platform expects something different.</p> <p>TSdlAudioStream can also be provided channel maps to change this ordering to whatever is necessary, in other audio processing scenarios. </p>"},{"location":"Reference/Neslib.Sdl3.Audio/#classes-records","title":"Classes &amp; Records","text":"Name Description TSdlAudioBuffer A buffer that holds audio data in a specific format TSdlAudioDevice SDL Audio Device. TSdlAudioDeviceID SDL Audio Device instance IDs. TSdlAudioDriver Audio driver. TSdlAudioSpec Format specifier for audio data. TSdlAudioStream Represents an audio stream."},{"location":"Reference/Neslib.Sdl3.Audio/#types","title":"Types","text":"Name Description PSdlAudioSpec TSdlAudioFormat Audio format. TSdlAudioPostmixCallback A callback that fires when data is about to be fed to an audio device. TSdlAudioStreamCallback A callback that fires when data passes through a TSdlAudioStream."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/","title":"TSdlAudioBuffer","text":"<p>A buffer that holds audio data in a specific format </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Audio</p> <pre><code>type TSdlAudioBuffer = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#properties","title":"Properties","text":"Name Description Buffer The audio data, in the format specified in Spec. Size The size of the audio data, in bytes. Spec Specifies the format of the audio in the buffer."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#constructors","title":"Constructors","text":"Name Description Create(TSdlAudioFormat, Integer, Integer, TSdlAudioBuffer) Creates a buffer from another buffer and converts it to the given format if needed. Create(TSdlAudioFormat, Integer, Integer, Integer) Creates a new audio buffer. CreateFromWav(String) Loads a WAV from a file path. CreateFromWav(TSdlIOStream, Boolean) Load the audio data of a WAVE file into this buffer."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#methods","title":"Methods","text":"Name Description Free Frees the audio buffer Mix Mix audio data."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#Buffer","title":"Buffer","text":"<p>The audio data, in the format specified in Spec. </p> <p><code>property Buffer: Pointer read FBuffer</code></p> <p>Type: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#Size","title":"Size","text":"<p>The size of the audio data, in bytes. </p> <p><code>property Size: Integer read FSize</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#Spec","title":"Spec","text":"<p>Specifies the format of the audio in the buffer. </p> <p><code>property Spec: TSdlAudioSpec read FSpec</code></p> <p>Type: <code>TSdlAudioSpec</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#Create_0","title":"<code>Create</code>","text":"<p>Creates a buffer from another buffer and converts it to the given format if needed.</p> <p>Please note that this constructor is for convenience, but should not be used to resample audio in blocks, as it will introduce audio artifacts on the boundaries. You should only use this constructor if you are converting audio data in its entirety in one call. If you want to convert audio in smaller chunks, use an TSDlAudioStream, which is designed for this situation.</p> <p>Internally, this function creates and destroys an TSdlAudioStream on each use, so it's also less efficient than using one directly, if you need to convert multiple times.</p> <p>When the application is done with this buffer, it should call Free to dispose of it. </p> <p><code>constructor Create(const AFormat: TSdlAudioFormat; const ANumChannels, AFreq: Integer; const ASrc: TSdlAudioBuffer); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#parameters","title":"Parameters","text":"<p><code>AFormat</code>: <code>TSdlAudioFormat</code> : The format of the audio in this buffer.</p> <p><code>ANumChannels</code>: <code>Integer</code> : The number of audio channels for this buffer.</p> <p><code>AFreq</code>: <code>Integer</code> : The sample frequency in Hz for this buffer.</p> <p><code>ASrc</code>: <code>TSdlAudioBuffer</code> : The input audio buffer that will be converted.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#remarks","title":"Remarks","text":"<p>It is safe to call this constructor from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#Create_1","title":"<code>Create</code>","text":"<p>Creates a new audio buffer.</p> <p>When the application is done with this buffer, it should call Free to dispose of it. </p> <p><code>constructor Create(const AFormat: TSdlAudioFormat; const ASize, ANumChannels, AFreq: Integer); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#parameters_1","title":"Parameters","text":"<p><code>AFormat</code>: <code>TSdlAudioFormat</code> : The format of the audio in the buffer.</p> <p><code>ASize</code>: <code>Integer</code> : The size in bytes of the buffer to create.</p> <p><code>ANumChannels</code>: <code>Integer</code> : The number of audio channels.</p> <p><code>AFreq</code>: <code>Integer</code> : The sample frequency in Hz.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#see-also","title":"See Also","text":"<ul> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#CreateFromWav_0","title":"<code>CreateFromWav</code>","text":"<p>Loads a WAV from a file path.</p> <p>This constructor raises an error if the .WAV file cannot be opened, uses an unknown data format, or is corrupt.</p> <p>When the application is done with this buffer, it should call Free to dispose of it. </p> <p><code>constructor CreateFromWav(const APath: String); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#parameters_2","title":"Parameters","text":"<p><code>APath</code>: <code>String</code> : The file path of the WAV file to open.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#see-also_1","title":"See Also","text":"<ul> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#remarks_1","title":"Remarks","text":"<p>It is safe to call this constructor from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#CreateFromWav_1","title":"<code>CreateFromWav</code>","text":"<p>Load the audio data of a WAVE file into this buffer.</p> <p>Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and A-law and mu-law (8 bits). Other formats are currently unsupported and cause an error.</p> <p>It's necessary to use Free to free this buffer when it is no longer used.</p> <p>Because of the underspecification of the .WAV format, there are many problematic files in the wild that cause issues with strict decoders. To provide compatibility with these files, this decoder is lenient in regards to the truncation of the file, the fact chunk, and the size of the RIFF chunk. The hints <code>TSdlHints.WaveRiffChunkSize</code>, <code>TSdlHints.WaveTruncation</code>, and <code>TSdlHints.WaveFactChunk</code> can be used to tune the behavior of the loading process.</p> <p>Any file that is invalid (due to truncation, corruption, or wrong values in the headers), too big, or unsupported causes an error. Additionally, any critical I/O error from the data source will terminate the loading process with an error.</p> <p>It is required that the data source supports seeking.</p> <p>This constructor raises an error if the .WAV file cannot be opened, uses an unknown data format, or is corrupt.</p> <p>When the application is done with this buffer, it should call Free to dispose of it. </p> <p><code>constructor CreateFromWav(const ASrc: TSdlIOStream; const ACloseIO: Boolean); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#parameters_3","title":"Parameters","text":"<p><code>ASrc</code>: <code>TSdlIOStream</code> : The data source for the WAVE data.</p> <p><code>ACloseIO</code>: <code>Boolean</code> : If True, calls TSdlIOStream.Close on <code>ASrc</code> before returning, even in the case of an error.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#see-also_2","title":"See Also","text":"<ul> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#remarks_2","title":"Remarks","text":"<p>It is safe to call this constructor from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#Free","title":"Free","text":"<p>Frees the audio buffer </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#Mix","title":"Mix(TSdlAudioBuffer, Integer, Single)","text":"<p>Mix audio data.</p> <p>This mixes ASrc into this buffer, performing addition, volume adjustment, and overflow clipping.</p> <p>The ASrc buffer must be in the same format as this buffer.</p> <p>This is provided for convenience -- you can mix your own audio data.</p> <p>Do not use this method for mixing together more than two streams of sample data. The output from repeated application of this function may be distorted by clipping, because there is no accumulator with greater range than the input (not to mention this being an inefficient way of doing it).</p> <p>It is a common misconception that this method is required to write audio data to an output stream in an audio callback. While you can do that, this method is really only needed when you're mixing a single audio stream with a volume adjustment. </p> <p><code>procedure Mix(const ASrc: TSdlAudioBuffer; const ASize: Integer = 0; const AVolume: Single = 1)</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#parameters_4","title":"Parameters","text":"<p><code>ASrc</code>: <code>TSdlAudioBuffer</code> : The source audio buffer to be mixed.</p> <p><code>ASize</code>: <code>Integer = 0</code> : (Optional) size in bytes of the audio buffers. If 0 (the default), it will use the minimum size of the 2 buffers.</p> <p><code>AVolume</code>: <code>Single = 1</code> : (Optional) volume, ranging from 0.0 - 1.0, and should be set to 1.0 (default) for full audio volume.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioBuffer/#remarks_3","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/","title":"TSdlAudioDevice","text":"<p>SDL Audio Device. </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Audio</p> <pre><code>type TSdlAudioDevice = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#properties","title":"Properties","text":"Name Description ChannelMap The current channel map. Gain The gain of the audio device. IsPaused Whether the audio device is paused. IsPlaybackDevice Whether this audio device is a playback device (instead of recording)."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>0</code>. Implicit Used to set the value to <code>0</code>. NotEqual Used to compare against <code>0</code>."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#methods","title":"Methods","text":"Name Description Bind(TSdlAudioStream) Bind a single audio stream to an audio device. Bind(TArray&lt;TSdlAudioStream&gt;) Bind a list of audio streams to an audio device. Close Close a previously-opened audio device. GetFormat Get audio format this device is currently using. Open(TSdlAudioDevice) Open a device from a previously opened device. This just creates another logical device on the same physical device. This may be useful for making logical groupings of audio streams. Open(TSdlAudioDeviceID, TSdlAudioSpec) Open a specific audio device. Open(TSdlAudioDeviceID) Open a specific audio device. Pause Pause audio playback on the device. Resume Use this method to unpause audio playback on a specified device. SetPostmixCallback Set a callback that fires when data is about to be fed to an audio device. Unbind(TSdlAudioStream) Unbind a single audio stream from its audio device. Unbind(TArray&lt;TSdlAudioStream&gt;) Unbind a list of audio streams from their audio devices."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#ChannelMap","title":"ChannelMap","text":"<p>The current channel map.</p> <p>Channel maps are optional; most things do not need them, instead passing data in the order that SDL expects.</p> <p>Audio devices usually have no remapping applied. This is represented by returning nil, and does not signify an error. </p> <p><code>property ChannelMap: TArray&lt;Integer&gt; read GetChannelMap</code></p> <p>Type: <code>TArray&lt;Integer&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#see-also","title":"See Also","text":"<ul> <li>TSdlAudioStream.InputChannelMap</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#remarks","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#Gain","title":"Gain","text":"<p>The gain of the audio device.</p> <p>The gain of a device is its volume; a larger gain means a louder output, with a gain of zero being silence.</p> <p>Audio devices default to a gain of 1.0 (no change in output).</p> <p>This is applied, along with any per-audiostream gain, during playback to the hardware, and can be continuously changed to create various effects. On recording devices, this will adjust the gain before passing the data into an audiostream; that recording audiostream can then adjust its gain further when outputting the data elsewhere, if it likes, but that second gain is not applied until the data leaves the audiostream again. </p> <p><code>property Gain: Single read GetGain write SetGain</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#remarks_1","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#IsPaused","title":"IsPaused","text":"<p>Whether the audio device is paused.</p> <p>Unlike in SDL2, audio devices start in an unpaused state, since an app has to bind a stream before any audio will flow.</p> <p>You can also set this property to pause/unpause the device. </p> <p><code>property IsPaused: Boolean read GetIsPaused write SetIsPaused</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#see-also_1","title":"See Also","text":"<ul> <li>Pause</li> <li>Resume</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#remarks_2","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#IsPlaybackDevice","title":"IsPlaybackDevice","text":"<p>Whether this audio device is a playback device (instead of recording). </p> <p><code>property IsPlaybackDevice: Boolean read GetIsPlaybackDevice</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#remarks_3","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#Equal","title":"Equal(TSdlAudioDevice, Cardinal)","text":"<p>Used to compare against <code>0</code>. </p> <p><code>class operator Equal(const ALeft: TSdlAudioDevice; const ARight: Cardinal): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlAudioDevice</code></p> <p><code>ARight</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#Implicit","title":"Implicit(Cardinal)","text":"<p>Used to set the value to <code>0</code>. </p> <p><code>class operator Implicit(const AValue: Cardinal): TSdlAudioDevice; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#returns_1","title":"Returns","text":"<p><code>TSdlAudioDevice</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#NotEqual","title":"NotEqual(TSdlAudioDevice, Cardinal)","text":"<p>Used to compare against <code>0</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlAudioDevice; const ARight: Cardinal): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlAudioDevice</code></p> <p><code>ARight</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#Bind_0","title":"Bind(TSdlAudioStream)","text":"<p>Bind a single audio stream to an audio device.</p> <p>This is a convenience method, equivalent to calling the other overload with an array containing 1 stream. </p> <p><code>procedure Bind(const AStream: TSdlAudioStream); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#parameters_3","title":"Parameters","text":"<p><code>AStream</code>: <code>TSdlAudioStream</code> : The audio stream to bind to a device.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#see-also_2","title":"See Also","text":"<ul> <li>Unbind</li> <li>TSdlAudioStream.Device</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#remarks_4","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#Bind_1","title":"Bind(TArray&lt;TSdlAudioStream&gt;)","text":"<p>Bind a list of audio streams to an audio device.</p> <p>Audio data will flow through any bound streams. For a playback device, data for all bound streams will be mixed together and fed to the device. For a recording device, a copy of recorded data will be provided to each bound stream.</p> <p>This operation is atomic--all streams bound in the same call will start processing at the same time, so they can stay in sync. Also: either all streams will be bound or none of them will be.</p> <p>It is an error to bind an already-bound stream; it must be explicitly unbound first.</p> <p>Binding a stream to a device will set its output format for playback devices, and its input format for recording devices, so they match the device's settings. The caller is welcome to change the other end of the stream's format at any time with TSdlAudioStream.Format. </p> <p><code>procedure Bind(const AStreams: TArray&lt;TSdlAudioStream&gt;); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#parameters_4","title":"Parameters","text":"<p><code>AStreams</code>: <code>TArray&lt;TSdlAudioStream&gt;</code> : The array of audio streams to bind.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#see-also_3","title":"See Also","text":"<ul> <li>Unbind</li> <li>TSdlAudioStream.Device</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#remarks_5","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#Close","title":"Close","text":"<p>Close a previously-opened audio device.</p> <p>The application should close open audio devices once they are no longer needed.</p> <p>This function may block briefly while pending audio data is played by the hardware, so that applications don't drop the last buffer of data they supplied if terminating immediately afterwards. </p> <p><code>procedure Close; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#see-also_4","title":"See Also","text":"<ul> <li>Open</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#remarks_6","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#GetFormat","title":"GetFormat(TSdlAudioSpec)","text":"<p>Get audio format this device is currently using.</p> <p>You can also use this to request the current device buffer size. This is specified in sample frames and represents the amount of data SDL will feed to the physical hardware in each chunk. This can be converted to milliseconds of audio with the following equation:</p> <p><code>ms = ((frames * 1000) / spec.freq);</code></p> <p>Buffer size is only important if you need low-level control over the audio playback timing. Most apps do not need this. </p> <p><code>function GetFormat(out ASpec: TSdlAudioSpec): Integer; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#parameters_5","title":"Parameters","text":"<p><code>ASpec</code>: <code>TSdlAudioSpec</code> : Will be filled with device details.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#returns_3","title":"Returns","text":"<p><code>Integer</code>: The device buffer size, in sample frames.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#remarks_7","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#Open_0","title":"Open(TSdlAudioDevice)","text":"<p>Open a device from a previously opened device. This just creates another logical device on the same physical device. This may be useful for making logical groupings of audio streams.</p> <p>An opened audio device starts out with no audio streams bound. To start audio playing, bind a stream and supply audio data to it. Unlike SDL2, there is no audio callback; you only bind audio streams and make sure they have data flowing into them (however, you can simulate SDL2's semantics fairly closely by using TSdlAudioStream.Open instead of this method).</p> <p>When done with an audio device, possibly at the end of the app's life, one should call Close. </p> <p><code>class function Open(const ADevice: TSdlAudioDevice): TSdlAudioDevice; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#parameters_6","title":"Parameters","text":"<p><code>ADevice</code>: <code>TSdlAudioDevice</code> : The previously opened device.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#returns_4","title":"Returns","text":"<p><code>TSdlAudioDevice</code>: The audio device.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#see-also_5","title":"See Also","text":"<ul> <li>Close</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#remarks_8","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#Open_1","title":"Open(TSdlAudioDeviceID, TSdlAudioSpec)","text":"<p>Open a specific audio device.</p> <p>You can open both playback and recording devices through this method. Playback devices will take data from bound audio streams, mix it, and send it to the hardware. Recording devices will feed any bound audio streams with a copy of any incoming data.</p> <p>An opened audio device starts out with no audio streams bound. To start audio playing, bind a stream and supply audio data to it. Unlike SDL2, there is no audio callback; you only bind audio streams and make sure they have data flowing into them (however, you can simulate SDL2's semantics fairly closely by using TSdlAudioStream.Open instead of this method).</p> <p>If you don't care about opening a specific device, pass a <code>ADeviceID</code> of either <code>TSdlAudioDeviceID.DefaultPlaybackDevice</code> or <code>TSdlAudioDeviceID.DefaultRecordingDevice</code>. In this case, SDL will try to pick the most reasonable default, and may also switch between physical devices seamlessly later, if the most reasonable default changes during the lifetime of this opened device (user changed the default in the OS's system preferences, the default got unplugged so the system jumped to a new default, the user plugged in headphones on a mobile device, etc). Unless you have a good reason to choose a specific device, this is probably what you want.</p> <p>You may request a specific format for the audio device, but there is no promise the device will honor that request for several reasons. As such, it's only meant to be a hint as to what data your app will provide. Audio streams will accept data in whatever format you specify and manage conversion for you as appropriate. TSdlAudioDeviceID.GetFormat can tell you the preferred format for the device before opening and the actual format the device is using after opening.</p> <p>It's legal to open the same device ID more than once; each successful open will generate a new logical audio device that is managed separately from others on the same physical device. This allows libraries to open a device separately from the main app and bind its own streams without conflicting.</p> <p>Some backends might offer arbitrary devices (for example, a networked audio protocol that can connect to an arbitrary server). For these, as a change from SDL2, you should open a default device ID and use an SDL hint to specify the target if you care, or otherwise let the backend figure out a reasonable default. Most backends don't offer anything like this, and often this would be an end user setting an environment variable for their custom need, and not something an application should specifically manage.</p> <p>When done with an audio device, possibly at the end of the app's life, one should call Close. </p> <p><code>class function Open(const ADeviceID: TSdlAudioDeviceID; const ASpec: TSdlAudioSpec): TSdlAudioDevice; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#exceptions_6","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#parameters_7","title":"Parameters","text":"<p><code>ADeviceID</code>: <code>TSdlAudioDeviceID</code> : The device instance id to open, or TSdlAudioDeviceID.DefaultPlaybackDevice or TSdlAudioDeviceID.DefaultRecordingDevice for the most reasonable default device.</p> <p><code>ASpec</code>: <code>TSdlAudioSpec</code> : The requested device configuration.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#returns_5","title":"Returns","text":"<p><code>TSdlAudioDevice</code>: The audio device.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#see-also_6","title":"See Also","text":"<ul> <li>Close</li> <li>TSdlAudioDeviceID.GetFormat</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#remarks_9","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#Open_2","title":"Open(TSdlAudioDeviceID)","text":"<p>Open a specific audio device.</p> <p>You can open both playback and recording devices through this method. Playback devices will take data from bound audio streams, mix it, and send it to the hardware. Recording devices will feed any bound audio streams with a copy of any incoming data.</p> <p>An opened audio device starts out with no audio streams bound. To start audio playing, bind a stream and supply audio data to it. Unlike SDL2, there is no audio callback; you only bind audio streams and make sure they have data flowing into them (however, you can simulate SDL2's semantics fairly closely by using TSdlAudioStream.Open instead of this method).</p> <p>If you don't care about opening a specific device, pass a <code>ADeviceID</code> of either <code>TSdlAudioDeviceID.DefaultPlaybackDevice</code> or <code>TSdlAudioDeviceID.DefaultRecordingDevice</code>. In this case, SDL will try to pick the most reasonable default, and may also switch between physical devices seamlessly later, if the most reasonable default changes during the lifetime of this opened device (user changed the default in the OS's system preferences, the default got unplugged so the system jumped to a new default, the user plugged in headphones on a mobile device, etc). Unless you have a good reason to choose a specific device, this is probably what you want.</p> <p>It's legal to open the same device ID more than once; each successful open will generate a new logical audio device that is managed separately from others on the same physical device. This allows libraries to open a device separately from the main app and bind its own streams without conflicting.</p> <p>Some backends might offer arbitrary devices (for example, a networked audio protocol that can connect to an arbitrary server). For these, as a change from SDL2, you should open a default device ID and use an SDL hint to specify the target if you care, or otherwise let the backend figure out a reasonable default. Most backends don't offer anything like this, and often this would be an end user setting an environment variable for their custom need, and not something an application should specifically manage.</p> <p>When done with an audio device, possibly at the end of the app's life, one should call Close. </p> <p><code>class function Open(const ADeviceID: TSdlAudioDeviceID): TSdlAudioDevice; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#exceptions_7","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#parameters_8","title":"Parameters","text":"<p><code>ADeviceID</code>: <code>TSdlAudioDeviceID</code> : The device instance id to open, or TSdlAudioDeviceID.DefaultPlaybackDevice or TSdlAudioDeviceID.DefaultRecordingDevice for the most reasonable default device.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#returns_6","title":"Returns","text":"<p><code>TSdlAudioDevice</code>: The audio device.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#see-also_7","title":"See Also","text":"<ul> <li>Close</li> <li>TSdlAudioDeviceID.GetFormat</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#remarks_10","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#Pause","title":"Pause","text":"<p>Pause audio playback on the device.</p> <p>This method pauses audio processing for the device. Any bound audio streams will not progress, and no audio will be generated. Pausing one device does not prevent other unpaused devices from running.</p> <p>Unlike in SDL2, audio devices start in an unpaused state, since an app has to bind a stream before any audio will flow. Pausing a paused device is a legal no-op.</p> <p>Pausing a device can be useful to halt all audio without unbinding all the audio streams. This might be useful while a game is paused, or a level is loading, etc. </p> <p><code>procedure Pause; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#exceptions_8","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#see-also_8","title":"See Also","text":"<ul> <li>Resume</li> <li>IsPaused</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#remarks_11","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#Resume","title":"Resume","text":"<p>Use this method to unpause audio playback on a specified device.</p> <p>This function unpauses audio processing for a given device that has previously been paused with Pause. Once unpaused, any bound audio streams will begin to progress again, and audio can be generated.</p> <p>Unlike in SDL2, audio devices start in an unpaused state, since an app has to bind a stream before any audio will flow. Unpausing an unpaused device is a legal no-op. </p> <p><code>procedure Resume; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#exceptions_9","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#see-also_9","title":"See Also","text":"<ul> <li>IsPaused</li> <li>Pause</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#remarks_12","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#SetPostmixCallback","title":"SetPostmixCallback(TSdlAudioPostmixCallback, Pointer)","text":"<p>Set a callback that fires when data is about to be fed to an audio device.</p> <p>This is useful for accessing the final mix, perhaps for writing a visualizer or applying a final effect to the audio data before playback.</p> <p>The buffer is the final mix of all bound audio streams on an opened device; this callback will fire regularly for any device that is both opened and unpaused. If there is no new data to mix, either because no streams are bound to the device or all the streams are empty, this callback will still fire with the entire buffer set to silence.</p> <p>This callback is allowed to make changes to the data; the contents of the buffer after this call is what is ultimately passed along to the hardware.</p> <p>The callback is always provided the data in float format (values from -1.0 to 1.0), but the number of channels or sample rate may be different than the format the app requested when opening the device; SDL might have had to manage a conversion behind the scenes, or the playback might have jumped to new physical hardware when a system default changed, etc. These details may change between calls. Accordingly, the size of the buffer might change between calls as well.</p> <p>This callback can run at any time, and from any thread; if you need to serialize access to your app's data, you should provide and use a mutex or other synchronization device.</p> <p>All of this to say: there are specific needs this callback can fulfill, but it is not the simplest interface. Apps should generally provide audio in their preferred format through an TSdlAudioStream and let SDL handle the difference.</p> <p>This function is extremely time-sensitive; the callback should do the least amount of work possible and return as quickly as it can. The longer the callback runs, the higher the risk of audio dropouts or other problems.</p> <p>This function will block until the audio device is in between iterations, so any existing callback that might be running will finish before this function sets the new callback and returns.</p> <p>Setting a nil callback function disables any previously-set callback. </p> <p><code>procedure SetPostmixCallback(const ACallback: TSdlAudioPostmixCallback; const AUserData: Pointer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#exceptions_10","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#parameters_9","title":"Parameters","text":"<p><code>ACallback</code>: <code>TSdlAudioPostmixCallback</code> : A callback function to be called. Can be nil.</p> <p><code>AUserData</code>: <code>Pointer</code> : App-controlled pointer passed to callback. Can be nil.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#remarks_13","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#Unbind_0","title":"Unbind(TSdlAudioStream)","text":"<p>Unbind a single audio stream from its audio device.</p> <p>This is a convenience method, equivalent to calling the other overload with an array containing 1 stream. </p> <p><code>class procedure Unbind(const AStream: TSdlAudioStream); overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#parameters_10","title":"Parameters","text":"<p><code>AStream</code>: <code>TSdlAudioStream</code> : The audio stream to unbind.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#see-also_10","title":"See Also","text":"<ul> <li>Bind</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#remarks_14","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#Unbind_1","title":"Unbind(TArray&lt;TSdlAudioStream&gt;)","text":"<p>Unbind a list of audio streams from their audio devices.</p> <p>The streams being unbound do not all have to be on the same device. All streams on the same device will be unbound atomically (data will stop flowing through all unbound streams on the same device at the same time).</p> <p>Unbinding a stream that isn't bound to a device is a legal no-op. </p> <p><code>class procedure Unbind(const AStreams: TArray&lt;TSdlAudioStream&gt;); overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#parameters_11","title":"Parameters","text":"<p><code>AStreams</code>: <code>TArray&lt;TSdlAudioStream&gt;</code> : An array of audio streams to unbind.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#see-also_11","title":"See Also","text":"<ul> <li>Bind</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDevice/#remarks_15","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/","title":"TSdlAudioDeviceID","text":"<p>SDL Audio Device instance IDs.</p> <p>Zero is used to signify an invalid/null device. </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Audio</p> <pre><code>type TSdlAudioDeviceID = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#properties","title":"Properties","text":"Name Description ChannelMap The current channel map. DefaultPlaybackDevice The default playback audio device ID. DefaultRecordingDevice The default recording audio device ID. IsPlaybackDevice Whether this audio device is a playback device (instead of recording). Name The human-readable name of this audio device. PlaybackDevices A list of currently-connected audio playback devices. RecordingDevices A list of currently-connected audio recording devices."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>0</code>. Implicit Used to set the value to <code>0</code>. NotEqual Used to compare against <code>0</code>."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#methods","title":"Methods","text":"Name Description GetFormat Get the device's preferred format (or a reasonable default if this can't be determined)."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#ChannelMap","title":"ChannelMap","text":"<p>The current channel map.</p> <p>Channel maps are optional; most things do not need them, instead passing data in the order that SDL expects.</p> <p>Audio devices usually have no remapping applied. This is represented by returning nil, and does not signify an error. </p> <p><code>property ChannelMap: TArray&lt;Integer&gt; read GetChannelMap</code></p> <p>Type: <code>TArray&lt;Integer&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#see-also","title":"See Also","text":"<ul> <li>TSdlAudioStream.InputChannelMap</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#remarks","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#DefaultPlaybackDevice","title":"DefaultPlaybackDevice","text":"<p>The default playback audio device ID. </p> <p><code>class property DefaultPlaybackDevice: TSdlAudioDeviceID read GetDefaultPlaybackDevice</code></p> <p>Type: <code>TSdlAudioDeviceID</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#DefaultRecordingDevice","title":"DefaultRecordingDevice","text":"<p>The default recording audio device ID. </p> <p><code>class property DefaultRecordingDevice: TSdlAudioDeviceID read GetDefaultRecordingDevice</code></p> <p>Type: <code>TSdlAudioDeviceID</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#IsPlaybackDevice","title":"IsPlaybackDevice","text":"<p>Whether this audio device is a playback device (instead of recording). </p> <p><code>property IsPlaybackDevice: Boolean read GetIsPlaybackDevice</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#remarks_1","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#Name","title":"Name","text":"<p>The human-readable name of this audio device. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#see-also_1","title":"See Also","text":"<ul> <li>PlaybackDevices</li> <li>RecordingDevices</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#remarks_2","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#PlaybackDevices","title":"PlaybackDevices","text":"<p>A list of currently-connected audio playback devices.</p> <p>This returns of list of available devices that play sound, perhaps to speakers or headphones (\"playback\" devices). If you want devices that record audio, like a microphone (\"recording\" devices), use RecordingDevices instead. </p> <p><code>class property PlaybackDevices: TArray&lt;TSdlAudioDeviceID&gt; read GetPlaybackDevices</code></p> <p>Type: <code>TArray&lt;TSdlAudioDeviceID&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#see-also_2","title":"See Also","text":"<ul> <li>TSdlAudioDevice.Open</li> <li>RecordingDevices</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#remarks_3","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#RecordingDevices","title":"RecordingDevices","text":"<p>A list of currently-connected audio recording devices.</p> <p>This returns of list of available devices that record audio, like a microphone (\"recording\" devices). If you want devices that play sound, perhaps to speakers or headphones (\"playback\" devices), use PlaybackDevices instead. </p> <p><code>class property RecordingDevices: TArray&lt;TSdlAudioDeviceID&gt; read GetRecordingDevices</code></p> <p>Type: <code>TArray&lt;TSdlAudioDeviceID&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#see-also_3","title":"See Also","text":"<ul> <li>TSdlAudioDevice.Open</li> <li>PlaybackDevices</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#remarks_4","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#Equal","title":"Equal(TSdlAudioDeviceID, Cardinal)","text":"<p>Used to compare against <code>0</code>. </p> <p><code>class operator Equal(const ALeft: TSdlAudioDeviceID; const ARight: Cardinal): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlAudioDeviceID</code></p> <p><code>ARight</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#Implicit","title":"Implicit(Cardinal)","text":"<p>Used to set the value to <code>0</code>. </p> <p><code>class operator Implicit(const AValue: Cardinal): TSdlAudioDeviceID; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#returns_1","title":"Returns","text":"<p><code>TSdlAudioDeviceID</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#NotEqual","title":"NotEqual(TSdlAudioDeviceID, Cardinal)","text":"<p>Used to compare against <code>0</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlAudioDeviceID; const ARight: Cardinal): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlAudioDeviceID</code></p> <p><code>ARight</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#GetFormat","title":"GetFormat(TSdlAudioSpec)","text":"<p>Get the device's preferred format (or a reasonable default if this can't be determined).</p> <p>You can also use this to request the current device buffer size. This is specified in sample frames and represents the amount of data SDL will feed to the physical hardware in each chunk. This can be converted to milliseconds of audio with the following equation:</p> <p><code>ms = ((frames * 1000) / spec.freq);</code></p> <p>Buffer size is only important if you need low-level control over the audio playback timing. Most apps do not need this. </p> <p><code>function GetFormat(out ASpec: TSdlAudioSpec): Integer; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#parameters_3","title":"Parameters","text":"<p><code>ASpec</code>: <code>TSdlAudioSpec</code> : Will be filled with device details.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#returns_3","title":"Returns","text":"<p><code>Integer</code>: The device buffer size, in sample frames.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDeviceID/#remarks_5","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/","title":"TSdlAudioDriver","text":"<p>Audio driver. </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Audio</p> <pre><code>type TSdlAudioDriver = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#properties","title":"Properties","text":"Name Description Current The current audio driver, or nil if no driver has been initialized. DriverCount The number of built-in audio drivers. Drivers The name built in audio drivers. Name The name of the driver."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#Current","title":"Current","text":"<p>The current audio driver, or nil if no driver has been initialized. </p> <p><code>class property Current: TSdlAudioDriver read GetCurrent</code></p> <p>Type: <code>TSdlAudioDriver</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#remarks","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#DriverCount","title":"DriverCount","text":"<p>The number of built-in audio drivers.</p> <p>This property returns a hardcoded number. This never returns a negative value; if there are no drivers compiled into this build of SDL, this property returns zero. The presence of a driver in this list does not mean it will function, it just means SDL is capable of interacting with that interface. For example, a build of SDL might have esound support, but if there's no esound server available, SDL's esound driver would fail if used.</p> <p>By default, SDL tries all drivers, in its preferred order, until one is found to be usable. </p> <p><code>class property DriverCount: Integer read GetDriverCount</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#see-also","title":"See Also","text":"<ul> <li>Drivers</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#remarks_1","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#Drivers","title":"Drivers","text":"<p>The name built in audio drivers.</p> <p>The list of audio drivers is given in the order that they are normally initialized by default; the drivers that seem more reasonable to choose first (as far as the SDL developers believe) are earlier in the list. </p> <p><code>class property Drivers[const AIndex: Integer]: TSdlAudioDriver read GetDriver</code></p> <p>Type: <code>TSdlAudioDriver</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#see-also_1","title":"See Also","text":"<ul> <li>DriverCount</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#remarks_2","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#Name","title":"Name","text":"<p>The name of the driver.</p> <p>The names of drivers are all simple, low-ASCII identifiers, like \"alsa\", \"coreaudio\" or \"wasapi\". These never have Unicode characters, and are not meant to be proper names. </p> <p><code>property Name: String read FName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#Equal","title":"Equal(TSdlAudioDriver, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlAudioDriver; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlAudioDriver</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlAudioDriver; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#returns_1","title":"Returns","text":"<p><code>TSdlAudioDriver</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#NotEqual","title":"NotEqual(TSdlAudioDriver, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlAudioDriver; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlAudioDriver</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioDriver/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioSpec/","title":"TSdlAudioSpec","text":"<p>Format specifier for audio data. </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioSpec/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Audio</p> <pre><code>type TSdlAudioSpec = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioSpec/#see-also","title":"See Also","text":"<ul> <li>TSdlAudioFormat</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioSpec/#properties","title":"Properties","text":"Name Description Format Audio data format FrameSize Calculate the size of each audio frame (in bytes). Freq Sample rate: sample frames per second NumChannels Number of channels: 1 mono, 2 stereo, etc"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioSpec/#constructors","title":"Constructors","text":"Name Description Create Creates a new audion format specification."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioSpec/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioSpec/#Format","title":"Format","text":"<p>Audio data format </p> <p><code>property Format: TSdlAudioFormat read GetFormat write SetFormat</code></p> <p>Type: <code>TSdlAudioFormat</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioSpec/#FrameSize","title":"FrameSize","text":"<p>Calculate the size of each audio frame (in bytes).</p> <p>This reports on the size of an audio sample frame: stereo Int16 data (2 channels of 2 bytes each) would be 4 bytes per frame, for example. </p> <p><code>property FrameSize: Integer read GetFrameSize</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioSpec/#Freq","title":"Freq","text":"<p>Sample rate: sample frames per second </p> <p><code>property Freq: Integer read FHandle.freq write FHandle.freq</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioSpec/#NumChannels","title":"NumChannels","text":"<p>Number of channels: 1 mono, 2 stereo, etc </p> <p><code>property NumChannels: Integer read FHandle.channels write FHandle.channels</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioSpec/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioSpec/#Create","title":"<code>Create</code>","text":"<p>Creates a new audion format specification. </p> <p><code>constructor Create(const AFormat: TSdlAudioFormat; const ANumChannels, AFreq: Integer)</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioSpec/#parameters","title":"Parameters","text":"<p><code>AFormat</code>: <code>TSdlAudioFormat</code> : Audio data format.</p> <p><code>ANumChannels</code>: <code>Integer</code> : Number of channels: 1 mono, 2 stereo, etc.</p> <p><code>AFreq</code>: <code>Integer</code> : Sample rate: sample frames per second.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/","title":"TSdlAudioStream","text":"<p>Represents an audio stream.</p> <p>TSdlAudioStream is an audio conversion interface.</p> <ul> <li>It can handle resampling data in chunks without generating artifacts, when it doesn't have the complete buffer available.</li> <li>It can handle incoming data in any variable size.</li> <li>It can handle input/output format changes on the fly.</li> <li>It can remap audio channels between inputs and outputs.</li> <li>You push data as you have it, and pull it when you need it</li> <li>It can also function as a basic audio data queue even if you just have sound that needs to pass from one place to another.</li> <li>You can hook callbacks up to them when more data is added or requested, to manage data on-the-fly.</li> </ul> <p>Audio streams are the core of the SDL3 audio interface. You create one or more of them, bind them to an opened audio device, and feed data to them (or for recording, consume data from them). </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Audio</p> <pre><code>type TSdlAudioStream = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#properties","title":"Properties","text":"Name Description Available The number of converted/resampled bytes available. Device The currently-bound device of the stream FrequencyRatio The frequency ratio of the audio stream. Gain The gain of an audio stream. InputChannelMap Get the current input channel map of the audio stream. IsPaused Whether the audio device associated with a stream is paused. OutputChannelMap Get the current output channel map of the audio stream. Properties The properties associated with an audio stream. Queued Get the number of bytes currently queued."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#constructors","title":"Constructors","text":"Name Description Create(TSdlAudioDeviceID, PSdlAudioSpec, TSdlAudioStreamCallback, Pointer) Convenience constructor for straightforward audio init for the common case. Create(TSdlAudioSpec, TSdlAudioSpec) Create a new audio stream. Create(TSdlAudioSpec) Create a new audio stream."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#methods","title":"Methods","text":"Name Description Clear Clear any pending data in the stream. Flush Tell the stream that you're done sending data, and anything being buffered should be converted/resampled and made available immediately. Free Free the audio stream. GetData Get converted/resampled data from the stream. GetFormat Query the current format of the stream. Lock Lock the audio stream for serialized access. Pause Pause audio playback on the audio device associated with this audio stream. PutData Add data to the stream. Resume Unpause audio playback on the audio device associated with this audio stream. SetFormat Change the input and output formats of the audio stream. SetGetCallback Set a callback that runs when data is requested from an audio stream. SetPutCallback Set a callback that runs when data is added to an audio stream. Unbind Unbinds this audio stream from its audio device. Unlock Unlock the audio stream for serialized access."},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Available","title":"Available","text":"<p>The number of converted/resampled bytes available.</p> <p>The stream may be buffering data behind the scenes until it has enough to resample correctly, so this number might be lower than what you expect, or even be zero. Add more data or flush the stream if you need the data now.</p> <p>If the stream has so much data that it would overflow an int, the return value is clamped to a maximum value, but no queued data is lost; if there are gigabytes of data queued, the app might need to read some of it with GetData before this function's return value is no longer clamped. </p> <p><code>property Available: Integer read GetAvailable</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also","title":"See Also","text":"<ul> <li>GetData</li> <li>PutData</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Device","title":"Device","text":"<p>The currently-bound device of the stream</p> <p>This reports the audio device that an audio stream is currently bound to.</p> <p>If not bound, or invalid, this returns zero, which is not a valid device ID. </p> <p><code>property Device: TSdlAudioDevice read GetDevice</code></p> <p>Type: <code>TSdlAudioDevice</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_1","title":"See Also","text":"<ul> <li>TSdlAudioDevice.Bind</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_1","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#FrequencyRatio","title":"FrequencyRatio","text":"<p>The frequency ratio of the audio stream.</p> <p>The frequency ratio is used to adjust the rate at which input data is consumed. Changing this effectively modifies the speed and pitch of the audio. A value greater than 1.0 will play the audio faster, and at a higher pitch. A value less than 1.0 will play the audio slower, and at a lower pitch.</p> <p>This is applied during GetData, and can be continuously changed to create various effects. </p> <p><code>property FrequencyRatio: Single read GetFrequencyRatio write SetFrequencyRatio</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_2","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Gain","title":"Gain","text":"<p>The gain of an audio stream.</p> <p>The gain of a stream is its volume; a larger gain means a louder output, with a gain of zero being silence.</p> <p>Audio streams default to a gain of 1.0 (no change in output).</p> <p>This is applied during GetData, and can be continuously changed to create various effects. </p> <p><code>property Gain: Single read GetGain write SetGain</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_3","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#InputChannelMap","title":"InputChannelMap","text":"<p>Get the current input channel map of the audio stream.</p> <p>Channel maps are optional; most things do not need them, instead passing data in the order that SDL expects.</p> <p>Audio streams default to no remapping applied. This is represented by returning nil, and does not signify an error.</p> <p>The input channel map reorders data that is added to a stream via PutData. Future calls to PutData must provide data in the new channel order.</p> <p>Each item in the array represents an input channel, and its value is the channel that it should be remapped to. To reverse a stereo signal's left and right values, you'd have an array of <code>{ 1, 0 }</code>. It is legal to remap multiple channels to the same thing, so <code>{ 1, 1 }</code> would duplicate the right channel to both channels of a stereo signal. An element in the channel map set to -1 instead of a valid channel will mute that channel, setting it to a silence value.</p> <p>You cannot change the number of channels through a channel map, just reorder/mute them.</p> <p>Data that was previously queued in the stream will still be operated on in the order that was current when it was added, which is to say you can put the end of a sound file in one order to a stream, change orders for the next sound file, and start putting that new data while the previous sound file is still queued, and everything will still play back correctly.</p> <p>Audio streams default to no remapping applied. Passing a nil channel map is legal, and turns off remapping.</p> <p>If the length of the array is not equal to the current number of channels in the audio stream's format, this will fail. This is a safety measure to make sure a race condition hasn't changed the format while this call is setting the channel map.</p> <p>Unlike attempting to change the stream's format, the input channel map on a stream bound to a recording device is permitted to change at any time; any data added to the stream from the device after this call will have the new mapping, but previously-added data will still have the prior mapping. </p> <p><code>property InputChannelMap: TArray&lt;Integer&gt; read GetInputChannelMap write SetInputChannelMap</code></p> <p>Type: <code>TArray&lt;Integer&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_4","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#IsPaused","title":"IsPaused","text":"<p>Whether the audio device associated with a stream is paused.</p> <p>Unlike in SDL2, audio devices start in an unpaused state, since an app has to bind a stream before any audio will flow.</p> <p>You can also set this property to pause/unpause the stream. </p> <p><code>property IsPaused: Boolean read GetIsPaused write SetIsPaused</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_2","title":"See Also","text":"<ul> <li>Pause</li> <li>Resume</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_5","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#OutputChannelMap","title":"OutputChannelMap","text":"<p>Get the current output channel map of the audio stream.</p> <p>Channel maps are optional; most things do not need them, instead passing data in the order that SDL expects.</p> <p>Audio streams default to no remapping applied. This is represented by returning nil, and does not signify an error.</p> <p>The output channel map reorders data that leaving a stream via GetData.</p> <p>Each item in the array represents an input channel, and its value is the channel that it should be remapped to. To reverse a stereo signal's left and right values, you'd have an array of <code>{ 1, 0 }</code>. It is legal to remap multiple channels to the same thing, so <code>{ 1, 1 }</code> would duplicate the right channel to both channels of a stereo signal. An element in the channel map set to -1 instead of a valid channel will mute that channel, setting it to a silence value.</p> <p>You cannot change the number of channels through a channel map, just reorder/mute them.</p> <p>The output channel map can be changed at any time, as output remapping is applied during GetData.</p> <p>Audio streams default to no remapping applied. Passing a nil channel map is legal, and turns off remapping.</p> <p>If the length of the array is not equal to the current number of channels in the audio stream's format, this will fail. This is a safety measure to make sure a race condition hasn't changed the format while this call is setting the channel map.</p> <p>Unlike attempting to change the stream's format, the output channel map on a stream bound to a recording device is permitted to change at any time; any data added to the stream after this call will have the new mapping, but previously-added data will still have the prior mapping. When the channel map doesn't match the hardware's channel layout, SDL will convert the data before feeding it to the device for playback. </p> <p><code>property OutputChannelMap: TArray&lt;Integer&gt; read GetOutputChannelMap write SetOutputChannelMap</code></p> <p>Type: <code>TArray&lt;Integer&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_6","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Properties","title":"Properties","text":"<p>The properties associated with an audio stream. </p> <p><code>property Properties: TSdlProperties read GetProperties</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_7","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Queued","title":"Queued","text":"<p>Get the number of bytes currently queued.</p> <p>This is the number of bytes put into a stream as input, not the number that can be retrieved as output. Because of several details, it's not possible to calculate one number directly from the other. If you need to know how much usable data can be retrieved right now, you should use Available.</p> <p>Note that audio streams can change their input format at any time, even if there is still data queued in a different format, so the returned byte count will not necessarily match the number of sample frames available. Users of this API should be aware of format changes they make when feeding a stream and plan accordingly.</p> <p>Queued data is not converted until it is consumed by GetData, so this value should be representative of the exact data that was put into the stream.</p> <p>If the stream has so much data that it would overflow an int, the return value is clamped to a maximum value, but no queued data is lost; if there are gigabytes of data queued, the app might need to read some of it with GetData before this function's return value is no longer clamped. </p> <p><code>property Queued: Integer read GetQueued</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_3","title":"See Also","text":"<ul> <li>PutData</li> <li>Clear</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_8","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Create_0","title":"<code>Create</code>","text":"<p>Convenience constructor for straightforward audio init for the common case.</p> <p>If all your app intends to do is provide a single source of PCM audio, this constructor allows you to do all your audio setup in a single call.</p> <p>This is also intended to be a clean means to migrate apps from SDL2.</p> <p>This constructor will open an audio device, create a stream and bind it. Unlike other methods of setup, the audio device will be closed when this stream is destroyed, so the app can treat the returned stream as the only object needed to manage audio playback.</p> <p>Also unlike other functions, the audio device begins paused. This is to map more closely to SDL2-style behavior, since there is no extra step here to bind a stream to begin audio flowing. The audio device should be resumed with <code>Resume</code>.</p> <p>This constructor works with both playback and recording devices.</p> <p>The <code>ASpec</code> parameter represents the app's side of the audio stream. That is, for recording audio, this will be the output format, and for playing audio, this will be the input format. If spec is nil, the system will choose the format, and the app can use GetFormat to obtain this information later.</p> <p>If you don't care about opening a specific audio device, you can (and probably should), use TSdlAudioDeviceID.DefaultPlaybackDevice for playback and TSdlAudioDeviceID.DefaultRecordingDevice for recording.</p> <p>One can optionally provide a callback function; if nil, the app is expected to queue audio data for playback (or unqueue audio data if capturing). Otherwise, the callback will begin to fire once the device is unpaused.</p> <p>Destroying the returned stream with Free will also close the audio device associated with this stream. </p> <p><code>constructor Create(const ADeviceID: TSdlAudioDeviceID; const ASpec: PSdlAudioSpec = nil; const ACallback: TSdlAudioStreamCallback = nil; const AUserData: Pointer = nil); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#parameters","title":"Parameters","text":"<p><code>ADeviceID</code>: <code>TSdlAudioDeviceID</code> : An audio device to open, or TSdlAudioDeviceID.DefaultPlaybackDevice or TSdlAudioDeviceID.DefaultRecordingDevice.</p> <p><code>ASpec</code>: <code>PSdlAudioSpec = nil</code> : (Optional) Audio stream's data format. Can be nil.</p> <p><code>ACallback</code>: <code>TSdlAudioStreamCallback = nil</code> : (Optional) Callback where the app will provide new data for playback, or receive new data for recording. Can be nil, in which case the app will need to call PutData or GetData as necessary.</p> <p><code>AUserData</code>: <code>Pointer = nil</code> : (Optional) App-controlled pointer passed to callback. Can be nil. Ignored if callback is nil.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_6","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_4","title":"See Also","text":"<ul> <li>TSdlAudioStream.Resume</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_9","title":"Remarks","text":"<p>It is safe to call this constructor from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Create_1","title":"<code>Create</code>","text":"<p>Create a new audio stream. </p> <p><code>constructor Create(const ASrcSpec, ADstSpec: TSdlAudioSpec); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#parameters_1","title":"Parameters","text":"<p><code>ASrcSpec</code>: <code>TSdlAudioSpec</code> : The format details of the input audio.</p> <p><code>ADstSpec</code>: <code>TSdlAudioSpec</code> : The format details of the output audio.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_7","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_5","title":"See Also","text":"<ul> <li>PutData</li> <li>GetData</li> <li>Available</li> <li>Flush</li> <li>Clear</li> <li>SetFormat</li> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_10","title":"Remarks","text":"<p>It is safe to call this constructor from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Create_2","title":"<code>Create</code>","text":"<p>Create a new audio stream. </p> <p><code>constructor Create(const ASpec: TSdlAudioSpec); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#parameters_2","title":"Parameters","text":"<p><code>ASpec</code>: <code>TSdlAudioSpec</code> : The format details of the (input) audio.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_8","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_6","title":"See Also","text":"<ul> <li>PutData</li> <li>GetData</li> <li>Available</li> <li>Flush</li> <li>Clear</li> <li>SetFormat</li> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_11","title":"Remarks","text":"<p>It is safe to call this constructor from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Equal","title":"Equal(TSdlAudioStream, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlAudioStream; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#parameters_3","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlAudioStream</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlAudioStream; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#parameters_4","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#returns_1","title":"Returns","text":"<p><code>TSdlAudioStream</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#NotEqual","title":"NotEqual(TSdlAudioStream, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlAudioStream; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#parameters_5","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlAudioStream</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Clear","title":"Clear","text":"<p>Clear any pending data in the stream.</p> <p>This drops any queued data, so there will be nothing to read from the stream until more is added. </p> <p><code>procedure Clear; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_9","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_7","title":"See Also","text":"<ul> <li>Available</li> <li>GetData</li> <li>Queued</li> <li>PutData</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_12","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Flush","title":"Flush","text":"<p>Tell the stream that you're done sending data, and anything being buffered should be converted/resampled and made available immediately.</p> <p>It is legal to add more data to a stream after flushing, but there may be audio gaps in the output. Generally this is intended to signal the end of input, so the complete output becomes available. </p> <p><code>procedure Flush; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_10","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_8","title":"See Also","text":"<ul> <li>PutData</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_13","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Free","title":"Free","text":"<p>Free the audio stream.</p> <p>This will release all allocated data, including any audio that is still queued. You do not need to manually clear the stream first.</p> <p>If this stream was bound to an audio device, it is unbound during this call. If this stream was created using a device, the audio device that was opened alongside this stream's creation will be closed, too. </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_9","title":"See Also","text":"<ul> <li>Create</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_14","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#GetData","title":"GetData(Pointer, Integer)","text":"<p>Get converted/resampled data from the stream.</p> <p>The input/output data format/channels/samplerate is specified when creating the stream, and can be changed after creation by setting calling SetFormat.</p> <p>Note that any conversion and resampling necessary is done during this call, and PutData simply queues unconverted data for later. This is different than SDL2, where that work was done while inputting new data to the stream and requesting the output just copied the converted data. </p> <p><code>function GetData(const ABuffer: Pointer; const ASize: Integer): Integer; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_11","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#parameters_6","title":"Parameters","text":"<p><code>ABuffer</code>: <code>Pointer</code> : A buffer to fill with audio data.</p> <p><code>ASize</code>: <code>Integer</code> : The maximum number of bytes to fill.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#returns_3","title":"Returns","text":"<p><code>Integer</code>: The number of bytes read from the stream.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_10","title":"See Also","text":"<ul> <li>Clear</li> <li>Available</li> <li>PutData</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_15","title":"Remarks","text":"<p>It is safe to call this method from any thread, but if the stream has a callback set, the caller might need to manage extra locking. </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#GetFormat","title":"GetFormat(PSdlAudioSpec, PSdlAudioSpec)","text":"<p>Query the current format of the stream. </p> <p><code>procedure GetFormat(const ASrcSpec, ADstSpec: PSdlAudioSpec); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_12","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#parameters_7","title":"Parameters","text":"<p><code>ASrcSpec</code>: <code>PSdlAudioSpec</code> : Where to store the input audio format, or nil if not needed.</p> <p><code>ADstSpec</code>: <code>PSdlAudioSpec</code> : Where to store the output audio format, or nil if not needed.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_11","title":"See Also","text":"<ul> <li>SetFormat</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_16","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Lock","title":"Lock","text":"<p>Lock the audio stream for serialized access.</p> <p>Each audio stream has an internal mutex it uses to protect its data structures from threading conflicts. This function allows an app to lock that mutex, which could be useful if registering callbacks on this stream.</p> <p>One does not need to lock a stream to use in it most cases, as the stream manages this lock internally. However, this lock is held during callbacks, which may run from arbitrary threads at any time, so if an app needs to protect shared data during those callbacks, locking the stream guarantees that the callback is not running while the lock is held. </p> <p><code>procedure Lock; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_13","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_12","title":"See Also","text":"<ul> <li>Unlock</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_17","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Pause","title":"Pause","text":"<p>Pause audio playback on the audio device associated with this audio stream.</p> <p>This method pauses audio processing for a given device. Any bound audio streams will not progress, and no audio will be generated. Pausing one device does not prevent other unpaused devices from running.</p> <p>Pausing a device can be useful to halt all audio without unbinding all the audio streams. This might be useful while a game is paused, or a level is loading, etc. </p> <p><code>procedure Pause; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_14","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_13","title":"See Also","text":"<ul> <li>Resume</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_18","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#PutData","title":"PutData(Pointer, Integer)","text":"<p>Add data to the stream.</p> <p>This data must match the format/channels/samplerate specified in the latest call to SetFormat, or the format specified when creating the stream if it hasn't been changed.</p> <p>Note that this call simply copies the unconverted data for later. This is different than SDL2, where data was converted during the Put call and the Get call would just dequeue the previously-converted data. </p> <p><code>procedure PutData(const ABuffer: Pointer; const ASize: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_15","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#parameters_8","title":"Parameters","text":"<p><code>ABuffer</code>: <code>Pointer</code> : A pointer to the audio data to add.</p> <p><code>ASize</code>: <code>Integer</code> : The number of bytes to write to the stream.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_14","title":"See Also","text":"<ul> <li>Clear</li> <li>Flush</li> <li>GetData</li> <li>Queued</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_19","title":"Remarks","text":"<p>It is safe to call this method from any thread, but if the stream has a callback set, the caller might need to manage extra locking. </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Resume","title":"Resume","text":"<p>Unpause audio playback on the audio device associated with this audio stream.</p> <p>This method unpauses audio processing for a given device that has previously been paused. Once unpaused, any bound audio streams will begin to progress again, and audio can be generated. </p> <p><code>procedure Resume; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_16","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_15","title":"See Also","text":"<ul> <li>Pause</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_20","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#SetFormat","title":"SetFormat(PSdlAudioSpec, PSdlAudioSpec)","text":"<p>Change the input and output formats of the audio stream.</p> <p>Future calls to and Available and GetData will reflect the new format, and future calls to PutData must provide data in the new input formats.</p> <p>Data that was previously queued in the stream will still be operated on in the format that was current when it was added, which is to say you can put the end of a sound file in one format to a stream, change formats for the next sound file, and start putting that new data while the previous sound file is still queued, and everything will still play back correctly.</p> <p>If a stream is bound to a device, then the format of the side of the stream bound to a device cannot be changed (ASrcSpec for recording devices, ADstSpec for playback devices). Attempts to make a change to this side will be ignored, but this will not report an error. The other side's format can be changed. </p> <p><code>procedure SetFormat(const ASrcSpec, ADstSpec: PSdlAudioSpec); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_17","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#parameters_9","title":"Parameters","text":"<p><code>ASrcSpec</code>: <code>PSdlAudioSpec</code> : The new format of the audio input or nil to leave it unchanged.</p> <p><code>ADstSpec</code>: <code>PSdlAudioSpec</code> : The new format of the audio output or nil to leave it unchanged.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_16","title":"See Also","text":"<ul> <li>GetFormat</li> <li>FrequencyRatio</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_21","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#SetGetCallback","title":"SetGetCallback(TSdlAudioStreamCallback, Pointer)","text":"<p>Set a callback that runs when data is requested from an audio stream.</p> <p>This callback is called before data is obtained from the stream, giving the callback the chance to add more on-demand.</p> <p>The callback can (optionally) call PutData to add more audio to the stream during this call; if needed, the request that triggered this callback will obtain the new data immediately.</p> <p>The callback's <code>AAdditionalAmount</code> argument is roughly how many bytes of unconverted data (in the stream's input format) is needed by the caller, although this may overestimate a little for safety. This takes into account how much is already in the stream and only asks for any extra necessary to resolve the request, which means the callback may be asked for zero bytes, and a different amount on each call.</p> <p>The callback is not required to supply exact amounts; it is allowed to supply too much or too little or none at all. The caller will get what's available, up to the amount they requested, regardless of this callback's outcome.</p> <p>Clearing or flushing an audio stream does not call this callback.</p> <p>This function obtains the stream's lock, which means any existing callback (get or put) in progress will finish running before setting the new callback.</p> <p>Setting a nil function turns off the callback. </p> <p><code>procedure SetGetCallback(const ACallback: TSdlAudioStreamCallback; const AUserData: Pointer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_18","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#parameters_10","title":"Parameters","text":"<p><code>ACallback</code>: <code>TSdlAudioStreamCallback</code> : The new callback function to call when data is requested from the stream.</p> <p><code>AUserData</code>: <code>Pointer</code> : An opaque pointer provided to the callback for its own personal use.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_17","title":"See Also","text":"<ul> <li>SetPutCallback</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_22","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#SetPutCallback","title":"SetPutCallback(TSdlAudioStreamCallback, Pointer)","text":"<p>Set a callback that runs when data is added to an audio stream.</p> <p>This callback is called after the data is added to the stream, giving the callback the chance to obtain it immediately.</p> <p>The callback can (optionally) call GetData to obtain audio from the stream during this call.</p> <p>The callback's <code>AAdditionalAmount</code> argument is how many bytes of converted data (in the stream's output format) was provided by the caller, although this may underestimate a little for safety. This value might be less than what is currently available in the stream, if data was already there, and might be less than the caller provided if the stream needs to keep a buffer to aid in resampling. Which means the callback may be provided with zero bytes, and a different amount on each call.</p> <p>The callback may use Available to see the total amount currently available to read from the stream, instead of the total provided by the current call.</p> <p>The callback is not required to obtain all data. It is allowed to read less or none at all. Anything not read now simply remains in the stream for later access.</p> <p>Clearing or flushing an audio stream does not call this callback.</p> <p>This function obtains the stream's lock, which means any existing callback (get or put) in progress will finish running before setting the new callback.</p> <p>Setting a nil function turns off the callback. </p> <p><code>procedure SetPutCallback(const ACallback: TSdlAudioStreamCallback; const AUserData: Pointer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_19","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#parameters_11","title":"Parameters","text":"<p><code>ACallback</code>: <code>TSdlAudioStreamCallback</code> : The new callback function to call when data is added to the stream.</p> <p><code>AUserData</code>: <code>Pointer</code> : an opaque pointer provided to the callback for its own personal use.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_18","title":"See Also","text":"<ul> <li>SetGetCallback</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_23","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Unbind","title":"Unbind","text":"<p>Unbinds this audio stream from its audio device. </p> <p><code>procedure Unbind; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_19","title":"See Also","text":"<ul> <li>TSdlAudioDevice.Bind</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_24","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#Unlock","title":"Unlock","text":"<p>Unlock the audio stream for serialized access.</p> <p>This unlocks an audio stream after a call to Lock. </p> <p><code>procedure Unlock; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#exceptions_20","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#see-also_20","title":"See Also","text":"<ul> <li>Lock</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/classes/TSdlAudioStream/#remarks_25","title":"Remarks","text":"<p>You should only call this from the same thread that previously called Lock. </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/PSdlAudioSpec/","title":"PSdlAudioSpec","text":""},{"location":"Reference/Neslib.Sdl3.Audio/types/PSdlAudioSpec/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Audio</p> <pre><code>type PSdlAudioSpec = ^TSdlAudioSpec\n</code></pre> <p>Base type: <code>TSdlAudioSpec</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/","title":"TSdlAudioFormat","text":"<p>Audio format. </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Audio</p> <pre><code>type TSdlAudioFormat = (Unknown, U8, S8, S16, S32, F32, S16LE, S16BE, S32LE, S32BE, F32LE, F32BE)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#unknown-sdl_audio_unknown","title":"<code>Unknown = SDL_AUDIO_UNKNOWN</code>","text":"<p>Unspecified audio format </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#u8-sdl_audio_u8","title":"<code>U8 = SDL_AUDIO_U8</code>","text":"<p>Unsigned 8-bit samples </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#s8-sdl_audio_s8","title":"<code>S8 = SDL_AUDIO_S8</code>","text":"<p>Signed 8-bit samples </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#s16-sdl_audio_s16","title":"<code>S16 = SDL_AUDIO_S16</code>","text":"<p>Signed 16-bit samples </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#s32-sdl_audio_s32","title":"<code>S32 = SDL_AUDIO_S32</code>","text":"<p>32-bit integer samples </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#f32-sdl_audio_f32","title":"<code>F32 = SDL_AUDIO_F32</code>","text":""},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#s16le-sdl_audio_s16le","title":"<code>S16LE = SDL_AUDIO_S16LE</code>","text":"<p>Signed 16-bit samples, in little-endian byte order </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#s16be-sdl_audio_s16be","title":"<code>S16BE = SDL_AUDIO_S16BE</code>","text":"<p>Signed 16-bit samples, big-endian byte order </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#s32le-sdl_audio_s32le","title":"<code>S32LE = SDL_AUDIO_S32LE</code>","text":"<p>32-bit integer samples, in little-endian byte order </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#s32be-sdl_audio_s32be","title":"<code>S32BE = SDL_AUDIO_S32BE</code>","text":"<p>32-bit integer samples, in big-endian byte order </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#f32le-sdl_audio_f32le","title":"<code>F32LE = SDL_AUDIO_F32LE</code>","text":"<p>32-bit floating point samples, in little-endian byte order </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#f32be-sdl_audio_f32be","title":"<code>F32BE = SDL_AUDIO_F32BE</code>","text":"<p>32-bit floating point samples, in big-endian byte order </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#properties","title":"Properties","text":"Name Description BitSize The size, in bits. ByteSize The size, in bytes. IsBigEndian Whether this format represents big-endian data. IsFloat Whether this format represents floating point data. IsInteger Whether this format represents integer data. IsLittleEndian Whether this format represents little-endian data. IsSigned Whether this format represents signed data. IsUnsigned Whether this format represents unsigned data. Name The human readable name of the audio format. SilenceValue Get the appropriate <code>FillChar</code> value for silencing this audio format."},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#BitSize","title":"BitSize","text":"<p>The size, in bits.</p> <p>For example, <code>TSdlAudioFormat.S16</code> returns 16. </p> <p><code>property BitSize: Byte read GetBitSize</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#ByteSize","title":"ByteSize","text":"<p>The size, in bytes.</p> <p>For example, <code>TSdlAudioFormat.S16</code> returns 2. </p> <p><code>property ByteSize: Byte read GetByteSize</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#IsBigEndian","title":"IsBigEndian","text":"<p>Whether this format represents big-endian data.</p> <p>For example, <code>TSdlAudioFormat.S16LE</code> returns False. </p> <p><code>property IsBigEndian: Boolean read GetIsBigEndian</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#IsFloat","title":"IsFloat","text":"<p>Whether this format represents floating point data.</p> <p>For example, <code>TSdlAudioFormat.S16</code> returns False. </p> <p><code>property IsFloat: Boolean read GetIsFloat</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#IsInteger","title":"IsInteger","text":"<p>Whether this format represents integer data.</p> <p>For example, <code>TSdlAudioFormat.S16</code> returns True. </p> <p><code>property IsInteger: Boolean read GetIsInteger</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#IsLittleEndian","title":"IsLittleEndian","text":"<p>Whether this format represents little-endian data.</p> <p>For example, <code>TSdlAudioFormat.S16LE</code> returns True. </p> <p><code>property IsLittleEndian: Boolean read GetIsLittleEndian</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#IsSigned","title":"IsSigned","text":"<p>Whether this format represents signed data.</p> <p>For example, <code>TSdlAudioFormat.U8</code> returns False. </p> <p><code>property IsSigned: Boolean read GetIsSigned</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#IsUnsigned","title":"IsUnsigned","text":"<p>Whether this format represents unsigned data.</p> <p>For example, <code>TSdlAudioFormat.U8</code> returns True. </p> <p><code>property IsUnsigned: Boolean read GetIsUnsigned</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#Name","title":"Name","text":"<p>The human readable name of the audio format. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#remarks","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#SilenceValue","title":"SilenceValue","text":"<p>Get the appropriate <code>FillChar</code> value for silencing this audio format.</p> <p>The value returned by this property can be used as the third argument to <code>FillChar</code> to set an audio buffer in this format to silence. </p> <p><code>property SilenceValue: Byte read GetSilenceValue</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioFormat/#remarks_1","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioPostmixCallback/","title":"TSdlAudioPostmixCallback","text":"<p>A callback that fires when data is about to be fed to an audio device.</p> <p>This is useful for accessing the final mix, perhaps for writing a visualizer or applying a final effect to the audio data before playback.</p> <p>This callback should run as quickly as possible and not block for any significant time, as this callback delays submission of data to the audio device, which can cause audio playback problems.</p> <p>The postmix callback must be able to handle any audio data format specified in <code>ASpec</code>, which can change between callbacks if the audio device changed. However, this only covers frequency and channel count; data is always provided here in TSdlAudioFormat.F32 format.</p> <p>The postmix callback runs after logical device gain and audiostream gain have been applied, which is to say you can make the output data louder at this point than the gain settings would suggest. </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioPostmixCallback/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Audio</p> <pre><code>type TSdlAudioPostmixCallback = procedure(AUserData: Pointer; \n  const ASpec: PSdlAudioSpec; ABuffer: PSingle; ASize: Integer); cdecl\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioPostmixCallback/#parameters","title":"Parameters","text":"<p><code>AUserData</code>: <code>Pointer</code> : A pointer provided by the app through TSdlAudioDevice.SetPostmixCallback, for its own use.</p> <p><code>ASpec</code>: <code>PSdlAudioSpec</code> : The current format of audio that is to be submitted to the audio device.</p> <p><code>ABuffer</code>: <code>PSingle</code> : The buffer of audio samples to be submitted. The callback can inspect and/or modify this data.</p> <p><code>ASize</code>: <code>Integer</code> : The size of <code>ABuffer</code> in bytes.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioPostmixCallback/#see-also","title":"See Also","text":"<ul> <li>TSdlAudioDevice.SetPostmixCallback</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioPostmixCallback/#remarks","title":"Remarks","text":"<p>This will run from a background thread owned by SDL. The application is responsible for locking resources the callback touches that need to be protected. </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioStreamCallback/","title":"TSdlAudioStreamCallback","text":"<p>A callback that fires when data passes through a TSdlAudioStream.</p> <p>Apps can (optionally) register a callback with an audio stream that is called when data is added with TSdlAudioStream.PutData, or requested with TSdlAudioStream.GetData.</p> <p>Two values are offered here: one is the amount of additional data needed to satisfy the immediate request (which might be zero if the stream already has enough data queued) and the other is the total amount being requested. In a Get call triggering a Put callback, these values can be different. In a Put call triggering a Get callback, these values are always the same.</p> <p>Byte counts might be slightly overestimated due to buffering or resampling, and may change from call to call.</p> <p>This callback is not required to do anything. Generally this is useful for adding/reading data on demand, and the app will often put/get data as appropriate, but the system goes on with the data currently available to it if this callback does nothing. </p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioStreamCallback/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Audio</p> <pre><code>type TSdlAudioStreamCallback = procedure(AUserData: Pointer; \n  AStream: TSdlAudioStream; AAdditionalAmount, ATotalAmount: Integer); cdecl\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioStreamCallback/#parameters","title":"Parameters","text":"<p><code>AUserData</code>: <code>Pointer</code> : An opaque pointer provided by the app for their personal use.</p> <p><code>AStream</code>: <code>TSdlAudioStream</code> : The SDL audio stream associated with this callback.</p> <p><code>AAdditionalAmount</code>: <code>Integer</code> : The amount of data, in bytes, that is needed right now.</p> <p><code>ATotalAmount</code>: <code>Integer</code> : The total amount of data requested, in bytes, that is requested or available.</p>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioStreamCallback/#see-also","title":"See Also","text":"<ul> <li>TSdlAudioStream.SetGetCallback</li> <li>TSdlAudioStream.SetPutCallback</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Audio/types/TSdlAudioStreamCallback/#remarks","title":"Remarks","text":"<p>This callback may run from any thread, so if you need to protect shared data, you should use TSdlAudioStream.Lock to serialize access; this lock will be held before your callback is called, so your callback does not need to manage the lock explicitly. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/","title":"Neslib.Sdl3.Basics","text":""},{"location":"Reference/Neslib.Sdl3.Basics/#classes-records","title":"Classes &amp; Records","text":"Name Description ESdlError Exception type for SDL errors. TSdlHints Lists and manages hints. TSdlLog Logging functionality. TSdlProperties A group of SDL properties. TSdlProperty Standard SDL properties TSdlVersion Information about the version of SDL in use."},{"location":"Reference/Neslib.Sdl3.Basics/#types","title":"Types","text":"Name Description TSdlEnumeratePropertiesCallback A callback used to enumerate all the properties in a group of properties. TSdlHintCallback A callback used to send notifications of hint value changes. TSdlHintPriority An enumeration of hint priorities. TSdlInitFlag Initialization flags for SdlInit and/or SdlInitSubSystem. TSdlInitFlags A set of initialization flags for SdlInit and/or SdlInitSubSystem. TSdlLogCategory The predefined log categories TSdlLogOutputFunction The prototype for the log output callback function. TSdlLogPriority The predefined log priorities TSdlMainThreadCallback Callback run on the main thread. TSdlPropertyCleanupCallback A callback used to free resources when a property is deleted. TSdlPropertyType SDL property type"},{"location":"Reference/Neslib.Sdl3.Basics/#routines","title":"Routines","text":"Name Description SdlCheck(THandle) Checks the result of an SDL API. SdlCheck(Boolean) Checks the result of an SDL API. SdlCheck(Pointer) Checks the result of an SDL API. SdlFailed(THandle) Checks if an SDL API failed. SdlFailed(Pointer) Checks if an SDL API failed. SdlFailed(Boolean) Checks if an SDL API failed. SdlGetAppMetadata Get metadata about your app. SdlInit Initialize the SDL library. SdlInitSubSystem Compatibility function to initialize the SDL library. SdlIsMainThread Return whether this is the main thread. SdlQuit Clean up all initialized subsystems. SdlQuitSubSystem Shut down specific SDL subsystems. SdlRunOnMainThread Call a function on the main thread during event processing. SdlSetAppMetadata(String, String, String) Specify basic metadata about your app. SdlSetAppMetadata(String, String) Specify metadata about your app through a set of properties. SdlSucceeded(Pointer) Checks if an SDL API succeeded. SdlSucceeded(Boolean) Checks if an SDL API succeeded. SdlSucceeded(THandle) Checks if an SDL API succeeded. SdlWasInit Get the specified subsystems which are currently initialized."},{"location":"Reference/Neslib.Sdl3.Basics/classes/ESdlError/","title":"ESdlError","text":"<p>Exception type for SDL errors.</p> <p>When an underlying C-API SDL API returns an error code, an exception of this type will be raised. The exception message is provided by the underlying SDL library.</p> <p>When a wrapped API can raise an exception, this is mentioned in the API's documentation. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/ESdlError/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type ESdlError = class(Exception) ... end\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/ESdlError/#inheritance","title":"Inheritance","text":"<p>Inherits: Exception</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/ESdlError/#see-also","title":"See Also","text":"<ul> <li>TSdlApp.HandleError</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/ESdlError/#remarks","title":"Remarks","text":"<p>Is used to raise the last error that occurred on the current thread.</p> <p>It is possible for multiple errors to occur. Only the last error is raised.</p> <p>SDL Exceptions can be disabled by overriding TSdlApp.HandleError. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/","title":"TSdlHints","text":"<p>Lists and manages hints. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type TSdlHints = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#constants","title":"Constants","text":"Name Description AllowTabWhileGrabbed Specify the behavior of Alt+Tab while the keyboard is grabbed. AndroidAllowRecreateActivity A variable to control whether the SDL activity is allowed to be re-created. AndroidBlockOnPause A variable to control whether the event loop will block itself when the app is paused. AndroidLowLatencyAudio A variable to control whether low latency audio should be enabled. AndroidTrapBackButton A variable to control whether we trap the Android back button to handle it manually. AppID A variable setting the app ID string. AppleTVControllerUIEvents A variable controlling whether controllers used with the Apple TV generate UI events. AppleTVRemoteAllowRotation A variable controlling whether the Apple TV remote's joystick axes will automatically match the rotation of the remote. AppName A variable setting the application name. Assert A variable controlling response to SdlAssert failures. AudioAlsaDefaultDevice Specify the default ALSA audio device name. AudioAlsaDefaultPlaybackDevice Specify the default ALSA audio playback device name. AudioAlsaDefaultRecordingDevice Specify the default ALSA audio recording device name. AudioCategory A variable controlling the audio category on iOS and macOS. AudioChannels A variable controlling the default audio channel count. AudioDeviceAppIconName Specify an application icon name for an audio device. AudioDeviceSampleFrames A variable controlling device buffer size. AudioDeviceStreamName Specify an audio stream name for an audio device. AudioDeviceStreamRole Specify an application role for an audio device. AudioDiskInputFile Specify the input file when recording audio using the disk audio driver. AudioDiskOutputFile Specify the output file when playing audio using the disk audio driver. AudioDiskTimescale A variable controlling the audio rate when using the disk audio driver. AudioDriver A variable that specifies an audio backend to use. AudioDummyTimescale A variable controlling the audio rate when using the dummy audio driver. AudioFormat A variable controlling the default audio format. AudioFrequency A variable controlling the default audio frequency. AudioIncludeMonitors A variable that causes SDL to not ignore audio 'monitors'. AutoUpdateJoysticks A variable controlling whether SDL updates joystick state when getting input events. AutoUpdateSensors A variable controlling whether SDL updates sensor state when getting input events. BmpSaveLegacyFormat Prevent SDL from using version 4 of the bitmap header when saving BMPs. CameraDriver A variable that decides what camera backend to use. CpuFeatureMask A variable that limits what CPU features are available. DisplayUsableBounds Override for TSdlDisplay.UsableBounds. EglLibrary Specify the EGL library to load. EnableScreenKeyboard A variable that controls whether the on-screen keyboard should be shown when text input is active. EVDevDevices A variable containing a list of evdev devices to use if udev is not available. EventLogging A variable controlling verbosity of the logging of SDL events pushed onto the internal queue. FileDialogDriver A variable that specifies a dialog backend to use. ForceRaiseWindow A variable controlling whether raising the window should be done more forcefully. FramebufferAcceleration A variable controlling how 3D acceleration is used to accelerate the SDL screen surface. GameControllerConfig A variable that lets you manually hint extra gamecontroller db entries. GameControllerConfigFile A variable that lets you provide a file with extra gamecontroller db entries. GameControllerIgnoreDevices A variable containing a list of devices to skip when scanning for game controllers. GameControllerIgnoreDevicesExcept If set, all devices will be skipped when scanning for game controllers except for the ones listed in this variable. GameControllerSensorFusion A variable that controls whether the device's built-in accelerometer and gyro should be used as sensors for gamepads. GameControllerType A variable that overrides the automatic controller type detection. GpuDriver A variable that specifies a GPU backend to use. HidApiEnumerateOnlyControllers A variable to control whether TSdlHid.Enumerate enumerates all HID devices or only controllers. HidApiIgnoreDevices A variable containing a list of devices to ignore in TSdlHid.Enumerate. HidApiLibUDev A variable to control whether HIDAPI uses udev for device detection. HidApiLibUsb A variable to control whether HIDAPI uses libusb for device access. HidApiLibUsbWhiteList A variable to control whether HIDAPI uses libusb only for whitelisted devices. ImeImplementedUI A variable describing what IME UI elements the application can display. IosHideHomeIndicator A variable controlling whether the home indicator bar on iPhone X should be hidden. JoystickAllowBackgroundEvents A variable that lets you enable joystick (and gamecontroller) events even when your app is in the background. JoystickArcadestickDevices A variable containing a list of arcade stick style controllers. JoystickArcadestickDevicesExcluded A variable containing a list of devices that are not arcade stick style controllers. JoystickBlacklistDevices A variable containing a list of devices that should not be considered joysticks. JoystickBlacklistDevicesExcluded A variable containing a list of devices that should be considered joysticks. JoystickDevice A variable containing a comma separated list of devices to open as joysticks. JoystickDirectInput A variable controlling whether DirectInput should be used for controllers. JoystickEnhancedReports A variable controlling whether enhanced reports should be used for controllers when using the HIDAPI driver. JoystickFlightstickDevices A variable containing a list of flightstick style controllers. JoystickFlightstickDevicesExcluded A variable containing a list of devices that are not flightstick style controllers. JoystickGameCubeDevices A variable containing a list of devices known to have a GameCube form factor. JoystickGameCubeDevicesExcluded A variable containing a list of devices known not to have a GameCube form factor. JoystickGameInput A variable controlling whether GameInput should be used for controller handling on Windows. JoystickHidApi A variable controlling whether the HIDAPI joystick drivers should be used. JoystickHidApiCombineJoyCons A variable controlling whether Nintendo Switch Joy-Con controllers will be combined into a single Pro-like controller when using the HIDAPI driver. JoystickHidApiGameCube A variable controlling whether the HIDAPI driver for Nintendo GameCube controllers should be used. JoystickHidApiGameCubeRumbleBrake A variable controlling whether rumble is used to implement the GameCube controller's 3 rumble modes, Stop(0), Rumble(1), and StopHard(2). JoystickHidApiJoyConHomeLed A variable controlling whether the Home button LED should be turned on when a Nintendo Switch Joy-Con controller is opened. JoystickHidApiJoyCons A variable controlling whether the HIDAPI driver for Nintendo Switch Joy-Cons should be used. JoystickHidApiLuna A variable controlling whether the HIDAPI driver for Amazon Luna controllers connected via Bluetooth should be used. JoystickHidApiNintendoClassic A variable controlling whether the HIDAPI driver for Nintendo Online classic controllers should be used. JoystickHidApiPS3 A variable controlling whether the HIDAPI driver for PS3 controllers should be used. JoystickHidApiPS3SixAxisDriver A variable controlling whether the Sony driver (sixaxis.sys) for PS3 controllers (Sixaxis/DualShock 3) should be used. JoystickHidApiPS4 A variable controlling whether the HIDAPI driver for PS4 controllers should be used. JoystickHidApiPS4ReportInterval A variable controlling the update rate of the PS4 controller over Bluetooth when using the HIDAPI driver. JoystickHidApiPS5 A variable controlling whether the HIDAPI driver for PS5 controllers should be used. JoystickHidApiPS5PlayerLed A variable controlling whether the player LEDs should be lit to indicate which player is associated with a PS5 controller. JoystickHidApiShield A variable controlling whether the HIDAPI driver for NVIDIA SHIELD controllers should be used. JoystickHidApiStadia A variable controlling whether the HIDAPI driver for Google Stadia controllers should be used. JoystickHidApiSteam A variable controlling whether the HIDAPI driver for Bluetooth Steam Controllers should be used. JoystickHidApiSteamDeck A variable controlling whether the HIDAPI driver for the Steam Deck builtin controller should be used. JoystickHidApiSteamHomeLed A variable controlling whether the Steam button LED should be turned on when a Steam controller is opened. JoystickHidApiSteamHori A variable controlling whether the HIDAPI driver for HORI licensed Steam controllers should be used. JoystickHidApiSwitch A variable controlling whether the HIDAPI driver for Nintendo Switch controllers should be used. JoystickHidApiSwitchHomeLed A variable controlling whether the Home button LED should be turned on when a Nintendo Switch Pro controller is opened. JoystickHidApiSwitchPlayerLed A variable controlling whether the player LEDs should be lit to indicate which player is associated with a Nintendo Switch controller. JoystickHidApiVerticalJoyCons A variable controlling whether Nintendo Switch Joy-Con controllers will be in vertical mode when using the HIDAPI driver. JoystickHidApiWii A variable controlling whether the HIDAPI driver for Nintendo Wii and Wii U controllers should be used. JoystickHidApiWiiPlayerLed A variable controlling whether the player LEDs should be lit to indicate which player is associated with a Wii controller. JoystickHidApiXbox A variable controlling whether the HIDAPI driver for XBox controllers should be used. JoystickHidApiXbox360 A variable controlling whether the HIDAPI driver for XBox 360 controllers should be used. JoystickHidApiXbox360PlayerLed A variable controlling whether the player LEDs should be lit to indicate which player is associated with an Xbox 360 controller. JoystickHidApiXbox360Wireless A variable controlling whether the HIDAPI driver for XBox 360 wireless controllers should be used. JoystickHidApiXboxOne A variable controlling whether the HIDAPI driver for XBox One controllers should be used. JoystickHidApiXboxOneHomeLed A variable controlling whether the Home button LED should be turned on when an Xbox One controller is opened. JoystickIOKit A variable controlling whether IOKit should be used for controller handling. JoystickLinuxClassic A variable controlling whether to use the classic /dev/input/js joystick interface or the newer /dev/input/event joystick interface on Linux. JoystickLinuxDeadzoned A variable controlling whether joysticks on Linux adhere to their HID-defined deadzones or return unfiltered values. JoystickLinuxDigitalHats A variable controlling whether joysticks on Linux will always treat 'hat' axis inputs (ABS_HAT0X - ABS_HAT3Y) as 8-way digital hats without checking whether they may be analog. JoystickLinuxHatDeadzones A variable controlling whether digital hats on Linux will apply deadzones to their underlying input axes or use unfiltered values. JoystickMfi A variable controlling whether GCController should be used for controller handling. JoystickRawInput A variable controlling whether the RAWINPUT joystick drivers should be used for better handling XInput-capable devices. JoystickRawInputCorrelateXInput A variable controlling whether the RAWINPUT driver should pull correlated data from XInput. JoystickRogChakram A variable controlling whether the ROG Chakram mice should show up as joysticks. JoystickThread A variable controlling whether a separate thread should be used for handling joystick detection and raw input messages on Windows. JoystickThrottleDevices A variable containing a list of throttle style controllers. JoystickThrottleDevicesExcluded A variable containing a list of devices that are not throttle style controllers. JoystickWgi A variable controlling whether Windows.Gaming.Input should be used for controller handling. JoystickWheelDevices A variable containing a list of wheel style controllers. JoystickWheelDevicesExcluded A variable containing a list of devices that are not wheel style controllers. JoystickZeroCenteredDevices A variable containing a list of devices known to have all axes centered at zero. KeycodeOptions A variable that controls keycode representation in keyboard events. KmsDrmDeviceIndex A variable that controls what KMSDRM device to use. KmsDrmRequireDrmMaster A variable that controls whether SDL requires DRM master access in order to initialize the KMSDRM video backend. Logging A variable controlling the default SDL log levels. MacBackgroundApp A variable controlling whether to force the application to become the foreground process when launched on macOS. MacCtrlClickEmulateRightClick A variable that determines whether Ctrl+Click should generate a right-click event on macOS. MacOpenGLAsyncDispatch A variable controlling whether dispatching OpenGL context updates should block the dispatching thread until the main thread finishes processing on macOS. MacOptionAsAlt A variable controlling whether the Option (\u2325) key on macOS should be remapped to act as the Alt key. MacScrollMomentum A variable controlling whether SDL_EVENT_MOUSE_WHEEL event values will have momentum on macOS. MainCallbackRate Request TSdlApp.Iterate be called at a specific rate. MouseAutoCapture A variable controlling whether the mouse is captured while mouse buttons are pressed. MouseDefaultSystemCursor A variable setting which system cursor to use as the default cursor. MouseDoubleClickRadius A variable setting the double click radius, in pixels. MouseDoubleClickTime A variable setting the double click time, in milliseconds. MouseEmulateWarpWithRelative A variable controlling whether warping a hidden mouse cursor will activate relative mouse mode. MouseFocusClickThrough Allow mouse click events when clicking to focus an SDL window. MouseNormalSpeedScale A variable setting the speed scale for mouse motion, in floating point, when the mouse is not in relative mode. MouseRelativeCursorVisible A variable controlling whether the hardware cursor stays visible when relative mode is active. MouseRelativeModeCenter A variable controlling whether relative mouse mode constrains the mouse to the center of the window. MouseRelativeSpeedScale A variable setting the scale for mouse motion, in floating point, when the mouse is in relative mode. MouseRelativeSystemScale A variable controlling whether the system mouse acceleration curve is used for relative mouse motion. MouseRelativeWarpMotion A variable controlling whether a motion event should be generated for mouse warping in relative mode. MouseTouchEvents A variable controlling whether mouse events should generate synthetic touch events. MuteConsoleKeyboard A variable controlling whether the keyboard should be muted on the console. NoSignalHandlers Tell SDL not to catch the SIGINT or SIGTERM signals on POSIX platforms. OpenGlesDriver A variable controlling what driver to use for OpenGL ES contexts. OpenGLLibrary Specify the OpenGL library to load. OpenVRLibrary Mechanism to specify openvr_api library location Orientations A variable controlling which orientations are allowed on iOS/Android. PenMouseEvents A variable controlling whether pen events should generate synthetic mouse events. PenTouchEvents A variable controlling whether pen events should generate synthetic touch events. PollSentinel A variable controlling the use of a sentinel event when polling the event queue. PreferredLocales Override for TSdlLocale.PreferredLocales. QuitOnLastWindowClose A variable that decides whether to send TSdlEventKind.Quit when closing the last window. RenderDirect3D11Debug A variable controlling whether to enable Direct3D 11+'s Debug Layer. RenderDirect3DThreadSafe A variable controlling whether the Direct3D device is initialized for thread-safe operations. RenderDriver A variable specifying which render driver to use. RenderGpuDebug A variable controlling whether to create the GPU device in debug mode. RenderGpuLowPower A variable controlling whether to prefer a low-power GPU on multi-GPU systems. RenderLineMethod A variable controlling how the 2D render API renders lines. RenderMetalPreferLowPowerDevice A variable controlling whether the Metal render driver select low power device over default one. RenderVSync A variable controlling whether updates to the SDL screen surface should be synchronized with the vertical refresh, to avoid tearing. RenderVulkanDebug A variable controlling whether to enable Vulkan Validation Layers. ReturnKeyHideIme A variable to control whether the return key on the soft keyboard should hide the soft keyboard on Android and iOS. RogGamepadMice A variable containing a list of ROG gamepad capable mice. RogGamepadMiceExcluded A variable containing a list of devices that are not ROG gamepad capable mice. RpiVideoLayer A variable controlling which Dispmanx layer to use on a Raspberry PI. ScreenSaverInhibitActivityName Specify an 'activity name' for screensaver inhibition. ShutdownDbusOnQuit A variable controlling whether SDL calls dbus_shutdown on quit. StorageTitleDriver A variable that specifies a backend to use for title storage. StorageUsbDriver A variable that specifies a backend to use for user storage. ThreadForceRealtimeTimeCritical Specifies whether TSdlThreadPriority.TimeCritical should be treated as realtime. ThreadPriorityPolicy A string specifying additional information to use with TSdlThread.Current.Priority. TimerResolution A variable that controls the timer resolution, in milliseconds. TouchMouseEvents A variable controlling whether touch events should generate synthetic mouse events. TrackpadIsTouchOnly A variable controlling whether trackpads should be treated as touch devices. TVRemoteAsJoystick A variable controlling whether the Android / tvOS remotes should be listed as joystick devices, instead of sending keyboard events. VideoAllowScreensave A variable controlling whether the screensaver is enabled. VideoDisplayPriority A comma separated list containing the names of the displays that SDL should sort to the front of the display list. VideoDoubleBuffer Tell the video driver that we only want a double buffer. VideoDriver A variable that specifies a video backend to use. VideoDummySaveFrames A variable controlling whether the dummy video driver saves output frames. VideoEglAllowGetDisplayFallback If eglGetPlatformDisplay fails, fall back to calling eglGetDisplay. VideoForceEgl A variable controlling whether the OpenGL context should be created with EGL. VideoMacFullscreenMenuVisibility A variable that specifies the menu visibility when a window is fullscreen in Spaces on macOS. VideoMacFullscreenSpaces A variable that specifies the policy for fullscreen Spaces on macOS. VideoMinimizeOnFocusLoss A variable controlling whether fullscreen windows are minimized when they lose focus. VideoOffScreenSaveFrames A variable controlling whether the offscreen video driver saves output frames. VideoSyncWindowOperations A variable controlling whether all window operations will block until complete. VideoWaylandAllowLibDecor A variable controlling whether the libdecor Wayland backend is allowed to be used. VideoWaylandModeEmulation A variable controlling whether video mode emulation is enabled under Wayland. VideoWaylandModeScaling A variable controlling how modes with a non-native aspect ratio are displayed under Wayland. VideoWaylandPreferLibDecor A variable controlling whether the libdecor Wayland backend is preferred over native decorations. VideoWaylandScaleToDisplay A variable forcing non-DPI-aware Wayland windows to output at 1:1 scaling. VideoWinD3DCompiler A variable specifying which shader compiler to preload when using the Chrome ANGLE binaries. VideoX11NetWMBypassCompositor A variable controlling whether the X11 _NET_WM_BYPASS_COMPOSITOR hint should be used. VideoX11NetWMPing A variable controlling whether the X11 _NET_WM_PING protocol should be supported. VideoX11NoDirectColor A variable controlling whether SDL uses DirectColor visuals. VideoX11ScalingFactor A variable forcing the content scaling factor for X11 displays. VideoX11VisualID A variable forcing the visual ID used for X11 display modes. VideoX11WindowVisualID A variable forcing the visual ID chosen for new X11 windows. VideoX11XRandR A variable controlling whether the X11 XRandR extension should be used. VitaEnableBackTouch A variable controlling whether touch should be enabled on the back panel of the PlayStation Vita. VitaEnableFrontTouch A variable controlling whether touch should be enabled on the front panel of the PlayStation Vita. VitaModulePath A variable controlling the module path on the PlayStation Vita. VitaPvrInit A variable controlling whether to perform PVR initialization on the PlayStation Vita. VitaPvrOpenGL A variable controlling whether OpenGL should be used instead of OpenGL ES on the PlayStation Vita. VitaResolution A variable overriding the resolution reported on the PlayStation Vita. VitaTouchMouseDevice A variable controlling which touchpad should generate synthetic mouse events. VulkanDisplay A variable overriding the display index used in SdlVulkanCreateSurface. VulkanLibrary Specify the Vulkan library to load. WaveChunkLimit A variable controlling the maximum number of chunks in a WAVE file. WaveFactChunk A variable controlling how the fact chunk affects the loading of a WAVE file. WaveRiffChunkSize A variable controlling how the size of the RIFF chunk affects the loading of a WAVE file. WaveTruncation A variable controlling how a truncated WAVE file is handled. WindowActivateWhenRaised A variable controlling whether the window is activated when the TSdlWindow.Raise function is called. WindowActivateWhenShown A variable controlling whether the window is activated when the TSdlWindow.Show function is called. WindowAllowTopMost If set to '0' then never set the top-most flag on an SDL Window even if the application requests it. WindowCloseOnAltF4 A variable controlling whether SDL generates window-close events for Alt+F4 on Windows. WindowFrameUsableWhileCursorHidden A variable controlling whether the window frame and title bar are interactive when the cursor is hidden. WindowsEnableMenuMnemonics A variable controlling whether menus can be opened with their keyboard shortcut (Alt+mnemonic). WindowsEnableMessageLoop A variable controlling whether the windows message loop is processed by SDL. WindowsEraseBackgroundMode A variable controlling whether SDL will clear the window contents when the WM_ERASEBKGND message is received. WindowsForceSemaphoreKernel A variable controlling whether SDL uses Kernel Semaphores on Windows. WindowsGameInput A variable controlling whether GameInput is used for raw keyboard and mouse on Windows. WindowsIntResourceIcon A variable to specify custom icon resource id from RC file on Windows platform. WindowsIntResourceIconSmall A variable to specify custom icon resource id from RC file on Windows platform. WindowsRawKeyboard A variable controlling whether raw keyboard events are used on Windows. WindowsUseD3D9Ex A variable controlling whether SDL uses the D3D9Ex API introduced in Windows Vista, instead of normal D3D9. X11ForceOverrideRedirect A variable controlling whether X11 windows are marked as override-redirect. X11WindowType A variable specifying the type of an X11 window. X11XcbLibrary Specify the XCB library to load for the X11 driver. XInputEnabled A variable controlling whether XInput should be used for controller handling."},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#properties","title":"Properties","text":"Name Description Hints The hint values."},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#constructors","title":"Constructors","text":"Name Description Destroy"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#methods","title":"Methods","text":"Name Description AddCallback Add a callback to watch a particular hint. Apply(PUTF8Char, String) Set a hint with normal priority. Apply(PUTF8Char, String, TSdlHintPriority) Set a hint with a specific priority. Get Get the value of a hint. GetBoolean Get the Boolean value of a hint variable. RemoveCallback Remove a callback watching a particular hint. Reset Reset a hint to the default value. ResetAll Reset all hints to the default values."},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#constant-descriptions","title":"Constant Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AllowTabWhileGrabbed","title":"AllowTabWhileGrabbed","text":"<p>Specify the behavior of Alt+Tab while the keyboard is grabbed.</p> <p>By default, SDL emulates Alt+Tab functionality while the keyboard is grabbed and your window is full-screen. This prevents the user from getting stuck in your application if you've enabled keyboard grab.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': SDL will not handle Alt+Tab. Your application is responsible for handling Alt+Tab while the keyboard is grabbed.</li> <li>'1': SDL will minimize your window when Alt+Tab is pressed (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const AllowTabWhileGrabbed = SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AndroidAllowRecreateActivity","title":"AndroidAllowRecreateActivity","text":"<p>A variable to control whether the SDL activity is allowed to be re-created.</p> <p>If this hint is true, the activity can be recreated on demand by the OS, and Java static data and C++ static data remain with their current values. If this hint is false, then SDL will call Halt when you return from your main function and the application will be terminated and then started fresh each time.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': The application starts fresh at each launch. (default)</li> <li>'1': The application activity can be recreated by the OS.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const AndroidAllowRecreateActivity = SDL_HINT_ANDROID_ALLOW_RECREATE_ACTIVITY</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AndroidBlockOnPause","title":"AndroidBlockOnPause","text":"<p>A variable to control whether the event loop will block itself when the app is paused.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Non blocking.</li> <li>'1': Blocking. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const AndroidBlockOnPause = SDL_HINT_ANDROID_BLOCK_ON_PAUSE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AndroidLowLatencyAudio","title":"AndroidLowLatencyAudio","text":"<p>A variable to control whether low latency audio should be enabled.</p> <p>Some devices have poor quality output when this is enabled, but this is usually an improvement in audio latency.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Low latency audio is not enabled.</li> <li>'1': Low latency audio is enabled. (default)</li> </ul> <p>This hint should be set before SDL audio is initialized. </p> <p><code>const AndroidLowLatencyAudio = SDL_HINT_ANDROID_LOW_LATENCY_AUDIO</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AndroidTrapBackButton","title":"AndroidTrapBackButton","text":"<p>A variable to control whether we trap the Android back button to handle it manually.</p> <p>This is necessary for the right mouse button to work on some Android devices, or to be able to trap the back button for use in your code reliably. If this hint is true, the back button will show up as an TSdlEventKind.KeyDown / TSdlEventKind.KeyUp pair with a keycode of TSdlScancode.ACBack.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Back button will be handled as usual for system. (default)</li> <li>'1': Back button will be trapped, allowing you to handle the key press manually. (This will also let right mouse click work on systems where the right mouse button functions as back.)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const AndroidTrapBackButton = SDL_HINT_ANDROID_TRAP_BACK_BUTTON</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AppID","title":"AppID","text":"<p>A variable setting the app ID string.</p> <p>This string is used by desktop compositors to identify and group windows together, as well as match applications with associated desktop settings and icons.</p> <p>This will override TSdlProperty.AppMetaDataIdentifier, if set by the application.</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const AppID = SDL_HINT_APP_ID</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AppleTVControllerUIEvents","title":"AppleTVControllerUIEvents","text":"<p>A variable controlling whether controllers used with the Apple TV generate UI events.</p> <p>When UI events are generated by controller input, the app will be backgrounded when the Apple TV remote's menu button is pressed, and when the pause or B buttons on gamepads are pressed.</p> <p>More information about properly making use of controllers for the Apple TV can be found here:  Human Interface Guidelines.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Controller input does not generate UI events. (default)</li> <li>'1': Controller input generates UI events.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const AppleTVControllerUIEvents = SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AppleTVRemoteAllowRotation","title":"AppleTVRemoteAllowRotation","text":"<p>A variable controlling whether the Apple TV remote's joystick axes will automatically match the rotation of the remote.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Remote orientation does not affect joystick axes. (default)</li> <li>'1': Joystick axes are based on the orientation of the remote.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const AppleTVRemoteAllowRotation = SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AppName","title":"AppName","text":"<p>A variable setting the application name.</p> <p>This hint lets you specify the application name sent to the OS when required. For example, this will often appear in volume control applets for audio streams, and in lists of applications which are inhibiting the screensaver. You should use a string that describes your program ('My Game 2: The Revenge')</p> <p>This will override TSdlProperty.AppMetaDataName, if set by the application.</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const AppName = SDL_HINT_APP_NAME</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#Assert","title":"Assert","text":"<p>A variable controlling response to SdlAssert failures.</p> <p>The variable can be set to the following case-sensitive values:</p> <ul> <li>'abort': Program terminates immediately.</li> <li>'break': Program triggers a debugger breakpoint.</li> <li>'retry': Program reruns the SDL_assert's test again.</li> <li>'ignore': Program continues on, ignoring this assertion failure this time.</li> <li>'always_ignore': Program continues on, ignoring this assertion failure for the rest of the run.</li> </ul> <p>Note that SdlSetAssertionHandler offers a programmatic means to deal with assertion failures through a callback, and this hint is largely intended to be used via environment variables by end users and automated tools.</p> <p>This hint should be set before an assertion failure is triggered and can be changed at any time. </p> <p><code>const Assert = SDL_HINT_ASSERT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioAlsaDefaultDevice","title":"AudioAlsaDefaultDevice","text":"<p>Specify the default ALSA audio device name.</p> <p>This variable is a specific audio device to open when the 'default' audio device is used.</p> <p>This hint will be ignored when opening the default playback device if AudioAlsaDefaultPlaybackDevice is set, or when opening the default recording device if AudioAlsaDefaultRecordingDevice is set.</p> <p>This hint should be set before an audio device is opened. </p> <p><code>const AudioAlsaDefaultDevice = SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioAlsaDefaultPlaybackDevice","title":"AudioAlsaDefaultPlaybackDevice","text":"<p>Specify the default ALSA audio playback device name.</p> <p>This variable is a specific audio device to open for playback, when the 'default' audio device is used.</p> <p>If this hint isn't set, SDL will check AudioAlsaDefaultDevice before choosing a reasonable default.</p> <p>This hint should be set before an audio device is opened. </p> <p><code>const AudioAlsaDefaultPlaybackDevice = SDL_HINT_AUDIO_ALSA_DEFAULT_PLAYBACK_DEVICE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioAlsaDefaultRecordingDevice","title":"AudioAlsaDefaultRecordingDevice","text":"<p>Specify the default ALSA audio recording device name.</p> <p>This variable is a specific audio device to open for recording, when the 'default' audio device is used.</p> <p>If this hint isn't set, SDL will check AudioAlsaDefaultDevice before choosing a reasonable default.</p> <p>This hint should be set before an audio device is opened. </p> <p><code>const AudioAlsaDefaultRecordingDevice = SDL_HINT_AUDIO_ALSA_DEFAULT_RECORDING_DEVICE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioCategory","title":"AudioCategory","text":"<p>A variable controlling the audio category on iOS and macOS.</p> <p>The variable can be set to the following values:</p> <ul> <li>'ambient': Use the AVAudioSessionCategoryAmbient audio category, will be muted by the phone mute switch (default)</li> <li>'playback': Use the AVAudioSessionCategoryPlayback category.</li> </ul> <p>For more information, see  Apple's documentation.</p> <p>This hint should be set before an audio device is opened. </p> <p><code>const AudioCategory = SDL_HINT_AUDIO_CATEGORY</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioChannels","title":"AudioChannels","text":"<p>A variable controlling the default audio channel count.</p> <p>If the application doesn't specify the audio channel count when opening the device, this hint can be used to specify a default channel count that will be used. This defaults to '1' for recording and '2' for playback devices.</p> <p>This hint should be set before an audio device is opened. </p> <p><code>const AudioChannels = SDL_HINT_AUDIO_CHANNELS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioDeviceAppIconName","title":"AudioDeviceAppIconName","text":"<p>Specify an application icon name for an audio device.</p> <p>Some audio backends (such as Pulseaudio and Pipewire) allow you to set an XDG icon name for your application. Among other things, this icon might show up in a system control panel that lets the user adjust the volume on specific audio streams instead of using one giant master volume slider. Note that this is unrelated to the icon used by the windowing system, which may be set with SDL_SetWindowIcon (or via desktop file on Wayland).</p> <p>Setting this to '' or leaving it unset will have SDL use a reasonable default, 'applications-games', which is likely to be installed. See  Icon Theme Specificationand  Icon Naming Specificationfor the relevant XDG icon specs.</p> <p>This hint should be set before an audio device is opened. </p> <p><code>const AudioDeviceAppIconName = SDL_HINT_AUDIO_DEVICE_APP_ICON_NAME</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioDeviceSampleFrames","title":"AudioDeviceSampleFrames","text":"<p>A variable controlling device buffer size.</p> <p>This hint is an integer &gt; 0, that represents the size of the device's buffer in sample frames (stereo audio data in 16-bit format is 4 bytes per sample frame, for example).</p> <p>SDL3 generally decides this value on behalf of the app, but if for some reason the app needs to dictate this (because they want either lower latency or higher throughput AND ARE WILLING TO DEAL WITH what that might require of the app), they can specify it.</p> <p>SDL will try to accommodate this value, but there is no promise you'll get the buffer size requested. Many platforms won't honor this request at all, or might adjust it.</p> <p>This hint should be set before an audio device is opened. </p> <p><code>const AudioDeviceSampleFrames = SDL_HINT_AUDIO_DEVICE_SAMPLE_FRAMES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioDeviceStreamName","title":"AudioDeviceStreamName","text":"<p>Specify an audio stream name for an audio device.</p> <p>Some audio backends (such as PulseAudio) allow you to describe your audio stream. Among other things, this description might show up in a system control panel that lets the user adjust the volume on specific audio streams instead of using one giant master volume slider.</p> <p>This hints lets you transmit that information to the OS. The contents of this hint are used while opening an audio device. You should use a string that describes your what your program is playing ('audio stream' is probably sufficient in many cases, but this could be useful for something like 'team chat' if you have a headset playing VoIP audio separately).</p> <p>Setting this to '' or leaving it unset will have SDL use a reasonable default: 'audio stream' or something similar.</p> <p>Note that while this talks about audio streams, this is an OS-level concept, so it applies to a physical audio device in this case, and not an TSdlAudioStream, nor an SDL logical audio device.</p> <p>This hint should be set before an audio device is opened. </p> <p><code>const AudioDeviceStreamName = SDL_HINT_AUDIO_DEVICE_STREAM_NAME</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioDeviceStreamRole","title":"AudioDeviceStreamRole","text":"<p>Specify an application role for an audio device.</p> <p>Some audio backends (such as Pipewire) allow you to describe the role of your audio stream. Among other things, this description might show up in a system control panel or software for displaying and manipulating media playback/recording graphs.</p> <p>This hints lets you transmit that information to the OS. The contents of this hint are used while opening an audio device. You should use a string that describes your what your program is playing (Game, Music, Movie, etc...).</p> <p>Setting this to '' or leaving it unset will have SDL use a reasonable default: 'Game' or something similar.</p> <p>Note that while this talks about audio streams, this is an OS-level concept, so it applies to a physical audio device in this case, and not an TSdlAudioStream, nor an SDL logical audio device.</p> <p>This hint should be set before an audio device is opened. </p> <p><code>const AudioDeviceStreamRole = SDL_HINT_AUDIO_DEVICE_STREAM_ROLE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioDiskInputFile","title":"AudioDiskInputFile","text":"<p>Specify the input file when recording audio using the disk audio driver.</p> <p>This defaults to 'sdlaudio-in.raw'</p> <p>This hint should be set before an audio device is opened. </p> <p><code>const AudioDiskInputFile = SDL_HINT_AUDIO_DISK_INPUT_FILE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioDiskOutputFile","title":"AudioDiskOutputFile","text":"<p>Specify the output file when playing audio using the disk audio driver.</p> <p>This defaults to 'sdlaudio.raw'</p> <p>This hint should be set before an audio device is opened. </p> <p><code>const AudioDiskOutputFile = SDL_HINT_AUDIO_DISK_OUTPUT_FILE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioDiskTimescale","title":"AudioDiskTimescale","text":"<p>A variable controlling the audio rate when using the disk audio driver.</p> <p>The disk audio driver normally simulates real-time for the audio rate that was specified, but you can use this variable to adjust this rate higher or lower down to 0. The default value is '1.0'.</p> <p>This hint should be set before an audio device is opened. </p> <p><code>const AudioDiskTimescale = SDL_HINT_AUDIO_DISK_TIMESCALE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioDriver","title":"AudioDriver","text":"<p>A variable that specifies an audio backend to use.</p> <p>By default, SDL will try all available audio backends in a reasonable order until it finds one that can work, but this hint allows the app or user to force a specific driver, such as 'pipewire' if, say, you are on PulseAudio but want to try talking to the lower level instead.</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const AudioDriver = SDL_HINT_AUDIO_DRIVER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioDummyTimescale","title":"AudioDummyTimescale","text":"<p>A variable controlling the audio rate when using the dummy audio driver.</p> <p>The dummy audio driver normally simulates real-time for the audio rate that was specified, but you can use this variable to adjust this rate higher or lower down to 0. The default value is '1.0'.</p> <p>This hint should be set before an audio device is opened. </p> <p><code>const AudioDummyTimescale = SDL_HINT_AUDIO_DUMMY_TIMESCALE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioFormat","title":"AudioFormat","text":"<p>A variable controlling the default audio format.</p> <p>If the application doesn't specify the audio format when opening the device, this hint can be used to specify a default format that will be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'U8': Unsigned 8-bit audio</li> <li>'S8': Signed 8-bit audio</li> <li>'S16LE': Signed 16-bit little-endian audio</li> <li>'S16BE': Signed 16-bit big-endian audio</li> <li>'S16': Signed 16-bit native-endian audio (default)</li> <li>'S32LE': Signed 32-bit little-endian audio</li> <li>'S32BE': Signed 32-bit big-endian audio</li> <li>'S32': Signed 32-bit native-endian audio</li> <li>'F32LE': Floating point little-endian audio</li> <li>'F32BE': Floating point big-endian audio</li> <li>'F32': Floating point native-endian audio</li> </ul> <p>This hint should be set before an audio device is opened. </p> <p><code>const AudioFormat = SDL_HINT_AUDIO_FORMAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioFrequency","title":"AudioFrequency","text":"<p>A variable controlling the default audio frequency.</p> <p>If the application doesn't specify the audio frequency when opening the device, this hint can be used to specify a default frequency that will be used. This defaults to '44100'.</p> <p>This hint should be set before an audio device is opened. </p> <p><code>const AudioFrequency = SDL_HINT_AUDIO_FREQUENCY</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AudioIncludeMonitors","title":"AudioIncludeMonitors","text":"<p>A variable that causes SDL to not ignore audio 'monitors'.</p> <p>This is currently only used by the PulseAudio driver.</p> <p>By default, SDL ignores audio devices that aren't associated with physical hardware. Changing this hint to '1' will expose anything SDL sees that appears to be an audio source or sink. This will add 'devices' to the list that the user probably doesn't want or need, but it can be useful in scenarios where you want to hook up SDL to some sort of virtual device, etc.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Audio monitor devices will be ignored. (default)</li> <li>'1': Audio monitor devices will show up in the device list.</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const AudioIncludeMonitors = SDL_HINT_AUDIO_INCLUDE_MONITORS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AutoUpdateJoysticks","title":"AutoUpdateJoysticks","text":"<p>A variable controlling whether SDL updates joystick state when getting input events.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': You'll call TSdlJoystick.Update manually.</li> <li>'1': SDL will automatically call TSdlJoystick.Update. (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const AutoUpdateJoysticks = SDL_HINT_AUTO_UPDATE_JOYSTICKS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AutoUpdateSensors","title":"AutoUpdateSensors","text":"<p>A variable controlling whether SDL updates sensor state when getting input events.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': You'll call TSdlSensor.Update manually.</li> <li>'1': SDL will automatically call TSdlSensor.Update. (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const AutoUpdateSensors = SDL_HINT_AUTO_UPDATE_SENSORS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#BmpSaveLegacyFormat","title":"BmpSaveLegacyFormat","text":"<p>Prevent SDL from using version 4 of the bitmap header when saving BMPs.</p> <p>The bitmap header version 4 is required for proper alpha channel support and SDL will use it when required. Should this not be desired, this hint can force the use of the 40 byte header version which is supported everywhere.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Surfaces with a colorkey or an alpha channel are saved to a 32-bit BMP file with an alpha mask. SDL will use the bitmap header version 4 and set the alpha mask accordingly. (default)</li> <li>'1': Surfaces with a colorkey or an alpha channel are saved to a 32-bit BMP file without an alpha mask. The alpha channel data will be in the file, but applications are going to ignore it.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const BmpSaveLegacyFormat = SDL_HINT_BMP_SAVE_LEGACY_FORMAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#CameraDriver","title":"CameraDriver","text":"<p>A variable that decides what camera backend to use.</p> <p>By default, SDL will try all available camera backends in a reasonable order until it finds one that can work, but this hint allows the app or user to force a specific target, such as 'directshow' if, say, you are on Windows Media Foundations but want to try DirectShow instead.</p> <p>The default value is unset, in which case SDL will try to figure out the best camera backend on your behalf. This hint needs to be set before SdlInit is called to be useful. </p> <p><code>const CameraDriver = SDL_HINT_CAMERA_DRIVER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#CpuFeatureMask","title":"CpuFeatureMask","text":"<p>A variable that limits what CPU features are available.</p> <p>By default, SDL marks all features the current CPU supports as available. This hint allows to limit these to a subset.</p> <p>When the hint is unset, or empty, SDL will enable all detected CPU features.</p> <p>The variable can be set to a comma separated list containing the following items:</p> <ul> <li>'all'</li> <li>'altivec'</li> <li>'sse'</li> <li>'sse2'</li> <li>'sse3'</li> <li>'sse41'</li> <li>'sse42'</li> <li>'avx'</li> <li>'avx2'</li> <li>'avx512f'</li> <li>'arm-simd'</li> <li>'neon'</li> <li>'lsx'</li> <li>'lasx'</li> </ul> <p>The items can be prefixed by '+'/'-' to add/remove features. </p> <p><code>const CpuFeatureMask = SDL_HINT_CPU_FEATURE_MASK</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#DisplayUsableBounds","title":"DisplayUsableBounds","text":"<p>Override for TSdlDisplay.UsableBounds.</p> <p>If set, this hint will override the expected results for TSdlDisplay.UsableBounds for display index 0. Generally you don't want to do this, but this allows an embedded system to request that some of the screen be reserved for other uses when paired with a well-behaved application.</p> <p>The contents of this hint must be 4 comma-separated integers, the first is the bounds x, then y, width and height, in that order.</p> <p>This hint can be set anytime. </p> <p><code>const DisplayUsableBounds = SDL_HINT_DISPLAY_USABLE_BOUNDS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#EglLibrary","title":"EglLibrary","text":"<p>Specify the EGL library to load.</p> <p>This hint should be set before creating an OpenGL window or creating an OpenGL context. This hint is only considered if SDL is using EGL to manage OpenGL contexts. If this hint isn't set, SDL will choose a reasonable default. </p> <p><code>const EglLibrary = SDL_HINT_EGL_LIBRARY</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#EnableScreenKeyboard","title":"EnableScreenKeyboard","text":"<p>A variable that controls whether the on-screen keyboard should be shown when text input is active.</p> <p>The variable can be set to the following values:</p> <ul> <li>'auto': The on-screen keyboard will be shown if there is no physical keyboard attached. (default)</li> <li>'0': Do not show the on-screen keyboard.</li> <li>'1': Show the on-screen keyboard, if available.</li> </ul> <p>This hint must be set before TSdlWindow.StartTextInput is called </p> <p><code>const EnableScreenKeyboard = SDL_HINT_ENABLE_SCREEN_KEYBOARD</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#EVDevDevices","title":"EVDevDevices","text":"<p>A variable containing a list of evdev devices to use if udev is not available.</p> <p>The list of devices is in the form:</p> <p>deviceclass:path[,deviceclass:path[,...]]</p> <p>where device class is an integer representing the SDL_UDEV_deviceclass and path is the full path to the event device.</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const EVDevDevices = SDL_HINT_EVDEV_DEVICES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#EventLogging","title":"EventLogging","text":"<p>A variable controlling verbosity of the logging of SDL events pushed onto the internal queue.</p> <p>The variable can be set to the following values, from least to most verbose:</p> <ul> <li>'0': Don't log any events. (default)</li> <li>'1': Log most events (other than the really spammy ones).</li> <li>'2': Include mouse and finger motion events.</li> </ul> <p>This is generally meant to be used to debug SDL itself, but can be useful for application developers that need better visibility into what is going on in the event queue. Logged events are sent through SdlLog, which means by default they appear on stdout on most platforms or maybe OutputDebugString on Windows, and can be funneled by the app with SdlSetLogOutputFunction, etc.</p> <p>This hint can be set anytime. </p> <p><code>const EventLogging = SDL_HINT_EVENT_LOGGING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#FileDialogDriver","title":"FileDialogDriver","text":"<p>A variable that specifies a dialog backend to use.</p> <p>By default, SDL will try all available dialog backends in a reasonable order until it finds one that can work, but this hint allows the app or user to force a specific target.</p> <p>If the specified target does not exist or is not available, the dialog-related function calls will fail.</p> <p>This hint currently only applies to platforms using the generic 'Unix' dialog implementation, but may be extended to more platforms in the future. Note that some Unix and Unix-like platforms have their own implementation, such as macOS and Haiku.</p> <p>The variable can be set to the following values:</p> <ul> <li>nil: Select automatically (default, all platforms)</li> <li>'portal': Use XDG Portals through DBus (Unix only)</li> <li>'zenity': Use the Zenity program (Unix only)</li> </ul> <p>More options may be added in the future.</p> <p>This hint can be set anytime. </p> <p><code>const FileDialogDriver = SDL_HINT_FILE_DIALOG_DRIVER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#ForceRaiseWindow","title":"ForceRaiseWindow","text":"<p>A variable controlling whether raising the window should be done more forcefully.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Honor the OS policy for raising windows. (default)</li> <li>'1': Force the window to be raised, overriding any OS policy.</li> </ul> <p>At present, this is only an issue under MS Windows, which makes it nearly impossible to programmatically move a window to the foreground, for 'security' reasons. See  Stack Overflowfor a discussion.</p> <p>This hint can be set anytime. </p> <p><code>const ForceRaiseWindow = SDL_HINT_FORCE_RAISEWINDOW</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#FramebufferAcceleration","title":"FramebufferAcceleration","text":"<p>A variable controlling how 3D acceleration is used to accelerate the SDL screen surface.</p> <p>SDL can try to accelerate the SDL screen surface by using streaming textures with a 3D rendering engine. This variable controls whether and how this is done.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Disable 3D acceleration</li> <li>'1': Enable 3D acceleration, using the default renderer. (default)</li> <li>'X': Enable 3D acceleration, using X where X is one of the valid rendering drivers. (e.g. 'direct3d', 'opengl', etc.)</li> </ul> <p>This hint should be set before calling SDL_GetWindowSurface() </p> <p><code>const FramebufferAcceleration = SDL_HINT_FRAMEBUFFER_ACCELERATION</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#GameControllerConfig","title":"GameControllerConfig","text":"<p>A variable that lets you manually hint extra gamecontroller db entries.</p> <p>The variable should be newline delimited rows of gamecontroller config data, see SDL_gamepad.h</p> <p>You can update mappings after SDL is initialized with TSdlGamepad.MappingForGuid and TSdlGamepad.AddMapping.</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const GameControllerConfig = SDL_HINT_GAMECONTROLLERCONFIG</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#GameControllerConfigFile","title":"GameControllerConfigFile","text":"<p>A variable that lets you provide a file with extra gamecontroller db entries.</p> <p>The file should contain lines of gamecontroller config data, see SDL_gamepad.h</p> <p>You can update mappings after SDL is initialized with TSdlGamepad.MappingForGuid and TSdlGamepad.AddMapping.</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const GameControllerConfigFile = SDL_HINT_GAMECONTROLLERCONFIG_FILE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#GameControllerIgnoreDevices","title":"GameControllerIgnoreDevices","text":"<p>A variable containing a list of devices to skip when scanning for game controllers.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p>0xAAAA/0xBBBB,0xCCCC/0xDDDD</p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint can be set anytime. </p> <p><code>const GameControllerIgnoreDevices = SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#GameControllerIgnoreDevicesExcept","title":"GameControllerIgnoreDevicesExcept","text":"<p>If set, all devices will be skipped when scanning for game controllers except for the ones listed in this variable.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p>0xAAAA/0xBBBB,0xCCCC/0xDDDD</p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint can be set anytime. </p> <p><code>const GameControllerIgnoreDevicesExcept = SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#GameControllerSensorFusion","title":"GameControllerSensorFusion","text":"<p>A variable that controls whether the device's built-in accelerometer and gyro should be used as sensors for gamepads.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Sensor fusion is disabled</li> <li>'1': Sensor fusion is enabled for all controllers that lack sensors</li> </ul> <p>Or the variable can be a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p>0xAAAA/0xBBBB,0xCCCC/0xDDDD</p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint should be set before a gamepad is opened. </p> <p><code>const GameControllerSensorFusion = SDL_HINT_GAMECONTROLLER_SENSOR_FUSION</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#GameControllerType","title":"GameControllerType","text":"<p>A variable that overrides the automatic controller type detection.</p> <p>The variable should be comma separated entries, in the form: VID/PID=type</p> <p>The VID and PID should be hexadecimal with exactly 4 digits, e.g. 0x00fd</p> <p>This hint affects what low level protocol is used with the HIDAPI driver.</p> <p>The variable can be set to the following values:</p> <ul> <li>'Xbox360'</li> <li>'XboxOne'</li> <li>'PS3'</li> <li>'PS4'</li> <li>'PS5'</li> <li>'SwitchPro'</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const GameControllerType = SDL_HINT_GAMECONTROLLERTYPE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#GpuDriver","title":"GpuDriver","text":"<p>A variable that specifies a GPU backend to use.</p> <p>By default, SDL will try all available GPU backends in a reasonable order until it finds one that can work, but this hint allows the app or user to force a specific target, such as 'direct3d11' if, say, your hardware supports D3D12 but want to try using D3D11 instead.</p> <p>This hint should be set before any GPU functions are called. </p> <p><code>const GpuDriver = SDL_HINT_GPU_DRIVER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#HidApiEnumerateOnlyControllers","title":"HidApiEnumerateOnlyControllers","text":"<p>A variable to control whether TSdlHid.Enumerate enumerates all HID devices or only controllers.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': TSdlHid.Enumerate will enumerate all HID devices.</li> <li>'1': TSdlHid.Enumerate will only enumerate controllers. (default)</li> </ul> <p>By default SDL will only enumerate controllers, to reduce risk of hanging or crashing on devices with bad drivers and avoiding macOS keyboard capture permission prompts.</p> <p>This hint can be set anytime. </p> <p><code>const HidApiEnumerateOnlyControllers = SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#HidApiIgnoreDevices","title":"HidApiIgnoreDevices","text":"<p>A variable containing a list of devices to ignore in TSdlHid.Enumerate.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p><code>0xAAAA/0xBBBB,0xCCCC/0xDDDD</code></p> <p>For example, to ignore the Shanwan DS3 controller and any Valve controller, you might use the string '0x2563/0x0523,0x28de/0x0000'</p> <p>This hint can be set anytime. </p> <p><code>const HidApiIgnoreDevices = SDL_HINT_HIDAPI_IGNORE_DEVICES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#HidApiLibUDev","title":"HidApiLibUDev","text":"<p>A variable to control whether HIDAPI uses udev for device detection.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI will poll for device changes.</li> <li>'1': HIDAPI will use udev for device detection. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const HidApiLibUDev = SDL_HINT_HIDAPI_UDEV</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#HidApiLibUsb","title":"HidApiLibUsb","text":"<p>A variable to control whether HIDAPI uses libusb for device access.</p> <p>By default libusb will only be used for a few devices that require direct USB access, and this can be controlled with HidApiLibUsbWhiteList.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI will not use libusb for device access.</li> <li>'1': HIDAPI will use libusb for device access if available. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const HidApiLibUsb = SDL_HINT_HIDAPI_LIBUSB</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#HidApiLibUsbWhiteList","title":"HidApiLibUsbWhiteList","text":"<p>A variable to control whether HIDAPI uses libusb only for whitelisted devices.</p> <p>By default libusb will only be used for a few devices that require direct USB access.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI will use libusb for all device access.</li> <li>'1': HIDAPI will use libusb only for whitelisted devices. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const HidApiLibUsbWhiteList = SDL_HINT_HIDAPI_LIBUSB_WHITELIST</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#ImeImplementedUI","title":"ImeImplementedUI","text":"<p>A variable describing what IME UI elements the application can display.</p> <p>By default IME UI is handled using native components by the OS where possible, however this can interfere with or not be visible when exclusive fullscreen mode is used.</p> <p>The variable can be set to a comma separated list containing the following items:</p> <ul> <li>'none' or '0': The application can't render any IME elements, and native UI should be used. (default)</li> <li>'composition': The application handles TSdlEventKind.TextEditing events and can render the composition text.</li> <li>'candidates': The application handles TSdlEventKind.TextEditingCandidates and can render the candidate list.</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const ImeImplementedUI = SDL_HINT_IME_IMPLEMENTED_UI</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#IosHideHomeIndicator","title":"IosHideHomeIndicator","text":"<p>A variable controlling whether the home indicator bar on iPhone X should be hidden.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': The indicator bar is not hidden. (default for windowed applications)</li> <li>'1': The indicator bar is hidden and is shown when the screen is touched (useful for movie playback applications).</li> <li>'2': The indicator bar is dim and the first swipe makes it visible and the second swipe performs the 'home' action. (default for fullscreen applications)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const IosHideHomeIndicator = SDL_HINT_IOS_HIDE_HOME_INDICATOR</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickAllowBackgroundEvents","title":"JoystickAllowBackgroundEvents","text":"<p>A variable that lets you enable joystick (and gamecontroller) events even when your app is in the background.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Disable joystick &amp; gamecontroller input events when the application is in the background. (default)</li> <li>'1': Enable joystick &amp; gamecontroller input events when the application is in the background.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const JoystickAllowBackgroundEvents = SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickArcadestickDevices","title":"JoystickArcadestickDevices","text":"<p>A variable containing a list of arcade stick style controllers.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p><code>0xAAAA/0xBBBB,0xCCCC/0xDDDD</code></p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint can be set anytime. </p> <p><code>const JoystickArcadestickDevices = SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickArcadestickDevicesExcluded","title":"JoystickArcadestickDevicesExcluded","text":"<p>A variable containing a list of devices that are not arcade stick style controllers.</p> <p>This will override JoystickArcadestickDevices and the built in device list.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p><code>0xAAAA/0xBBBB,0xCCCC/0xDDDD</code></p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint can be set anytime. </p> <p><code>const JoystickArcadestickDevicesExcluded = SDL_HINT_JOYSTICK_ARCADESTICK_DEVICES_EXCLUDED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickBlacklistDevices","title":"JoystickBlacklistDevices","text":"<p>A variable containing a list of devices that should not be considered joysticks.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p><code>0xAAAA/0xBBBB,0xCCCC/0xDDDD</code></p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint can be set anytime. </p> <p><code>const JoystickBlacklistDevices = SDL_HINT_JOYSTICK_BLACKLIST_DEVICES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickBlacklistDevicesExcluded","title":"JoystickBlacklistDevicesExcluded","text":"<p>A variable containing a list of devices that should be considered joysticks.</p> <p>This will override JoystickBlacklistDevices and the built in device list.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p><code>0xAAAA/0xBBBB,0xCCCC/0xDDDD</code></p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint can be set anytime. </p> <p><code>const JoystickBlacklistDevicesExcluded = SDL_HINT_JOYSTICK_BLACKLIST_DEVICES_EXCLUDED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickDevice","title":"JoystickDevice","text":"<p>A variable containing a comma separated list of devices to open as joysticks.</p> <p>This variable is currently only used by the Linux joystick driver. </p> <p><code>const JoystickDevice = SDL_HINT_JOYSTICK_DEVICE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickDirectInput","title":"JoystickDirectInput","text":"<p>A variable controlling whether DirectInput should be used for controllers.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Disable DirectInput detection.</li> <li>'1': Enable DirectInput detection. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const JoystickDirectInput = SDL_HINT_JOYSTICK_DIRECTINPUT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickEnhancedReports","title":"JoystickEnhancedReports","text":"<p>A variable controlling whether enhanced reports should be used for controllers when using the HIDAPI driver.</p> <p>Enhanced reports allow rumble and effects on Bluetooth PlayStation controllers and gyro on Nintendo Switch controllers, but break Windows DirectInput for other applications that don't use SDL.</p> <p>Once enhanced reports are enabled, they can't be disabled on PlayStation controllers without power cycling the controller.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': enhanced reports are not enabled.</li> <li>'1': enhanced reports are enabled. (default)</li> <li>'auto': enhanced features are advertised to the application, but SDL doesn't change the controller report mode unless the application uses them.</li> </ul> <p>This hint can be enabled anytime. </p> <p><code>const JoystickEnhancedReports = SDL_HINT_JOYSTICK_ENHANCED_REPORTS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickFlightstickDevices","title":"JoystickFlightstickDevices","text":"<p>A variable containing a list of flightstick style controllers.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p><code>0xAAAA/0xBBBB,0xCCCC/0xDDDD</code></p> <p>The variable can also take the form of @file, in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint can be set anytime. </p> <p><code>const JoystickFlightstickDevices = SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickFlightstickDevicesExcluded","title":"JoystickFlightstickDevicesExcluded","text":"<p>A variable containing a list of devices that are not flightstick style controllers.</p> <p>This will override JoystickFlightstickDevices and the built in device list.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p><code>0xAAAA/0xBBBB,0xCCCC/0xDDDD</code></p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint can be set anytime. </p> <p><code>const JoystickFlightstickDevicesExcluded = SDL_HINT_JOYSTICK_FLIGHTSTICK_DEVICES_EXCLUDED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickGameCubeDevices","title":"JoystickGameCubeDevices","text":"<p>A variable containing a list of devices known to have a GameCube form factor.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p><code>0xAAAA/0xBBBB,0xCCCC/0xDDDD</code></p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint can be set anytime. </p> <p><code>const JoystickGameCubeDevices = SDL_HINT_JOYSTICK_GAMECUBE_DEVICES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickGameCubeDevicesExcluded","title":"JoystickGameCubeDevicesExcluded","text":"<p>A variable containing a list of devices known not to have a GameCube form factor.</p> <p>This will override JoystickGameCubeDevices and the built in device list.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p><code>0xAAAA/0xBBBB,0xCCCC/0xDDDD</code></p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint can be set anytime. </p> <p><code>const JoystickGameCubeDevicesExcluded = SDL_HINT_JOYSTICK_GAMECUBE_DEVICES_EXCLUDED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickGameInput","title":"JoystickGameInput","text":"<p>A variable controlling whether GameInput should be used for controller handling on Windows.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': GameInput is not used.</li> <li>'1': GameInput is used.</li> </ul> <p>The default is '1' on GDK platforms, and '0' otherwise.</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const JoystickGameInput = SDL_HINT_JOYSTICK_GAMEINPUT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApi","title":"JoystickHidApi","text":"<p>A variable controlling whether the HIDAPI joystick drivers should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI drivers are not used.</li> <li>'1': HIDAPI drivers are used. (default)</li> </ul> <p>This variable is the default for all drivers, but can be overridden by the hints for specific drivers below.</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApi = SDL_HINT_JOYSTICK_HIDAPI</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiCombineJoyCons","title":"JoystickHidApiCombineJoyCons","text":"<p>A variable controlling whether Nintendo Switch Joy-Con controllers will be combined into a single Pro-like controller when using the HIDAPI driver.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Left and right Joy-Con controllers will not be combined and each will be a mini-gamepad.</li> <li>'1': Left and right Joy-Con controllers will be combined into a single controller. (default)</li> </ul> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiCombineJoyCons = SDL_HINT_JOYSTICK_HIDAPI_COMBINE_JOY_CONS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiGameCube","title":"JoystickHidApiGameCube","text":"<p>A variable controlling whether the HIDAPI driver for Nintendo GameCube controllers should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used.</li> <li>'1': HIDAPI driver is used.</li> </ul> <p>The default is the value of JoystickHidApi.</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiGameCube = SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiGameCubeRumbleBrake","title":"JoystickHidApiGameCubeRumbleBrake","text":"<p>A variable controlling whether rumble is used to implement the GameCube controller's 3 rumble modes, Stop(0), Rumble(1), and StopHard(2).</p> <p>This is useful for applications that need full compatibility for things like ADSR envelopes. - Stop is implemented by setting low_frequency_rumble to 0 and high_frequency_rumble &gt;0 - Rumble is both at any arbitrary value - StopHard is implemented by setting both low_frequency_rumble and high_frequency_rumble to 0</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Normal rumble behavior is behavior is used. (default)</li> <li>'1': Proper GameCube controller rumble behavior is used.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const JoystickHidApiGameCubeRumbleBrake = SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE_RUMBLE_BRAKE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiJoyConHomeLed","title":"JoystickHidApiJoyConHomeLed","text":"<p>A variable controlling whether the Home button LED should be turned on when a Nintendo Switch Joy-Con controller is opened.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': home button LED is turned off</li> <li>'1': home button LED is turned on</li> </ul> <p>By default the Home button LED state is not changed. This hint can also be set to a floating point value between 0.0 and 1.0 which controls the brightness of the Home button LED.</p> <p>This hint can be set anytime. </p> <p><code>const JoystickHidApiJoyConHomeLed = SDL_HINT_JOYSTICK_HIDAPI_JOYCON_HOME_LED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiJoyCons","title":"JoystickHidApiJoyCons","text":"<p>A variable controlling whether the HIDAPI driver for Nintendo Switch Joy-Cons should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used.</li> <li>'1': HIDAPI driver is used.</li> </ul> <p>The default is the value of JoystickHidApi.</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiJoyCons = SDL_HINT_JOYSTICK_HIDAPI_JOY_CONS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiLuna","title":"JoystickHidApiLuna","text":"<p>A variable controlling whether the HIDAPI driver for Amazon Luna controllers connected via Bluetooth should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used.</li> <li>'1': HIDAPI driver is used.</li> </ul> <p>The default is the value of JoystickHidApi.</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiLuna = SDL_HINT_JOYSTICK_HIDAPI_LUNA</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiNintendoClassic","title":"JoystickHidApiNintendoClassic","text":"<p>A variable controlling whether the HIDAPI driver for Nintendo Online classic controllers should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used.</li> <li>'1': HIDAPI driver is used.</li> </ul> <p>The default is the value of JoystickHidApi.</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiNintendoClassic = SDL_HINT_JOYSTICK_HIDAPI_NINTENDO_CLASSIC</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiPS3","title":"JoystickHidApiPS3","text":"<p>A variable controlling whether the HIDAPI driver for PS3 controllers should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used.</li> <li>'1': HIDAPI driver is used.</li> </ul> <p>The default is the value of JoystickHidApi on macOS, and '0' on other platforms.</p> <p>For official Sony driver (sixaxis.sys) use JoystickHidApiPS3SixAxisDriver. See  DsHidMinifor an alternative driver on Windows.</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiPS3 = SDL_HINT_JOYSTICK_HIDAPI_PS3</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiPS3SixAxisDriver","title":"JoystickHidApiPS3SixAxisDriver","text":"<p>A variable controlling whether the Sony driver (sixaxis.sys) for PS3 controllers (Sixaxis/DualShock 3) should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Sony driver (sixaxis.sys) is not used.</li> <li>'1': Sony driver (sixaxis.sys) is used.</li> </ul> <p>The default value is 0.</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiPS3SixAxisDriver = SDL_HINT_JOYSTICK_HIDAPI_PS3_SIXAXIS_DRIVER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiPS4","title":"JoystickHidApiPS4","text":"<p>A variable controlling whether the HIDAPI driver for PS4 controllers should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used.</li> <li>'1': HIDAPI driver is used.</li> </ul> <p>The default is the value of JoystickHidApi.</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiPS4 = SDL_HINT_JOYSTICK_HIDAPI_PS4</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiPS4ReportInterval","title":"JoystickHidApiPS4ReportInterval","text":"<p>A variable controlling the update rate of the PS4 controller over Bluetooth when using the HIDAPI driver.</p> <p>This defaults to 4 ms, to match the behavior over USB, and to be more friendly to other Bluetooth devices and older Bluetooth hardware on the computer. It can be set to '1' (1000Hz), '2' (500Hz) and '4' (250Hz)</p> <p>This hint can be set anytime, but only takes effect when extended input reports are enabled. </p> <p><code>const JoystickHidApiPS4ReportInterval = SDL_HINT_JOYSTICK_HIDAPI_PS4_REPORT_INTERVAL</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiPS5","title":"JoystickHidApiPS5","text":"<p>A variable controlling whether the HIDAPI driver for PS5 controllers should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used.</li> <li>'1': HIDAPI driver is used.</li> </ul> <p>The default is the value of JoystickHidApi.</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiPS5 = SDL_HINT_JOYSTICK_HIDAPI_PS5</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiPS5PlayerLed","title":"JoystickHidApiPS5PlayerLed","text":"<p>A variable controlling whether the player LEDs should be lit to indicate which player is associated with a PS5 controller.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': player LEDs are not enabled.</li> <li>'1': player LEDs are enabled. (default) </li> </ul> <p><code>const JoystickHidApiPS5PlayerLed = SDL_HINT_JOYSTICK_HIDAPI_PS5_PLAYER_LED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiShield","title":"JoystickHidApiShield","text":"<p>A variable controlling whether the HIDAPI driver for NVIDIA SHIELD controllers should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used.</li> <li>'1': HIDAPI driver is used.</li> </ul> <p>The default is the value of JoystickHidApi.</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiShield = SDL_HINT_JOYSTICK_HIDAPI_SHIELD</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiStadia","title":"JoystickHidApiStadia","text":"<p>A variable controlling whether the HIDAPI driver for Google Stadia controllers should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used.</li> <li>'1': HIDAPI driver is used.</li> </ul> <p>The default is the value of JoystickHidApi. </p> <p><code>const JoystickHidApiStadia = SDL_HINT_JOYSTICK_HIDAPI_STADIA</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiSteam","title":"JoystickHidApiSteam","text":"<p>A variable controlling whether the HIDAPI driver for Bluetooth Steam Controllers should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used. (default)</li> <li>'1': HIDAPI driver is used for Steam Controllers, which requires Bluetooth access and may prompt the user for permission on iOS and Android.</li> </ul> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiSteam = SDL_HINT_JOYSTICK_HIDAPI_STEAM</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiSteamDeck","title":"JoystickHidApiSteamDeck","text":"<p>A variable controlling whether the HIDAPI driver for the Steam Deck builtin controller should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used.</li> <li>'1': HIDAPI driver is used.</li> </ul> <p>The default is the value of JoystickHidApi.</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiSteamDeck = SDL_HINT_JOYSTICK_HIDAPI_STEAMDECK</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiSteamHomeLed","title":"JoystickHidApiSteamHomeLed","text":"<p>A variable controlling whether the Steam button LED should be turned on when a Steam controller is opened.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Steam button LED is turned off.</li> <li>'1': Steam button LED is turned on.</li> </ul> <p>By default the Steam button LED state is not changed. This hint can also be set to a floating point value between 0.0 and 1.0 which controls the brightness of the Steam button LED.</p> <p>This hint can be set anytime. </p> <p><code>const JoystickHidApiSteamHomeLed = SDL_HINT_JOYSTICK_HIDAPI_STEAM_HOME_LED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiSteamHori","title":"JoystickHidApiSteamHori","text":"<p>A variable controlling whether the HIDAPI driver for HORI licensed Steam controllers should be used.</p> <p>This variable can be set to the following values: '0' - HIDAPI driver is not used '1' - HIDAPI driver is used</p> <p>The default is the value of JoystickHidApi. </p> <p><code>const JoystickHidApiSteamHori = SDL_JOYSTICK_HIDAPI_STEAM_HORI</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiSwitch","title":"JoystickHidApiSwitch","text":"<p>A variable controlling whether the HIDAPI driver for Nintendo Switch controllers should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used.</li> <li>'1': HIDAPI driver is used.</li> </ul> <p>The default is the value of JoystickHidApi.</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiSwitch = SDL_HINT_JOYSTICK_HIDAPI_SWITCH</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiSwitchHomeLed","title":"JoystickHidApiSwitchHomeLed","text":"<p>A variable controlling whether the Home button LED should be turned on when a Nintendo Switch Pro controller is opened.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Home button LED is turned off.</li> <li>'1': Home button LED is turned on.</li> </ul> <p>By default the Home button LED state is not changed. This hint can also be set to a floating point value between 0.0 and 1.0 which controls the brightness of the Home button LED.</p> <p>This hint can be set anytime. </p> <p><code>const JoystickHidApiSwitchHomeLed = SDL_HINT_JOYSTICK_HIDAPI_SWITCH_HOME_LED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiSwitchPlayerLed","title":"JoystickHidApiSwitchPlayerLed","text":"<p>A variable controlling whether the player LEDs should be lit to indicate which player is associated with a Nintendo Switch controller.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Player LEDs are not enabled.</li> <li>'1': Player LEDs are enabled. (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const JoystickHidApiSwitchPlayerLed = SDL_HINT_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiVerticalJoyCons","title":"JoystickHidApiVerticalJoyCons","text":"<p>A variable controlling whether Nintendo Switch Joy-Con controllers will be in vertical mode when using the HIDAPI driver.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Left and right Joy-Con controllers will not be in vertical mode. (default)</li> <li>'1': Left and right Joy-Con controllers will be in vertical mode.</li> </ul> <p>This hint should be set before opening a Joy-Con controller. </p> <p><code>const JoystickHidApiVerticalJoyCons = SDL_HINT_JOYSTICK_HIDAPI_VERTICAL_JOY_CONS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiWii","title":"JoystickHidApiWii","text":"<p>A variable controlling whether the HIDAPI driver for Nintendo Wii and Wii U controllers should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used.</li> <li>'1': HIDAPI driver is used.</li> </ul> <p>This driver doesn't work with the dolphinbar, so the default is false for now.</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiWii = SDL_HINT_JOYSTICK_HIDAPI_WII</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiWiiPlayerLed","title":"JoystickHidApiWiiPlayerLed","text":"<p>A variable controlling whether the player LEDs should be lit to indicate which player is associated with a Wii controller.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Player LEDs are not enabled.</li> <li>'1': Player LEDs are enabled. (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const JoystickHidApiWiiPlayerLed = SDL_HINT_JOYSTICK_HIDAPI_WII_PLAYER_LED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiXbox","title":"JoystickHidApiXbox","text":"<p>A variable controlling whether the HIDAPI driver for XBox controllers should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used.</li> <li>'1': HIDAPI driver is used.</li> </ul> <p>The default is '0' on Windows, otherwise the value of JoystickHidApi</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiXbox = SDL_HINT_JOYSTICK_HIDAPI_XBOX</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiXbox360","title":"JoystickHidApiXbox360","text":"<p>A variable controlling whether the HIDAPI driver for XBox 360 controllers should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used.</li> <li>'1': HIDAPI driver is used.</li> </ul> <p>The default is the value of JoystickHidApiXbox</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiXbox360 = SDL_HINT_JOYSTICK_HIDAPI_XBOX_360</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiXbox360PlayerLed","title":"JoystickHidApiXbox360PlayerLed","text":"<p>A variable controlling whether the player LEDs should be lit to indicate which player is associated with an Xbox 360 controller.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Player LEDs are not enabled.</li> <li>'1': Player LEDs are enabled. (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const JoystickHidApiXbox360PlayerLed = SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiXbox360Wireless","title":"JoystickHidApiXbox360Wireless","text":"<p>A variable controlling whether the HIDAPI driver for XBox 360 wireless controllers should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used.</li> <li>'1': HIDAPI driver is used.</li> </ul> <p>The default is the value of JoystickHidApiXbox360.</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiXbox360Wireless = SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_WIRELESS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiXboxOne","title":"JoystickHidApiXboxOne","text":"<p>A variable controlling whether the HIDAPI driver for XBox One controllers should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': HIDAPI driver is not used.</li> <li>'1': HIDAPI driver is used.</li> </ul> <p>The default is the value of JoystickHidApiXbox.</p> <p>This hint should be set before initializing joysticks and gamepads. </p> <p><code>const JoystickHidApiXboxOne = SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickHidApiXboxOneHomeLed","title":"JoystickHidApiXboxOneHomeLed","text":"<p>A variable controlling whether the Home button LED should be turned on when an Xbox One controller is opened.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Home button LED is turned off.</li> <li>'1': Home button LED is turned on.</li> </ul> <p>By default the Home button LED state is not changed. This hint can also be set to a floating point value between 0.0 and 1.0 which controls the brightness of the Home button LED. The default brightness is 0.4.</p> <p>This hint can be set anytime. </p> <p><code>const JoystickHidApiXboxOneHomeLed = SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickIOKit","title":"JoystickIOKit","text":"<p>A variable controlling whether IOKit should be used for controller handling.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': IOKit is not used.</li> <li>'1': IOKit is used. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const JoystickIOKit = SDL_HINT_JOYSTICK_IOKIT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickLinuxClassic","title":"JoystickLinuxClassic","text":"<p>A variable controlling whether to use the classic /dev/input/js joystick interface or the newer /dev/input/event joystick interface on Linux.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Use /dev/input/event* (default)</li> <li>'1': Use /dev/input/js*</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const JoystickLinuxClassic = SDL_HINT_JOYSTICK_LINUX_CLASSIC</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickLinuxDeadzoned","title":"JoystickLinuxDeadzoned","text":"<p>A variable controlling whether joysticks on Linux adhere to their HID-defined deadzones or return unfiltered values.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Return unfiltered joystick axis values. (default)</li> <li>'1': Return axis values with deadzones taken into account.</li> </ul> <p>This hint should be set before a controller is opened. </p> <p><code>const JoystickLinuxDeadzoned = SDL_HINT_JOYSTICK_LINUX_DEADZONES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickLinuxDigitalHats","title":"JoystickLinuxDigitalHats","text":"<p>A variable controlling whether joysticks on Linux will always treat 'hat' axis inputs (ABS_HAT0X - ABS_HAT3Y) as 8-way digital hats without checking whether they may be analog.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Only map hat axis inputs to digital hat outputs if the input axes appear to actually be digital. (default)</li> <li>'1': Always handle the input axes numbered ABS_HAT0X to ABS_HAT3Y as digital hats.</li> </ul> <p>This hint should be set before a controller is opened. </p> <p><code>const JoystickLinuxDigitalHats = SDL_HINT_JOYSTICK_LINUX_DIGITAL_HATS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickLinuxHatDeadzones","title":"JoystickLinuxHatDeadzones","text":"<p>A variable controlling whether digital hats on Linux will apply deadzones to their underlying input axes or use unfiltered values.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Return digital hat values based on unfiltered input axis values.</li> <li>'1': Return digital hat values with deadzones on the input axes taken into account. (default)</li> </ul> <p>This hint should be set before a controller is opened. </p> <p><code>const JoystickLinuxHatDeadzones = SDL_HINT_JOYSTICK_LINUX_HAT_DEADZONES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickMfi","title":"JoystickMfi","text":"<p>A variable controlling whether GCController should be used for controller handling.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': GCController is not used.</li> <li>'1': GCController is used. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const JoystickMfi = SDL_HINT_JOYSTICK_MFI</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickRawInput","title":"JoystickRawInput","text":"<p>A variable controlling whether the RAWINPUT joystick drivers should be used for better handling XInput-capable devices.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': RAWINPUT drivers are not used.</li> <li>'1': RAWINPUT drivers are used. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const JoystickRawInput = SDL_HINT_JOYSTICK_RAWINPUT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickRawInputCorrelateXInput","title":"JoystickRawInputCorrelateXInput","text":"<p>A variable controlling whether the RAWINPUT driver should pull correlated data from XInput.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': RAWINPUT driver will only use data from raw input APIs.</li> <li>'1': RAWINPUT driver will also pull data from XInput and Windows.Gaming.Input, providing better trigger axes, guide button presses, and rumble support for Xbox controllers. (default)</li> </ul> <p>This hint should be set before a gamepad is opened. </p> <p><code>const JoystickRawInputCorrelateXInput = SDL_HINT_JOYSTICK_RAWINPUT_CORRELATE_XINPUT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickRogChakram","title":"JoystickRogChakram","text":"<p>A variable controlling whether the ROG Chakram mice should show up as joysticks.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': ROG Chakram mice do not show up as joysticks. (default)</li> <li>'1': ROG Chakram mice show up as joysticks.</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const JoystickRogChakram = SDL_HINT_JOYSTICK_ROG_CHAKRAM</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickThread","title":"JoystickThread","text":"<p>A variable controlling whether a separate thread should be used for handling joystick detection and raw input messages on Windows.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': A separate thread is not used.</li> <li>'1': A separate thread is used for handling raw input messages. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const JoystickThread = SDL_HINT_JOYSTICK_THREAD</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickThrottleDevices","title":"JoystickThrottleDevices","text":"<p>A variable containing a list of throttle style controllers.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p><code>0xAAAA/0xBBBB,0xCCCC/0xDDDD</code></p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint can be set anytime. </p> <p><code>const JoystickThrottleDevices = SDL_HINT_JOYSTICK_THROTTLE_DEVICES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickThrottleDevicesExcluded","title":"JoystickThrottleDevicesExcluded","text":"<p>A variable containing a list of devices that are not throttle style controllers.</p> <p>This will override JoystickThrottleDevices and the built in device list.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p><code>0xAAAA/0xBBBB,0xCCCC/0xDDDD</code></p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint can be set anytime. </p> <p><code>const JoystickThrottleDevicesExcluded = SDL_HINT_JOYSTICK_THROTTLE_DEVICES_EXCLUDED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickWgi","title":"JoystickWgi","text":"<p>A variable controlling whether Windows.Gaming.Input should be used for controller handling.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': WGI is not used.</li> <li>'1': WGI is used. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const JoystickWgi = SDL_HINT_JOYSTICK_WGI</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickWheelDevices","title":"JoystickWheelDevices","text":"<p>A variable containing a list of wheel style controllers.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p><code>0xAAAA/0xBBBB,0xCCCC/0xDDDD</code></p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint can be set anytime. </p> <p><code>const JoystickWheelDevices = SDL_HINT_JOYSTICK_WHEEL_DEVICES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickWheelDevicesExcluded","title":"JoystickWheelDevicesExcluded","text":"<p>A variable containing a list of devices that are not wheel style controllers.</p> <p>This will override JoystickWheelDevices and the built in device list.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p><code>0xAAAA/0xBBBB,0xCCCC/0xDDDD</code></p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint can be set anytime. </p> <p><code>const JoystickWheelDevicesExcluded = SDL_HINT_JOYSTICK_WHEEL_DEVICES_EXCLUDED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#JoystickZeroCenteredDevices","title":"JoystickZeroCenteredDevices","text":"<p>A variable containing a list of devices known to have all axes centered at zero.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p><code>0xAAAA/0xBBBB,0xCCCC/0xDDDD</code></p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint should be set before a controller is opened. </p> <p><code>const JoystickZeroCenteredDevices = SDL_HINT_JOYSTICK_ZERO_CENTERED_DEVICES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#KeycodeOptions","title":"KeycodeOptions","text":"<p>A variable that controls keycode representation in keyboard events.</p> <p>This variable is a comma separated set of options for translating keycodes in events:</p> <ul> <li>'none': Keycode options are cleared, this overrides other options.</li> <li>'hide_numpad': The numpad keysyms will be translated into their non-numpad versions based on the current NumLock state. For example, TSdlKeycode.KP4 would become TSdlKeycode._4 if TSdlKeyMod.Num is set in the event modifiers, and TSdlKeycode.Left if it is unset.</li> <li>'french_numbers': The number row on French keyboards is inverted, so pressing the 1 key would yield the keycode TSdlKeycode._1, or '1', instead of TSdlKeycode.Ampersand, or '&amp;'</li> <li>'latin_letters': For keyboards using non-Latin letters, such as Russian or Thai, the letter keys generate keycodes as though it had an en_US layout. e.g. pressing the key associated with TSdlScancode.A on a Russian keyboard would yield 'a' instead of a Cyrillic letter.</li> </ul> <p>The default value for this hint is 'french_numbers,latin_letters'</p> <p>Some platforms like Emscripten only provide modified keycodes and the options are not used.</p> <p>These options do not affect the return value of TSdlKeycode.FromScancode or TSdlScancode.FromKeycode, they just apply to the keycode included in key events.</p> <p>This hint can be set anytime. </p> <p><code>const KeycodeOptions = SDL_HINT_KEYCODE_OPTIONS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#KmsDrmDeviceIndex","title":"KmsDrmDeviceIndex","text":"<p>A variable that controls what KMSDRM device to use.</p> <p>SDL might open something like '/dev/dri/cardNN' to access KMSDRM functionality, where 'NN' is a device index number. SDL makes a guess at the best index to use (usually zero), but the app or user can set this hint to a number between 0 and 99 to force selection.</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const KmsDrmDeviceIndex = SDL_HINT_KMSDRM_DEVICE_INDEX</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#KmsDrmRequireDrmMaster","title":"KmsDrmRequireDrmMaster","text":"<p>A variable that controls whether SDL requires DRM master access in order to initialize the KMSDRM video backend.</p> <p>The DRM subsystem has a concept of a 'DRM master' which is a DRM client that has the ability to set planes, set cursor, etc. When SDL is DRM master, it can draw to the screen using the SDL rendering APIs. Without DRM master, SDL is still able to process input and query attributes of attached displays, but it cannot change display state or draw to the screen directly.</p> <p>In some cases, it can be useful to have the KMSDRM backend even if it cannot be used for rendering. An app may want to use SDL for input processing while using another rendering API (such as an MMAL overlay on Raspberry Pi) or using its own code to render to DRM overlays that SDL doesn't support.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': SDL will allow usage of the KMSDRM backend without DRM master.</li> <li>'1': SDL Will require DRM master to use the KMSDRM backend. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const KmsDrmRequireDrmMaster = SDL_HINT_KMSDRM_REQUIRE_DRM_MASTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#Logging","title":"Logging","text":"<p>A variable controlling the default SDL log levels.</p> <p>This variable is a comma separated set of category=level tokens that define the default logging levels for SDL applications.</p> <p>The category can be a numeric category, one of 'app', 'error', 'assert', 'system', 'audio', 'video', 'render', 'input', 'test', or <code>*</code> for any unspecified category.</p> <p>The level can be a numeric level, one of 'verbose', 'debug', 'info', 'warn', 'error', 'critical', or 'quiet' to disable that category.</p> <p>You can omit the category if you want to set the logging level for all categories.</p> <p>If this hint isn't set, the default log levels are equivalent to:</p> <p><code>app=info,assert=warn,test=verbose,*=error</code></p> <p>This hint can be set anytime. </p> <p><code>const Logging = SDL_HINT_LOGGING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MacBackgroundApp","title":"MacBackgroundApp","text":"<p>A variable controlling whether to force the application to become the foreground process when launched on macOS.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': The application is brought to the foreground when launched. (default)</li> <li>'1': The application may remain in the background when launched.</li> </ul> <p>This hint needs to be set before SDL_Init(). </p> <p><code>const MacBackgroundApp = SDL_HINT_MAC_BACKGROUND_APP</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MacCtrlClickEmulateRightClick","title":"MacCtrlClickEmulateRightClick","text":"<p>A variable that determines whether Ctrl+Click should generate a right-click event on macOS.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Ctrl+Click does not generate a right mouse button click event. (default)</li> <li>'1': Ctrl+Click generated a right mouse button click event.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const MacCtrlClickEmulateRightClick = SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MacOpenGLAsyncDispatch","title":"MacOpenGLAsyncDispatch","text":"<p>A variable controlling whether dispatching OpenGL context updates should block the dispatching thread until the main thread finishes processing on macOS.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Dispatching OpenGL context updates will block the dispatching thread until the main thread finishes processing. (default)</li> <li>'1': Dispatching OpenGL context updates will allow the dispatching thread to continue execution.</li> </ul> <p>Generally you want the default, but if you have OpenGL code in a background thread on a Mac, and the main thread hangs because it's waiting for that background thread, but that background thread is also hanging because it's waiting for the main thread to do an update, this might fix your issue.</p> <p>This hint can be set anytime. </p> <p><code>const MacOpenGLAsyncDispatch = SDL_HINT_MAC_OPENGL_ASYNC_DISPATCH</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MacOptionAsAlt","title":"MacOptionAsAlt","text":"<p>A variable controlling whether the Option (\u2325) key on macOS should be remapped to act as the Alt key.</p> <p>The variable can be set to the following values:</p> <ul> <li>'none': The Option key is not remapped to Alt. (default)</li> <li>'only_left': Only the left Option key is remapped to Alt.</li> <li>'only_right': Only the right Option key is remapped to Alt.</li> <li>'both': Both Option keys are remapped to Alt.</li> </ul> <p>This will prevent the triggering of key compositions that rely on the Option key, but will still send the Alt modifier for keyboard events. In the case that both Alt and Option are pressed, the Option key will be ignored. This is particularly useful for applications like terminal emulators and graphical user interfaces (GUIs) that rely on Alt key functionality for shortcuts or navigation. This does not apply to TSdlKeycode.FromScancode and only has an effect if IME is enabled.</p> <p>This hint can be set anytime. </p> <p><code>const MacOptionAsAlt = SDL_HINT_MAC_OPTION_AS_ALT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MacScrollMomentum","title":"MacScrollMomentum","text":"<p>A variable controlling whether SDL_EVENT_MOUSE_WHEEL event values will have momentum on macOS.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': The mouse wheel events will have no momentum. (default)</li> <li>'1': The mouse wheel events will have momentum.</li> </ul> <p>This hint needs to be set before SDL_Init(). </p> <p><code>const MacScrollMomentum = SDL_HINT_MAC_SCROLL_MOMENTUM</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MainCallbackRate","title":"MainCallbackRate","text":"<p>Request TSdlApp.Iterate be called at a specific rate.</p> <p>If this is set to a number, it represents Hz, so '60' means try to iterate 60 times per second. '0' means to iterate as fast as possible. Negative values are illegal, but reserved, in case they are useful in a future revision of SDL.</p> <p>There are other strings that have special meaning. If set to 'waitevent', TSdlApp.Iterate will not be called until new event(s) have arrived (and been processed by TSdlApp.Event). This can be useful for apps that are completely idle except in response to input.</p> <p>This defaults to 0, and specifying nil for the hint's value will restore the default.</p> <p>This hint can be set anytime. </p> <p><code>const MainCallbackRate = SDL_HINT_MAIN_CALLBACK_RATE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MouseAutoCapture","title":"MouseAutoCapture","text":"<p>A variable controlling whether the mouse is captured while mouse buttons are pressed.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': The mouse is not captured while mouse buttons are pressed.</li> <li>'1': The mouse is captured while mouse buttons are pressed.</li> </ul> <p>By default the mouse is captured while mouse buttons are pressed so if the mouse is dragged outside the window, the application continues to receive mouse events until the button is released.</p> <p>This hint can be set anytime. </p> <p><code>const MouseAutoCapture = SDL_HINT_MOUSE_AUTO_CAPTURE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MouseDefaultSystemCursor","title":"MouseDefaultSystemCursor","text":"<p>A variable setting which system cursor to use as the default cursor.</p> <p>This should be an integer corresponding to the SDL_SystemCursor enum. The default value is zero (TSdlSystemCursor.Default).</p> <p>This hint needs to be set before SdlInit. </p> <p><code>const MouseDefaultSystemCursor = SDL_HINT_MOUSE_DEFAULT_SYSTEM_CURSOR</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MouseDoubleClickRadius","title":"MouseDoubleClickRadius","text":"<p>A variable setting the double click radius, in pixels.</p> <p>This hint can be set anytime. </p> <p><code>const MouseDoubleClickRadius = SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MouseDoubleClickTime","title":"MouseDoubleClickTime","text":"<p>A variable setting the double click time, in milliseconds.</p> <p>This hint can be set anytime. </p> <p><code>const MouseDoubleClickTime = SDL_HINT_MOUSE_DOUBLE_CLICK_TIME</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MouseEmulateWarpWithRelative","title":"MouseEmulateWarpWithRelative","text":"<p>A variable controlling whether warping a hidden mouse cursor will activate relative mouse mode.</p> <p>When this hint is set, the mouse cursor is hidden, and multiple warps to the window center occur within a short time period, SDL will emulate mouse warps using relative mouse mode. This can provide smoother and more reliable mouse motion for some older games, which continuously calculate the distance travelled by the mouse pointer and warp it back to the center of the window, rather than using relative mouse motion.</p> <p>Note that relative mouse mode may have different mouse acceleration behavior than pointer warps.</p> <p>If your application needs to repeatedly warp the hidden mouse cursor at a high-frequency for other purposes, it should disable this hint.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Attempts to warp the mouse will always be made.</li> <li>'1': Some mouse warps will be emulated by forcing relative mouse mode. (default)</li> </ul> <p>If not set, this is automatically enabled unless an application uses relative mouse mode directly.</p> <p>This hint can be set anytime. </p> <p><code>const MouseEmulateWarpWithRelative = SDL_HINT_MOUSE_EMULATE_WARP_WITH_RELATIVE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MouseFocusClickThrough","title":"MouseFocusClickThrough","text":"<p>Allow mouse click events when clicking to focus an SDL window.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Ignore mouse clicks that activate a window. (default)</li> <li>'1': Generate events for mouse clicks that activate a window.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const MouseFocusClickThrough = SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MouseNormalSpeedScale","title":"MouseNormalSpeedScale","text":"<p>A variable setting the speed scale for mouse motion, in floating point, when the mouse is not in relative mode.</p> <p>This hint can be set anytime. </p> <p><code>const MouseNormalSpeedScale = SDL_HINT_MOUSE_NORMAL_SPEED_SCALE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MouseRelativeCursorVisible","title":"MouseRelativeCursorVisible","text":"<p>A variable controlling whether the hardware cursor stays visible when relative mode is active.</p> <p>This variable can be set to the following values:</p> <ul> <li>'0': The cursor will be hidden while relative mode is active (default)</li> <li>'1': The cursor will remain visible while relative mode is active</li> </ul> <p>Note that for systems without raw hardware inputs, relative mode is implemented using warping, so the hardware cursor will visibly warp between frames if this is enabled on those systems.</p> <p>This hint can be set anytime. </p> <p><code>const MouseRelativeCursorVisible = SDL_HINT_MOUSE_RELATIVE_CURSOR_VISIBLE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MouseRelativeModeCenter","title":"MouseRelativeModeCenter","text":"<p>A variable controlling whether relative mouse mode constrains the mouse to the center of the window.</p> <p>Constraining to the center of the window works better for FPS games and when the application is running over RDP. Constraining to the whole window works better for 2D games and increases the chance that the mouse will be in the correct position when using high DPI mice.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Relative mouse mode constrains the mouse to the window.</li> <li>'1': Relative mouse mode constrains the mouse to the center of the window. (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const MouseRelativeModeCenter = SDL_HINT_MOUSE_RELATIVE_MODE_CENTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MouseRelativeSpeedScale","title":"MouseRelativeSpeedScale","text":"<p>A variable setting the scale for mouse motion, in floating point, when the mouse is in relative mode.</p> <p>This hint can be set anytime. </p> <p><code>const MouseRelativeSpeedScale = SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MouseRelativeSystemScale","title":"MouseRelativeSystemScale","text":"<p>A variable controlling whether the system mouse acceleration curve is used for relative mouse motion.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Relative mouse motion will be unscaled. (default)</li> <li>'1': Relative mouse motion will be scaled using the system mouse acceleration curve.</li> </ul> <p>If MouseRelativeSpeedScale is set, that will be applied after system speed scale.</p> <p>This hint can be set anytime. </p> <p><code>const MouseRelativeSystemScale = SDL_HINT_MOUSE_RELATIVE_SYSTEM_SCALE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MouseRelativeWarpMotion","title":"MouseRelativeWarpMotion","text":"<p>A variable controlling whether a motion event should be generated for mouse warping in relative mode.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Warping the mouse will not generate a motion event in relative mode</li> <li>'1': Warping the mouse will generate a motion event in relative mode</li> </ul> <p>By default warping the mouse will not generate motion events in relative mode. This avoids the application having to filter out large relative motion due to warping.</p> <p>This hint can be set anytime. </p> <p><code>const MouseRelativeWarpMotion = SDL_HINT_MOUSE_RELATIVE_WARP_MOTION</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MouseTouchEvents","title":"MouseTouchEvents","text":"<p>A variable controlling whether mouse events should generate synthetic touch events.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Mouse events will not generate touch events. (default for desktop platforms)</li> <li>'1': Mouse events will generate touch events. (default for mobile platforms, such as Android and iOS)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const MouseTouchEvents = SDL_HINT_MOUSE_TOUCH_EVENTS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#MuteConsoleKeyboard","title":"MuteConsoleKeyboard","text":"<p>A variable controlling whether the keyboard should be muted on the console.</p> <p>Normally the keyboard is muted while SDL applications are running so that keyboard input doesn't show up as key strokes on the console. This hint allows you to turn that off for debugging purposes.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Allow keystrokes to go through to the console.</li> <li>'1': Mute keyboard input so it doesn't show up on the console. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const MuteConsoleKeyboard = SDL_HINT_MUTE_CONSOLE_KEYBOARD</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#NoSignalHandlers","title":"NoSignalHandlers","text":"<p>Tell SDL not to catch the SIGINT or SIGTERM signals on POSIX platforms.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': SDL will install a SIGINT and SIGTERM handler, and when it catches a signal, convert it into an TSdlEventKind.Quit event. (default)</li> <li>'1': SDL will not install a signal handler at all.</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const NoSignalHandlers = SDL_HINT_NO_SIGNAL_HANDLERS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#OpenGlesDriver","title":"OpenGlesDriver","text":"<p>A variable controlling what driver to use for OpenGL ES contexts.</p> <p>On some platforms, currently Windows and X11, OpenGL drivers may support creating contexts with an OpenGL ES profile. By default SDL uses these profiles, when available, otherwise it attempts to load an OpenGL ES library, e.g. that provided by the ANGLE project. This variable controls whether SDL follows this default behaviour or will always load an OpenGL ES library.</p> <p>Circumstances where this is useful include - Testing an app with a particular OpenGL ES implementation, e.g ANGLE, or emulator, e.g. those from ARM, Imagination or Qualcomm. - Resolving OpenGL ES function addresses at link time by linking with the OpenGL ES library instead of querying them at run time with TSdlGL.GetProcAddress.</p> <p>Caution: for an application to work with the default behaviour across different OpenGL drivers it must query the OpenGL ES function addresses at run time using TSdlGL.GetProcAddress.</p> <p>This variable is ignored on most platforms because OpenGL ES is native or not supported.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Use ES profile of OpenGL, if available. (default)</li> <li>'1': Load OpenGL ES library using the default library names.</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const OpenGlesDriver = SDL_HINT_OPENGL_ES_DRIVER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#OpenGLLibrary","title":"OpenGLLibrary","text":"<p>Specify the OpenGL library to load.</p> <p>This hint should be set before creating an OpenGL window or creating an OpenGL context. If this hint isn't set, SDL will choose a reasonable default. </p> <p><code>const OpenGLLibrary = SDL_HINT_OPENGL_LIBRARY</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#OpenVRLibrary","title":"OpenVRLibrary","text":"<p>Mechanism to specify openvr_api library location</p> <p>By default, when using the OpenVR driver, it will search for the API library in the current folder. But, if you wish to use a system API you can specify that by using this hint. This should be the full or relative path to a .dll on Windows or .so on Linux. </p> <p><code>const OpenVRLibrary = SDL_HINT_OPENVR_LIBRARY</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#Orientations","title":"Orientations","text":"<p>A variable controlling which orientations are allowed on iOS/Android.</p> <p>In some circumstances it is necessary to be able to explicitly control which UI orientations are allowed.</p> <p>This variable is a space delimited list of the following values:</p> <ul> <li>'LandscapeLeft'</li> <li>'LandscapeRight'</li> <li>'Portrait'</li> <li>'PortraitUpsideDown'</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const Orientations = SDL_HINT_ORIENTATIONS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#PenMouseEvents","title":"PenMouseEvents","text":"<p>A variable controlling whether pen events should generate synthetic mouse events.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Pen events will not generate mouse events.</li> <li>'1': Pen events will generate mouse events. (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const PenMouseEvents = SDL_HINT_PEN_MOUSE_EVENTS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#PenTouchEvents","title":"PenTouchEvents","text":"<p>A variable controlling whether pen events should generate synthetic touch events.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Pen events will not generate touch events.</li> <li>'1': Pen events will generate touch events. (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const PenTouchEvents = SDL_HINT_PEN_TOUCH_EVENTS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#PollSentinel","title":"PollSentinel","text":"<p>A variable controlling the use of a sentinel event when polling the event queue.</p> <p>When polling for events, TSdlEvents.Pump is used to gather new events from devices. If a device keeps producing new events between calls to TSdlEvents.Pump, a poll loop will become stuck until the new events stop. This is most noticeable when moving a high frequency mouse.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Disable poll sentinels.</li> <li>'1': Enable poll sentinels. (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const PollSentinel = SDL_HINT_POLL_SENTINEL</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#PreferredLocales","title":"PreferredLocales","text":"<p>Override for TSdlLocale.PreferredLocales.</p> <p>If set, this will be favored over anything the OS might report for the user's preferred locales. Changing this hint at runtime will not generate a TSdlEventKind.LocaleChanged event (but if you can change the hint, you can push your own event, if you want).</p> <p>The format of this hint is a comma-separated list of language and locale, combined with an underscore, as is a common format: 'en_GB'. Locale is optional: 'en'. So you might have a list like this: 'en_GB,jp,es_PT'</p> <p>This hint can be set anytime. </p> <p><code>const PreferredLocales = SDL_HINT_PREFERRED_LOCALES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#QuitOnLastWindowClose","title":"QuitOnLastWindowClose","text":"<p>A variable that decides whether to send TSdlEventKind.Quit when closing the last window.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': SDL will not send an TSdlEventKind.Quit event when the last window is requesting to close. Note that in this case, there are still other legitimate reasons one might get an TSdlEventKind.Quit event: choosing 'Quit' from the macOS menu bar, sending a SIGINT (ctrl-c) on Unix, etc.</li> <li>'1': SDL will send a quit event when the last window is requesting to close. (default)</li> </ul> <p>If there is at least one active system tray icon, TSdlEventKind.Quit will instead be sent when both the last window will be closed and the last tray icon will be destroyed.</p> <p>This hint can be set anytime. </p> <p><code>const QuitOnLastWindowClose = SDL_HINT_QUIT_ON_LAST_WINDOW_CLOSE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#RenderDirect3D11Debug","title":"RenderDirect3D11Debug","text":"<p>A variable controlling whether to enable Direct3D 11+'s Debug Layer.</p> <p>This variable does not have any effect on the Direct3D 9 based renderer.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Disable Debug Layer use. (default)</li> <li>'1': Enable Debug Layer use.</li> </ul> <p>This hint should be set before creating a renderer. </p> <p><code>const RenderDirect3D11Debug = SDL_HINT_RENDER_DIRECT3D11_DEBUG</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#RenderDirect3DThreadSafe","title":"RenderDirect3DThreadSafe","text":"<p>A variable controlling whether the Direct3D device is initialized for thread-safe operations.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Thread-safety is not enabled. (default)</li> <li>'1': Thread-safety is enabled.</li> </ul> <p>This hint should be set before creating a renderer. </p> <p><code>const RenderDirect3DThreadSafe = SDL_HINT_RENDER_DIRECT3D_THREADSAFE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#RenderDriver","title":"RenderDriver","text":"<p>A variable specifying which render driver to use.</p> <p>If the application doesn't pick a specific renderer to use, this variable specifies the name of the preferred renderer. If the preferred renderer can't be initialized, creating a renderer will fail.</p> <p>This variable is case insensitive and can be set to the following values:</p> <ul> <li>'direct3d'</li> <li>'direct3d11'</li> <li>'direct3d12'</li> <li>'opengl'</li> <li>'opengles2'</li> <li>'opengles'</li> <li>'metal'</li> <li>'vulkan'</li> <li>'gpu'</li> <li>'software'</li> </ul> <p>This hint accepts a comma-separated list of driver names, and each will be tried in the order listed when creating a renderer until one succeeds or all of them fail.</p> <p>The default varies by platform, but it's the first one in the list that is available on the current platform.</p> <p>This hint should be set before creating a renderer. </p> <p><code>const RenderDriver = SDL_HINT_RENDER_DRIVER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#RenderGpuDebug","title":"RenderGpuDebug","text":"<p>A variable controlling whether to create the GPU device in debug mode.</p> <p>This variable can be set to the following values:</p> <ul> <li>'0': Disable debug mode use (default)</li> <li>'1': Enable debug mode use</li> </ul> <p>This hint should be set before creating a renderer. </p> <p><code>const RenderGpuDebug = SDL_HINT_RENDER_GPU_DEBUG</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#RenderGpuLowPower","title":"RenderGpuLowPower","text":"<p>A variable controlling whether to prefer a low-power GPU on multi-GPU systems.</p> <p>This variable can be set to the following values:</p> <ul> <li>'0': Prefer high-performance GPU (default)</li> <li>'1': Prefer low-power GPU</li> </ul> <p>This hint should be set before creating a renderer. </p> <p><code>const RenderGpuLowPower = SDL_HINT_RENDER_GPU_LOW_POWER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#RenderLineMethod","title":"RenderLineMethod","text":"<p>A variable controlling how the 2D render API renders lines.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Use the default line drawing method (Bresenham's line algorithm)</li> <li>'1': Use the driver point API using Bresenham's line algorithm (correct, draws many points)</li> <li>'2': Use the driver line API (occasionally misses line endpoints based on hardware driver quirks</li> <li>'3': Use the driver geometry API (correct, draws thicker diagonal lines)</li> </ul> <p>This hint should be set before creating a renderer. </p> <p><code>const RenderLineMethod = SDL_HINT_RENDER_LINE_METHOD</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#RenderMetalPreferLowPowerDevice","title":"RenderMetalPreferLowPowerDevice","text":"<p>A variable controlling whether the Metal render driver select low power device over default one.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Use the preferred OS device. (default)</li> <li>'1': Select a low power device.</li> </ul> <p>This hint should be set before creating a renderer. </p> <p><code>const RenderMetalPreferLowPowerDevice = SDL_HINT_RENDER_METAL_PREFER_LOW_POWER_DEVICE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#RenderVSync","title":"RenderVSync","text":"<p>A variable controlling whether updates to the SDL screen surface should be synchronized with the vertical refresh, to avoid tearing.</p> <p>This hint overrides the application preference when creating a renderer.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Disable vsync. (default)</li> <li>'1': Enable vsync.</li> </ul> <p>This hint should be set before creating a renderer. </p> <p><code>const RenderVSync = SDL_HINT_RENDER_VSYNC</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#RenderVulkanDebug","title":"RenderVulkanDebug","text":"<p>A variable controlling whether to enable Vulkan Validation Layers.</p> <p>This variable can be set to the following values:</p> <ul> <li>'0': Disable Validation Layer use</li> <li>'1': Enable Validation Layer use</li> </ul> <p>By default, SDL does not use Vulkan Validation Layers. </p> <p><code>const RenderVulkanDebug = SDL_HINT_RENDER_VULKAN_DEBUG</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#ReturnKeyHideIme","title":"ReturnKeyHideIme","text":"<p>A variable to control whether the return key on the soft keyboard should hide the soft keyboard on Android and iOS.</p> <p>This hint sets the default value of TSdlProperty.TextInputMultiLine.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': The return key will be handled as a key event. (default)</li> <li>'1': The return key will hide the keyboard.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const ReturnKeyHideIme = SDL_HINT_RETURN_KEY_HIDES_IME</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#RogGamepadMice","title":"RogGamepadMice","text":"<p>A variable containing a list of ROG gamepad capable mice.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p><code>0xAAAA/0xBBBB,0xCCCC/0xDDDD</code></p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const RogGamepadMice = SDL_HINT_ROG_GAMEPAD_MICE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#RogGamepadMiceExcluded","title":"RogGamepadMiceExcluded","text":"<p>A variable containing a list of devices that are not ROG gamepad capable mice.</p> <p>This will override RogGamepadMice and the built in device list.</p> <p>The format of the string is a comma separated list of USB VID/PID pairs in hexadecimal form, e.g.</p> <p><code>0xAAAA/0xBBBB,0xCCCC/0xDDDD</code></p> <p>The variable can also take the form of '@file', in which case the named file will be loaded and interpreted as the value of the variable.</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const RogGamepadMiceExcluded = SDL_HINT_ROG_GAMEPAD_MICE_EXCLUDED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#RpiVideoLayer","title":"RpiVideoLayer","text":"<p>A variable controlling which Dispmanx layer to use on a Raspberry PI.</p> <p>Also known as Z-order. The variable can take a negative or positive value. The default is 10000.</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const RpiVideoLayer = SDL_HINT_RPI_VIDEO_LAYER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#ScreenSaverInhibitActivityName","title":"ScreenSaverInhibitActivityName","text":"<p>Specify an 'activity name' for screensaver inhibition.</p> <p>Some platforms, notably Linux desktops, list the applications which are inhibiting the screensaver or other power-saving features.</p> <p>This hint lets you specify the 'activity name' sent to the OS when TSdlScreenSaver.Disable is used (or the screensaver is automatically disabled). The contents of this hint are used when the screensaver is disabled. You should use a string that describes what your program is doing (and, therefore, why the screensaver is disabled). For example, 'Playing a game' or 'Watching a video'.</p> <p>Setting this to '' or leaving it unset will have SDL use a reasonable default: 'Playing a game' or something similar.</p> <p>This hint should be set before calling TSdlScreenSaver.Disable. </p> <p><code>const ScreenSaverInhibitActivityName = SDL_HINT_SCREENSAVER_INHIBIT_ACTIVITY_NAME</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#ShutdownDbusOnQuit","title":"ShutdownDbusOnQuit","text":"<p>A variable controlling whether SDL calls dbus_shutdown on quit.</p> <p>This is useful as a debug tool to validate memory leaks, but shouldn't ever be set in production applications, as other libraries used by the application might use dbus under the hood and this can cause crashes if they continue after SdlQuit.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': SDL will not call dbus_shutdown on quit. (default)</li> <li>'1': SDL will call dbus_shutdown on quit.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const ShutdownDbusOnQuit = SDL_HINT_SHUTDOWN_DBUS_ON_QUIT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#StorageTitleDriver","title":"StorageTitleDriver","text":"<p>A variable that specifies a backend to use for title storage.</p> <p>By default, SDL will try all available storage backends in a reasonable order until it finds one that can work, but this hint allows the app or user to force a specific target, such as 'pc' if, say, you are on Steam but want to avoid SteamRemoteStorage for title data.</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const StorageTitleDriver = SDL_HINT_STORAGE_TITLE_DRIVER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#StorageUsbDriver","title":"StorageUsbDriver","text":"<p>A variable that specifies a backend to use for user storage.</p> <p>By default, SDL will try all available storage backends in a reasonable order until it finds one that can work, but this hint allows the app or user to force a specific target, such as 'pc' if, say, you are on Steam but want to avoid SteamRemoteStorage for user data.</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const StorageUsbDriver = SDL_HINT_STORAGE_USER_DRIVER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#ThreadForceRealtimeTimeCritical","title":"ThreadForceRealtimeTimeCritical","text":"<p>Specifies whether TSdlThreadPriority.TimeCritical should be treated as realtime.</p> <p>On some platforms, like Linux, a realtime priority thread may be subject to restrictions that require special handling by the application. This hint exists to let SDL know that the app is prepared to handle said restrictions.</p> <p>On Linux, SDL will apply the following configuration to any thread that becomes realtime:</p> <ul> <li>The SCHED_RESET_ON_FORK bit will be set on the scheduling policy,</li> <li>An RLIMIT_RTTIME budget will be configured to the rtkit specified limit.</li> <li>Exceeding this limit will result in the kernel sending SIGKILL to the app, refer to the man pages for more information.</li> </ul> <p>The variable can be set to the following values:</p> <ul> <li>'0': default platform specific behaviour</li> <li>'1': Force TSdlThreadPriority.TimeCritical to a realtime scheduling policy</li> </ul> <p>This hint should be set before calling TSdlThread.Current.Priority. </p> <p><code>const ThreadForceRealtimeTimeCritical = SDL_HINT_THREAD_FORCE_REALTIME_TIME_CRITICAL</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#ThreadPriorityPolicy","title":"ThreadPriorityPolicy","text":"<p>A string specifying additional information to use with TSdlThread.Current.Priority.</p> <p>By default TSdlThread.Current.Priority will make appropriate system changes in order to apply a thread priority. For example on systems using pthreads the scheduler policy is changed automatically to a policy that works well with a given priority. Code which has specific requirements can override SDL's default behavior with this hint.</p> <p>pthread hint values are 'current', 'other', 'fifo' and 'rr'. Currently no other platform hint values are defined but may be in the future.</p> <p>On Linux, the kernel may send SIGKILL to realtime tasks which exceed the distro configured execution budget for rtkit. This budget can be queried through RLIMIT_RTTIME after calling TSdlThread.Current.Priority.</p> <p>This hint should be set before calling TSdlThread.Current.Priority. </p> <p><code>const ThreadPriorityPolicy = SDL_HINT_THREAD_PRIORITY_POLICY</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#TimerResolution","title":"TimerResolution","text":"<p>A variable that controls the timer resolution, in milliseconds.</p> <p>The higher resolution the timer, the more frequently the CPU services timer interrupts, and the more precise delays are, but this takes up power and CPU time. This hint is only used on Windows.</p> <p>See  this blog postfor more information.</p> <p>The default value is '1'.</p> <p>If this variable is set to '0', the system timer resolution is not set.</p> <p>This hint can be set anytime. </p> <p><code>const TimerResolution = SDL_HINT_TIMER_RESOLUTION</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#TouchMouseEvents","title":"TouchMouseEvents","text":"<p>A variable controlling whether touch events should generate synthetic mouse events.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Touch events will not generate mouse events.</li> <li>'1': Touch events will generate mouse events. (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const TouchMouseEvents = SDL_HINT_TOUCH_MOUSE_EVENTS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#TrackpadIsTouchOnly","title":"TrackpadIsTouchOnly","text":"<p>A variable controlling whether trackpads should be treated as touch devices.</p> <p>On macOS (and possibly other platforms in the future), SDL will report touches on a trackpad as mouse input, which is generally what users expect from this device; however, these are often actually full multitouch-capable touch devices, so it might be preferable to some apps to treat them as such.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Trackpad will send mouse events. (default)</li> <li>'1': Trackpad will send touch events.</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const TrackpadIsTouchOnly = SDL_HINT_TRACKPAD_IS_TOUCH_ONLY</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#TVRemoteAsJoystick","title":"TVRemoteAsJoystick","text":"<p>A variable controlling whether the Android / tvOS remotes should be listed as joystick devices, instead of sending keyboard events.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Remotes send enter/escape/arrow key events.</li> <li>'1': Remotes are available as 2 axis, 2 button joysticks. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const TVRemoteAsJoystick = SDL_HINT_TV_REMOTE_AS_JOYSTICK</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoAllowScreensave","title":"VideoAllowScreensave","text":"<p>A variable controlling whether the screensaver is enabled.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Disable screensaver. (default)</li> <li>'1': Enable screensaver.</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const VideoAllowScreensave = SDL_HINT_VIDEO_ALLOW_SCREENSAVER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoDisplayPriority","title":"VideoDisplayPriority","text":"<p>A comma separated list containing the names of the displays that SDL should sort to the front of the display list.</p> <p>When this hint is set, displays with matching name strings will be prioritized in the list of displays, as exposed by calling TSdlDisplay.Displays, with the first listed becoming the primary display. The naming convention can vary depending on the environment, but it is usually a connector name (e.g. 'DP-1', 'DP-2', 'HDMI-A-1',etc...).</p> <p>On Wayland and X11 desktops, the connector names associated with displays can typically be found by using the <code>xrandr</code> utility.</p> <p>This hint is currently supported on the following drivers:</p> <ul> <li>KMSDRM (kmsdrm)</li> <li>Wayland (wayland)</li> <li>X11 (x11)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const VideoDisplayPriority = SDL_HINT_VIDEO_DISPLAY_PRIORITY</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoDoubleBuffer","title":"VideoDoubleBuffer","text":"<p>Tell the video driver that we only want a double buffer.</p> <p>By default, most lowlevel 2D APIs will use a triple buffer scheme that wastes no CPU time on waiting for vsync after issuing a flip, but introduces a frame of latency. On the other hand, using a double buffer scheme instead is recommended for cases where low latency is an important factor because we save a whole frame of latency.</p> <p>We do so by waiting for vsync immediately after issuing a flip, usually just after eglSwapBuffers call in the backend's *_SwapWindow function.</p> <p>This hint is currently supported on the following drivers:</p> <ul> <li>Raspberry Pi (raspberrypi)</li> <li>Wayland (wayland)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const VideoDoubleBuffer = SDL_HINT_VIDEO_DOUBLE_BUFFER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoDriver","title":"VideoDriver","text":"<p>A variable that specifies a video backend to use.</p> <p>By default, SDL will try all available video backends in a reasonable order until it finds one that can work, but this hint allows the app or user to force a specific target, such as 'x11' if, say, you are on Wayland but want to try talking to the X server instead.</p> <p>This hint accepts a comma-separated list of driver names, and each will be tried in the order listed during init, until one succeeds or all of them fail.</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const VideoDriver = SDL_HINT_VIDEO_DRIVER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoDummySaveFrames","title":"VideoDummySaveFrames","text":"<p>A variable controlling whether the dummy video driver saves output frames.</p> <ul> <li>'0': Video frames are not saved to disk. (default)</li> <li>'1': Video frames are saved to files in the format 'SDL_windowX-Y.bmp', where X is the window ID, and Y is the frame number.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const VideoDummySaveFrames = SDL_HINT_VIDEO_DUMMY_SAVE_FRAMES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoEglAllowGetDisplayFallback","title":"VideoEglAllowGetDisplayFallback","text":"<p>If eglGetPlatformDisplay fails, fall back to calling eglGetDisplay.</p> <p>The variable can be set to one of the following values:</p> <ul> <li>'0': Do not fall back to eglGetDisplay.</li> <li>'1': Fall back to eglGetDisplay if eglGetPlatformDisplay fails. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const VideoEglAllowGetDisplayFallback = SDL_HINT_VIDEO_EGL_ALLOW_GETDISPLAY_FALLBACK</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoForceEgl","title":"VideoForceEgl","text":"<p>A variable controlling whether the OpenGL context should be created with EGL.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Use platform-specific GL context creation API (GLX, WGL, CGL, etc). (default)</li> <li>'1': Use EGL</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const VideoForceEgl = SDL_HINT_VIDEO_FORCE_EGL</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoMacFullscreenMenuVisibility","title":"VideoMacFullscreenMenuVisibility","text":"<p>A variable that specifies the menu visibility when a window is fullscreen in Spaces on macOS.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': The menu will be hidden when the window is in a fullscreen space, and not accessible by moving the mouse to the top of the screen.</li> <li>'1': The menu will be accessible when the window is in a fullscreen space.</li> <li>'auto': The menu will be hidden if fullscreen mode was toggled on programmatically via <code>TSdlWindow.Fullscreen</code>, and accessible if fullscreen was entered via the 'fullscreen' button on the window title bar. (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const VideoMacFullscreenMenuVisibility = SDL_HINT_VIDEO_MAC_FULLSCREEN_MENU_VISIBILITY</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoMacFullscreenSpaces","title":"VideoMacFullscreenSpaces","text":"<p>A variable that specifies the policy for fullscreen Spaces on macOS.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Disable Spaces support (TSdlWindowFlag.FullscreenDesktop won't use them and TSdlWindowFlag.Resizable windows won't offer the 'fullscreen' button on their titlebars).</li> <li>'1': Enable Spaces support (TSdlWindowFlag.FullscreenDesktop will use them and TSdlWindowFlag.Resizable windows will offer the 'fullscreen' button on their titlebars). (default)</li> </ul> <p>This hint should be set before creating a window. </p> <p><code>const VideoMacFullscreenSpaces = SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoMinimizeOnFocusLoss","title":"VideoMinimizeOnFocusLoss","text":"<p>A variable controlling whether fullscreen windows are minimized when they lose focus.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Fullscreen windows will not be minimized when they lose focus. (default)</li> <li>'1': Fullscreen windows are minimized when they lose focus.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const VideoMinimizeOnFocusLoss = SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoOffScreenSaveFrames","title":"VideoOffScreenSaveFrames","text":"<p>A variable controlling whether the offscreen video driver saves output frames.</p> <p>This only saves frames that are generated using software rendering, not accelerated OpenGL rendering.</p> <ul> <li>'0': Video frames are not saved to disk. (default)</li> <li>'1': Video frames are saved to files in the format 'SDL_windowX-Y.bmp', where X is the window ID, and Y is the frame number.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const VideoOffScreenSaveFrames = SDL_HINT_VIDEO_OFFSCREEN_SAVE_FRAMES</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoSyncWindowOperations","title":"VideoSyncWindowOperations","text":"<p>A variable controlling whether all window operations will block until complete.</p> <p>Window systems that run asynchronously may not have the results of window operations that resize or move the window applied immediately upon the return of the requesting function. Setting this hint will cause such operations to block after every call until the pending operation has completed. Setting this to '1' is the equivalent of calling TSdlWindow.Sync after every function call.</p> <p>Be aware that amount of time spent blocking while waiting for window operations to complete can be quite lengthy, as animations may have to complete, which can take upwards of multiple seconds in some cases.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Window operations are non-blocking. (default)</li> <li>'1': Window operations will block until completed.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const VideoSyncWindowOperations = SDL_HINT_VIDEO_SYNC_WINDOW_OPERATIONS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoWaylandAllowLibDecor","title":"VideoWaylandAllowLibDecor","text":"<p>A variable controlling whether the libdecor Wayland backend is allowed to be used.</p> <p>libdecor is used over xdg-shell when xdg-decoration protocol is unavailable.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': libdecor use is disabled.</li> <li>'1': libdecor use is enabled. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const VideoWaylandAllowLibDecor = SDL_HINT_VIDEO_WAYLAND_ALLOW_LIBDECOR</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoWaylandModeEmulation","title":"VideoWaylandModeEmulation","text":"<p>A variable controlling whether video mode emulation is enabled under Wayland.</p> <p>When this hint is set, a standard set of emulated CVT video modes will be exposed for use by the application. If it is disabled, the only modes exposed will be the logical desktop size and, in the case of a scaled desktop, the native display resolution.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Video mode emulation is disabled.</li> <li>'1': Video mode emulation is enabled. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const VideoWaylandModeEmulation = SDL_HINT_VIDEO_WAYLAND_MODE_EMULATION</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoWaylandModeScaling","title":"VideoWaylandModeScaling","text":"<p>A variable controlling how modes with a non-native aspect ratio are displayed under Wayland.</p> <p>When this hint is set, the requested scaling will be used when displaying fullscreen video modes that don't match the display's native aspect ratio. This is contingent on compositor viewport support.</p> <p>The variable can be set to the following values:</p> <ul> <li>'aspect' - Video modes will be displayed scaled, in their proper aspect ratio, with black bars.</li> <li>'stretch' - Video modes will be scaled to fill the entire display. (default)</li> <li>'none' - Video modes will be displayed as 1:1 with no scaling.</li> </ul> <p>This hint should be set before creating a window. </p> <p><code>const VideoWaylandModeScaling = SDL_HINT_VIDEO_WAYLAND_MODE_SCALING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoWaylandPreferLibDecor","title":"VideoWaylandPreferLibDecor","text":"<p>A variable controlling whether the libdecor Wayland backend is preferred over native decorations.</p> <p>When this hint is set, libdecor will be used to provide window decorations, even if xdg-decoration is available. (Note that, by default, libdecor will use xdg-decoration itself if available).</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': libdecor is enabled only if server-side decorations are unavailable. (default)</li> <li>'1': libdecor is always enabled if available.</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const VideoWaylandPreferLibDecor = SDL_HINT_VIDEO_WAYLAND_PREFER_LIBDECOR</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoWaylandScaleToDisplay","title":"VideoWaylandScaleToDisplay","text":"<p>A variable forcing non-DPI-aware Wayland windows to output at 1:1 scaling.</p> <p>This must be set before initializing the video subsystem.</p> <p>When this hint is set, Wayland windows that are not flagged as being DPI-aware will be output with scaling designed to force 1:1 pixel mapping.</p> <p>This is intended to allow legacy applications to be displayed without desktop scaling being applied, and has issues with certain display configurations, as this forces the window to behave in a way that Wayland desktops were not designed to accommodate:</p> <ul> <li>Rounding errors can result with odd window sizes and/or desktop scales, which can cause the window contents to appear slightly blurry.</li> <li>Positioning the window may be imprecise due to unit conversions and rounding.</li> <li>The window may be unusably small on scaled desktops.</li> <li>The window may jump in size when moving between displays of different scale factors.</li> <li>Displays may appear to overlap when using a multi-monitor setup with scaling enabled.</li> <li>Possible loss of cursor precision due to the logical size of the window being reduced.</li> </ul> <p>New applications should be designed with proper DPI awareness handling instead of enabling this.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Windows will be scaled normally.</li> <li>'1': Windows will be forced to scale to achieve 1:1 output.</li> </ul> <p>This hint should be set before creating a window. </p> <p><code>const VideoWaylandScaleToDisplay = SDL_HINT_VIDEO_WAYLAND_SCALE_TO_DISPLAY</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoWinD3DCompiler","title":"VideoWinD3DCompiler","text":"<p>A variable specifying which shader compiler to preload when using the Chrome ANGLE binaries.</p> <p>SDL has EGL and OpenGL ES2 support on Windows via the ANGLE project. It can use two different sets of binaries, those compiled by the user from source or those provided by the Chrome browser. In the later case, these binaries require that SDL loads a DLL providing the shader compiler.</p> <p>The variable can be set to the following values:</p> <ul> <li>'d3dcompiler_46.dll' - best for Vista or later. (default)</li> <li>'d3dcompiler_43.dll' - for XP support.</li> <li>'none' - do not load any library, useful if you compiled ANGLE from source and included the compiler in your binaries.</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const VideoWinD3DCompiler = SDL_HINT_VIDEO_WIN_D3DCOMPILER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoX11NetWMBypassCompositor","title":"VideoX11NetWMBypassCompositor","text":"<p>A variable controlling whether the X11 _NET_WM_BYPASS_COMPOSITOR hint should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Disable _NET_WM_BYPASS_COMPOSITOR.</li> <li>'1': Enable _NET_WM_BYPASS_COMPOSITOR. (default)</li> </ul> <p>This hint should be set before creating a window. </p> <p><code>const VideoX11NetWMBypassCompositor = SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoX11NetWMPing","title":"VideoX11NetWMPing","text":"<p>A variable controlling whether the X11 _NET_WM_PING protocol should be supported.</p> <p>By default SDL will use _NET_WM_PING, but for applications that know they will not always be able to respond to ping requests in a timely manner they can turn it off to avoid the window manager thinking the app is hung.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Disable _NET_WM_PING.</li> <li>'1': Enable _NET_WM_PING. (default)</li> </ul> <p>This hint should be set before creating a window. </p> <p><code>const VideoX11NetWMPing = SDL_HINT_VIDEO_X11_NET_WM_PING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoX11NoDirectColor","title":"VideoX11NoDirectColor","text":"<p>A variable controlling whether SDL uses DirectColor visuals.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Disable DirectColor visuals.</li> <li>'1': Enable DirectColor visuals. (default)</li> </ul> <p>This hint should be set before initializing the video subsystem. </p> <p><code>const VideoX11NoDirectColor = SDL_HINT_VIDEO_X11_NODIRECTCOLOR</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoX11ScalingFactor","title":"VideoX11ScalingFactor","text":"<p>A variable forcing the content scaling factor for X11 displays.</p> <p>The variable can be set to a floating point value in the range 1.0-10.0</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const VideoX11ScalingFactor = SDL_HINT_VIDEO_X11_SCALING_FACTOR</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoX11VisualID","title":"VideoX11VisualID","text":"<p>A variable forcing the visual ID used for X11 display modes.</p> <p>This hint should be set before initializing the video subsystem. </p> <p><code>const VideoX11VisualID = SDL_HINT_VIDEO_X11_VISUALID</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoX11WindowVisualID","title":"VideoX11WindowVisualID","text":"<p>A variable forcing the visual ID chosen for new X11 windows.</p> <p>This hint should be set before creating a window. </p> <p><code>const VideoX11WindowVisualID = SDL_HINT_VIDEO_X11_WINDOW_VISUALID</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VideoX11XRandR","title":"VideoX11XRandR","text":"<p>A variable controlling whether the X11 XRandR extension should be used.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Disable XRandR.</li> <li>'1': Enable XRandR. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const VideoX11XRandR = SDL_HINT_VIDEO_X11_XRANDR</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VitaEnableBackTouch","title":"VitaEnableBackTouch","text":"<p>A variable controlling whether touch should be enabled on the back panel of the PlayStation Vita.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Disable touch on the back panel.</li> <li>'1': Enable touch on the back panel. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const VitaEnableBackTouch = SDL_HINT_VITA_ENABLE_BACK_TOUCH</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VitaEnableFrontTouch","title":"VitaEnableFrontTouch","text":"<p>A variable controlling whether touch should be enabled on the front panel of the PlayStation Vita.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Disable touch on the front panel.</li> <li>'1': Enable touch on the front panel. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const VitaEnableFrontTouch = SDL_HINT_VITA_ENABLE_FRONT_TOUCH</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VitaModulePath","title":"VitaModulePath","text":"<p>A variable controlling the module path on the PlayStation Vita.</p> <p>This hint defaults to 'app0:module'</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const VitaModulePath = SDL_HINT_VITA_MODULE_PATH</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VitaPvrInit","title":"VitaPvrInit","text":"<p>A variable controlling whether to perform PVR initialization on the PlayStation Vita.</p> <ul> <li>'0': Skip PVR initialization.</li> <li>'1': Perform the normal PVR initialization. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const VitaPvrInit = SDL_HINT_VITA_PVR_INIT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VitaPvrOpenGL","title":"VitaPvrOpenGL","text":"<p>A variable controlling whether OpenGL should be used instead of OpenGL ES on the PlayStation Vita.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Use OpenGL ES. (default)</li> <li>'1': Use OpenGL.</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const VitaPvrOpenGL = SDL_HINT_VITA_PVR_OPENGL</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VitaResolution","title":"VitaResolution","text":"<p>A variable overriding the resolution reported on the PlayStation Vita.</p> <p>The variable can be set to the following values:</p> <ul> <li>'544': 544p (default)</li> <li>'720': 725p for PSTV</li> <li>'1080': 1088i for PSTV</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const VitaResolution = SDL_HINT_VITA_RESOLUTION</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VitaTouchMouseDevice","title":"VitaTouchMouseDevice","text":"<p>A variable controlling which touchpad should generate synthetic mouse events.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Only front touchpad should generate mouse events. (default)</li> <li>'1': Only back touchpad should generate mouse events.</li> <li>'2': Both touchpads should generate mouse events.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const VitaTouchMouseDevice = SDL_HINT_VITA_TOUCH_MOUSE_DEVICE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VulkanDisplay","title":"VulkanDisplay","text":"<p>A variable overriding the display index used in SdlVulkanCreateSurface.</p> <p>The display index starts at 0, which is the default.</p> <p>This hint should be set before calling SdlVulkanCreateSurface. </p> <p><code>const VulkanDisplay = SDL_HINT_VULKAN_DISPLAY</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#VulkanLibrary","title":"VulkanLibrary","text":"<p>Specify the Vulkan library to load.</p> <p>This hint should be set before creating a Vulkan window or calling SdlVulkanLoadLibrary. </p> <p><code>const VulkanLibrary = SDL_HINT_VULKAN_LIBRARY</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WaveChunkLimit","title":"WaveChunkLimit","text":"<p>A variable controlling the maximum number of chunks in a WAVE file.</p> <p>This sets an upper bound on the number of chunks in a WAVE file to avoid wasting time on malformed or corrupt WAVE files. This defaults to '10000'.</p> <p>This hint should be set before calling TSdlAudioBuffer.CreateFromWav. </p> <p><code>const WaveChunkLimit = SDL_HINT_WAVE_CHUNK_LIMIT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WaveFactChunk","title":"WaveFactChunk","text":"<p>A variable controlling how the fact chunk affects the loading of a WAVE file.</p> <p>The fact chunk stores information about the number of samples of a WAVE file. The Standards Update from Microsoft notes that this value can be used to 'determine the length of the data in seconds'. This is especially useful for compressed formats (for which this is a mandatory chunk) if they produce multiple sample frames per block and truncating the block is not allowed. The fact chunk can exactly specify how many sample frames there should be in this case.</p> <p>Unfortunately, most application seem to ignore the fact chunk and so SDL ignores it by default as well.</p> <p>The variable can be set to the following values:</p> <ul> <li>'truncate' - Use the number of samples to truncate the wave data if the fact chunk is present and valid.</li> <li>'strict' - Like 'truncate', but raise an error if the fact chunk is invalid, not present for non-PCM formats, or if the data chunk doesn't have that many samples.</li> <li>'ignorezero' - Like 'truncate', but ignore fact chunk if the number of samples is zero.</li> <li>'ignore' - Ignore fact chunk entirely. (default)</li> </ul> <p>This hint should be set before calling TSdlAudioBuffer.CreateFromWav. </p> <p><code>const WaveFactChunk = SDL_HINT_WAVE_FACT_CHUNK</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WaveRiffChunkSize","title":"WaveRiffChunkSize","text":"<p>A variable controlling how the size of the RIFF chunk affects the loading of a WAVE file.</p> <p>The size of the RIFF chunk (which includes all the sub-chunks of the WAVE file) is not always reliable. In case the size is wrong, it's possible to just ignore it and step through the chunks until a fixed limit is reached.</p> <p>Note that files that have trailing data unrelated to the WAVE file or corrupt files may slow down the loading process without a reliable boundary. By default, SDL stops after 10000 chunks to prevent wasting time. Use WaveChunkLimit to adjust this value.</p> <p>The variable can be set to the following values:</p> <ul> <li>'force' - Always use the RIFF chunk size as a boundary for the chunk search.</li> <li>'ignorezero' - Like 'force', but a zero size searches up to 4 GiB. (default)</li> <li>'ignore' - Ignore the RIFF chunk size and always search up to 4 GiB.</li> <li>'maximum' - Search for chunks until the end of file. (not recommended)</li> </ul> <p>This hint should be set before calling TSdlAudioBuffer.CreateFromWav. </p> <p><code>const WaveRiffChunkSize = SDL_HINT_WAVE_RIFF_CHUNK_SIZE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WaveTruncation","title":"WaveTruncation","text":"<p>A variable controlling how a truncated WAVE file is handled.</p> <p>A WAVE file is considered truncated if any of the chunks are incomplete or the data chunk size is not a multiple of the block size. By default, SDL decodes until the first incomplete block, as most applications seem to do.</p> <p>The variable can be set to the following values:</p> <ul> <li>'verystrict' - Raise an error if the file is truncated.</li> <li>'strict' - Like 'verystrict', but the size of the RIFF chunk is ignored.</li> <li>'dropframe' - Decode until the first incomplete sample frame.</li> <li>'dropblock' - Decode until the first incomplete block. (default)</li> </ul> <p>This hint should be set before calling TSdlAudioBuffer.CreateFromWav. </p> <p><code>const WaveTruncation = SDL_HINT_WAVE_TRUNCATION</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WindowActivateWhenRaised","title":"WindowActivateWhenRaised","text":"<p>A variable controlling whether the window is activated when the TSdlWindow.Raise function is called.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': The window is not activated when the TSdlWindow.Raise function is called.</li> <li>'1': The window is activated when the TSdlWindow.Raise function is called. (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const WindowActivateWhenRaised = SDL_HINT_WINDOW_ACTIVATE_WHEN_RAISED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WindowActivateWhenShown","title":"WindowActivateWhenShown","text":"<p>A variable controlling whether the window is activated when the TSdlWindow.Show function is called.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': The window is not activated when the TSdlWindow.Show function is called.</li> <li>'1': The window is activated when the TSdlWindow.Show function is called. (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const WindowActivateWhenShown = SDL_HINT_WINDOW_ACTIVATE_WHEN_SHOWN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WindowAllowTopMost","title":"WindowAllowTopMost","text":"<p>If set to '0' then never set the top-most flag on an SDL Window even if the application requests it.</p> <p>This is a debugging aid for developers and not expected to be used by end users.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': don't allow topmost</li> <li>'1': allow topmost (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const WindowAllowTopMost = SDL_HINT_WINDOW_ALLOW_TOPMOST</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WindowCloseOnAltF4","title":"WindowCloseOnAltF4","text":"<p>A variable controlling whether SDL generates window-close events for Alt+F4 on Windows.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': SDL will only do normal key handling for Alt+F4.</li> <li>'1': SDL will generate a window-close event when it sees Alt+F4. (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const WindowCloseOnAltF4 = SDL_HINT_WINDOWS_CLOSE_ON_ALT_F4</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WindowFrameUsableWhileCursorHidden","title":"WindowFrameUsableWhileCursorHidden","text":"<p>A variable controlling whether the window frame and title bar are interactive when the cursor is hidden.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': The window frame is not interactive when the cursor is hidden (no move, resize, etc).</li> <li>'1': The window frame is interactive when the cursor is hidden. (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const WindowFrameUsableWhileCursorHidden = SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WindowsEnableMenuMnemonics","title":"WindowsEnableMenuMnemonics","text":"<p>A variable controlling whether menus can be opened with their keyboard shortcut (Alt+mnemonic).</p> <p>If the mnemonics are enabled, then menus can be opened by pressing the Alt key and the corresponding mnemonic (for example, Alt+F opens the File menu). However, in case an invalid mnemonic is pressed, Windows makes an audible beep to convey that nothing happened. This is true even if the window has no menu at all!</p> <p>Because most SDL applications don't have menus, and some want to use the Alt key for other purposes, SDL disables mnemonics (and the beeping) by default.</p> <p>Note: This also affects keyboard events: with mnemonics enabled, when a menu is opened from the keyboard, you will not receive a KEYUP event for the mnemonic key, and might not receive one for Alt.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Alt+mnemonic does nothing, no beeping. (default)</li> <li>'1': Alt+mnemonic opens menus, invalid mnemonics produce a beep.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const WindowsEnableMenuMnemonics = SDL_HINT_WINDOWS_ENABLE_MENU_MNEMONICS</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WindowsEnableMessageLoop","title":"WindowsEnableMessageLoop","text":"<p>A variable controlling whether the windows message loop is processed by SDL.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': The window message loop is not run.</li> <li>'1': The window message loop is processed in TSdlEvents.Pump. (default)</li> </ul> <p>This hint can be set anytime. </p> <p><code>const WindowsEnableMessageLoop = SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WindowsEraseBackgroundMode","title":"WindowsEraseBackgroundMode","text":"<p>A variable controlling whether SDL will clear the window contents when the WM_ERASEBKGND message is received.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0'/'never': Never clear the window.</li> <li>'1'/'initial': Clear the window when the first WM_ERASEBKGND event fires. (default)</li> <li>'2'/'always': Clear the window on every WM_ERASEBKGND event.</li> </ul> <p>This hint should be set before creating a window. </p> <p><code>const WindowsEraseBackgroundMode = SDL_HINT_WINDOWS_ERASE_BACKGROUND_MODE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WindowsForceSemaphoreKernel","title":"WindowsForceSemaphoreKernel","text":"<p>A variable controlling whether SDL uses Kernel Semaphores on Windows.</p> <p>Kernel Semaphores are inter-process and require a context switch on every interaction. On Windows 8 and newer, the WaitOnAddress API is available. Using that and atomics to implement semaphores increases performance. SDL will fall back to Kernel Objects on older OS versions or if forced to by this hint.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Use Atomics and WaitOnAddress API when available, otherwise fall back to Kernel Objects. (default)</li> <li>'1': Force the use of Kernel Objects in all cases.</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const WindowsForceSemaphoreKernel = SDL_HINT_WINDOWS_FORCE_SEMAPHORE_KERNEL</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WindowsGameInput","title":"WindowsGameInput","text":"<p>A variable controlling whether GameInput is used for raw keyboard and mouse on Windows.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': GameInput is not used for raw keyboard and mouse events.</li> <li>'1': GameInput is used for raw keyboard and mouse events, if available. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const WindowsGameInput = SDL_HINT_WINDOWS_GAMEINPUT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WindowsIntResourceIcon","title":"WindowsIntResourceIcon","text":"<p>A variable to specify custom icon resource id from RC file on Windows platform.</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const WindowsIntResourceIcon = SDL_HINT_WINDOWS_INTRESOURCE_ICON</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WindowsIntResourceIconSmall","title":"WindowsIntResourceIconSmall","text":"<p>A variable to specify custom icon resource id from RC file on Windows platform.</p> <p>This hint should be set before SDL is initialized. </p> <p><code>const WindowsIntResourceIconSmall = SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WindowsRawKeyboard","title":"WindowsRawKeyboard","text":"<p>A variable controlling whether raw keyboard events are used on Windows.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': The Windows message loop is used for keyboard events. (default)</li> <li>'1': Low latency raw keyboard events are used.</li> </ul> <p>This hint can be set anytime. </p> <p><code>const WindowsRawKeyboard = SDL_HINT_WINDOWS_RAW_KEYBOARD</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#WindowsUseD3D9Ex","title":"WindowsUseD3D9Ex","text":"<p>A variable controlling whether SDL uses the D3D9Ex API introduced in Windows Vista, instead of normal D3D9.</p> <p>Direct3D 9Ex contains changes to state management that can eliminate device loss errors during scenarios like Alt+Tab or UAC prompts. D3D9Ex may require some changes to your application to cope with the new behavior, so this is disabled by default.</p> <p>For more information on Direct3D 9Ex, see:</p> <ul> <li> <p>Direct3D-9Ex-  Direct3D 9Ex improvementsThe variable can be set to the following values:</p> </li> <li> <p>'0': Use the original Direct3D 9 API. (default)</p> </li> <li>'1': Use the Direct3D 9Ex API on Vista and later (and fall back if D3D9Ex is unavailable)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const WindowsUseD3D9Ex = SDL_HINT_WINDOWS_USE_D3D9EX</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#X11ForceOverrideRedirect","title":"X11ForceOverrideRedirect","text":"<p>A variable controlling whether X11 windows are marked as override-redirect.</p> <p>If set, this might increase framerate at the expense of the desktop not working as expected. Override-redirect windows aren't noticed by the window manager at all.</p> <p>You should probably only use this for fullscreen windows, and you probably shouldn't even use it for that. But it's here if you want to try!</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': Do not mark the window as override-redirect. (default)</li> <li>'1': Mark the window as override-redirect.</li> </ul> <p>This hint should be set before creating a window. </p> <p><code>const X11ForceOverrideRedirect = SDL_HINT_X11_FORCE_OVERRIDE_REDIRECT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#X11WindowType","title":"X11WindowType","text":"<p>A variable specifying the type of an X11 window.</p> <p>During SDL_CreateWindow, SDL uses the _NET_WM_WINDOW_TYPE X11 property to report to the window manager the type of window it wants to create. This might be set to various things if TSdlWindowFlag.Tooltip or TSdlWindowFlag.PopupMenu, etc, were specified. For 'normal' windows that haven't set a specific type, this hint can be used to specify a custom type. For example, a dock window might set this to '_NET_WM_WINDOW_TYPE_DOCK'.</p> <p>This hint should be set before creating a window. </p> <p><code>const X11WindowType = SDL_HINT_X11_WINDOW_TYPE</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#X11XcbLibrary","title":"X11XcbLibrary","text":"<p>Specify the XCB library to load for the X11 driver.</p> <p>The default is platform-specific, often 'libX11-xcb.so.1'.</p> <p>This hint should be set before initializing the video subsystem. </p> <p><code>const X11XcbLibrary = SDL_HINT_X11_XCB_LIBRARY</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#XInputEnabled","title":"XInputEnabled","text":"<p>A variable controlling whether XInput should be used for controller handling.</p> <p>The variable can be set to the following values:</p> <ul> <li>'0': XInput is not enabled.</li> <li>'1': XInput is enabled. (default)</li> </ul> <p>This hint should be set before SDL is initialized. </p> <p><code>const XInputEnabled = SDL_HINT_XINPUT_ENABLED</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#Hints","title":"Hints","text":"<p>The hint values.</p> <p>When getting, returns an empty string if not set.</p> <p>When setting, it sets the hint with normal priority. Hints will not be set if there is an existing override hint or environment variable that takes precedence. You can use Apply with a priority to set the hint with override priority instead. </p> <p><code>class property Hints[const AName: PUTF8Char]: String read GetHint write SetHint; default</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#see-also","title":"See Also","text":"<ul> <li>Apply</li> <li>Get</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#remarks","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#Destroy","title":"<code>Destroy</code>","text":"<p><code>class destructor Destroy</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#AddCallback","title":"AddCallback(PUTF8Char, TSdlHintCallback)","text":"<p>Add a callback to watch a particular hint.</p> <p>The callback function is called during this method, to provide it an initial value, and again each time the hint's value changes. </p> <p><code>class procedure AddCallback(const AName: PUTF8Char; const ACallback: TSdlHintCallback); static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#parameters","title":"Parameters","text":"<p><code>AName</code>: <code>PUTF8Char</code> : The hint to watch (one of the TSdlHints constants).</p> <p><code>ACallback</code>: <code>TSdlHintCallback</code> : TSdlHintCallback function that will be called when the hint value changes.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#see-also_1","title":"See Also","text":"<ul> <li>RemoveCallback</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#remarks_1","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#Apply_0","title":"Apply(PUTF8Char, String)","text":"<p>Set a hint with normal priority.</p> <p>Hints will not be set if there is an existing override hint or environment variable that takes precedence. You can use the other overload to set the hint with override priority instead. </p> <p><code>class procedure Apply(const AName: PUTF8Char; const AValue: String); overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#parameters_1","title":"Parameters","text":"<p><code>AName</code>: <code>PUTF8Char</code> : The hint to set (one of the TSdlHints constants).</p> <p><code>AValue</code>: <code>String</code> : The value of the hint variable.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#see-also_2","title":"See Also","text":"<ul> <li>Get</li> <li>Reset</li> <li>Hints</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#remarks_2","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#Apply_1","title":"Apply(PUTF8Char, String, TSdlHintPriority)","text":"<p>Set a hint with a specific priority.</p> <p>The priority controls the behavior when setting a hint that already has a value. Hints will replace existing hints of their priority and lower. Environment variables are considered to have override priority. </p> <p><code>class procedure Apply(const AName: PUTF8Char; const AValue: String; const APriority: TSdlHintPriority); overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#parameters_2","title":"Parameters","text":"<p><code>AName</code>: <code>PUTF8Char</code> : The hint to set (one of the TSdlHints constants).</p> <p><code>AValue</code>: <code>String</code> : The value of the hint variable.</p> <p><code>APriority</code>: <code>TSdlHintPriority</code> : Priority level for the hint.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#see-also_3","title":"See Also","text":"<ul> <li>Get</li> <li>Reset</li> <li>Hints</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#remarks_3","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#Get","title":"Get(PUTF8Char)","text":"<p>Get the value of a hint. </p> <p><code>class function Get(const AName: PUTF8Char): String; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#parameters_3","title":"Parameters","text":"<p><code>AName</code>: <code>PUTF8Char</code> : The hint to query (one of the TSdlHints constants).</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#returns","title":"Returns","text":"<p><code>String</code>: The value of the hint or an empty string if the hint does not exist.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#see-also_4","title":"See Also","text":"<ul> <li>Apply</li> <li>Hints</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#remarks_4","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#GetBoolean","title":"GetBoolean(PUTF8Char, Boolean)","text":"<p>Get the Boolean value of a hint variable. </p> <p><code>class function GetBoolean(const AName: PUTF8Char; const ADefaultValue: Boolean = False): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#parameters_4","title":"Parameters","text":"<p><code>AName</code>: <code>PUTF8Char</code> : The name of the hint to get the boolean value from (one of the TSdlHints constants).</p> <p><code>ADefaultValue</code>: <code>Boolean = False</code> : (Optional) value to return if the hint does not exist. Defaults to False.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#returns_1","title":"Returns","text":"<p><code>Boolean</code>: The Boolean value of a hint or the provided default value if the hint does not exist.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#see-also_5","title":"See Also","text":"<ul> <li>Get</li> <li>Apply</li> <li>Hints</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#remarks_5","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#RemoveCallback","title":"RemoveCallback(PUTF8Char, TSdlHintCallback)","text":"<p>Remove a callback watching a particular hint. </p> <p><code>class procedure RemoveCallback(const AName: PUTF8Char; const ACallback: TSdlHintCallback); static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#parameters_5","title":"Parameters","text":"<p><code>AName</code>: <code>PUTF8Char</code> : The hint being watched (one of the TSdlHints constants).</p> <p><code>ACallback</code>: <code>TSdlHintCallback</code> : TSdlHintCallback function that will be called when the hint value changes.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#see-also_6","title":"See Also","text":"<ul> <li>AddCallback</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#remarks_6","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#Reset","title":"Reset(PUTF8Char)","text":"<p>Reset a hint to the default value.</p> <p>This will reset a hint to the value of the environment variable, or nil if the environment isn't set. Callbacks will be called normally with this change. </p> <p><code>class procedure Reset(const AName: PUTF8Char); inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#parameters_6","title":"Parameters","text":"<p><code>AName</code>: <code>PUTF8Char</code> : The hint to set (one of the TSdlHints constants).</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#see-also_7","title":"See Also","text":"<ul> <li>Apply</li> <li>ResetAll</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#remarks_7","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#ResetAll","title":"ResetAll","text":"<p>Reset all hints to the default values.</p> <p>This will reset all hints to the value of the associated environment variable, or nil if the environment isn't set. Callbacks will be called normally with this change. </p> <p><code>class procedure ResetAll; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#see-also_8","title":"See Also","text":"<ul> <li>Reset</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlHints/#remarks_8","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/","title":"TSdlLog","text":"<p>Logging functionality. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type TSdlLog = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#properties","title":"Properties","text":"Name Description CustomOutputFunction A custom log output function, or nil to use the default log function. Priorities The priorities of log categories."},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#constructors","title":"Constructors","text":"Name Description Create"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#methods","title":"Methods","text":"Name Description Critical(String, const[], TSdlLogCategory) Log a message with TSdlLogPriority.Critical. Critical(String, TSdlLogCategory) Log a message with TSdlLogPriority.Critical. Debug(String, const[], TSdlLogCategory) Log a message with TSdlLogPriority.Debug. Debug(String, TSdlLogCategory) Log a message with TSdlLogPriority.Debug. Error(String, const[], TSdlLogCategory) Log a message with TSdlLogPriority.Error. Error(String, TSdlLogCategory) Log a message with TSdlLogPriority.Error. Info(String, const[], TSdlLogCategory) Log a message with TSdlLogCategory.Application and TSdlLogPriority.Info. Info(String, TSdlLogCategory) Log a message with TSdlLogCategory.Application and TSdlLogPriority.Info. Message(TSdlLogCategory, TSdlLogPriority, String, const[]) Log a message with the specified category and priority. Message(TSdlLogCategory, TSdlLogPriority, String) Log a message with the specified category and priority. ResetPriorities Reset all priorities to default. SetAllPriorities Set the priority of all log categories. SetPriorityPrefix Set the text prepended to log messages of a given priority. Trace(String, const[], TSdlLogCategory) Log a message with TSdlLogPriority.Trace. Trace(String, TSdlLogCategory) Log a message with TSdlLogPriority.Trace. Verbose(String, const[], TSdlLogCategory) Log a message with TSdlLogPriority.Verbose. Verbose(String, TSdlLogCategory) Log a message with TSdlLogPriority.Verbose. Warn(String, const[], TSdlLogCategory) Log a message with TSdlLogPriority.Warn. Warn(String, TSdlLogCategory) Log a message with TSdlLogPriority.Warn."},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#CustomOutputFunction","title":"CustomOutputFunction","text":"<p>A custom log output function, or nil to use the default log function.</p> <p>Note that using a custom log output function can impact performance, especially when a lot of messages are logged (for example, when using a log log priority). </p> <p><code>class property CustomOutputFunction: TSdlLogOutputFunction read FCustomOutputFunction write SetCustomOutputFunction</code></p> <p>Type: <code>TSdlLogOutputFunction</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Priorities","title":"Priorities","text":"<p>The priorities of log categories. </p> <p><code>class property Priorities[const ACategory: TSdlLogCategory]: TSdlLogPriority read GetPriority write SetPriority</code></p> <p>Type: <code>TSdlLogPriority</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#see-also","title":"See Also","text":"<ul> <li>ResetPriorities</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_1","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Create","title":"<code>Create</code>","text":"<p><code>class constructor Create</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Critical_0","title":"Critical(String, const[], TSdlLogCategory)","text":"<p>Log a message with TSdlLogPriority.Critical. </p> <p><code>class procedure Critical(const AMessage: String; const AArgs: array of const; const ACategory: TSdlLogCategory = TSdlLogCategory.Application); overload; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters","title":"Parameters","text":"<p><code>AMessage</code>: <code>String</code> : The message</p> <p><code>AArgs</code>: <code>array of const</code> : Additional arguments matching the format specifiers.</p> <p><code>ACategory</code>: <code>TSdlLogCategory = TSdlLogCategory.Application</code> : (Optional) category. Defaults to Application.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_2","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Critical_1","title":"Critical(String, TSdlLogCategory)","text":"<p>Log a message with TSdlLogPriority.Critical. </p> <p><code>class procedure Critical(const AMessage: String; const ACategory: TSdlLogCategory = TSdlLogCategory.Application); overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_1","title":"Parameters","text":"<p><code>AMessage</code>: <code>String</code> : The message</p> <p><code>ACategory</code>: <code>TSdlLogCategory = TSdlLogCategory.Application</code> : (Optional) category. Defaults to Application.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_3","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Debug_0","title":"Debug(String, const[], TSdlLogCategory)","text":"<p>Log a message with TSdlLogPriority.Debug. </p> <p><code>class procedure Debug(const AMessage: String; const AArgs: array of const; const ACategory: TSdlLogCategory = TSdlLogCategory.Application); overload; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_2","title":"Parameters","text":"<p><code>AMessage</code>: <code>String</code> : The message</p> <p><code>AArgs</code>: <code>array of const</code> : Additional arguments matching the format specifiers.</p> <p><code>ACategory</code>: <code>TSdlLogCategory = TSdlLogCategory.Application</code> : (Optional) category. Defaults to Application.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_4","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Debug_1","title":"Debug(String, TSdlLogCategory)","text":"<p>Log a message with TSdlLogPriority.Debug. </p> <p><code>class procedure Debug(const AMessage: String; const ACategory: TSdlLogCategory = TSdlLogCategory.Application); overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_3","title":"Parameters","text":"<p><code>AMessage</code>: <code>String</code> : The message</p> <p><code>ACategory</code>: <code>TSdlLogCategory = TSdlLogCategory.Application</code> : (Optional) category. Defaults to Application.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_5","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Error_0","title":"Error(String, const[], TSdlLogCategory)","text":"<p>Log a message with TSdlLogPriority.Error. </p> <p><code>class procedure Error(const AMessage: String; const AArgs: array of const; const ACategory: TSdlLogCategory = TSdlLogCategory.Application); overload; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_4","title":"Parameters","text":"<p><code>AMessage</code>: <code>String</code> : The message</p> <p><code>AArgs</code>: <code>array of const</code> : Additional arguments matching the format specifiers.</p> <p><code>ACategory</code>: <code>TSdlLogCategory = TSdlLogCategory.Application</code> : (Optional) category. Defaults to Application.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_6","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Error_1","title":"Error(String, TSdlLogCategory)","text":"<p>Log a message with TSdlLogPriority.Error. </p> <p><code>class procedure Error(const AMessage: String; const ACategory: TSdlLogCategory = TSdlLogCategory.Application); overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_5","title":"Parameters","text":"<p><code>AMessage</code>: <code>String</code> : The message</p> <p><code>ACategory</code>: <code>TSdlLogCategory = TSdlLogCategory.Application</code> : (Optional) category. Defaults to Application.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_7","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Info_0","title":"Info(String, const[], TSdlLogCategory)","text":"<p>Log a message with TSdlLogCategory.Application and TSdlLogPriority.Info. </p> <p><code>class procedure Info(const AMessage: String; const AArgs: array of const; const ACategory: TSdlLogCategory = TSdlLogCategory.Application); overload; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_6","title":"Parameters","text":"<p><code>AMessage</code>: <code>String</code> : The message with format specifiers.</p> <p><code>AArgs</code>: <code>array of const</code> : Additional arguments matching the format specifiers.</p> <p><code>ACategory</code>: <code>TSdlLogCategory = TSdlLogCategory.Application</code> : (Optional) category. Defaults to Application.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_8","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Info_1","title":"Info(String, TSdlLogCategory)","text":"<p>Log a message with TSdlLogCategory.Application and TSdlLogPriority.Info. </p> <p><code>class procedure Info(const AMessage: String; const ACategory: TSdlLogCategory = TSdlLogCategory.Application); overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_7","title":"Parameters","text":"<p><code>AMessage</code>: <code>String</code> : The message</p> <p><code>ACategory</code>: <code>TSdlLogCategory = TSdlLogCategory.Application</code> : (Optional) category. Defaults to Application.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_9","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Message_0","title":"Message(TSdlLogCategory, TSdlLogPriority, String, const[])","text":"<p>Log a message with the specified category and priority. </p> <p><code>class procedure Message(const ACategory: TSdlLogCategory; const APriority: TSdlLogPriority; const AMessage: String; const AArgs: array of const); overload; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_8","title":"Parameters","text":"<p><code>ACategory</code>: <code>TSdlLogCategory</code> : The category of the message.</p> <p><code>APriority</code>: <code>TSdlLogPriority</code> : The priority of the message.</p> <p><code>AMessage</code>: <code>String</code> : The message</p> <p><code>AArgs</code>: <code>array of const</code> : Additional arguments matching the format specifiers.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_10","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Message_1","title":"Message(TSdlLogCategory, TSdlLogPriority, String)","text":"<p>Log a message with the specified category and priority. </p> <p><code>class procedure Message(const ACategory: TSdlLogCategory; const APriority: TSdlLogPriority; const AMessage: String); overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_9","title":"Parameters","text":"<p><code>ACategory</code>: <code>TSdlLogCategory</code> : The category of the message.</p> <p><code>APriority</code>: <code>TSdlLogPriority</code> : The priority of the message.</p> <p><code>AMessage</code>: <code>String</code> : The message</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_11","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#ResetPriorities","title":"ResetPriorities","text":"<p>Reset all priorities to default.</p> <p>This is called by SdlQuit. </p> <p><code>class procedure ResetPriorities; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#see-also_1","title":"See Also","text":"<ul> <li>SetAllPriorities</li> <li>Priorities</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_12","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#SetAllPriorities","title":"SetAllPriorities(TSdlLogPriority)","text":"<p>Set the priority of all log categories. </p> <p><code>class procedure SetAllPriorities(const APriority: TSdlLogPriority); static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_10","title":"Parameters","text":"<p><code>APriority</code>: <code>TSdlLogPriority</code> : The TSdlLogPriority to assign.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#see-also_2","title":"See Also","text":"<ul> <li>ResetPriorities</li> <li>Priorities</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_13","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#SetPriorityPrefix","title":"SetPriorityPrefix(TSdlLogPriority, String)","text":"<p>Set the text prepended to log messages of a given priority.</p> <p>By default TSdlLogPriority.Info and below have no prefix, and TSdlLogPriority.Warn and higher have a prefix showing their priority, e.g. 'WARNING: '. </p> <p><code>class procedure SetPriorityPrefix(const APriority: TSdlLogPriority; const APrefix: String); static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_11","title":"Parameters","text":"<p><code>APriority</code>: <code>TSdlLogPriority</code> : The TSdlLogPriority to modify.</p> <p><code>APrefix</code>: <code>String</code> : The prefix to use for that log priority, or an empty string to use no prefix.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#see-also_3","title":"See Also","text":"<ul> <li>SetAllPriorities</li> <li>Priorities</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_14","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Trace_0","title":"Trace(String, const[], TSdlLogCategory)","text":"<p>Log a message with TSdlLogPriority.Trace. </p> <p><code>class procedure Trace(const AMessage: String; const AArgs: array of const; const ACategory: TSdlLogCategory = TSdlLogCategory.Application); overload; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_12","title":"Parameters","text":"<p><code>AMessage</code>: <code>String</code> : The message</p> <p><code>AArgs</code>: <code>array of const</code> : Additional arguments matching the format specifiers.</p> <p><code>ACategory</code>: <code>TSdlLogCategory = TSdlLogCategory.Application</code> : (Optional) category. Defaults to Application.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_15","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Trace_1","title":"Trace(String, TSdlLogCategory)","text":"<p>Log a message with TSdlLogPriority.Trace. </p> <p><code>class procedure Trace(const AMessage: String; const ACategory: TSdlLogCategory = TSdlLogCategory.Application); overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_13","title":"Parameters","text":"<p><code>AMessage</code>: <code>String</code> : The message</p> <p><code>ACategory</code>: <code>TSdlLogCategory = TSdlLogCategory.Application</code> : (Optional) category. Defaults to Application.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_16","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Verbose_0","title":"Verbose(String, const[], TSdlLogCategory)","text":"<p>Log a message with TSdlLogPriority.Verbose. </p> <p><code>class procedure Verbose(const AMessage: String; const AArgs: array of const; const ACategory: TSdlLogCategory = TSdlLogCategory.Application); overload; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_14","title":"Parameters","text":"<p><code>AMessage</code>: <code>String</code> : The message</p> <p><code>AArgs</code>: <code>array of const</code> : Additional arguments matching the format specifiers.</p> <p><code>ACategory</code>: <code>TSdlLogCategory = TSdlLogCategory.Application</code> : (Optional) category. Defaults to Application.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_17","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Verbose_1","title":"Verbose(String, TSdlLogCategory)","text":"<p>Log a message with TSdlLogPriority.Verbose. </p> <p><code>class procedure Verbose(const AMessage: String; const ACategory: TSdlLogCategory = TSdlLogCategory.Application); overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_15","title":"Parameters","text":"<p><code>AMessage</code>: <code>String</code> : The message</p> <p><code>ACategory</code>: <code>TSdlLogCategory = TSdlLogCategory.Application</code> : (Optional) category. Defaults to Application.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_18","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Warn_0","title":"Warn(String, const[], TSdlLogCategory)","text":"<p>Log a message with TSdlLogPriority.Warn. </p> <p><code>class procedure Warn(const AMessage: String; const AArgs: array of const; const ACategory: TSdlLogCategory = TSdlLogCategory.Application); overload; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_16","title":"Parameters","text":"<p><code>AMessage</code>: <code>String</code> : The message</p> <p><code>AArgs</code>: <code>array of const</code> : Additional arguments matching the format specifiers.</p> <p><code>ACategory</code>: <code>TSdlLogCategory = TSdlLogCategory.Application</code> : (Optional) category. Defaults to Application.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_19","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#Warn_1","title":"Warn(String, TSdlLogCategory)","text":"<p>Log a message with TSdlLogPriority.Warn. </p> <p><code>class procedure Warn(const AMessage: String; const ACategory: TSdlLogCategory = TSdlLogCategory.Application); overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#parameters_17","title":"Parameters","text":"<p><code>AMessage</code>: <code>String</code> : The message</p> <p><code>ACategory</code>: <code>TSdlLogCategory = TSdlLogCategory.Application</code> : (Optional) category. Defaults to Application.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlLog/#remarks_20","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/","title":"TSdlProperties","text":"<p>A group of SDL properties. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type TSdlProperties = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#properties","title":"Properties","text":"Name Description AsBoolean Boolean property values. AsFloat Floating-point property values. AsNumber Integer property values. AsPointer Pointer property values. AsString String property values. Global The global SDL properties."},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#methods","title":"Methods","text":"Name Description Assign Copy a group of properties. Create Create a group of properties. Delete Delete a property from a group of properties. Enumerate Enumerate the properties contained in this group of properties. Free Destroy this group of properties. GetType Get the type of a property in this group of properties. Has Return whether a property exists in this group of properties. Lock Lock this group of properties. SetPointerWithCleanup Set a pointer property in this group of properties with a cleanup function that is called when the property is deleted. Unlock Unlock this group of properties."},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#AsBoolean","title":"AsBoolean","text":"<p>Boolean property values. </p> <p><code>property AsBoolean[const AName: String]: Boolean read GetAsBoolean write SetAsBoolean</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#remarks","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#AsFloat","title":"AsFloat","text":"<p>Floating-point property values. </p> <p><code>property AsFloat[const AName: String]: Single read GetAsFloat write SetAsFloat</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#remarks_1","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#AsNumber","title":"AsNumber","text":"<p>Integer property values. </p> <p><code>property AsNumber[const AName: String]: Int64 read GetAsNumber write SetAsNumber</code></p> <p>Type: <code>Int64</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#remarks_2","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#AsPointer","title":"AsPointer","text":"<p>Pointer property values.</p> <p>By convention, the names of properties that SDL exposes on objects will start with 'SDL.', and properties that SDL uses internally will start with 'SDL.internal.'. These should be considered read-only and should not be modified by applications. </p> <p><code>property AsPointer[const AName: String]: Pointer read GetAsPointer write SetAsPointer</code></p> <p>Type: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#see-also","title":"See Also","text":"<ul> <li>Has</li> <li>AsBoolean</li> <li>AsFloat</li> <li>AsNumber</li> <li>AsString</li> <li>SetPointerWithCleanup</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#remarks_3","title":"Remarks","text":"<p>Set the value to nil to delete the property.</p> <p>It is safe to use this property from any thread, although the data returned is not protected and could potentially be freed if you set the value to nil or call Delete on these properties from another thread. If you need to avoid this, Lock and Unlock. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#AsString","title":"AsString","text":"<p>String property values. </p> <p><code>property AsString[const AName: String]: String read GetAsString write SetAsString</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#remarks_4","title":"Remarks","text":"<p>Set the value to an empty string to delete the property.</p> <p>It is safe to use this property from any thread, although the data returned is not protected and could potentially be freed if you set the value to an empty string or call Delete on these properties from another thread. If you need to avoid this, Lock and Unlock. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#Global","title":"Global","text":"<p>The global SDL properties. </p> <p><code>class property Global: TSdlProperties read GetGlobal</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#Equal","title":"Equal(TSdlProperties, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlProperties; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlProperties</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlProperties; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#returns_1","title":"Returns","text":"<p><code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#NotEqual","title":"NotEqual(TSdlProperties, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlProperties; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlProperties</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#Assign","title":"Assign(TSdlProperties)","text":"<p>Copy a group of properties.</p> <p>Copy all the properties from ASource to this group, with the exception of properties requiring cleanup (set using SetPointerWithCleanup), which will not be copied. Any property that already exists in this group will be overwritten. </p> <p><code>procedure Assign(const ASource: TSdlProperties); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#exceptions_6","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#parameters_3","title":"Parameters","text":"<p><code>ASource</code>: <code>TSdlProperties</code> : The properties to copy.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#remarks_5","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#Create","title":"Create","text":"<p>Create a group of properties.</p> <p>All properties are automatically destroyed when SdlQuit is called. </p> <p><code>class function Create: TSdlProperties; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#exceptions_7","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#returns_3","title":"Returns","text":"<p><code>TSdlProperties</code>: A new group of properties.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#see-also_1","title":"See Also","text":"<ul> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#remarks_6","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#Delete","title":"Delete(String)","text":"<p>Delete a property from a group of properties. </p> <p><code>procedure Delete(const AName: String); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#exceptions_8","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#parameters_4","title":"Parameters","text":"<p><code>AName</code>: <code>String</code> : The name of the property to delete.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#remarks_7","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#Enumerate","title":"Enumerate(TSdlEnumeratePropertiesCallback)","text":"<p>Enumerate the properties contained in this group of properties.</p> <p>The callback function is called for each property in the group of properties. The properties are locked during enumeration. </p> <p><code>procedure Enumerate(const ACallback: TSdlEnumeratePropertiesCallback)</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#exceptions_9","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#parameters_5","title":"Parameters","text":"<p><code>ACallback</code>: <code>TSdlEnumeratePropertiesCallback</code> : The function to call for each property.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#remarks_8","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#Free","title":"Free","text":"<p>Destroy this group of properties.</p> <p>All properties are deleted and their cleanup functions will be called, if any. </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#remarks_9","title":"Remarks","text":"<p>This function should not be called while these properties are locked or other threads might be setting or getting values from these properties. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#GetType","title":"GetType(String)","text":"<p>Get the type of a property in this group of properties. </p> <p><code>function GetType(const AName: String): TSdlPropertyType; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#parameters_6","title":"Parameters","text":"<p><code>AName</code>: <code>String</code> : The name of the property to query.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#returns_4","title":"Returns","text":"<p><code>TSdlPropertyType</code>: The type of the property, or TSdlPropertyType.Invalid if it is not set.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#see-also_2","title":"See Also","text":"<ul> <li>Has</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#remarks_10","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#Has","title":"Has(String)","text":"<p>Return whether a property exists in this group of properties. </p> <p><code>function Has(const AName: String): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#parameters_7","title":"Parameters","text":"<p><code>AName</code>: <code>String</code> : The name of the property to query.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#returns_5","title":"Returns","text":"<p><code>Boolean</code>: True if the property exists, or False if it doesn't.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#see-also_3","title":"See Also","text":"<ul> <li>GetType</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#remarks_11","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#Lock","title":"Lock","text":"<p>Lock this group of properties.</p> <p>Obtain a multi-threaded lock for these properties. Other threads will wait while trying to lock these properties until they are unlocked. Properties must be unlocked before they are destroyed.</p> <p>The lock is automatically taken when setting individual properties, this function is only needed when you want to set several properties atomically or want to guarantee that properties being queried aren't freed in another thread. </p> <p><code>procedure Lock; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#exceptions_10","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#see-also_4","title":"See Also","text":"<ul> <li>Unlock</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#remarks_12","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#SetPointerWithCleanup","title":"SetPointerWithCleanup(String, Pointer, TSdlPropertyCleanupCallback)","text":"<p>Set a pointer property in this group of properties with a cleanup function that is called when the property is deleted.</p> <p>The cleanup function is also called if setting the property fails for any reason.</p> <p>For simply setting basic data types, like numbers, bools, or strings, use AsNumber, AsBoolean or AsString instead, as those functions will handle cleanup on your behalf. This function is only for more complex, custom data. </p> <p><code>procedure SetPointerWithCleanup(const AName: String; const AValue: Pointer; const ACleanup: TSdlPropertyCleanupCallback)</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#exceptions_11","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#parameters_8","title":"Parameters","text":"<p><code>AName</code>: <code>String</code> : The name of the property to modify.</p> <p><code>AValue</code>: <code>Pointer</code> : The new value of the property, or nil to delete the property.</p> <p><code>ACleanup</code>: <code>TSdlPropertyCleanupCallback</code> : The function to call when this property is deleted, or nil if no cleanup is necessary.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#see-also_5","title":"See Also","text":"<ul> <li>AsPointer</li> <li>TSdlPropertyCleanupCallback</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#remarks_13","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#Unlock","title":"Unlock","text":"<p>Unlock this group of properties. </p> <p><code>procedure Unlock; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#see-also_6","title":"See Also","text":"<ul> <li>Lock</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperties/#remarks_14","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/","title":"TSdlProperty","text":"<p>Standard SDL properties </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type TSdlProperty = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#constants","title":"Constants","text":"Name Description AppMetadataCopyright AppMetadataCreator AppMetadataIdentifier AppMetadataName AppMetadataType AppMetadataUrl AppMetadataVersion GamepadCapMonoLed GamepadCapPlayerLed GamepadCapRgbLed GamepadCapRumble GamepadCapTriggerRumble GpuBufferCreateName GpuComputePipelineCreateName GpuDeviceCreateD3D12SemanticName GpuDeviceCreateDebugMode GpuDeviceCreateName GpuDeviceCreatePreferLowPower GpuDeviceCreateShadersDxbc GpuDeviceCreateShadersDxil GpuDeviceCreateShadersMetalLib GpuDeviceCreateShadersMsl GpuDeviceCreateShadersPrivate GpuDeviceCreateShadersSpirV GpuGraphicsPipelineCreateName GpuSamplerCreateName GpuShaderCreateName GpuTextureCreateD3D12ClearA GpuTextureCreateD3D12ClearB GpuTextureCreateD3D12ClearDepth GpuTextureCreateD3D12ClearG GpuTextureCreateD3D12ClearR GpuTextureCreateD3D12ClearStencil GpuTextureCreateName GpuTransferBufferCreateName IOStreamAndroidAAsset IOStreamDynamicChunkSize IOStreamDynamicMemory IOStreamFileDescriptor IOStreamMemory IOStreamMemorySize IOStreamWindowHandle JoystickCapMonoLed JoystickCapPlayerLed JoystickCapRgbLed JoystickCapRumble JoystickCapTriggerRumble ProcessBackground ProcessCreateArgs ProcessCreateBackground ProcessCreateEnvironment ProcessCreateStdErr ProcessCreateStdErrStream ProcessCreateStdErrToStdOut ProcessCreateStdIn ProcessCreateStdInStream ProcessCreateStdOut ProcessCreateStdOutStream ProcessPid ProcessStdErr ProcessStdIn ProcessStdOut RendererCreateName RendererCreateOutputColorspace RendererCreatePresentVSync RendererCreateSurface RendererCreateVulkanDevice RendererCreateVulkanGraphicsQueueFamilyIndex RendererCreateVulkanInstance RendererCreateVulkanPhysicalDevice RendererCreateVulkanPresentQueueFamilyIndex RendererCreateVulkanSurface RendererCreateWindow RendererD3D11Device RendererD3D11SwapChain RendererD3D12CommandQueue RendererD3D12Device RendererD3D12SwapChain RendererD3D9Device RendererGpuDevice RendererHdrEnabled RendererHdrHeadroom RendererMaxTextureSize RendererName RendererOutputColorspace RendererSdrWhitePoint RendererSurface RendererTextureFormats RendererVSync RendererVulkanDevice RendererVulkanGraphicsQueueFamilyIndex RendererVulkanInstance RendererVulkanPhysicalDevice RendererVulkanPresentQueueFamilyIndex RendererVulkanSurface RendererVulkanSwapChainImageCount RendererWindow SurfaceHdrHeadroom SurfaceSdrWhitePoint SurfaceTonemapOperator TextInputAndroidInputType TextInputAutoCorrect TextInputCapitalization TextInputMultiLine TextInputType TextureAccess TextureColorspace TextureCreateAccess TextureCreateColorspace TextureCreateD3D11Texture TextureCreateD3D11TextureU TextureCreateD3D11TextureV TextureCreateD3D12Texture TextureCreateD3D12TextureU TextureCreateD3D12TextureV TextureCreateFormat TextureCreateHdrHeadroom TextureCreateHeight TextureCreateMetalPixelBuffer TextureCreateOpenGles2Texture TextureCreateOpenGles2TextureU TextureCreateOpenGles2TextureUV TextureCreateOpenGles2TextureV TextureCreateOpenGLTexture TextureCreateOpenGLTextureU TextureCreateOpenGLTextureUV TextureCreateOpenGLTextureV TextureCreateSdrWhitePoint TextureCreateVulkanTexture TextureCreateWidth TextureD3D11Texture TextureD3D11TextureU TextureD3D11TextureV TextureD3D12Texture TextureD3D12TextureU TextureD3D12TextureV TextureFormat TextureHdrHeadroom TextureHeight TextureOpenGles2Texture TextureOpenGles2TextureTarget TextureOpenGles2TextureU TextureOpenGles2TextureUV TextureOpenGles2TextureV TextureOpenGLTexH TextureOpenGLTexture TextureOpenGLTextureTarget TextureOpenGLTextureU TextureOpenGLTextureUV TextureOpenGLTextureV TextureOpenGLTexW TextureSdrWhitePoint TextureVulkanTexture TextureWidth WindowAndroidSurface WindowAndroidWindow WindowCocoaMetalViewTag WindowCocoaWindow WindowCreateAlwaysOnTop WindowCreateBorderless WindowCreateCocoaView WindowCreateCocoaWindow WindowCreateExternalGraphicsContext WindowCreateFlags WindowCreateFocusable WindowCreateFullscreen WindowCreateHeight WindowCreateHidden WindowCreateHighPixelDensity WindowCreateMaximized WindowCreateMenu WindowCreateMetal WindowCreateMinimized WindowCreateModal WindowCreateMouseGrabbed WindowCreateOpenGL WindowCreateParent WindowCreateResizable WindowCreateTitle WindowCreateTooltip WindowCreateTransparent WindowCreateUtility WindowCreateVulkan WindowCreateWidth WindowCreateWin32HWnd WindowCreateWin32PixelFormatHWnd WindowCreateX WindowCreateY WindowHdrEnabled WindowHdrHeadroom WindowSdrWhiteLevel WindowShape WindowUIKitMetalViewTag WindowUIKitOpenGLFramebuffer WindowUIKitOpenGLRenderbuffer WindowUIKitOpenGLResolveFramebuffer WindowUIKitWindow WindowWin32Hdc WindowWin32Hwnd WindowWin32Instance"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#constant-descriptions","title":"Constant Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#AppMetadataCopyright","title":"AppMetadataCopyright","text":"<p><code>const AppMetadataCopyright = SDL_PROP_APP_METADATA_COPYRIGHT_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#AppMetadataCreator","title":"AppMetadataCreator","text":"<p><code>const AppMetadataCreator = SDL_PROP_APP_METADATA_CREATOR_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#AppMetadataIdentifier","title":"AppMetadataIdentifier","text":"<p><code>const AppMetadataIdentifier = SDL_PROP_APP_METADATA_IDENTIFIER_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#AppMetadataName","title":"AppMetadataName","text":"<p><code>const AppMetadataName = SDL_PROP_APP_METADATA_NAME_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#AppMetadataType","title":"AppMetadataType","text":"<p><code>const AppMetadataType = SDL_PROP_APP_METADATA_TYPE_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#AppMetadataUrl","title":"AppMetadataUrl","text":"<p><code>const AppMetadataUrl = SDL_PROP_APP_METADATA_URL_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#AppMetadataVersion","title":"AppMetadataVersion","text":"<p><code>const AppMetadataVersion = SDL_PROP_APP_METADATA_VERSION_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GamepadCapMonoLed","title":"GamepadCapMonoLed","text":"<p><code>const GamepadCapMonoLed = SDL_PROP_GAMEPAD_CAP_MONO_LED_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GamepadCapPlayerLed","title":"GamepadCapPlayerLed","text":"<p><code>const GamepadCapPlayerLed = SDL_PROP_GAMEPAD_CAP_PLAYER_LED_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GamepadCapRgbLed","title":"GamepadCapRgbLed","text":"<p><code>const GamepadCapRgbLed = SDL_PROP_GAMEPAD_CAP_RGB_LED_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GamepadCapRumble","title":"GamepadCapRumble","text":"<p><code>const GamepadCapRumble = SDL_PROP_GAMEPAD_CAP_RUMBLE_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GamepadCapTriggerRumble","title":"GamepadCapTriggerRumble","text":"<p><code>const GamepadCapTriggerRumble = SDL_PROP_GAMEPAD_CAP_TRIGGER_RUMBLE_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuBufferCreateName","title":"GpuBufferCreateName","text":"<p><code>const GpuBufferCreateName = SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuComputePipelineCreateName","title":"GpuComputePipelineCreateName","text":"<p><code>const GpuComputePipelineCreateName = SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuDeviceCreateD3D12SemanticName","title":"GpuDeviceCreateD3D12SemanticName","text":"<p><code>const GpuDeviceCreateD3D12SemanticName = SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuDeviceCreateDebugMode","title":"GpuDeviceCreateDebugMode","text":"<p><code>const GpuDeviceCreateDebugMode = SDL_PROP_GPU_DEVICE_CREATE_DEBUGMODE_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuDeviceCreateName","title":"GpuDeviceCreateName","text":"<p><code>const GpuDeviceCreateName = SDL_PROP_GPU_DEVICE_CREATE_NAME_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuDeviceCreatePreferLowPower","title":"GpuDeviceCreatePreferLowPower","text":"<p><code>const GpuDeviceCreatePreferLowPower = SDL_PROP_GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuDeviceCreateShadersDxbc","title":"GpuDeviceCreateShadersDxbc","text":"<p><code>const GpuDeviceCreateShadersDxbc = SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXBC_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuDeviceCreateShadersDxil","title":"GpuDeviceCreateShadersDxil","text":"<p><code>const GpuDeviceCreateShadersDxil = SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXIL_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuDeviceCreateShadersMetalLib","title":"GpuDeviceCreateShadersMetalLib","text":"<p><code>const GpuDeviceCreateShadersMetalLib = SDL_PROP_GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuDeviceCreateShadersMsl","title":"GpuDeviceCreateShadersMsl","text":"<p><code>const GpuDeviceCreateShadersMsl = SDL_PROP_GPU_DEVICE_CREATE_SHADERS_MSL_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuDeviceCreateShadersPrivate","title":"GpuDeviceCreateShadersPrivate","text":"<p><code>const GpuDeviceCreateShadersPrivate = SDL_PROP_GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuDeviceCreateShadersSpirV","title":"GpuDeviceCreateShadersSpirV","text":"<p><code>const GpuDeviceCreateShadersSpirV = SDL_PROP_GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuGraphicsPipelineCreateName","title":"GpuGraphicsPipelineCreateName","text":"<p><code>const GpuGraphicsPipelineCreateName = SDL_PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuSamplerCreateName","title":"GpuSamplerCreateName","text":"<p><code>const GpuSamplerCreateName = SDL_PROP_GPU_SAMPLER_CREATE_NAME_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuShaderCreateName","title":"GpuShaderCreateName","text":"<p><code>const GpuShaderCreateName = SDL_PROP_GPU_SHADER_CREATE_NAME_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuTextureCreateD3D12ClearA","title":"GpuTextureCreateD3D12ClearA","text":"<p><code>const GpuTextureCreateD3D12ClearA = SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuTextureCreateD3D12ClearB","title":"GpuTextureCreateD3D12ClearB","text":"<p><code>const GpuTextureCreateD3D12ClearB = SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuTextureCreateD3D12ClearDepth","title":"GpuTextureCreateD3D12ClearDepth","text":"<p><code>const GpuTextureCreateD3D12ClearDepth = SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuTextureCreateD3D12ClearG","title":"GpuTextureCreateD3D12ClearG","text":"<p><code>const GpuTextureCreateD3D12ClearG = SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuTextureCreateD3D12ClearR","title":"GpuTextureCreateD3D12ClearR","text":"<p><code>const GpuTextureCreateD3D12ClearR = SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuTextureCreateD3D12ClearStencil","title":"GpuTextureCreateD3D12ClearStencil","text":"<p><code>const GpuTextureCreateD3D12ClearStencil = SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_UINT8</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuTextureCreateName","title":"GpuTextureCreateName","text":"<p><code>const GpuTextureCreateName = SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#GpuTransferBufferCreateName","title":"GpuTransferBufferCreateName","text":"<p><code>const GpuTransferBufferCreateName = SDL_PROP_GPU_TRANSFERBUFFER_CREATE_NAME_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#IOStreamAndroidAAsset","title":"IOStreamAndroidAAsset","text":"<p><code>const IOStreamAndroidAAsset = SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#IOStreamDynamicChunkSize","title":"IOStreamDynamicChunkSize","text":"<p><code>const IOStreamDynamicChunkSize = SDL_PROP_IOSTREAM_DYNAMIC_CHUNKSIZE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#IOStreamDynamicMemory","title":"IOStreamDynamicMemory","text":"<p><code>const IOStreamDynamicMemory = SDL_PROP_IOSTREAM_DYNAMIC_MEMORY_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#IOStreamFileDescriptor","title":"IOStreamFileDescriptor","text":"<p><code>const IOStreamFileDescriptor = SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#IOStreamMemory","title":"IOStreamMemory","text":"<p><code>const IOStreamMemory = SDL_PROP_IOSTREAM_MEMORY_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#IOStreamMemorySize","title":"IOStreamMemorySize","text":"<p><code>const IOStreamMemorySize = SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#IOStreamWindowHandle","title":"IOStreamWindowHandle","text":"<p><code>const IOStreamWindowHandle = SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#JoystickCapMonoLed","title":"JoystickCapMonoLed","text":"<p><code>const JoystickCapMonoLed = SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#JoystickCapPlayerLed","title":"JoystickCapPlayerLed","text":"<p><code>const JoystickCapPlayerLed = SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#JoystickCapRgbLed","title":"JoystickCapRgbLed","text":"<p><code>const JoystickCapRgbLed = SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#JoystickCapRumble","title":"JoystickCapRumble","text":"<p><code>const JoystickCapRumble = SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#JoystickCapTriggerRumble","title":"JoystickCapTriggerRumble","text":"<p><code>const JoystickCapTriggerRumble = SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#ProcessBackground","title":"ProcessBackground","text":"<p><code>const ProcessBackground = SDL_PROP_PROCESS_BACKGROUND_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#ProcessCreateArgs","title":"ProcessCreateArgs","text":"<p><code>const ProcessCreateArgs = SDL_PROP_PROCESS_CREATE_ARGS_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#ProcessCreateBackground","title":"ProcessCreateBackground","text":"<p><code>const ProcessCreateBackground = SDL_PROP_PROCESS_CREATE_BACKGROUND_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#ProcessCreateEnvironment","title":"ProcessCreateEnvironment","text":"<p><code>const ProcessCreateEnvironment = SDL_PROP_PROCESS_CREATE_ENVIRONMENT_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#ProcessCreateStdErr","title":"ProcessCreateStdErr","text":"<p><code>const ProcessCreateStdErr = SDL_PROP_PROCESS_CREATE_STDERR_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#ProcessCreateStdErrStream","title":"ProcessCreateStdErrStream","text":"<p><code>const ProcessCreateStdErrStream = SDL_PROP_PROCESS_CREATE_STDERR_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#ProcessCreateStdErrToStdOut","title":"ProcessCreateStdErrToStdOut","text":"<p><code>const ProcessCreateStdErrToStdOut = SDL_PROP_PROCESS_CREATE_STDERR_TO_STDOUT_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#ProcessCreateStdIn","title":"ProcessCreateStdIn","text":"<p><code>const ProcessCreateStdIn = SDL_PROP_PROCESS_CREATE_STDIN_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#ProcessCreateStdInStream","title":"ProcessCreateStdInStream","text":"<p><code>const ProcessCreateStdInStream = SDL_PROP_PROCESS_CREATE_STDIN_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#ProcessCreateStdOut","title":"ProcessCreateStdOut","text":"<p><code>const ProcessCreateStdOut = SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#ProcessCreateStdOutStream","title":"ProcessCreateStdOutStream","text":"<p><code>const ProcessCreateStdOutStream = SDL_PROP_PROCESS_CREATE_STDOUT_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#ProcessPid","title":"ProcessPid","text":"<p><code>const ProcessPid = SDL_PROP_PROCESS_PID_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#ProcessStdErr","title":"ProcessStdErr","text":"<p><code>const ProcessStdErr = SDL_PROP_PROCESS_STDERR_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#ProcessStdIn","title":"ProcessStdIn","text":"<p><code>const ProcessStdIn = SDL_PROP_PROCESS_STDIN_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#ProcessStdOut","title":"ProcessStdOut","text":"<p><code>const ProcessStdOut = SDL_PROP_PROCESS_STDOUT_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererCreateName","title":"RendererCreateName","text":"<p><code>const RendererCreateName = SDL_PROP_RENDERER_CREATE_NAME_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererCreateOutputColorspace","title":"RendererCreateOutputColorspace","text":"<p><code>const RendererCreateOutputColorspace = SDL_PROP_RENDERER_CREATE_OUTPUT_COLORSPACE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererCreatePresentVSync","title":"RendererCreatePresentVSync","text":"<p><code>const RendererCreatePresentVSync = SDL_PROP_RENDERER_CREATE_PRESENT_VSYNC_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererCreateSurface","title":"RendererCreateSurface","text":"<p><code>const RendererCreateSurface = SDL_PROP_RENDERER_CREATE_SURFACE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererCreateVulkanDevice","title":"RendererCreateVulkanDevice","text":"<p><code>const RendererCreateVulkanDevice = SDL_PROP_RENDERER_CREATE_VULKAN_DEVICE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererCreateVulkanGraphicsQueueFamilyIndex","title":"RendererCreateVulkanGraphicsQueueFamilyIndex","text":"<p><code>const RendererCreateVulkanGraphicsQueueFamilyIndex = SDL_PROP_RENDERER_CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererCreateVulkanInstance","title":"RendererCreateVulkanInstance","text":"<p><code>const RendererCreateVulkanInstance = SDL_PROP_RENDERER_CREATE_VULKAN_INSTANCE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererCreateVulkanPhysicalDevice","title":"RendererCreateVulkanPhysicalDevice","text":"<p><code>const RendererCreateVulkanPhysicalDevice = SDL_PROP_RENDERER_CREATE_VULKAN_PHYSICAL_DEVICE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererCreateVulkanPresentQueueFamilyIndex","title":"RendererCreateVulkanPresentQueueFamilyIndex","text":"<p><code>const RendererCreateVulkanPresentQueueFamilyIndex = SDL_PROP_RENDERER_CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererCreateVulkanSurface","title":"RendererCreateVulkanSurface","text":"<p><code>const RendererCreateVulkanSurface = SDL_PROP_RENDERER_CREATE_VULKAN_SURFACE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererCreateWindow","title":"RendererCreateWindow","text":"<p><code>const RendererCreateWindow = SDL_PROP_RENDERER_CREATE_WINDOW_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererD3D11Device","title":"RendererD3D11Device","text":"<p><code>const RendererD3D11Device = SDL_PROP_RENDERER_D3D11_DEVICE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererD3D11SwapChain","title":"RendererD3D11SwapChain","text":"<p><code>const RendererD3D11SwapChain = SDL_PROP_RENDERER_D3D11_SWAPCHAIN_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererD3D12CommandQueue","title":"RendererD3D12CommandQueue","text":"<p><code>const RendererD3D12CommandQueue = SDL_PROP_RENDERER_D3D12_COMMAND_QUEUE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererD3D12Device","title":"RendererD3D12Device","text":"<p><code>const RendererD3D12Device = SDL_PROP_RENDERER_D3D12_DEVICE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererD3D12SwapChain","title":"RendererD3D12SwapChain","text":"<p><code>const RendererD3D12SwapChain = SDL_PROP_RENDERER_D3D12_SWAPCHAIN_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererD3D9Device","title":"RendererD3D9Device","text":"<p><code>const RendererD3D9Device = SDL_PROP_RENDERER_D3D9_DEVICE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererGpuDevice","title":"RendererGpuDevice","text":"<p><code>const RendererGpuDevice = SDL_PROP_RENDERER_GPU_DEVICE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererHdrEnabled","title":"RendererHdrEnabled","text":"<p><code>const RendererHdrEnabled = SDL_PROP_RENDERER_HDR_ENABLED_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererHdrHeadroom","title":"RendererHdrHeadroom","text":"<p><code>const RendererHdrHeadroom = SDL_PROP_RENDERER_HDR_HEADROOM_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererMaxTextureSize","title":"RendererMaxTextureSize","text":"<p><code>const RendererMaxTextureSize = SDL_PROP_RENDERER_MAX_TEXTURE_SIZE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererName","title":"RendererName","text":"<p><code>const RendererName = SDL_PROP_RENDERER_NAME_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererOutputColorspace","title":"RendererOutputColorspace","text":"<p><code>const RendererOutputColorspace = SDL_PROP_RENDERER_OUTPUT_COLORSPACE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererSdrWhitePoint","title":"RendererSdrWhitePoint","text":"<p><code>const RendererSdrWhitePoint = SDL_PROP_RENDERER_SDR_WHITE_POINT_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererSurface","title":"RendererSurface","text":"<p><code>const RendererSurface = SDL_PROP_RENDERER_SURFACE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererTextureFormats","title":"RendererTextureFormats","text":"<p><code>const RendererTextureFormats = SDL_PROP_RENDERER_TEXTURE_FORMATS_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererVSync","title":"RendererVSync","text":"<p><code>const RendererVSync = SDL_PROP_RENDERER_VSYNC_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererVulkanDevice","title":"RendererVulkanDevice","text":"<p><code>const RendererVulkanDevice = SDL_PROP_RENDERER_VULKAN_DEVICE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererVulkanGraphicsQueueFamilyIndex","title":"RendererVulkanGraphicsQueueFamilyIndex","text":"<p><code>const RendererVulkanGraphicsQueueFamilyIndex = SDL_PROP_RENDERER_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererVulkanInstance","title":"RendererVulkanInstance","text":"<p><code>const RendererVulkanInstance = SDL_PROP_RENDERER_VULKAN_INSTANCE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererVulkanPhysicalDevice","title":"RendererVulkanPhysicalDevice","text":"<p><code>const RendererVulkanPhysicalDevice = SDL_PROP_RENDERER_VULKAN_PHYSICAL_DEVICE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererVulkanPresentQueueFamilyIndex","title":"RendererVulkanPresentQueueFamilyIndex","text":"<p><code>const RendererVulkanPresentQueueFamilyIndex = SDL_PROP_RENDERER_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererVulkanSurface","title":"RendererVulkanSurface","text":"<p><code>const RendererVulkanSurface = SDL_PROP_RENDERER_VULKAN_SURFACE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererVulkanSwapChainImageCount","title":"RendererVulkanSwapChainImageCount","text":"<p><code>const RendererVulkanSwapChainImageCount = SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#RendererWindow","title":"RendererWindow","text":"<p><code>const RendererWindow = SDL_PROP_RENDERER_WINDOW_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#SurfaceHdrHeadroom","title":"SurfaceHdrHeadroom","text":"<p><code>const SurfaceHdrHeadroom = SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#SurfaceSdrWhitePoint","title":"SurfaceSdrWhitePoint","text":"<p><code>const SurfaceSdrWhitePoint = SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#SurfaceTonemapOperator","title":"SurfaceTonemapOperator","text":"<p><code>const SurfaceTonemapOperator = SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextInputAndroidInputType","title":"TextInputAndroidInputType","text":"<p><code>const TextInputAndroidInputType = SDL_PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextInputAutoCorrect","title":"TextInputAutoCorrect","text":"<p><code>const TextInputAutoCorrect = SDL_PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextInputCapitalization","title":"TextInputCapitalization","text":"<p><code>const TextInputCapitalization = SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextInputMultiLine","title":"TextInputMultiLine","text":"<p><code>const TextInputMultiLine = SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextInputType","title":"TextInputType","text":"<p><code>const TextInputType = SDL_PROP_TEXTINPUT_TYPE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureAccess","title":"TextureAccess","text":"<p><code>const TextureAccess = SDL_PROP_TEXTURE_ACCESS_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureColorspace","title":"TextureColorspace","text":"<p><code>const TextureColorspace = SDL_PROP_TEXTURE_COLORSPACE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateAccess","title":"TextureCreateAccess","text":"<p><code>const TextureCreateAccess = SDL_PROP_TEXTURE_CREATE_ACCESS_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateColorspace","title":"TextureCreateColorspace","text":"<p><code>const TextureCreateColorspace = SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateD3D11Texture","title":"TextureCreateD3D11Texture","text":"<p><code>const TextureCreateD3D11Texture = SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateD3D11TextureU","title":"TextureCreateD3D11TextureU","text":"<p><code>const TextureCreateD3D11TextureU = SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_U_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateD3D11TextureV","title":"TextureCreateD3D11TextureV","text":"<p><code>const TextureCreateD3D11TextureV = SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_V_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateD3D12Texture","title":"TextureCreateD3D12Texture","text":"<p><code>const TextureCreateD3D12Texture = SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateD3D12TextureU","title":"TextureCreateD3D12TextureU","text":"<p><code>const TextureCreateD3D12TextureU = SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_U_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateD3D12TextureV","title":"TextureCreateD3D12TextureV","text":"<p><code>const TextureCreateD3D12TextureV = SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_V_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateFormat","title":"TextureCreateFormat","text":"<p><code>const TextureCreateFormat = SDL_PROP_TEXTURE_CREATE_FORMAT_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateHdrHeadroom","title":"TextureCreateHdrHeadroom","text":"<p><code>const TextureCreateHdrHeadroom = SDL_PROP_TEXTURE_CREATE_HDR_HEADROOM_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateHeight","title":"TextureCreateHeight","text":"<p><code>const TextureCreateHeight = SDL_PROP_TEXTURE_CREATE_HEIGHT_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateMetalPixelBuffer","title":"TextureCreateMetalPixelBuffer","text":"<p><code>const TextureCreateMetalPixelBuffer = SDL_PROP_TEXTURE_CREATE_METAL_PIXELBUFFER_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateOpenGles2Texture","title":"TextureCreateOpenGles2Texture","text":"<p><code>const TextureCreateOpenGles2Texture = SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateOpenGles2TextureU","title":"TextureCreateOpenGles2TextureU","text":"<p><code>const TextureCreateOpenGles2TextureU = SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_U_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateOpenGles2TextureUV","title":"TextureCreateOpenGles2TextureUV","text":"<p><code>const TextureCreateOpenGles2TextureUV = SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_UV_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateOpenGles2TextureV","title":"TextureCreateOpenGles2TextureV","text":"<p><code>const TextureCreateOpenGles2TextureV = SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_V_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateOpenGLTexture","title":"TextureCreateOpenGLTexture","text":"<p><code>const TextureCreateOpenGLTexture = SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateOpenGLTextureU","title":"TextureCreateOpenGLTextureU","text":"<p><code>const TextureCreateOpenGLTextureU = SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_U_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateOpenGLTextureUV","title":"TextureCreateOpenGLTextureUV","text":"<p><code>const TextureCreateOpenGLTextureUV = SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_UV_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateOpenGLTextureV","title":"TextureCreateOpenGLTextureV","text":"<p><code>const TextureCreateOpenGLTextureV = SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_V_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateSdrWhitePoint","title":"TextureCreateSdrWhitePoint","text":"<p><code>const TextureCreateSdrWhitePoint = SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateVulkanTexture","title":"TextureCreateVulkanTexture","text":"<p><code>const TextureCreateVulkanTexture = SDL_PROP_TEXTURE_CREATE_VULKAN_TEXTURE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureCreateWidth","title":"TextureCreateWidth","text":"<p><code>const TextureCreateWidth = SDL_PROP_TEXTURE_CREATE_WIDTH_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureD3D11Texture","title":"TextureD3D11Texture","text":"<p><code>const TextureD3D11Texture = SDL_PROP_TEXTURE_D3D11_TEXTURE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureD3D11TextureU","title":"TextureD3D11TextureU","text":"<p><code>const TextureD3D11TextureU = SDL_PROP_TEXTURE_D3D11_TEXTURE_U_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureD3D11TextureV","title":"TextureD3D11TextureV","text":"<p><code>const TextureD3D11TextureV = SDL_PROP_TEXTURE_D3D11_TEXTURE_V_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureD3D12Texture","title":"TextureD3D12Texture","text":"<p><code>const TextureD3D12Texture = SDL_PROP_TEXTURE_D3D12_TEXTURE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureD3D12TextureU","title":"TextureD3D12TextureU","text":"<p><code>const TextureD3D12TextureU = SDL_PROP_TEXTURE_D3D12_TEXTURE_U_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureD3D12TextureV","title":"TextureD3D12TextureV","text":"<p><code>const TextureD3D12TextureV = SDL_PROP_TEXTURE_D3D12_TEXTURE_V_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureFormat","title":"TextureFormat","text":"<p><code>const TextureFormat = SDL_PROP_TEXTURE_FORMAT_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureHdrHeadroom","title":"TextureHdrHeadroom","text":"<p><code>const TextureHdrHeadroom = SDL_PROP_TEXTURE_HDR_HEADROOM_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureHeight","title":"TextureHeight","text":"<p><code>const TextureHeight = SDL_PROP_TEXTURE_HEIGHT_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureOpenGles2Texture","title":"TextureOpenGles2Texture","text":"<p><code>const TextureOpenGles2Texture = SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureOpenGles2TextureTarget","title":"TextureOpenGles2TextureTarget","text":"<p><code>const TextureOpenGles2TextureTarget = SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_TARGET_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureOpenGles2TextureU","title":"TextureOpenGles2TextureU","text":"<p><code>const TextureOpenGles2TextureU = SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_U_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureOpenGles2TextureUV","title":"TextureOpenGles2TextureUV","text":"<p><code>const TextureOpenGles2TextureUV = SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_UV_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureOpenGles2TextureV","title":"TextureOpenGles2TextureV","text":"<p><code>const TextureOpenGles2TextureV = SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_V_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureOpenGLTexH","title":"TextureOpenGLTexH","text":"<p><code>const TextureOpenGLTexH = SDL_PROP_TEXTURE_OPENGL_TEX_H_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureOpenGLTexture","title":"TextureOpenGLTexture","text":"<p><code>const TextureOpenGLTexture = SDL_PROP_TEXTURE_OPENGL_TEXTURE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureOpenGLTextureTarget","title":"TextureOpenGLTextureTarget","text":"<p><code>const TextureOpenGLTextureTarget = SDL_PROP_TEXTURE_OPENGL_TEXTURE_TARGET_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureOpenGLTextureU","title":"TextureOpenGLTextureU","text":"<p><code>const TextureOpenGLTextureU = SDL_PROP_TEXTURE_OPENGL_TEXTURE_U_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureOpenGLTextureUV","title":"TextureOpenGLTextureUV","text":"<p><code>const TextureOpenGLTextureUV = SDL_PROP_TEXTURE_OPENGL_TEXTURE_UV_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureOpenGLTextureV","title":"TextureOpenGLTextureV","text":"<p><code>const TextureOpenGLTextureV = SDL_PROP_TEXTURE_OPENGL_TEXTURE_V_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureOpenGLTexW","title":"TextureOpenGLTexW","text":"<p><code>const TextureOpenGLTexW = SDL_PROP_TEXTURE_OPENGL_TEX_W_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureSdrWhitePoint","title":"TextureSdrWhitePoint","text":"<p><code>const TextureSdrWhitePoint = SDL_PROP_TEXTURE_SDR_WHITE_POINT_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureVulkanTexture","title":"TextureVulkanTexture","text":"<p><code>const TextureVulkanTexture = SDL_PROP_TEXTURE_VULKAN_TEXTURE_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#TextureWidth","title":"TextureWidth","text":"<p><code>const TextureWidth = SDL_PROP_TEXTURE_WIDTH_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowAndroidSurface","title":"WindowAndroidSurface","text":"<p><code>const WindowAndroidSurface = SDL_PROP_WINDOW_ANDROID_SURFACE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowAndroidWindow","title":"WindowAndroidWindow","text":"<p><code>const WindowAndroidWindow = SDL_PROP_WINDOW_ANDROID_WINDOW_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCocoaMetalViewTag","title":"WindowCocoaMetalViewTag","text":"<p><code>const WindowCocoaMetalViewTag = SDL_PROP_WINDOW_COCOA_METAL_VIEW_TAG_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCocoaWindow","title":"WindowCocoaWindow","text":"<p><code>const WindowCocoaWindow = SDL_PROP_WINDOW_COCOA_WINDOW_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateAlwaysOnTop","title":"WindowCreateAlwaysOnTop","text":"<p><code>const WindowCreateAlwaysOnTop = SDL_PROP_WINDOW_CREATE_ALWAYS_ON_TOP_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateBorderless","title":"WindowCreateBorderless","text":"<p><code>const WindowCreateBorderless = SDL_PROP_WINDOW_CREATE_BORDERLESS_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateCocoaView","title":"WindowCreateCocoaView","text":"<p><code>const WindowCreateCocoaView = SDL_PROP_WINDOW_CREATE_COCOA_VIEW_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateCocoaWindow","title":"WindowCreateCocoaWindow","text":"<p><code>const WindowCreateCocoaWindow = SDL_PROP_WINDOW_CREATE_COCOA_WINDOW_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateExternalGraphicsContext","title":"WindowCreateExternalGraphicsContext","text":"<p><code>const WindowCreateExternalGraphicsContext = SDL_PROP_WINDOW_CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateFlags","title":"WindowCreateFlags","text":"<p><code>const WindowCreateFlags = SDL_PROP_WINDOW_CREATE_FLAGS_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateFocusable","title":"WindowCreateFocusable","text":"<p><code>const WindowCreateFocusable = SDL_PROP_WINDOW_CREATE_FOCUSABLE_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateFullscreen","title":"WindowCreateFullscreen","text":"<p><code>const WindowCreateFullscreen = SDL_PROP_WINDOW_CREATE_FULLSCREEN_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateHeight","title":"WindowCreateHeight","text":"<p><code>const WindowCreateHeight = SDL_PROP_WINDOW_CREATE_HEIGHT_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateHidden","title":"WindowCreateHidden","text":"<p><code>const WindowCreateHidden = SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateHighPixelDensity","title":"WindowCreateHighPixelDensity","text":"<p><code>const WindowCreateHighPixelDensity = SDL_PROP_WINDOW_CREATE_HIGH_PIXEL_DENSITY_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateMaximized","title":"WindowCreateMaximized","text":"<p><code>const WindowCreateMaximized = SDL_PROP_WINDOW_CREATE_MAXIMIZED_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateMenu","title":"WindowCreateMenu","text":"<p><code>const WindowCreateMenu = SDL_PROP_WINDOW_CREATE_MENU_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateMetal","title":"WindowCreateMetal","text":"<p><code>const WindowCreateMetal = SDL_PROP_WINDOW_CREATE_METAL_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateMinimized","title":"WindowCreateMinimized","text":"<p><code>const WindowCreateMinimized = SDL_PROP_WINDOW_CREATE_MINIMIZED_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateModal","title":"WindowCreateModal","text":"<p><code>const WindowCreateModal = SDL_PROP_WINDOW_CREATE_MODAL_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateMouseGrabbed","title":"WindowCreateMouseGrabbed","text":"<p><code>const WindowCreateMouseGrabbed = SDL_PROP_WINDOW_CREATE_MOUSE_GRABBED_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateOpenGL","title":"WindowCreateOpenGL","text":"<p><code>const WindowCreateOpenGL = SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateParent","title":"WindowCreateParent","text":"<p><code>const WindowCreateParent = SDL_PROP_WINDOW_CREATE_PARENT_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateResizable","title":"WindowCreateResizable","text":"<p><code>const WindowCreateResizable = SDL_PROP_WINDOW_CREATE_RESIZABLE_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateTitle","title":"WindowCreateTitle","text":"<p><code>const WindowCreateTitle = SDL_PROP_WINDOW_CREATE_TITLE_STRING</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateTooltip","title":"WindowCreateTooltip","text":"<p><code>const WindowCreateTooltip = SDL_PROP_WINDOW_CREATE_TOOLTIP_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateTransparent","title":"WindowCreateTransparent","text":"<p><code>const WindowCreateTransparent = SDL_PROP_WINDOW_CREATE_TRANSPARENT_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateUtility","title":"WindowCreateUtility","text":"<p><code>const WindowCreateUtility = SDL_PROP_WINDOW_CREATE_UTILITY_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateVulkan","title":"WindowCreateVulkan","text":"<p><code>const WindowCreateVulkan = SDL_PROP_WINDOW_CREATE_VULKAN_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateWidth","title":"WindowCreateWidth","text":"<p><code>const WindowCreateWidth = SDL_PROP_WINDOW_CREATE_WIDTH_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateWin32HWnd","title":"WindowCreateWin32HWnd","text":"<p><code>const WindowCreateWin32HWnd = SDL_PROP_WINDOW_CREATE_WIN32_HWND_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateWin32PixelFormatHWnd","title":"WindowCreateWin32PixelFormatHWnd","text":"<p><code>const WindowCreateWin32PixelFormatHWnd = SDL_PROP_WINDOW_CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateX","title":"WindowCreateX","text":"<p><code>const WindowCreateX = SDL_PROP_WINDOW_CREATE_X_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowCreateY","title":"WindowCreateY","text":"<p><code>const WindowCreateY = SDL_PROP_WINDOW_CREATE_Y_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowHdrEnabled","title":"WindowHdrEnabled","text":"<p><code>const WindowHdrEnabled = SDL_PROP_WINDOW_HDR_ENABLED_BOOLEAN</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowHdrHeadroom","title":"WindowHdrHeadroom","text":"<p><code>const WindowHdrHeadroom = SDL_PROP_WINDOW_HDR_HEADROOM_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowSdrWhiteLevel","title":"WindowSdrWhiteLevel","text":"<p><code>const WindowSdrWhiteLevel = SDL_PROP_WINDOW_SDR_WHITE_LEVEL_FLOAT</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowShape","title":"WindowShape","text":"<p><code>const WindowShape = SDL_PROP_WINDOW_SHAPE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowUIKitMetalViewTag","title":"WindowUIKitMetalViewTag","text":"<p><code>const WindowUIKitMetalViewTag = SDL_PROP_WINDOW_UIKIT_METAL_VIEW_TAG_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowUIKitOpenGLFramebuffer","title":"WindowUIKitOpenGLFramebuffer","text":"<p><code>const WindowUIKitOpenGLFramebuffer = SDL_PROP_WINDOW_UIKIT_OPENGL_FRAMEBUFFER_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowUIKitOpenGLRenderbuffer","title":"WindowUIKitOpenGLRenderbuffer","text":"<p><code>const WindowUIKitOpenGLRenderbuffer = SDL_PROP_WINDOW_UIKIT_OPENGL_RENDERBUFFER_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowUIKitOpenGLResolveFramebuffer","title":"WindowUIKitOpenGLResolveFramebuffer","text":"<p><code>const WindowUIKitOpenGLResolveFramebuffer = SDL_PROP_WINDOW_UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowUIKitWindow","title":"WindowUIKitWindow","text":"<p><code>const WindowUIKitWindow = SDL_PROP_WINDOW_UIKIT_WINDOW_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowWin32Hdc","title":"WindowWin32Hdc","text":"<p><code>const WindowWin32Hdc = SDL_PROP_WINDOW_WIN32_HDC_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowWin32Hwnd","title":"WindowWin32Hwnd","text":"<p><code>const WindowWin32Hwnd = SDL_PROP_WINDOW_WIN32_HWND_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlProperty/#WindowWin32Instance","title":"WindowWin32Instance","text":"<p><code>const WindowWin32Instance = SDL_PROP_WINDOW_WIN32_INSTANCE_POINTER</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/","title":"TSdlVersion","text":"<p>Information about the version of SDL in use.</p> <p>Represents the library's version as three levels: major revision (increments with massive changes, additions, and enhancements), minor revision (increments with backwards-compatible changes to the major revision), and patchlevel (increments with fixes to the minor revision). </p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type TSdlVersion = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#properties","title":"Properties","text":"Name Description CompiledVersion The SDL version the program was compiled against. Major The current major version of SDL headers. Minor The current minor version of the SDL headers. Patch The current micro (or patchlevel) version of the SDL headers. Revision Get the code revision of SDL that is linked against your program. RuntimeVersion The version of SDL that is linked against your program."},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#constructors","title":"Constructors","text":"Name Description Create Creates a version instance."},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#methods","title":"Methods","text":"Name Description AtLeast Checks whether the program was compiled against a version of SDL with at least the given version number. FromNumber Creates a version from a numeric value. ToNumber Turns this version numbers into a numeric value."},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#CompiledVersion","title":"CompiledVersion","text":"<p>The SDL version the program was compiled against.</p> <p>Note that if you dynamically linked the library, you might have a slightly newer or older version at runtime. That version can be determined with RuntimeVersion. </p> <p><code>class property CompiledVersion: TSdlVersion read GetCompiledVersion</code></p> <p>Type: <code>TSdlVersion</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#Major","title":"Major","text":"<p>The current major version of SDL headers.</p> <p>If this were SDL version 3.2.1, this value would be 3. </p> <p><code>property Major: Byte read FMajor</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#Minor","title":"Minor","text":"<p>The current minor version of the SDL headers.</p> <p>If this were SDL version 3.2.1, this value would be 2. </p> <p><code>property Minor: Byte read FMinor</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#Patch","title":"Patch","text":"<p>The current micro (or patchlevel) version of the SDL headers.</p> <p>If this were SDL version 3.2.1, this value would be 1. </p> <p><code>property Patch: Byte read FPatch</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#Revision","title":"Revision","text":"<p>Get the code revision of SDL that is linked against your program.</p> <p>This value is the revision of the code you are linked with and may be different from the code you are compiling with.</p> <p>The revision is arbitrary string (a hash value) uniquely identifying the exact revision of the SDL library in use, and is only useful in comparing against other revisions. It is NOT an incrementing number.</p> <p>If SDL wasn't built from a git repository with the appropriate tools, this will return an empty string.</p> <p>You shouldn't use this property for anything but logging it for debugging purposes. The string is not intended to be reliable in any way. </p> <p><code>class property Revision: String read GetRevision</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#RuntimeVersion","title":"RuntimeVersion","text":"<p>The version of SDL that is linked against your program.</p> <p>If you are linking to SDL dynamically, then it is possible that the current version will be different than the version you compiled (see CompiledVersion) against.</p> <p>This property may be called safely at any time, even before SdlInit. </p> <p><code>class property RuntimeVersion: TSdlVersion read GetRuntimeVersion</code></p> <p>Type: <code>TSdlVersion</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#Create","title":"<code>Create</code>","text":"<p>Creates a version instance. </p> <p><code>constructor Create(const AMajor: Byte; const AMinor: Byte = 0; const APatch: Byte = 0)</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#parameters","title":"Parameters","text":"<p><code>AMajor</code>: <code>Byte</code> : The major version number.</p> <p><code>AMinor</code>: <code>Byte = 0</code> : (optional) Minor version number.</p> <p><code>APatch</code>: <code>Byte = 0</code> : (optional) Patch level.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#AtLeast","title":"AtLeast(Byte, Byte, Byte)","text":"<p>Checks whether the program was compiled against a version of SDL with at least the given version number. </p> <p><code>class function AtLeast(const AMajor: Byte; const AMinor: Byte = 0; const APatch: Byte = 0): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#parameters_1","title":"Parameters","text":"<p><code>AMajor</code>: <code>Byte</code> : Major version to check against.</p> <p><code>AMinor</code>: <code>Byte = 0</code> : (optional) Minor version to check against.</p> <p><code>APatch</code>: <code>Byte = 0</code> : (optional) Patch level to check against.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#returns","title":"Returns","text":"<p><code>Boolean</code>: True if the program was compiled with at least SDL version AMajor.AMinor.APatch</p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#FromNumber","title":"FromNumber(Integer)","text":"<p>Creates a version from a numeric value.</p> <p>Turns 1002003 into (1,2,3) </p> <p><code>class function FromNumber(const ANumber: Integer): TSdlVersion; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#parameters_2","title":"Parameters","text":"<p><code>ANumber</code>: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#returns_1","title":"Returns","text":"<p><code>TSdlVersion</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#ToNumber","title":"ToNumber","text":"<p>Turns this version numbers into a numeric value.</p> <p>(1,2,3) becomes 1002003. </p> <p><code>function ToNumber: Integer; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/classes/TSdlVersion/#returns_2","title":"Returns","text":"<p><code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlCheck_0/","title":"SdlCheck","text":"<p>Checks the result of an SDL API. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlCheck_0/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>procedure SdlCheck(const ASdlResult: THandle); overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlCheck_0/#parameters","title":"Parameters","text":"<p><code>ASdlResult</code>: <code>THandle</code> : The Pointer result of an SDL API.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlCheck_0/#remarks","title":"Remarks","text":"<p>If ASdlResult=0, then TSdlApp.HandleError will be called. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlCheck_1/","title":"SdlCheck","text":"<p>Checks the result of an SDL API. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlCheck_1/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>procedure SdlCheck(const ASdlResult: Boolean); overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlCheck_1/#parameters","title":"Parameters","text":"<p><code>ASdlResult</code>: <code>Boolean</code> : The Boolean result of an SDL API.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlCheck_1/#remarks","title":"Remarks","text":"<p>If ASdlResult=False, then TSdlApp.HandleError will be called. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlCheck_2/","title":"SdlCheck","text":"<p>Checks the result of an SDL API. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlCheck_2/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>procedure SdlCheck(const ASdlResult: Pointer); overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlCheck_2/#parameters","title":"Parameters","text":"<p><code>ASdlResult</code>: <code>Pointer</code> : The Pointer result of an SDL API.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlCheck_2/#remarks","title":"Remarks","text":"<p>If ASdlResult=nil, then TSdlApp.HandleError will be called. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlFailed_0/","title":"SdlFailed","text":"<p>Checks if an SDL API failed. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlFailed_0/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>function SdlFailed(const ASdlResult: THandle): Boolean; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlFailed_0/#parameters","title":"Parameters","text":"<p><code>ASdlResult</code>: <code>THandle</code> : The THandle result of an SDL API.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlFailed_0/#returns","title":"Returns","text":"<p><code>Boolean</code>: True if ASdlResult=0, False if ASdlResult&lt;&gt;0.If this method returns True, then TSdlApp.HandleError will be called. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlFailed_1/","title":"SdlFailed","text":"<p>Checks if an SDL API failed. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlFailed_1/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>function SdlFailed(const ASdlResult: Pointer): Boolean; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlFailed_1/#parameters","title":"Parameters","text":"<p><code>ASdlResult</code>: <code>Pointer</code> : The Pointer result of an SDL API.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlFailed_1/#returns","title":"Returns","text":"<p><code>Boolean</code>: True if ASdlResult=nil, False if ASdlResult&lt;&gt;nil.If this method returns True, then TSdlApp.HandleError will be called. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlFailed_2/","title":"SdlFailed","text":"<p>Checks if an SDL API failed. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlFailed_2/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>function SdlFailed(const ASdlResult: Boolean): Boolean; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlFailed_2/#parameters","title":"Parameters","text":"<p><code>ASdlResult</code>: <code>Boolean</code> : The Boolean result of an SDL API.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlFailed_2/#returns","title":"Returns","text":"<p><code>Boolean</code>: True if ASdlResult=False, False if ASdlResult=True.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlFailed_2/#remarks","title":"Remarks","text":"<p>If this method returns True, then TSdlApp.HandleError will be called. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlGetAppMetadata/","title":"SdlGetAppMetadata","text":"<p>Get metadata about your app.</p> <p>This returns metadata previously set using SdlSetAppMetadata. See SdlSetAppMetadata for the list of available properties and their meanings. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlGetAppMetadata/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>function SdlGetAppMetadata(const AName: String): String; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlGetAppMetadata/#parameters","title":"Parameters","text":"<p><code>AName</code>: <code>String</code> : The name of the metadata property to get.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlGetAppMetadata/#returns","title":"Returns","text":"<p><code>String</code>: The current value of the metadata property, the default if it is not set, or an empty string for properties with no default.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlGetAppMetadata/#see-also","title":"See Also","text":"<ul> <li>SdlSetAppMetadata</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlGetAppMetadata/#remarks","title":"Remarks","text":"<p>It is safe to call this routine from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlInit/","title":"SdlInit","text":"<p>Initialize the SDL library.</p> <p>Init simply forwards to calling InitSubSystem. Therefore, the two may be used interchangeably. Though for readability of your code InitSubSystem might be preferred.</p> <p>The file I/O and threading subsystems are initialized by default. Message boxes also attempt to work without initializing the video subsystem, in hopes of being useful in showing an error dialog when Init fails. You must specifically initialize other subsystems if you use them in your application.</p> <p>Logging works without initialization, too.</p> <p>AFlags may be zero or more of the following:</p> <ul> <li><code>TSdlInitFlag.Audio</code>: audio subsystem; automatically initializes the events subsystem.</li> <li><code>TSdlInitFlag.Video</code>: video subsystem; automatically initializes the events subsystem, should be initialized on the main thread.</li> <li><code>TSdlInitFlag.Joystick</code>: joystick subsystem; automatically initializes the events subsystem</li> <li><code>TSdlInitFlag.Haptic</code>: haptic (force feedback) subsystem</li> <li><code>TSdlInitFlag.Gamepad</code>: gamepad subsystem; automatically initializes the joystick subsystem</li> <li><code>TSdlInitFlag.Events</code>: events subsystem</li> <li><code>TSdlInitFlag.Sensor</code>: sensor subsystem; automatically initializes the events subsystem</li> <li><code>TSdlInitFlag.Camera</code>: camera subsystem; automatically initializes the events subsystem</li> </ul> <p>Subsystem initialization is ref-counted, you must call QuitSubSystem for each InitSubSystem to correctly shutdown a subsystem manually (or call Quit to force shutdown). If a subsystem is already loaded then this call will increase the ref-count and return.</p> <p>Consider reporting some basic metadata about your application before calling Init, using SdlSetAppMetadata. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlInit/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>procedure SdlInit(const AFlags: TSdlInitFlags); inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlInit/#parameters","title":"Parameters","text":"<p><code>AFlags</code>: <code>TSdlInitFlags</code> : Subsystem initialization flags.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlInit/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlInit/#see-also","title":"See Also","text":"<ul> <li>SdlSetAppMetadata</li> <li>SdlInitSubSystem</li> <li>SdlQuit</li> <li>SdlWasInit</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlInitSubSystem/","title":"SdlInitSubSystem","text":"<p>Compatibility function to initialize the SDL library.</p> <p>This routine and SdlInit are interchangeable. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlInitSubSystem/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>procedure SdlInitSubSystem(const AFlags: TSdlInitFlags); inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlInitSubSystem/#parameters","title":"Parameters","text":"<p><code>AFlags</code>: <code>TSdlInitFlags</code> : Any of the flags used by SdlInit; see SdlInit for details.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlInitSubSystem/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlInitSubSystem/#see-also","title":"See Also","text":"<ul> <li>SdlInit</li> <li>SdlQuit</li> <li>SdlQuitSubSystem</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlIsMainThread/","title":"SdlIsMainThread","text":"<p>Return whether this is the main thread.</p> <p>On Apple platforms, the main thread is the thread that runs your program's entry point. On other platforms, the main thread is the one that calls SdlInit([TSdlInitFlag.Video]), which should usually be the one that runs your program's entry point. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlIsMainThread/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>function SdlIsMainThread: Boolean; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlIsMainThread/#returns","title":"Returns","text":"<p><code>Boolean</code>: True if this thread is the main thread, or False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlIsMainThread/#see-also","title":"See Also","text":"<ul> <li>SdlRunOnMainThread</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlIsMainThread/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlQuit/","title":"SdlQuit","text":"<p>Clean up all initialized subsystems.</p> <p>You should call this function even if you have already shutdown each initialized subsystem with SdlQuitSubSystem. It is safe to call this function even in the case of errors in initialization.</p> <p>You can use this function with atexit() to ensure that it is run when your application is shutdown, but it is not wise to do this from a library or other dynamically loaded code. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlQuit/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>procedure SdlQuit; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlQuit/#see-also","title":"See Also","text":"<ul> <li>SdlInit</li> <li>SdlQuitSubSystem</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlQuitSubSystem/","title":"SdlQuitSubSystem","text":"<p>Shut down specific SDL subsystems.</p> <p>You still need to call SdlQuit even if you close all open subsystems with SdlQuitSubSystem. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlQuitSubSystem/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>procedure SdlQuitSubSystem(const AFlags: TSdlInitFlags); inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlQuitSubSystem/#parameters","title":"Parameters","text":"<p><code>AFlags</code>: <code>TSdlInitFlags</code> : Any of the flags used by SdlInit; see SdlInit for details.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlQuitSubSystem/#see-also","title":"See Also","text":"<ul> <li>SdlInitSubSystem</li> <li>SdlQuit</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlRunOnMainThread/","title":"SdlRunOnMainThread","text":"<p>Call a function on the main thread during event processing.</p> <p>If this is called on the main thread, the callback is executed immediately. If this is called on another thread, this callback is queued for execution on the main thread during event processing.</p> <p>Be careful of deadlocks when using this functionality. You should not have the main thread wait for the current thread while this function is being called with <code>AWaitComplete</code> true. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlRunOnMainThread/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>procedure SdlRunOnMainThread(const ACallback: TSdlMainThreadCallback; \n  const AWaitComplete: Boolean = False)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlRunOnMainThread/#parameters","title":"Parameters","text":"<p><code>ACallback</code>: <code>TSdlMainThreadCallback</code> : The callback to call on the main thread.</p> <p><code>AWaitComplete</code>: <code>Boolean = False</code> : (Optional) True to wait for the callback to complete, False (default) to return immediately.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlRunOnMainThread/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlRunOnMainThread/#see-also","title":"See Also","text":"<ul> <li>SdlIsMainThread</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlRunOnMainThread/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSetAppMetadata_0/","title":"SdlSetAppMetadata","text":"<p>Specify basic metadata about your app.</p> <p>You can optionally provide metadata about your app to SDL. This is not required, but strongly encouraged.</p> <p>There are several locations where SDL can make use of metadata (an \"About\" box in the macOS menu bar, the name of the app can be shown on some audio mixers, etc). Any piece of metadata can be left empty, if a specific detail doesn't make sense for the app.</p> <p>This function should be called as early as possible, before Init. Multiple calls to this function are allowed, but various state might not change once it has been set up with a previous call to this function.</p> <p>Passing an empty string removes any previous metadata.</p> <p>This is a simplified interface for the most important information. You can supply significantly more detailed metadata with SetAppMetadataProperty. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSetAppMetadata_0/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>procedure SdlSetAppMetadata(const AAppName, AAppVersion, \n  AAppIdentifier: String); overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSetAppMetadata_0/#parameters","title":"Parameters","text":"<p><code>AAppName</code>: <code>String</code> : The name of the application ('My Game 2: Bad Guy's Revenge!').</p> <p><code>AAppVersion</code>: <code>String</code> : The version of the application ('1.0.0beta5' or a git hash, or whatever makes sense).</p> <p><code>AAppIdentifier</code>: <code>String</code> : A unique string in reverse-domain format that identifies this app ('com.example.mygame2').</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSetAppMetadata_0/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSetAppMetadata_0/#see-also","title":"See Also","text":"<ul> <li>SdlGetAppMetadata</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSetAppMetadata_0/#remarks","title":"Remarks","text":"<p>It is safe to call this routine from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSetAppMetadata_1/","title":"SdlSetAppMetadata","text":"<p>Specify metadata about your app through a set of properties.</p> <p>You can optionally provide metadata about your app to SDL. This is not required, but strongly encouraged.</p> <p>There are several locations where SDL can make use of metadata (an \"About\" box in the macOS menu bar, the name of the app can be shown on some audio mixers, etc). Any piece of metadata can be left out, if a specific detail doesn't make sense for the app.</p> <p>This routine should be called as early as possible, before SdlInit. Multiple calls to this routine are allowed, but various state might not change once it has been set up with a previous call to this routine.</p> <p>Once set, this metadata can be read using SdlGetAppMetadata.</p> <p>These are the supported properties:</p> <ul> <li><code>TSdlProperty.AppMetadataName</code>: The human-readable name of the application, like 'My Game 2: Bad Guy's Revenge!'. This will show up anywhere the OS shows the name of the application separately from window titles, such as volume control applets, etc. This defaults to 'SDL Application'.</li> <li><code>TSdlProperty.AppMetadataVersion</code>: The version of the app that is running; there are no rules on format, so '1.0.3beta2' and 'April 22nd, 2024' and a git hash are all valid options. This has no default.</li> <li><code>TSdlProperty.AppMetadataIdentifier</code>: A unique string that identifies this app. This must be in reverse-domain format, like 'com.example.mygame2'. This string is used by desktop compositors to identify and group windows together, as well as match applications with associated desktop settings and icons. If you plan to package your application in a container such as Flatpak, the app ID should match the name of your Flatpak container as well. This has no default.</li> <li><code>TSdlProperty.AppMetadataCreator</code>: The human-readable name of the creator/developer/maker of this app, like 'MojoWorkshop, LLC'</li> <li><code>TSdlProperty.AppMetadataCopyright</code>: The human-readable copyright notice, like 'Copyright (c) 2025 MojoWorkshop, LLC' or whatnot. Keep this to one line, don't paste a copy of a whole software license in here. This has no default.</li> <li><code>TSdlProperty.AppMetadataUrl</code>: A URL to the app on the web. Maybe a product page, or a storefront, or even a GitHub repository, for user's further information This has no default.</li> <li><code>TSdlProperty.AppMetadataType</code>: The type of application this is. Currently this string can be 'game' for a video game, 'mediaplayer' for a media player, or generically 'application' if nothing else applies. Future versions of SDL might add new types. This defaults to 'application'. </li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSetAppMetadata_1/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>procedure SdlSetAppMetadata(const AName, AValue: String); overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSetAppMetadata_1/#parameters","title":"Parameters","text":"<p><code>AName</code>: <code>String</code> : The name of the metadata property to set.</p> <p><code>AValue</code>: <code>String</code> : The value of the property, or an empty string to remove that property.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSetAppMetadata_1/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSetAppMetadata_1/#see-also","title":"See Also","text":"<ul> <li>SdlGetAppMetadata</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSetAppMetadata_1/#remarks","title":"Remarks","text":"<p>It is safe to call this routine from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSucceeded_0/","title":"SdlSucceeded","text":"<p>Checks if an SDL API succeeded. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSucceeded_0/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>function SdlSucceeded(const ASdlResult: Pointer): Boolean; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSucceeded_0/#parameters","title":"Parameters","text":"<p><code>ASdlResult</code>: <code>Pointer</code> : The Pointer result of an SDL API.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSucceeded_0/#returns","title":"Returns","text":"<p><code>Boolean</code>: True of ASdlResult is assigned, False if it is nil.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSucceeded_0/#remarks","title":"Remarks","text":"<p>If this method returns False, then TSdlApp.HandleError will be called. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSucceeded_1/","title":"SdlSucceeded","text":"<p>Checks if an SDL API succeeded. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSucceeded_1/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>function SdlSucceeded(const ASdlResult: Boolean): Boolean; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSucceeded_1/#parameters","title":"Parameters","text":"<p><code>ASdlResult</code>: <code>Boolean</code> : The Boolean result of an SDL API.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSucceeded_1/#returns","title":"Returns","text":"<p><code>Boolean</code>: ASdlResult.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSucceeded_1/#remarks","title":"Remarks","text":"<p>If this method returns False, then TSdlApp.HandleError will be called. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSucceeded_2/","title":"SdlSucceeded","text":"<p>Checks if an SDL API succeeded. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSucceeded_2/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>function SdlSucceeded(const ASdlResult: THandle): Boolean; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSucceeded_2/#parameters","title":"Parameters","text":"<p><code>ASdlResult</code>: <code>THandle</code> : The THandle result of an SDL API.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlSucceeded_2/#returns","title":"Returns","text":"<p><code>Boolean</code>: True of ASdlResult&lt;&gt;0, False if it is 0.If this method returns False, then TSdlApp.HandleError will be called. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlWasInit/","title":"SdlWasInit","text":"<p>Get the specified subsystems which are currently initialized. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlWasInit/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>function SdlWasInit(const AFlags: TSdlInitFlags = []): TSdlInitFlags; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlWasInit/#parameters","title":"Parameters","text":"<p><code>AFlags</code>: <code>TSdlInitFlags = []</code> : (Optional) flags used by SdlInit; see SdlInit for details.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlWasInit/#returns","title":"Returns","text":"<p><code>TSdlInitFlags</code>: All initialized subsystems if <code>AFlags</code> is [], otherwise it returns the initialization status of the specified subsystems.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/routines/SdlWasInit/#see-also","title":"See Also","text":"<ul> <li>SdlInit</li> <li>SdlInitSubSystem</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlEnumeratePropertiesCallback/","title":"TSdlEnumeratePropertiesCallback","text":"<p>A callback used to enumerate all the properties in a group of properties.</p> <p>This callback is called from TSdlProperties.Enumerate, and is called once per property in the set. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlEnumeratePropertiesCallback/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type TSdlEnumeratePropertiesCallback = procedure(const AProps: TSdlProperties; \n  const AName: String) of object\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlEnumeratePropertiesCallback/#parameters","title":"Parameters","text":"<p><code>AProps</code>: <code>TSdlProperties</code> : The properties that is being enumerated.</p> <p><code>AName</code>: <code>String</code> : The next property name in the enumeration.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlEnumeratePropertiesCallback/#see-also","title":"See Also","text":"<ul> <li>TSdlProperties.Enumerate</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlEnumeratePropertiesCallback/#remarks","title":"Remarks","text":"<p>TSdlProperties.Enumerate holds a lock on <code>AProps</code> during this callback. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlHintCallback/","title":"TSdlHintCallback","text":"<p>A callback used to send notifications of hint value changes.</p> <p>This is called an initial time during SDL_AddHintCallback with the hint's current value, and then again each time the hint's value changes. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlHintCallback/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type TSdlHintCallback = procedure(const AName, AOldValue, \n  ANewValue: String) of object\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlHintCallback/#parameters","title":"Parameters","text":"<p><code>AName</code>: <code>String</code> : What was passed as <code>AName</code> to TSdlHints.AddCallback (one of the TSdlHints constants).</p> <p><code>AOldValue</code>: <code>String</code> : The previous hint value.</p> <p><code>ANewValue</code>: <code>String</code> : The new value hint is to be set to.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlHintCallback/#see-also","title":"See Also","text":"<ul> <li>TSdlHints.AddCallback</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlHintCallback/#remarks","title":"Remarks","text":"<p>This callback is fired from whatever thread is setting a new hint value. SDL holds a lock on the hint subsystem when calling this callback. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlHintPriority/","title":"TSdlHintPriority","text":"<p>An enumeration of hint priorities. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlHintPriority/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type TSdlHintPriority = (Default, Normal, Override)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlHintPriority/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlHintPriority/#default-sdl_hint_default","title":"<code>Default = SDL_HINT_DEFAULT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlHintPriority/#normal-sdl_hint_normal","title":"<code>Normal = SDL_HINT_NORMAL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlHintPriority/#override-sdl_hint_override","title":"<code>Override = SDL_HINT_OVERRIDE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlInitFlag/","title":"TSdlInitFlag","text":"<p>Initialization flags for SdlInit and/or SdlInitSubSystem.</p> <p>These are the flags which may be passed to SdlInit. You should specify the subsystems which you will be using in your application. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlInitFlag/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type TSdlInitFlag = (Audio, Video, Joystick, Haptick, Gamepad, Events, Sensor, Camera)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlInitFlag/#see-also","title":"See Also","text":"<ul> <li>SdlInit</li> <li>SdlQuit</li> <li>SdlInitSubSystem</li> <li>SdlQuitSubSystem</li> <li>SdlWasInit</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlInitFlag/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlInitFlag/#audio-4","title":"<code>Audio = 4</code>","text":"<p>The audio subsystem. Implies TSdlInitFlag.Events.</p> <p>Enables the functionality in the Neslib.Sdl3.Audio unit. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlInitFlag/#video-5","title":"<code>Video = 5</code>","text":"<p>The video subsystem. Implies TSdlInitFlag.Events. Should be initialized on the main thread.</p> <p>Enables the functionality in the Neslib.Sdl3.Video unit. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlInitFlag/#joystick-9","title":"<code>Joystick = 9</code>","text":"<p>The joystick subsystem. Implies TSdlInitFlag.Events. Should be initialized on the same thread as TSdlInitFlag.Video on Windows if you don't set TSdlHints.JoystickThread.</p> <p>Enables the joystick functionality in the Neslib.Sdl3.Events unit. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlInitFlag/#haptick-12","title":"<code>Haptick = 12</code>","text":"<p>The haptick (force feedback) subsystem. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlInitFlag/#gamepad-13","title":"<code>Gamepad = 13</code>","text":"<p>The gamepad subsystem. Implies TSdlInitFlag.Joystick.</p> <p>Enables the gamepad functionality in the Neslib.Sdl3.Events unit. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlInitFlag/#events-14","title":"<code>Events = 14</code>","text":"<p>The events subsystem.</p> <p>Enables the functionality in the Neslib.Sdl3.Events unit. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlInitFlag/#sensor-15","title":"<code>Sensor = 15</code>","text":"<p>The sensor subsystem. Implies TSdlInitFlag.Events.</p> <p>Enables the sensor functionality in the Neslib.Sdl3.Events unit. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlInitFlag/#camera-16","title":"<code>Camera = 16</code>","text":"<p>The camera subsystem. Implies TSdlInitFlag.Events.</p> <p>Enables the functionality in the Neslib.Sdl3.Camera and Neslib.Sdl3.Events units. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlInitFlags/","title":"TSdlInitFlags","text":"<p>A set of initialization flags for SdlInit and/or SdlInitSubSystem. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlInitFlags/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type TSdlInitFlags = set of TSdlInitFlag\n</code></pre> <p>Base type: <code>TSdlInitFlag</code></p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogCategory/","title":"TSdlLogCategory","text":"<p>The predefined log categories</p> <p>By default the Application and Gpu categories are enabled at the Info level, the Assert category is enabled at the Warn level, Test is enabled at the Verbose level and all other categories are enabled at the Error level. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogCategory/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type TSdlLogCategory = (Application, Error, Assert, System, Audio, Video, Render, Input, Test, Gpu, Custom)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogCategory/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogCategory/#application-sdl_log_category_application","title":"<code>Application = SDL_LOG_CATEGORY_APPLICATION</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogCategory/#error-sdl_log_category_error","title":"<code>Error = SDL_LOG_CATEGORY_ERROR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogCategory/#assert-sdl_log_category_assert","title":"<code>Assert = SDL_LOG_CATEGORY_ASSERT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogCategory/#system-sdl_log_category_system","title":"<code>System = SDL_LOG_CATEGORY_SYSTEM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogCategory/#audio-sdl_log_category_audio","title":"<code>Audio = SDL_LOG_CATEGORY_AUDIO</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogCategory/#video-sdl_log_category_video","title":"<code>Video = SDL_LOG_CATEGORY_VIDEO</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogCategory/#render-sdl_log_category_render","title":"<code>Render = SDL_LOG_CATEGORY_RENDER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogCategory/#input-sdl_log_category_input","title":"<code>Input = SDL_LOG_CATEGORY_INPUT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogCategory/#test-sdl_log_category_test","title":"<code>Test = SDL_LOG_CATEGORY_TEST</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogCategory/#gpu-sdl_log_category_gpu","title":"<code>Gpu = SDL_LOG_CATEGORY_GPU</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogCategory/#custom-sdl_log_category_custom","title":"<code>Custom = SDL_LOG_CATEGORY_CUSTOM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogOutputFunction/","title":"TSdlLogOutputFunction","text":"<p>The prototype for the log output callback function.</p> <p>This function is called by SDL when there is new text to be logged. A mutex is held so that this function is never called by more than one thread at once. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogOutputFunction/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type TSdlLogOutputFunction = procedure(const ACategory: TSdlLogCategory; \n  const APriority: TSdlLogPriority; const AMessage: String) of object\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogOutputFunction/#parameters","title":"Parameters","text":"<p><code>ACategory</code>: <code>TSdlLogCategory</code> : The category of the message.</p> <p><code>APriority</code>: <code>TSdlLogPriority</code> : The priority of the message.</p> <p><code>AMessage</code>: <code>String</code> : The message being output.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogPriority/","title":"TSdlLogPriority","text":"<p>The predefined log priorities </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogPriority/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type TSdlLogPriority = (Invalid, Trace, Verbose, Debug, Info, Warn, Error, Critical)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogPriority/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogPriority/#invalid-sdl_log_priority_invalid","title":"<code>Invalid = SDL_LOG_PRIORITY_INVALID</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogPriority/#trace-sdl_log_priority_trace","title":"<code>Trace = SDL_LOG_PRIORITY_TRACE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogPriority/#verbose-sdl_log_priority_verbose","title":"<code>Verbose = SDL_LOG_PRIORITY_VERBOSE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogPriority/#debug-sdl_log_priority_debug","title":"<code>Debug = SDL_LOG_PRIORITY_DEBUG</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogPriority/#info-sdl_log_priority_info","title":"<code>Info = SDL_LOG_PRIORITY_INFO</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogPriority/#warn-sdl_log_priority_warn","title":"<code>Warn = SDL_LOG_PRIORITY_WARN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogPriority/#error-sdl_log_priority_error","title":"<code>Error = SDL_LOG_PRIORITY_ERROR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlLogPriority/#critical-sdl_log_priority_critical","title":"<code>Critical = SDL_LOG_PRIORITY_CRITICAL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlMainThreadCallback/","title":"TSdlMainThreadCallback","text":"<p>Callback run on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlMainThreadCallback/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type TSdlMainThreadCallback = procedure of object\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlMainThreadCallback/#see-also","title":"See Also","text":"<ul> <li>SdlRunOnMainThread</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlPropertyCleanupCallback/","title":"TSdlPropertyCleanupCallback","text":"<p>A callback used to free resources when a property is deleted.</p> <p>This should release any resources associated with <code>AValue</code> that are no longer needed.</p> <p>This callback is set per-property. Different properties in the same group can have different cleanup callbacks.</p> <p>This callback will be called during TSdlProperties.SetPointerWithCleanup if the function fails for any reason. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlPropertyCleanupCallback/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type TSdlPropertyCleanupCallback = procedure(const AValue: Pointer) of object\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlPropertyCleanupCallback/#parameters","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code> : The pointer assigned to the property to clean up.</p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlPropertyCleanupCallback/#see-also","title":"See Also","text":"<ul> <li>TSdlProperties.SetPointerWithCleanup</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlPropertyCleanupCallback/#remarks","title":"Remarks","text":"<p>This callback may fire without any locks held; if this is a concern, the app should provide its own locking. </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlPropertyType/","title":"TSdlPropertyType","text":"<p>SDL property type </p>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlPropertyType/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Basics</p> <pre><code>type TSdlPropertyType = (Invalid, Pointer, &amp;String, Number, Float, Bool)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlPropertyType/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlPropertyType/#invalid-sdl_property_type_invalid","title":"<code>Invalid = SDL_PROPERTY_TYPE_INVALID</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlPropertyType/#pointer-sdl_property_type_pointer","title":"<code>Pointer = SDL_PROPERTY_TYPE_POINTER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlPropertyType/#string-sdl_property_type_string","title":"<code>&amp;String = SDL_PROPERTY_TYPE_STRING</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlPropertyType/#number-sdl_property_type_number","title":"<code>Number = SDL_PROPERTY_TYPE_NUMBER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlPropertyType/#float-sdl_property_type_float","title":"<code>Float = SDL_PROPERTY_TYPE_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Basics/types/TSdlPropertyType/#bool-sdl_property_type_boolean","title":"<code>Bool = SDL_PROPERTY_TYPE_BOOLEAN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Events/","title":"Neslib.Sdl3.Events","text":""},{"location":"Reference/Neslib.Sdl3.Events/#classes-records","title":"Classes &amp; Records","text":"Name Description TSdlAudioDeviceEvent Audio device event structure (Event.Audio.* ) TSdlCameraDeviceEvent Camera device event structure (Event.Camera.* ) TSdlClipboardEvent An event used to drop text or request a file open by the system (Event.Drop.* ) TSdlCommonEvent Fields shared by every event. TSdlDisplayEvent Display state change event data (Event.Display.* ) TSdlDropEvent An event used to drop text or request a file open by the system (Event.Drop.* ) TSdlEvent A variant record that contains records for the different event types. TSdlEvents Event queue management. TSdlGamepadAxisEvent Gamepad axis motion event structure (Event.GamepadAxis.* ) TSdlGamepadButtonEvent Gamepad button event structure (Event.GamepadButton.* ) TSdlGamepadDeviceEvent Gamepad device event structure (Event.GamepadDevice.* ) TSdlGamepadSensorEvent Gamepad sensor event structure (Event.GamepadSensor.* ) TSdlGamepadTouchpadEvent Gamepad touchpad event structure (Event.GamepadTouch.* ) TSdlJoyAxisEvent Joystick axis motion event structure (Event.JoyAxis.* ) TSdlJoyBallEvent Joystick trackball motion event structure (Event.JoyBball.* ) TSdlJoyBatteryEvent Joystick battery level change event structure (Event.JoyBattery.* ) TSdlJoyButtonEvent Joystick button event structure (Event.JoyButton.* ) TSdlJoyDeviceEvent Joystick device event structure (Event.JoyDevice.* ) TSdlJoyHatEvent Joystick hat position change event structure (Event.JoyHat.* ) TSdlKeyboardDeviceEvent Keyboard device event structure (Event.KeyboardDevice.* ) TSdlKeyboardEvent Keyboard button event structure (Event.Key.* ) TSdlMouseButtonEvent Mouse button event structure (Event.MouseButton.* ) TSdlMouseDeviceEvent Mouse device event structure (Event.MouseDevice.* ) TSdlMouseMotionEvent Mouse motion event structure (Event.MouseMotion.* ) TSdlMouseWheelEvent Mouse wheel event structure (Event.MouseWheel.* ) TSdlPenAxisEvent Pressure-sensitive pen pressure / angle event structure (Event.PenAxis.* ) TSdlPenButtonEvent Pressure-sensitive pen button event structure (Event.PenButton.* ) TSdlPenMotionEvent Pressure-sensitive pen motion event structure (Event.PenMotion.* ) TSdlPenProximityEvent Pressure-sensitive pen proximity event structure (Event.PenProximity.* ) TSdlPenTouchEvent Pressure-sensitive pen touched event structure (Event.PenTouch.* ) TSdlQuitEvent The \"quit requested\" event TSdlRenderEvent Renderer event structure (Event.Render.* ) TSdlSensorEvent Sensor event structure (Event.Sensor.* ) TSdlTextEditingCandidatesEvent Keyboard IME candidates event structure (Event.TextCandidates.* ) TSdlTextEditingEvent Keyboard text editing event structure (Event.TextEdit.* ) TSdlTextInputEvent Keyboard text input event structure (Event.TextInput.* ) TSdlTouchFingerEvent Touch finger event structure (Event.Finger.* ) TSdlUserEvent A user-defined event type (event.user.* ) TSdlWindowEvent Window state change event data (Event.Window.* )"},{"location":"Reference/Neslib.Sdl3.Events/#types","title":"Types","text":"Name Description PSdlEvent TSdlEventAction The type of action to request from TSdlEvents.Peep. TSdlEventFilter A function type used for callbacks that watch the event queue. TSdlEventKind The types of events that can be delivered."},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlAudioDeviceEvent/","title":"TSdlAudioDeviceEvent","text":"<p>Audio device event structure (Event.Audio.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlAudioDeviceEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlAudioDeviceEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlAudioDeviceEvent/#properties","title":"Properties","text":"Name Description AudioDevice The device being added or removed or changing AudioDeviceID ID for the device being added or removed or changing IsRecording False if a playback device, True if a recording device. Kind Event kind (TSdlEventKind.AudioDevice*) Timestamp In nanoseconds, populated using SdlGetTicksNS"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlAudioDeviceEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlAudioDeviceEvent/#AudioDevice","title":"AudioDevice","text":"<p>The device being added or removed or changing</p> <p><code>property AudioDevice: TSdlAudioDevice read GetAudioDevice</code></p> <p>Type: <code>TSdlAudioDevice</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlAudioDeviceEvent/#AudioDeviceID","title":"AudioDeviceID","text":"<p>ID for the device being added or removed or changing</p> <p><code>property AudioDeviceID: TSdlAudioDeviceID read GetAudioDeviceID</code></p> <p>Type: <code>TSdlAudioDeviceID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlAudioDeviceEvent/#IsRecording","title":"IsRecording","text":"<p>False if a playback device, True if a recording device.</p> <p><code>property IsRecording: Boolean read FHandle.recording</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlAudioDeviceEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.AudioDevice*)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlAudioDeviceEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlCameraDeviceEvent/","title":"TSdlCameraDeviceEvent","text":"<p>Camera device event structure (Event.Camera.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlCameraDeviceEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlCameraDeviceEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlCameraDeviceEvent/#properties","title":"Properties","text":"Name Description CameraID ID for the device being added or removed or changing Kind Event kind (TSdlEventKind.CameraDevice*) Timestamp In nanoseconds, populated using SdlGetTicksNS"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlCameraDeviceEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlCameraDeviceEvent/#CameraID","title":"CameraID","text":"<p>ID for the device being added or removed or changing</p> <p><code>property CameraID: TSdlCameraID read GetCameraID</code></p> <p>Type: <code>TSdlCameraID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlCameraDeviceEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.CameraDevice*)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlCameraDeviceEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlClipboardEvent/","title":"TSdlClipboardEvent","text":"<p>An event used to drop text or request a file open by the system (Event.Drop.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlClipboardEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlClipboardEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlClipboardEvent/#properties","title":"Properties","text":"Name Description IsOwner Are we owning the clipboard (internal update) Kind Event kind (TSdlEventKind.ClipboardUpdate) MimeTypes Current mime types MimeTypesPtr Pointer to current mime types NumMimeTypes Number of mime types Timestamp In nanoseconds, populated using SdlGetTicksNS"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlClipboardEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlClipboardEvent/#IsOwner","title":"IsOwner","text":"<p>Are we owning the clipboard (internal update)</p> <p><code>property IsOwner: Boolean read FHandle.owner</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlClipboardEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.ClipboardUpdate)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlClipboardEvent/#MimeTypes","title":"MimeTypes","text":"<p>Current mime types</p> <p><code>property MimeTypes: TArray&lt;String&gt; read GetMimeTypes</code></p> <p>Type: <code>TArray&lt;String&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlClipboardEvent/#MimeTypesPtr","title":"MimeTypesPtr","text":"<p>Pointer to current mime types</p> <p><code>property MimeTypesPtr: PPUTF8Char read FHandle.mime_types</code></p> <p>Type: <code>PPUTF8Char</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlClipboardEvent/#NumMimeTypes","title":"NumMimeTypes","text":"<p>Number of mime types</p> <p><code>property NumMimeTypes: Integer read FHandle.num_mime_types</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlClipboardEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlCommonEvent/","title":"TSdlCommonEvent","text":"<p>Fields shared by every event. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlCommonEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlCommonEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlCommonEvent/#properties","title":"Properties","text":"Name Description Kind Event kind, shared with all events Timestamp In nanoseconds, populated using SdlGetTicksNS"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlCommonEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlCommonEvent/#Kind","title":"Kind","text":"<p>Event kind, shared with all events</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlCommonEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDisplayEvent/","title":"TSdlDisplayEvent","text":"<p>Display state change event data (Event.Display.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDisplayEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlDisplayEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDisplayEvent/#properties","title":"Properties","text":"Name Description Data1 Event dependent data Data2 Event dependent data DisplayID The associated display Kind Event kind (TSdlEventKind.Display*) Timestamp In nanoseconds, populated using SdlGetTicksNS"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDisplayEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDisplayEvent/#Data1","title":"Data1","text":"<p>Event dependent data</p> <p><code>property Data1: Integer read FHandle.data1</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDisplayEvent/#Data2","title":"Data2","text":"<p>Event dependent data</p> <p><code>property Data2: Integer read FHandle.data2</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDisplayEvent/#DisplayID","title":"DisplayID","text":"<p>The associated display</p> <p><code>property DisplayID: TSdlDisplayID read FHandle.displayID</code></p> <p>Type: <code>TSdlDisplayID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDisplayEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.Display*)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDisplayEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDropEvent/","title":"TSdlDropEvent","text":"<p>An event used to drop text or request a file open by the system (Event.Drop.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDropEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlDropEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDropEvent/#properties","title":"Properties","text":"Name Description Data The text for TSdlEventKind.DropText and the file name for TSdlEventKind.DropFile, nil for other events DataPtr Pointer to the text for TSdlEventKind.DropText and the file name for TSdlEventKind.DropFile, nil for other events Kind Event kind (TSdlEventKind.Drop*) Position Position, relative to window (not on begin) Source The source app that sent this drop event, or empty if that isn't available SourcePtr Pointer to a string of the source app that sent this drop event, or nil if that isn't available Timestamp In nanoseconds, populated using SdlGetTicksNS Window The window that was dropped on, if any WindowID The ID of the window that was dropped on, if any X X coordinate, relative to window (not on begin) Y Y coordinate, relative to window (not on begin)"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDropEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDropEvent/#Data","title":"Data","text":"<p>The text for TSdlEventKind.DropText and the file name for TSdlEventKind.DropFile, nil for other events</p> <p><code>property Data: String read GetData</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDropEvent/#DataPtr","title":"DataPtr","text":"<p>Pointer to the text for TSdlEventKind.DropText and the file name for TSdlEventKind.DropFile, nil for other events</p> <p><code>property DataPtr: PUTF8Char read FHandle.data</code></p> <p>Type: <code>PUTF8Char</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDropEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.Drop*)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDropEvent/#Position","title":"Position","text":"<p>Position, relative to window (not on begin)</p> <p><code>property Position: TSdlPointF read GetPosition</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDropEvent/#Source","title":"Source","text":"<p>The source app that sent this drop event, or empty if that isn't available</p> <p><code>property Source: String read GetSource</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDropEvent/#SourcePtr","title":"SourcePtr","text":"<p>Pointer to a string of the source app that sent this drop event, or nil if that isn't available</p> <p><code>property SourcePtr: PUTF8Char read FHandle.source</code></p> <p>Type: <code>PUTF8Char</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDropEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDropEvent/#Window","title":"Window","text":"<p>The window that was dropped on, if any</p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDropEvent/#WindowID","title":"WindowID","text":"<p>The ID of the window that was dropped on, if any</p> <p><code>property WindowID: TSdlWindowID read FHandle.windowID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDropEvent/#X","title":"X","text":"<p>X coordinate, relative to window (not on begin)</p> <p><code>property X: Single read FHandle.x</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlDropEvent/#Y","title":"Y","text":"<p>Y coordinate, relative to window (not on begin)</p> <p><code>property Y: Single read FHandle.y</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/","title":"TSdlEvent","text":"<p>A variant record that contains records for the different event types.</p> <p>The TSdlEvent record is the core of all event handling in SDL. TSdlEvent is a variant record of all event records used in SDL. Using it is a simple matter of knowing which event kind corresponds to which property. The table below lists these relationships.</p> TSdlEventKind Event Record TSdlEvent Field Display* TSdlDisplayEvent Display Window* TSdlWindowEvent Window KeyboardAdded/Removed TSdlKeyboardDeviceEvent KeyboardDevice Key* TSdlKeyboardEvent Key TextEditing TSdlTextEditingEvent TextEdit TextEditingCandidates TSdlTextEditingCandidatesEvent TextCandidates TextInput TSdlTextInputEvent TextInput MouseAdded/Removed TSdlMouseDeviceEvent MouseDevice MouseMotion TSdlMouseMotionEvent MouseMotion MouseButtonUp/Down TSdlMouseButtonEvent MouseButton MouseWheel TSdlMouseWheelEvent MouseWheel JoystickAxisMotion TSdlJoyAxisEvent JoyAxis JoystickBallMotion TSdlJoyBallEvent JoyBall JoystickHatMotion TSdlJoyHatEvent JoyHat JoystickButtonUp/Down TSdlJoyButtonEvent JoyButton JoystickBatteryUpdated TSdlJoyBatteryEvent JoyBattery Joystick* (others) TSdlJoyDeviceEvent JoyDevice GamepadAxisMotion TSdlGamepadAxisEvent GamepadAxis GamepadButtonUp/Down TSdlGamepadButtonEvent GamepadButton GamepadTouchpad* TSdlGamepadTouchpadEvent GamepadTouch GamepadSensorUpdate TSdlGamepadSensorEvent GamepadSensor GamepadAdded* (others) TSdlGamepadDeviceEvent GamepadDevice AudioDevice* TSdlAudioDeviceEvent Audio CameraDevice* TSdlCameraDeviceEvent Camera SensorUpdate TSdlSensorEvent Sensor Quit TSdlQuitEvent Quit Finger* TSdlTouchFingerEvent Finger PenProximityIn/Out TSdlPenProximityEvent PenProximity PenUp/Down TSdlPenTouchEvent PenTouch PenMotion TSdlPenMotionEvent PenMotion PenButtonUp/Down TSdlPenButtonEvent PenButton PenAxis TSdlPenAxisEvent PenAxis Render* TSdlRenderEvent Render Drop* TSdlDropEvent Drop ClipboardUpdate TSdlClipboardEvent Clipboard (registered user event) TSdlUserEvent User (other events) TSdlCommonEvent Common"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#fields","title":"Fields","text":"Name Description Audio Audio device event data Camera Camera device event data Clipboard Clipboard event data Common Common event data Display Display event data Drop Drag and drop event data Finger Touch finger event data GamepadAxis Gamepad axis event data GamepadButton Gamepad button event data GamepadDevice Gamepad device event data GamepadSensor Gamepad sensor event data GamepadTouch Gamepad touchpad event data Handle Handle to underlying C event record JoyAxis Joystick axis event data JoyBall Joystick ball event data JoyBattery Joystick battery event data JoyButton Joystick button event data JoyDevice Joystick device change event data JoyHat Joystick hat event data Key Keyboard event data KeyboardDevice Keyboard device change event data Kind Event kind, shared with all events MouseButton Mouse button event data MouseDevice Mouse device change event data MouseMotion Mouse motion event data MouseWheel Mouse wheel event data PenAxis Pen axis event data PenButton Pen button event data PenMotion Pen motion event data PenProximity Pen proximity event data PenTouch Pen tip touching event data Quit Quit request event data Render Render event data Sensor Sensor event data TextCandidates Text editing candidates event data TextEdit Text editing event data TextInput Text editing candidates event data User Custom event data Window Window event data"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#methods","title":"Methods","text":"Name Description ConvertToRenderCoordinates Convert the coordinates in an event to render coordinates."},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#Audio","title":"Audio","text":"<p>Audio device event data</p> <p><code>var Audio: TSdlAudioDeviceEvent</code></p> <p>Type: <code>TSdlAudioDeviceEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#Camera","title":"Camera","text":"<p>Camera device event data</p> <p><code>var Camera: TSdlCameraDeviceEvent</code></p> <p>Type: <code>TSdlCameraDeviceEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#Clipboard","title":"Clipboard","text":"<p>Clipboard event data</p> <p><code>var Clipboard: TSdlClipboardEvent</code></p> <p>Type: <code>TSdlClipboardEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#Common","title":"Common","text":"<p>Common event data</p> <p><code>var Common: TSdlCommonEvent</code></p> <p>Type: <code>TSdlCommonEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#Display","title":"Display","text":"<p>Display event data</p> <p><code>var Display: TSdlDisplayEvent</code></p> <p>Type: <code>TSdlDisplayEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#Drop","title":"Drop","text":"<p>Drag and drop event data</p> <p><code>var Drop: TSdlDropEvent</code></p> <p>Type: <code>TSdlDropEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#Finger","title":"Finger","text":"<p>Touch finger event data</p> <p><code>var Finger: TSdlTouchFingerEvent</code></p> <p>Type: <code>TSdlTouchFingerEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#GamepadAxis","title":"GamepadAxis","text":"<p>Gamepad axis event data</p> <p><code>var GamepadAxis: TSdlGamepadAxisEvent</code></p> <p>Type: <code>TSdlGamepadAxisEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#GamepadButton","title":"GamepadButton","text":"<p>Gamepad button event data</p> <p><code>var GamepadButton: TSdlGamepadButtonEvent</code></p> <p>Type: <code>TSdlGamepadButtonEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#GamepadDevice","title":"GamepadDevice","text":"<p>Gamepad device event data</p> <p><code>var GamepadDevice: TSdlGamepadDeviceEvent</code></p> <p>Type: <code>TSdlGamepadDeviceEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#GamepadSensor","title":"GamepadSensor","text":"<p>Gamepad sensor event data</p> <p><code>var GamepadSensor: TSdlGamepadSensorEvent</code></p> <p>Type: <code>TSdlGamepadSensorEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#GamepadTouch","title":"GamepadTouch","text":"<p>Gamepad touchpad event data</p> <p><code>var GamepadTouch: TSdlGamepadTouchpadEvent</code></p> <p>Type: <code>TSdlGamepadTouchpadEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#Handle","title":"Handle","text":"<p>Handle to underlying C event record</p> <p><code>var Handle: SDL_Event</code></p> <p>Type: <code>SDL_Event</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#JoyAxis","title":"JoyAxis","text":"<p>Joystick axis event data</p> <p><code>var JoyAxis: TSdlJoyAxisEvent</code></p> <p>Type: <code>TSdlJoyAxisEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#JoyBall","title":"JoyBall","text":"<p>Joystick ball event data</p> <p><code>var JoyBall: TSdlJoyBallEvent</code></p> <p>Type: <code>TSdlJoyBallEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#JoyBattery","title":"JoyBattery","text":"<p>Joystick battery event data</p> <p><code>var JoyBattery: TSdlJoyBatteryEvent</code></p> <p>Type: <code>TSdlJoyBatteryEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#JoyButton","title":"JoyButton","text":"<p>Joystick button event data</p> <p><code>var JoyButton: TSdlJoyButtonEvent</code></p> <p>Type: <code>TSdlJoyButtonEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#JoyDevice","title":"JoyDevice","text":"<p>Joystick device change event data</p> <p><code>var JoyDevice: TSdlJoyDeviceEvent</code></p> <p>Type: <code>TSdlJoyDeviceEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#JoyHat","title":"JoyHat","text":"<p>Joystick hat event data</p> <p><code>var JoyHat: TSdlJoyHatEvent</code></p> <p>Type: <code>TSdlJoyHatEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#Key","title":"Key","text":"<p>Keyboard event data</p> <p><code>var Key: TSdlKeyboardEvent</code></p> <p>Type: <code>TSdlKeyboardEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#KeyboardDevice","title":"KeyboardDevice","text":"<p>Keyboard device change event data</p> <p><code>var KeyboardDevice: TSdlKeyboardDeviceEvent</code></p> <p>Type: <code>TSdlKeyboardDeviceEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#Kind","title":"Kind","text":"<p>Event kind, shared with all events</p> <p><code>var Kind: TSdlEventKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#MouseButton","title":"MouseButton","text":"<p>Mouse button event data</p> <p><code>var MouseButton: TSdlMouseButtonEvent</code></p> <p>Type: <code>TSdlMouseButtonEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#MouseDevice","title":"MouseDevice","text":"<p>Mouse device change event data</p> <p><code>var MouseDevice: TSdlMouseDeviceEvent</code></p> <p>Type: <code>TSdlMouseDeviceEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#MouseMotion","title":"MouseMotion","text":"<p>Mouse motion event data</p> <p><code>var MouseMotion: TSdlMouseMotionEvent</code></p> <p>Type: <code>TSdlMouseMotionEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#MouseWheel","title":"MouseWheel","text":"<p>Mouse wheel event data</p> <p><code>var MouseWheel: TSdlMouseWheelEvent</code></p> <p>Type: <code>TSdlMouseWheelEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#PenAxis","title":"PenAxis","text":"<p>Pen axis event data</p> <p><code>var PenAxis: TSdlPenAxisEvent</code></p> <p>Type: <code>TSdlPenAxisEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#PenButton","title":"PenButton","text":"<p>Pen button event data</p> <p><code>var PenButton: TSdlPenButtonEvent</code></p> <p>Type: <code>TSdlPenButtonEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#PenMotion","title":"PenMotion","text":"<p>Pen motion event data</p> <p><code>var PenMotion: TSdlPenMotionEvent</code></p> <p>Type: <code>TSdlPenMotionEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#PenProximity","title":"PenProximity","text":"<p>Pen proximity event data</p> <p><code>var PenProximity: TSdlPenProximityEvent</code></p> <p>Type: <code>TSdlPenProximityEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#PenTouch","title":"PenTouch","text":"<p>Pen tip touching event data</p> <p><code>var PenTouch: TSdlPenTouchEvent</code></p> <p>Type: <code>TSdlPenTouchEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#Quit","title":"Quit","text":"<p>Quit request event data</p> <p><code>var Quit: TSdlQuitEvent</code></p> <p>Type: <code>TSdlQuitEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#Render","title":"Render","text":"<p>Render event data</p> <p><code>var Render: TSdlRenderEvent</code></p> <p>Type: <code>TSdlRenderEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#Sensor","title":"Sensor","text":"<p>Sensor event data</p> <p><code>var Sensor: TSdlSensorEvent</code></p> <p>Type: <code>TSdlSensorEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#TextCandidates","title":"TextCandidates","text":"<p>Text editing candidates event data</p> <p><code>var TextCandidates: TSdlTextEditingCandidatesEvent</code></p> <p>Type: <code>TSdlTextEditingCandidatesEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#TextEdit","title":"TextEdit","text":"<p>Text editing event data</p> <p><code>var TextEdit: TSdlTextEditingEvent</code></p> <p>Type: <code>TSdlTextEditingEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#TextInput","title":"TextInput","text":"<p>Text editing candidates event data</p> <p><code>var TextInput: TSdlTextInputEvent</code></p> <p>Type: <code>TSdlTextInputEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#User","title":"User","text":"<p>Custom event data</p> <p><code>var User: TSdlUserEvent</code></p> <p>Type: <code>TSdlUserEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#Window","title":"Window","text":"<p>Window event data</p> <p><code>var Window: TSdlWindowEvent</code></p> <p>Type: <code>TSdlWindowEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#ConvertToRenderCoordinates","title":"ConvertToRenderCoordinates(TSdlRenderer)","text":"<p>Convert the coordinates in an event to render coordinates.</p> <p>This takes into account several states:</p> <ul> <li>The window dimensions.</li> <li>The logical presentation settings (SetLogicalPresentation)</li> <li>The scale (Scale)</li> <li>The viewport (Viewport)</li> </ul> <p>Various event types are converted with this function: mouse, touch, pen, etc.</p> <p>Touch coordinates are converted from normalized coordinates in the window to non-normalized rendering coordinates.</p> <p>Relative mouse coordinates (XRel and YRel event fields) are also converted. Applications that do not want these fields converted should use TSdlRenderer.RenderCoordinatesFromWindow on the specific event fields instead of converting the entire event structure.</p> <p>Once converted, coordinates may be outside the rendering area. </p> <p><code>procedure ConvertToRenderCoordinates(const ARenderer: TSdlRenderer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#parameters","title":"Parameters","text":"<p><code>ARenderer</code>: <code>TSdlRenderer</code> : The rendering context.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#see-also","title":"See Also","text":"<ul> <li>TSdlRenderer.RenderCoordinatesFromWindow</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvent/#remarks","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/","title":"TSdlEvents","text":"<p>Event queue management.</p> <p>It's extremely common--often required--that an app deal with SDL's event queue. Almost all useful information about interactions with the real world flow through here: the user interacting with the computer and app, hardware coming and going, the system changing in some way, etc.</p> <p>An app generally takes a moment, perhaps at the start of a new frame, to examine any events that have occured since the last time and process or ignore them. This is generally done by overriding TSdlApp.Event.</p> <p>There is other forms of control, too: Peep has more functionality at the cost of more complexity, and Wait can block the process until something interesting happens, which might be beneficial for certain types of programs on low-power hardware. One may also call AddWatch to set a callback when new events arrive.</p> <p>The app is free to generate their own events, too: Push allows the app to put events onto the queue for later retrieval; Register can guarantee that these events have a kind that isn't in use by other parts of the system. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlEvents = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#methods","title":"Methods","text":"Name Description AddWatch Add a callback to be triggered when an event is added to the event queue. Filter Run a specific filter function on the current event queue, removing any events for which the filter returns false. Flush(TSdlEventKind, TSdlEventKind) Clear events of a range of kinds from the event queue. Flush(TSdlEventKind) Clear events of a specific kind from the event queue. GetFilter Query the current event filter. Has(TSdlEventKind, TSdlEventKind) Check for the existence of certain event kind in the event queue. Has(TSdlEventKind) Check for the existence of a certain event kind in the event queue. IsEnabled Query the state of processing events by kind. Peep(PSdlEvent, Integer, TSdlEventAction, TSdlEventKind, TSdlEventKind) Check the event queue for messages and optionally return them. Peep(TArray&lt;TSdlEvent&gt;, TSdlEventAction, TSdlEventKind, TSdlEventKind) Check the event queue for messages and optionally return them. Poll(TSdlEvent) Poll Poll for currently pending events. Pump Pump the event loop, gathering events from the input devices. Push Add an event to the event queue. Register Registers a user-defined events. RemoveWatch Remove an event watch callback added with AddWatch. SetEnabled Set the state of processing events by kind. SetFilter Set up a filter to process all events before they are added to the internal event queue. Wait(Integer, TSdlEvent) Wait(Integer) Wait until the specified timeout (in milliseconds) for the next available event. Wait(TSdlEvent) Wait Wait indefinitely for the next available event."},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#AddWatch","title":"AddWatch(TSdlEventFilter)","text":"<p>Add a callback to be triggered when an event is added to the event queue.</p> <p><code>AFilter</code> will be called when an event happens, and its return value is ignored.</p> <p>WARNING: Be very careful of what you do in the event filter function, as it may run in a different thread!</p> <p>If the quit event is generated by a signal (e.g. SIGINT), it will bypass the internal queue and be delivered to the watch callback immediately, and arrive at the next event poll.</p> <p>Note: the callback is called for events posted by the user through Push, but not for disabled events, nor for events by a filter callback set with SetFilter, nor for events posted by the user through Peep. </p> <p><code>class procedure AddWatch(const AFilter: TSdlEventFilter); static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters","title":"Parameters","text":"<p><code>AFilter</code>: <code>TSdlEventFilter</code> : Function to call when an event happens.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#see-also","title":"See Also","text":"<ul> <li>RemoveWatch</li> <li>SetFilter</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#Filter","title":"Filter(TSdlEventFilter)","text":"<p>Run a specific filter function on the current event queue, removing any events for which the filter returns false.</p> <p>See SetFilter for more information. Unlike SetFilter, this method does not change the filter permanently, it only uses the supplied filter until this function returns. </p> <p><code>class procedure Filter(const AFilter: TSdlEventFilter); static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_1","title":"Parameters","text":"<p><code>AFilter</code>: <code>TSdlEventFilter</code> : The function to call when an event happens.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#see-also_1","title":"See Also","text":"<ul> <li>GetFilter</li> <li>SetFilter</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_1","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#Flush_0","title":"Flush(TSdlEventKind, TSdlEventKind)","text":"<p>Clear events of a range of kinds from the event queue.</p> <p>This will unconditionally remove any events from the queue that are in the range of <code>AMinKind</code> to <code>AMaxKind</code>, inclusive. If you need to remove a single event kind, use the other overload instead.</p> <p>It's also normal to just ignore events you don't care about in your event loop without calling this function.</p> <p>This function only affects currently queued events. If you want to make sure that all pending OS events are flushed, you can call Pump on the main thread immediately before the flush call. </p> <p><code>class procedure Flush(const AMinKind, AMaxKind: TSdlEventKind); overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_2","title":"Parameters","text":"<p><code>AMinKind</code>: <code>TSdlEventKind</code> : The low end of event kind to be cleared.</p> <p><code>AMaxKind</code>: <code>TSdlEventKind</code> : The high end of event kind to be cleared, inclusive.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_2","title":"Remarks","text":"<p>This function is available since SDL 3.2.0. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#Flush_1","title":"Flush(TSdlEventKind)","text":"<p>Clear events of a specific kind from the event queue.</p> <p>This will unconditionally remove any events from the queue that match <code>AKind</code>. If you need to remove a range of event types, use the other overload instead.</p> <p>It's also normal to just ignore events you don't care about in your event loop without calling this function.</p> <p>This function only affects currently queued events. If you want to make sure that all pending OS events are flushed, you can call Pump on the main thread immediately before the flush call.</p> <p>If you have user events with custom data that needs to be freed, you should use Peep to remove and clean up those events before calling this function. </p> <p><code>class procedure Flush(const AKind: TSdlEventKind); overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_3","title":"Parameters","text":"<p><code>AKind</code>: <code>TSdlEventKind</code> : The kind of event to be cleared.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_3","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#GetFilter","title":"GetFilter(TSdlEventFilter)","text":"<p>Query the current event filter.</p> <p>This function can be used to \"chain\" filters, by saving the existing filter before replacing it with a function that will call that saved filter. </p> <p><code>class function GetFilter(out AFilter: TSdlEventFilter): Boolean; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_4","title":"Parameters","text":"<p><code>AFilter</code>: <code>TSdlEventFilter</code> : The current callback function will be stored here.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#returns","title":"Returns","text":"<p><code>Boolean</code>: True on success or False if there is no event filter set.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#see-also_2","title":"See Also","text":"<ul> <li>SetFilter</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_4","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#Has_0","title":"Has(TSdlEventKind, TSdlEventKind)","text":"<p>Check for the existence of certain event kind in the event queue.</p> <p>If you need to check for a single event kind, use the other overload instead. </p> <p><code>class function Has(const AMinKind, AMaxKind: TSdlEventKind): Boolean; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_5","title":"Parameters","text":"<p><code>AMinKind</code>: <code>TSdlEventKind</code> : The low end of event kind to be queried, inclusive.</p> <p><code>AMaxKind</code>: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#returns_1","title":"Returns","text":"<p><code>Boolean</code>: True if events with type &gt;= <code>AMinKind</code> and = <code>aminkind</code> and &gt;are present, or False if not.= <code>aminkind</code> and &gt;It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#Has_1","title":"Has(TSdlEventKind)","text":"<p>Check for the existence of a certain event kind in the event queue.</p> <p>If you need to check for a range of event types, use the other overload instead. </p> <p><code>class function Has(const AKind: TSdlEventKind): Boolean; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_6","title":"Parameters","text":"<p><code>AKind</code>: <code>TSdlEventKind</code> : The kind of event to be queried.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#returns_2","title":"Returns","text":"<p><code>Boolean</code>: True if events matching <code>AKind</code> are present, or False if events matching <code>AKind</code> are not present.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_5","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#IsEnabled","title":"IsEnabled(TSdlEventKind)","text":"<p>Query the state of processing events by kind. </p> <p><code>class function IsEnabled(const AKind: TSdlEventKind): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_7","title":"Parameters","text":"<p><code>AKind</code>: <code>TSdlEventKind</code> : The kind of event.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#returns_3","title":"Returns","text":"<p><code>Boolean</code>: True if the event is being processed, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#see-also_3","title":"See Also","text":"<ul> <li>SetEnabled</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_6","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#Peep_0","title":"Peep(PSdlEvent, Integer, TSdlEventAction, TSdlEventKind, TSdlEventKind)","text":"<p>Check the event queue for messages and optionally return them.</p> <p><code>AAction</code> may be any of the following:</p> <ul> <li><code>TSdlEventAction.Add</code>: up to <code>ANumEvents</code> events will be added to the back of the event queue.</li> <li><code>TSdlEventAction.Peek</code>: <code>ANumEvents</code> events at the front of the event queue, within the specified minimum and maximum type, will be returned to the caller and will not be removed from the queue. If you pass nil for <code>AEvents</code>, then <code>ANumEvents</code> is ignored and the total number of matching events will be returned.</li> <li><code>TSdlEventAction.Get</code>: up to <code>ANumEvents</code> events at the front of the event queue, within the specified minimum and maximum type, will be returned to the caller and will be removed from the queue.</li> </ul> <p>You may have to call Pump before calling this function. Otherwise, the events may not be ready to be filtered when you call Peep. </p> <p><code>class function Peep(const AEvents: PSdlEvent; const ANumEvents: Integer; const AAction: TSdlEventAction; const AMinKind: TSdlEventKind = TSdlEventKind.First; const AMaxKind: TSdlEventKind = TSdlEventKind.Last): Integer; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_8","title":"Parameters","text":"<p><code>AEvents</code>: <code>PSdlEvent</code> : Destination buffer for the retrieved events, may be nil to leave the events in the queue and return the number of events that would have been stored.</p> <p><code>ANumEvents</code>: <code>Integer</code> : If action is TSdlEventAction.Add, the number of events to add back to the event queue; if action is TSdlEventAction.Peek or TSdlEventAction.Get, the maximum number of events to retrieve.</p> <p><code>AAction</code>: <code>TSdlEventAction</code> : Action to take.</p> <p><code>AMinKind</code>: <code>TSdlEventKind = TSdlEventKind.First</code> : (Optional) Minimum value of the event kind to be considered; TSdlEventKind.First is a safe choice.</p> <p><code>AMaxKind</code>: <code>TSdlEventKind = TSdlEventKind.Last</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#returns_4","title":"Returns","text":"<p><code>Integer</code>: The number of events actually stored.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#see-also_4","title":"See Also","text":"<ul> <li>Poll</li> <li>Pump</li> <li>Push</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_7","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#Peep_1","title":"Peep(TArray&lt;TSdlEvent&gt;, TSdlEventAction, TSdlEventKind, TSdlEventKind)","text":"<p>Check the event queue for messages and optionally return them.</p> <p><code>AAction</code> may be any of the following:</p> <ul> <li><code>TSdlEventAction.Add</code>: up to <code>ANumEvents</code> events will be added to the back of the event queue.</li> <li><code>TSdlEventAction.Peek</code>: <code>ANumEvents</code> events at the front of the event queue, within the specified minimum and maximum type, will be returned to the caller and will not be removed from the queue. If you pass nil for <code>AEvents</code>, then <code>ANumEvents</code> is ignored and the total number of matching events will be returned.</li> <li><code>TSdlEventAction.Get</code>: up to <code>ANumEvents</code> events at the front of the event queue, within the specified minimum and maximum type, will be returned to the caller and will be removed from the queue.</li> </ul> <p>You may have to call Pump before calling this function. Otherwise, the events may not be ready to be filtered when you call Peep. </p> <p><code>class function Peep(const AEvents: TArray&lt;TSdlEvent&gt;; const AAction: TSdlEventAction; const AMinKind: TSdlEventKind = TSdlEventKind.First; const AMaxKind: TSdlEventKind = TSdlEventKind.Last): Integer; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_9","title":"Parameters","text":"<p><code>AEvents</code>: <code>TArray&lt;TSdlEvent&gt;</code> : Destination buffer for the retrieved events, may be nil to leave the events in the queue and return the number of events that would have been stored.</p> <p><code>AAction</code>: <code>TSdlEventAction</code> : Action to take.</p> <p><code>AMinKind</code>: <code>TSdlEventKind = TSdlEventKind.First</code> : (Optional) Minimum value of the event kind to be considered; TSdlEventKind.First is a safe choice.</p> <p><code>AMaxKind</code>: <code>TSdlEventKind = TSdlEventKind.Last</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#returns_5","title":"Returns","text":"<p><code>Integer</code>: The number of events actually stored.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#see-also_5","title":"See Also","text":"<ul> <li>Poll</li> <li>Pump</li> <li>Push</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_8","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#Poll_0","title":"Poll(TSdlEvent)","text":"<p><code>class function Poll(out AEvent: TSdlEvent): Boolean; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_10","title":"Parameters","text":"<p><code>AEvent</code>: <code>TSdlEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#returns_6","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#Poll_1","title":"Poll","text":"<p>Poll for currently pending events.</p> <p>If <code>AEvent</code> is given, the next event is removed from the queue and stored in this record. It returns True if there was an event.</p> <p>If <code>AEvent</code> is not given, it simply returns True if there is an event in the queue, but will not remove it from the queue.</p> <p>As this function may implicitly call Pump, you can only call this function in the thread that set the video mode.</p> <p>Either using TSdlApp.Event or Poll are the favored ways of receiving system events since it can be done from the main loop and does not suspend the main loop while waiting on an event to be posted.</p> <p>The common practice is to fully process the event queue once every frame, usually as a first step before updating the game's state. This is done automatically if you override TSdlApp.Poll. </p> <p><code>class function Poll: Boolean; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#returns_7","title":"Returns","text":"<p><code>Boolean</code>: True if this got an event or False if there are none available.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#see-also_6","title":"See Also","text":"<ul> <li>Push</li> <li>Wait</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_9","title":"Remarks","text":"<p>This function should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#Pump","title":"Pump","text":"<p>Pump the event loop, gathering events from the input devices.</p> <p>This function updates the event queue and internal input device state.</p> <p>Pump gathers all the pending input information from devices and places it in the event queue. Without calls to Pump no events would ever be placed on the queue. Often the need for calls to Pump is hidden from the user since TSdlApp.Event, Poll and Wait implicitly call Pump. However, if you are not polling or waiting for events (e.g. you are filtering them), then you must call Pump to force an event queue update. </p> <p><code>class procedure Pump; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#see-also_7","title":"See Also","text":"<ul> <li>Poll</li> <li>Wait</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_10","title":"Remarks","text":"<p>This function should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#Push","title":"Push(TSdlEvent)","text":"<p>Add an event to the event queue.</p> <p>The event queue can actually be used as a two way communication channel. Not only can events be read from the queue, but the user can also push their own events onto it. <code>AEvent</code> is the event record you wish to push onto the queue. The event is copied into the queue.</p> <p>Note: Pushing device input events onto the queue doesn't modify the state of the device within SDL.</p> <p>Note: Events pushed onto the queue with Push get passed through the event filter but events added with Peep do not.</p> <p>For pushing application-specific events, please use Register to get an event kind that does not conflict with other code that also wants its own custom event kinds. </p> <p><code>class function Push(const AEvent: TSdlEvent): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_11","title":"Parameters","text":"<p><code>AEvent</code>: <code>TSdlEvent</code> : The event to be added to the queue.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#returns_8","title":"Returns","text":"<p><code>Boolean</code>: True on success, False if the event was filtered.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#see-also_8","title":"See Also","text":"<ul> <li>Peep</li> <li>Poll</li> <li>Register</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_11","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#Register","title":"Register","text":"<p>Registers a user-defined events. </p> <p><code>class function Register: TSdlEventKind; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#returns_9","title":"Returns","text":"<p><code>TSdlEventKind</code>: A new TSdlEventKind value, or TSdlEventKind.First if there are not enough user-defined events left.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#see-also_9","title":"See Also","text":"<ul> <li>Push</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_12","title":"Remarks","text":"<p>It is safe to call this function from any thread.</p> <p>The returned value is outside of the standard TSdlEventKind enum range, but can still be used with all event functionality. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#RemoveWatch","title":"RemoveWatch(TSdlEventFilter)","text":"<p>Remove an event watch callback added with AddWatch.</p> <p>This function takes the same input as AddWatch to identify and delete the corresponding callback. </p> <p><code>class procedure RemoveWatch(const AFilter: TSdlEventFilter); static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_12","title":"Parameters","text":"<p><code>AFilter</code>: <code>TSdlEventFilter</code> : The function originally passed to AddWatch.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#see-also_10","title":"See Also","text":"<ul> <li>AddWatch</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_13","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#SetEnabled","title":"SetEnabled(TSdlEventKind, Boolean)","text":"<p>Set the state of processing events by kind. </p> <p><code>class procedure SetEnabled(const AKind: TSdlEventKind; const AEnabled: Boolean); inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_13","title":"Parameters","text":"<p><code>AKind</code>: <code>TSdlEventKind</code> : The kind of event.</p> <p><code>AEnabled</code>: <code>Boolean</code> : Whether to process the event or not.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#see-also_11","title":"See Also","text":"<ul> <li>IsEnabled</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_14","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#SetFilter","title":"SetFilter(TSdlEventFilter)","text":"<p>Set up a filter to process all events before they are added to the internal event queue.</p> <p>If you just want to see events without modifying them or preventing them from being queued, you should use AddWatch instead.</p> <p>If the filter function returns True when called, then the event will be added to the internal queue. If it returns False, then the event will be dropped from the queue, but the internal state will still be updated. This allows selective filtering of dynamically arriving events.</p> <p>WARNING: Be very careful of what you do in the event filter function, as it may run in a different thread!</p> <p>On platforms that support it, if the quit event is generated by an interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the application at the next event poll.</p> <p>Note: Disabled events never make it to the event filter function; see SetEnabled.</p> <p>Note: Events pushed onto the queue with Push get passed through the event filter, but events pushed onto the queue with Peep do not. </p> <p><code>class procedure SetFilter(const AFilter: TSdlEventFilter); static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_14","title":"Parameters","text":"<p><code>AFilter</code>: <code>TSdlEventFilter</code> : Filter function to call when an event happens.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#see-also_12","title":"See Also","text":"<ul> <li>AddWatch</li> <li>SetEnabled</li> <li>GetFilter</li> <li>Peep</li> <li>Push</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_15","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#Wait_0","title":"Wait(Integer, TSdlEvent)","text":"<p><code>class function Wait(const ATimeoutMS: Integer; out AEvent: TSdlEvent): Boolean; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_15","title":"Parameters","text":"<p><code>ATimeoutMS</code>: <code>Integer</code></p> <p><code>AEvent</code>: <code>TSdlEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#returns_10","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#Wait_1","title":"Wait(Integer)","text":"<p>Wait until the specified timeout (in milliseconds) for the next available event.</p> <p>If <code>AEvent</code> is not given, the next event is removed from the queue and stored in this record.</p> <p>As this function may implicitly call Pump, you can only call this function in the thread that initialized the video subsystem.</p> <p>The timeout is not guaranteed, the actual wait time could be longer due to system scheduling. </p> <p><code>class function Wait(const ATimeoutMS: Integer): Boolean; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_16","title":"Parameters","text":"<p><code>ATimeoutMS</code>: <code>Integer</code> : the maximum number of milliseconds to wait for the next available event.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#returns_11","title":"Returns","text":"<p><code>Boolean</code>: True if this got an event or False if the timeout elapsed without any events available.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#see-also_13","title":"See Also","text":"<ul> <li>Poll</li> <li>Push</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_16","title":"Remarks","text":"<p>This function should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#Wait_2","title":"Wait(TSdlEvent)","text":"<p><code>class procedure Wait(out AEvent: TSdlEvent); overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#parameters_17","title":"Parameters","text":"<p><code>AEvent</code>: <code>TSdlEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#Wait_3","title":"Wait","text":"<p>Wait indefinitely for the next available event.</p> <p>If <code>AEvent</code> is not given, the next event is removed from the queue and stored in this record.</p> <p>As this function may implicitly call Pump, you can only call this function in the thread that initialized the video subsystem. </p> <p><code>class procedure Wait; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: If there was an error while waiting for events.</p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#see-also_14","title":"See Also","text":"<ul> <li>Poll</li> <li>Push</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlEvents/#remarks_17","title":"Remarks","text":"<p>This function should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadAxisEvent/","title":"TSdlGamepadAxisEvent","text":"<p>Gamepad axis motion event structure (Event.GamepadAxis.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadAxisEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlGamepadAxisEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadAxisEvent/#properties","title":"Properties","text":"Name Description Axis The gamepad axis Joystick The joystick (or nil if not opened) JoystickID The joystick instance ID Kind Event kind (TSdlEventKind.GamepadAxisMotion) Timestamp In nanoseconds, populated using SdlGetTicksNS Value The axis value (range: -32768 to 32767)"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadAxisEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadAxisEvent/#Axis","title":"Axis","text":"<p>The gamepad axis</p> <p><code>property Axis: TSdlGamepadAxis read GetAxis</code></p> <p>Type: <code>TSdlGamepadAxis</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadAxisEvent/#Joystick","title":"Joystick","text":"<p>The joystick (or nil if not opened)</p> <p><code>property Joystick: TSdlJoystick read GetJoystick</code></p> <p>Type: <code>TSdlJoystick</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadAxisEvent/#JoystickID","title":"JoystickID","text":"<p>The joystick instance ID</p> <p><code>property JoystickID: TSdlJoystickID read GetJoystickID</code></p> <p>Type: <code>TSdlJoystickID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadAxisEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.GamepadAxisMotion)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadAxisEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadAxisEvent/#Value","title":"Value","text":"<p>The axis value (range: -32768 to 32767)</p> <p><code>property Value: Smallint read FHandle.value</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadButtonEvent/","title":"TSdlGamepadButtonEvent","text":"<p>Gamepad button event structure (Event.GamepadButton.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadButtonEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlGamepadButtonEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadButtonEvent/#properties","title":"Properties","text":"Name Description Button The gamepad button IsDown True if the button is pressed Joystick The joystick (or nil if not opened) JoystickID The joystick instance ID Kind Event kind (TSdlEventKind.GamepadButtonUp/Down) Timestamp In nanoseconds, populated using SdlGetTicksNS"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadButtonEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadButtonEvent/#Button","title":"Button","text":"<p>The gamepad button</p> <p><code>property Button: TSdlGamepadButton read GetButton</code></p> <p>Type: <code>TSdlGamepadButton</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadButtonEvent/#IsDown","title":"IsDown","text":"<p>True if the button is pressed</p> <p><code>property IsDown: Boolean read FHandle.down</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadButtonEvent/#Joystick","title":"Joystick","text":"<p>The joystick (or nil if not opened)</p> <p><code>property Joystick: TSdlJoystick read GetJoystick</code></p> <p>Type: <code>TSdlJoystick</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadButtonEvent/#JoystickID","title":"JoystickID","text":"<p>The joystick instance ID</p> <p><code>property JoystickID: TSdlJoystickID read GetJoystickID</code></p> <p>Type: <code>TSdlJoystickID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadButtonEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.GamepadButtonUp/Down)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadButtonEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadDeviceEvent/","title":"TSdlGamepadDeviceEvent","text":"<p>Gamepad device event structure (Event.GamepadDevice.* )</p> <p>Joysticks that are supported gamepads receive both an TSdlJoyDeviceEvent and an TSdlGamepadDeviceEvent.</p> <p>SDL will send TSdlEventKind.GamepadAdded events for joysticks that are already plugged in during SdlInit and are recognized as gamepads. It will also send events for joysticks that get gamepad mappings at runtime. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadDeviceEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlGamepadDeviceEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadDeviceEvent/#see-also","title":"See Also","text":"<ul> <li>TSdlJoyDeviceEvent</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadDeviceEvent/#properties","title":"Properties","text":"Name Description Joystick The joystick (or nil if not opened) JoystickID The joystick instance ID Kind Event kind (TSdlEventKind.GamepadAdded/Removed/Remapped/ UpdateComplete/SteamHandleUpdated) Timestamp In nanoseconds, populated using SdlGetTicksNS"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadDeviceEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadDeviceEvent/#Joystick","title":"Joystick","text":"<p>The joystick (or nil if not opened)</p> <p><code>property Joystick: TSdlJoystick read GetJoystick</code></p> <p>Type: <code>TSdlJoystick</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadDeviceEvent/#JoystickID","title":"JoystickID","text":"<p>The joystick instance ID</p> <p><code>property JoystickID: TSdlJoystickID read GetJoystickID</code></p> <p>Type: <code>TSdlJoystickID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadDeviceEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.GamepadAdded/Removed/Remapped/ UpdateComplete/SteamHandleUpdated)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadDeviceEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadSensorEvent/","title":"TSdlGamepadSensorEvent","text":"<p>Gamepad sensor event structure (Event.GamepadSensor.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadSensorEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlGamepadSensorEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadSensorEvent/#properties","title":"Properties","text":"Name Description Data Up to 3 values from the sensor Joystick The joystick (or nil if not opened) JoystickID The joystick instance ID Kind Event kind (TSdlEventKind.GamepadSensorUpdate) Sensor The type of the sensor SensorTimestamp The timestamp of the sensor reading in nanoseconds, not necessarily synchronized with the system clock Timestamp In nanoseconds, populated using SdlGetTicksNS"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadSensorEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadSensorEvent/#Data","title":"Data","text":"<p>Up to 3 values from the sensor</p> <p><code>property Data[const AIndex: Integer]: Single read GetData</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadSensorEvent/#Joystick","title":"Joystick","text":"<p>The joystick (or nil if not opened)</p> <p><code>property Joystick: TSdlJoystick read GetJoystick</code></p> <p>Type: <code>TSdlJoystick</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadSensorEvent/#JoystickID","title":"JoystickID","text":"<p>The joystick instance ID</p> <p><code>property JoystickID: TSdlJoystickID read GetJoystickID</code></p> <p>Type: <code>TSdlJoystickID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadSensorEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.GamepadSensorUpdate)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadSensorEvent/#Sensor","title":"Sensor","text":"<p>The type of the sensor</p> <p><code>property Sensor: TSdlSensorKind read GetSensor</code></p> <p>Type: <code>TSdlSensorKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadSensorEvent/#SensorTimestamp","title":"SensorTimestamp","text":"<p>The timestamp of the sensor reading in nanoseconds, not necessarily synchronized with the system clock</p> <p><code>property SensorTimestamp: UInt64 read FHandle.sensor_timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadSensorEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadTouchpadEvent/","title":"TSdlGamepadTouchpadEvent","text":"<p>Gamepad touchpad event structure (Event.GamepadTouch.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadTouchpadEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlGamepadTouchpadEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadTouchpadEvent/#properties","title":"Properties","text":"Name Description Finger The index of the finger on the touchpad Joystick The joystick (or nil if not opened) JoystickID The joystick instance ID Kind Event kind (TSdlEventKind.GamepadTouchpad*) Position Normalized in the range (0...1, 0...1) with 0 being at the top-left Pressure Normalized in the range 0...1 Timestamp In nanoseconds, populated using SdlGetTicksNS Touchpad The index of the touchpad X Normalized in the range 0...1 with 0 being on the left Y Normalized in the range 0...1 with 0 being at the top"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadTouchpadEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadTouchpadEvent/#Finger","title":"Finger","text":"<p>The index of the finger on the touchpad</p> <p><code>property Finger: Integer read FHandle.finger</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadTouchpadEvent/#Joystick","title":"Joystick","text":"<p>The joystick (or nil if not opened)</p> <p><code>property Joystick: TSdlJoystick read GetJoystick</code></p> <p>Type: <code>TSdlJoystick</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadTouchpadEvent/#JoystickID","title":"JoystickID","text":"<p>The joystick instance ID</p> <p><code>property JoystickID: TSdlJoystickID read GetJoystickID</code></p> <p>Type: <code>TSdlJoystickID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadTouchpadEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.GamepadTouchpad*)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadTouchpadEvent/#Position","title":"Position","text":"<p>Normalized in the range (0...1, 0...1) with 0 being at the top-left</p> <p><code>property Position: TSdlPointF read GetPosition</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadTouchpadEvent/#Pressure","title":"Pressure","text":"<p>Normalized in the range 0...1</p> <p><code>property Pressure: Single read FHandle.pressure</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadTouchpadEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadTouchpadEvent/#Touchpad","title":"Touchpad","text":"<p>The index of the touchpad</p> <p><code>property Touchpad: Integer read FHandle.touchpad</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadTouchpadEvent/#X","title":"X","text":"<p>Normalized in the range 0...1 with 0 being on the left</p> <p><code>property X: Single read FHandle.x</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlGamepadTouchpadEvent/#Y","title":"Y","text":"<p>Normalized in the range 0...1 with 0 being at the top</p> <p><code>property Y: Single read FHandle.y</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyAxisEvent/","title":"TSdlJoyAxisEvent","text":"<p>Joystick axis motion event structure (Event.JoyAxis.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyAxisEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlJoyAxisEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyAxisEvent/#properties","title":"Properties","text":"Name Description Axis The joystick axis index Joystick The joystick (or nil if not opened) JoystickID The joystick instance ID Kind Event kind (TSdlEventKind.JoystickAxisMotion) Timestamp In nanoseconds, populated using SdlGetTicksNS Value The axis value (range: -32768 to 32767)"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyAxisEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyAxisEvent/#Axis","title":"Axis","text":"<p>The joystick axis index</p> <p><code>property Axis: Byte read FHandle.axis</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyAxisEvent/#Joystick","title":"Joystick","text":"<p>The joystick (or nil if not opened)</p> <p><code>property Joystick: TSdlJoystick read GetJoystick</code></p> <p>Type: <code>TSdlJoystick</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyAxisEvent/#JoystickID","title":"JoystickID","text":"<p>The joystick instance ID</p> <p><code>property JoystickID: TSdlJoystickID read GetJoystickID</code></p> <p>Type: <code>TSdlJoystickID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyAxisEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.JoystickAxisMotion)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyAxisEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyAxisEvent/#Value","title":"Value","text":"<p>The axis value (range: -32768 to 32767)</p> <p><code>property Value: Smallint read FHandle.value</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBallEvent/","title":"TSdlJoyBallEvent","text":"<p>Joystick trackball motion event structure (Event.JoyBball.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBallEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlJoyBallEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBallEvent/#properties","title":"Properties","text":"Name Description Ball The joystick trackball index Joystick The joystick (or nil if not opened) JoystickID The joystick instance ID Kind Event kind (TSdlEventKind.JoystickBallMotion) Rel The relative motion Timestamp In nanoseconds, populated using SdlGetTicksNS XRel The relative motion in the X direction YRel The relative motion in the Y direction"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBallEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBallEvent/#Ball","title":"Ball","text":"<p>The joystick trackball index</p> <p><code>property Ball: Byte read FHandle.ball</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBallEvent/#Joystick","title":"Joystick","text":"<p>The joystick (or nil if not opened)</p> <p><code>property Joystick: TSdlJoystick read GetJoystick</code></p> <p>Type: <code>TSdlJoystick</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBallEvent/#JoystickID","title":"JoystickID","text":"<p>The joystick instance ID</p> <p><code>property JoystickID: TSdlJoystickID read GetJoystickID</code></p> <p>Type: <code>TSdlJoystickID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBallEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.JoystickBallMotion)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBallEvent/#Rel","title":"Rel","text":"<p>The relative motion</p> <p><code>property Rel: TSdlPointF read GetRel</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBallEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBallEvent/#XRel","title":"XRel","text":"<p>The relative motion in the X direction</p> <p><code>property XRel: Smallint read FHandle.xrel</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBallEvent/#YRel","title":"YRel","text":"<p>The relative motion in the Y direction</p> <p><code>property YRel: Smallint read FHandle.yrel</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBatteryEvent/","title":"TSdlJoyBatteryEvent","text":"<p>Joystick battery level change event structure (Event.JoyBattery.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBatteryEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlJoyBatteryEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBatteryEvent/#properties","title":"Properties","text":"Name Description Joystick The joystick (or nil if not opened) JoystickID The joystick instance ID Kind Event kind (TSdlEventKind.JoystickBatteryUpdated) Percent The joystick battery percent charge remaining State The joystick battery state Timestamp In nanoseconds, populated using SdlGetTicksNS"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBatteryEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBatteryEvent/#Joystick","title":"Joystick","text":"<p>The joystick (or nil if not opened)</p> <p><code>property Joystick: TSdlJoystick read GetJoystick</code></p> <p>Type: <code>TSdlJoystick</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBatteryEvent/#JoystickID","title":"JoystickID","text":"<p>The joystick instance ID</p> <p><code>property JoystickID: TSdlJoystickID read GetJoystickID</code></p> <p>Type: <code>TSdlJoystickID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBatteryEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.JoystickBatteryUpdated)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBatteryEvent/#Percent","title":"Percent","text":"<p>The joystick battery percent charge remaining</p> <p><code>property Percent: Integer read FHandle.percent</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBatteryEvent/#State","title":"State","text":"<p>The joystick battery state</p> <p><code>property State: TSdlPowerState read GetState</code></p> <p>Type: <code>TSdlPowerState</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyBatteryEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyButtonEvent/","title":"TSdlJoyButtonEvent","text":"<p>Joystick button event structure (Event.JoyButton.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyButtonEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlJoyButtonEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyButtonEvent/#properties","title":"Properties","text":"Name Description Button The joystick button index IsDown True if the button is pressed Joystick The joystick (or nil if not opened) JoystickID The joystick instance ID Kind Event kind (TSdlEventKind.JoystickButtonUp/Down) Timestamp In nanoseconds, populated using SdlGetTicksNS"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyButtonEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyButtonEvent/#Button","title":"Button","text":"<p>The joystick button index</p> <p><code>property Button: Byte read FHandle.button</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyButtonEvent/#IsDown","title":"IsDown","text":"<p>True if the button is pressed</p> <p><code>property IsDown: Boolean read FHandle.down</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyButtonEvent/#Joystick","title":"Joystick","text":"<p>The joystick (or nil if not opened)</p> <p><code>property Joystick: TSdlJoystick read GetJoystick</code></p> <p>Type: <code>TSdlJoystick</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyButtonEvent/#JoystickID","title":"JoystickID","text":"<p>The joystick instance ID</p> <p><code>property JoystickID: TSdlJoystickID read GetJoystickID</code></p> <p>Type: <code>TSdlJoystickID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyButtonEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.JoystickButtonUp/Down)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyButtonEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyDeviceEvent/","title":"TSdlJoyDeviceEvent","text":"<p>Joystick device event structure (Event.JoyDevice.* )</p> <p>SDL will send TSdlEventKind.JoystickAdded events for devices that are already plugged in during SdlInit. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyDeviceEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlJoyDeviceEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyDeviceEvent/#see-also","title":"See Also","text":"<ul> <li>TSdlGamepadDeviceEvent</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyDeviceEvent/#properties","title":"Properties","text":"Name Description Joystick The joystick (or nil if not opened) JoystickID The joystick instance ID Kind Event kind (TSdlEventKind.JoystickAdded/Removed/UpdateComplete) Timestamp In nanoseconds, populated using SdlGetTicksNS"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyDeviceEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyDeviceEvent/#Joystick","title":"Joystick","text":"<p>The joystick (or nil if not opened)</p> <p><code>property Joystick: TSdlJoystick read GetJoystick</code></p> <p>Type: <code>TSdlJoystick</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyDeviceEvent/#JoystickID","title":"JoystickID","text":"<p>The joystick instance ID</p> <p><code>property JoystickID: TSdlJoystickID read GetJoystickID</code></p> <p>Type: <code>TSdlJoystickID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyDeviceEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.JoystickAdded/Removed/UpdateComplete)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyDeviceEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyHatEvent/","title":"TSdlJoyHatEvent","text":"<p>Joystick hat position change event structure (Event.JoyHat.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyHatEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlJoyHatEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyHatEvent/#properties","title":"Properties","text":"Name Description Hat The joystick hat index Joystick The joystick (or nil if not opened) JoystickID The joystick instance ID Kind Event kind (TSdlEventKind.JoystickHatMotion) Timestamp In nanoseconds, populated using SdlGetTicksNS Value The hat position value. Note that zero means the POV is centered."},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyHatEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyHatEvent/#Hat","title":"Hat","text":"<p>The joystick hat index</p> <p><code>property Hat: Byte read FHandle.hat</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyHatEvent/#Joystick","title":"Joystick","text":"<p>The joystick (or nil if not opened)</p> <p><code>property Joystick: TSdlJoystick read GetJoystick</code></p> <p>Type: <code>TSdlJoystick</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyHatEvent/#JoystickID","title":"JoystickID","text":"<p>The joystick instance ID</p> <p><code>property JoystickID: TSdlJoystickID read GetJoystickID</code></p> <p>Type: <code>TSdlJoystickID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyHatEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.JoystickHatMotion)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyHatEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlJoyHatEvent/#Value","title":"Value","text":"<p>The hat position value. Note that zero means the POV is centered. </p> <p><code>property Value: TSdlHat read GetValue</code></p> <p>Type: <code>TSdlHat</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardDeviceEvent/","title":"TSdlKeyboardDeviceEvent","text":"<p>Keyboard device event structure (Event.KeyboardDevice.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardDeviceEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlKeyboardDeviceEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardDeviceEvent/#properties","title":"Properties","text":"Name Description Keyboard The keyboard instance Kind Event kind (TSdlEventKind.KeyboardAdded/Removed) Timestamp In nanoseconds, populated using SdlGetTicksNS"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardDeviceEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardDeviceEvent/#Keyboard","title":"Keyboard","text":"<p>The keyboard instance</p> <p><code>property Keyboard: TSdlKeyboard read GetKeyboard</code></p> <p>Type: <code>TSdlKeyboard</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardDeviceEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.KeyboardAdded/Removed)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardDeviceEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardEvent/","title":"TSdlKeyboardEvent","text":"<p>Keyboard button event structure (Event.Key.* )</p> <p>The <code>Key</code> is the base TSdlKeycode generated by pressing the <code>Scancode</code> using the current keyboard layout, applying any options specified in TSdlHints.KeycodeOptions. You can get the TSdlKeycode corresponding to the event scancode and modifiers directly from the keyboard layout, bypassing TSdlHints.KeycodeOptions, by calling TSdlScancode.ToKeycode. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlKeyboardEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardEvent/#see-also","title":"See Also","text":"<ul> <li>TSdlScancode.ToKeycode</li> <li>TSdlHints.KeycodeOptions</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardEvent/#properties","title":"Properties","text":"Name Description IsDown True if the key is pressed IsRepeat True if this is a key repeat Key SDL virtual key code Keyboard The keyboard instance, or nil if unknown or virtual Kind Event kind (TSdlEventKind.Key*) Mods current key modifiers Raw The platform dependent scancode for this event Scancode SDL physical key code Timestamp In nanoseconds, populated using SdlGetTicksNS"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardEvent/#IsDown","title":"IsDown","text":"<p>True if the key is pressed</p> <p><code>property IsDown: Boolean read FHandle.down</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardEvent/#IsRepeat","title":"IsRepeat","text":"<p>True if this is a key repeat</p> <p><code>property IsRepeat: Boolean read FHandle.&amp;repeat</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardEvent/#Key","title":"Key","text":"<p>SDL virtual key code</p> <p><code>property Key: TSdlKeycode read GetKey</code></p> <p>Type: <code>TSdlKeycode</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardEvent/#Keyboard","title":"Keyboard","text":"<p>The keyboard instance, or nil if unknown or virtual</p> <p><code>property Keyboard: TSdlKeyboard read GetKeyboard</code></p> <p>Type: <code>TSdlKeyboard</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.Key*)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardEvent/#Mods","title":"Mods","text":"<p>current key modifiers</p> <p><code>property Mods: TSdlKeymods read GetMods</code></p> <p>Type: <code>TSdlKeymods</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardEvent/#Raw","title":"Raw","text":"<p>The platform dependent scancode for this event</p> <p><code>property Raw: Word read FHandle.raw</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardEvent/#Scancode","title":"Scancode","text":"<p>SDL physical key code</p> <p><code>property Scancode: TSdlScancode read GetScancode</code></p> <p>Type: <code>TSdlScancode</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlKeyboardEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseButtonEvent/","title":"TSdlMouseButtonEvent","text":"<p>Mouse button event structure (Event.MouseButton.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseButtonEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlMouseButtonEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseButtonEvent/#properties","title":"Properties","text":"Name Description Button The mouse button Clicks 1 for single-click, 2 for double-click, etc. IsDown True if the button is pressed Kind Event kind (TSdlEventKind.MouseButtonUp/Down) Mouse The mouse instance in relative mode, TSdlMouse.Touch for touch events, or nil Position Position, relative to window Timestamp In nanoseconds, populated using SdlGetTicksNS Window The window with mouse focus, if any WindowID The ID of the window with mouse focus, if any X X coordinate, relative to window Y Y coordinate, relative to window"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseButtonEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseButtonEvent/#Button","title":"Button","text":"<p>The mouse button</p> <p><code>property Button: TSdlMouseButton read GetButton</code></p> <p>Type: <code>TSdlMouseButton</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseButtonEvent/#Clicks","title":"Clicks","text":"<p>1 for single-click, 2 for double-click, etc.</p> <p><code>property Clicks: Byte read FHandle.clicks</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseButtonEvent/#IsDown","title":"IsDown","text":"<p>True if the button is pressed</p> <p><code>property IsDown: Boolean read FHandle.down</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseButtonEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.MouseButtonUp/Down)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseButtonEvent/#Mouse","title":"Mouse","text":"<p>The mouse instance in relative mode, TSdlMouse.Touch for touch events, or nil</p> <p><code>property Mouse: TSdlMouse read GetMouse</code></p> <p>Type: <code>TSdlMouse</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseButtonEvent/#Position","title":"Position","text":"<p>Position, relative to window</p> <p><code>property Position: TSdlPointF read GetPosition</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseButtonEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseButtonEvent/#Window","title":"Window","text":"<p>The window with mouse focus, if any</p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseButtonEvent/#WindowID","title":"WindowID","text":"<p>The ID of the window with mouse focus, if any</p> <p><code>property WindowID: TSdlWindowID read FHandle.windowID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseButtonEvent/#X","title":"X","text":"<p>X coordinate, relative to window</p> <p><code>property X: Single read FHandle.x</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseButtonEvent/#Y","title":"Y","text":"<p>Y coordinate, relative to window</p> <p><code>property Y: Single read FHandle.y</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseDeviceEvent/","title":"TSdlMouseDeviceEvent","text":"<p>Mouse device event structure (Event.MouseDevice.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseDeviceEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlMouseDeviceEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseDeviceEvent/#properties","title":"Properties","text":"Name Description Kind Event kind (TSdlEventKind.MouseAdded/Removed) Mouse The mouse instance Timestamp In nanoseconds, populated using SdlGetTicksNS"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseDeviceEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseDeviceEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.MouseAdded/Removed)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseDeviceEvent/#Mouse","title":"Mouse","text":"<p>The mouse instance</p> <p><code>property Mouse: TSdlMouse read GetMouse</code></p> <p>Type: <code>TSdlMouse</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseDeviceEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseMotionEvent/","title":"TSdlMouseMotionEvent","text":"<p>Mouse motion event structure (Event.MouseMotion.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseMotionEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlMouseMotionEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseMotionEvent/#properties","title":"Properties","text":"Name Description Buttons The currently pressed buttons Kind Event kind (TSdlEventKind.MouseMotion) Mouse The mouse instance in relative mode, TSdlMouse.Touch for touch events, or nil Position Position, relative to window Rel The relative motion Timestamp In nanoseconds, populated using SdlGetTicksNS Window The window with mouse focus, if any WindowID The ID of the window with mouse focus, if any X X coordinate, relative to window XRel The relative motion in the X direction Y Y coordinate, relative to window YRel The relative motion in the Y direction"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseMotionEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseMotionEvent/#Buttons","title":"Buttons","text":"<p>The currently pressed buttons</p> <p><code>property Buttons: TSdlMouseButtons read GetButtons</code></p> <p>Type: <code>TSdlMouseButtons</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseMotionEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.MouseMotion)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseMotionEvent/#Mouse","title":"Mouse","text":"<p>The mouse instance in relative mode, TSdlMouse.Touch for touch events, or nil</p> <p><code>property Mouse: TSdlMouse read GetMouse</code></p> <p>Type: <code>TSdlMouse</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseMotionEvent/#Position","title":"Position","text":"<p>Position, relative to window</p> <p><code>property Position: TSdlPointF read GetPosition</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseMotionEvent/#Rel","title":"Rel","text":"<p>The relative motion</p> <p><code>property Rel: TSdlPointF read GetRel</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseMotionEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseMotionEvent/#Window","title":"Window","text":"<p>The window with mouse focus, if any</p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseMotionEvent/#WindowID","title":"WindowID","text":"<p>The ID of the window with mouse focus, if any</p> <p><code>property WindowID: TSdlWindowID read FHandle.windowID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseMotionEvent/#X","title":"X","text":"<p>X coordinate, relative to window</p> <p><code>property X: Single read FHandle.x</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseMotionEvent/#XRel","title":"XRel","text":"<p>The relative motion in the X direction</p> <p><code>property XRel: Single read FHandle.xrel</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseMotionEvent/#Y","title":"Y","text":"<p>Y coordinate, relative to window</p> <p><code>property Y: Single read FHandle.y</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseMotionEvent/#YRel","title":"YRel","text":"<p>The relative motion in the Y direction</p> <p><code>property YRel: Single read FHandle.yrel</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseWheelEvent/","title":"TSdlMouseWheelEvent","text":"<p>Mouse wheel event structure (Event.MouseWheel.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseWheelEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlMouseWheelEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseWheelEvent/#properties","title":"Properties","text":"Name Description Amount The amount scrolled. Direction When TSdlMouseWheelDirection.Flipped the values in X and Y will be opposite. Multiply by -1 to change them back Kind Event kind (TSdlEventKind.MouseWheel) Mouse The mouse instance in relative mode or nil MouseX X coordinate, relative to window MouseY Y coordinate, relative to window Position Position, relative to window Timestamp In nanoseconds, populated using SdlGetTicksNS Window The window with mouse focus, if any WindowID The ID of the window with mouse focus, if any X The amount scrolled horizontally, positive to the right and negative to the left Y The amount scrolled vertically, positive away from the user and negative toward the user"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseWheelEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseWheelEvent/#Amount","title":"Amount","text":"<p>The amount scrolled.</p> <p><code>property Amount: TSdlPointF read GetAmount</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseWheelEvent/#Direction","title":"Direction","text":"<p>When TSdlMouseWheelDirection.Flipped the values in X and Y will be opposite. Multiply by -1 to change them back</p> <p><code>property Direction: TSdlMouseWheelDirection read GetDirection</code></p> <p>Type: <code>TSdlMouseWheelDirection</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseWheelEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.MouseWheel)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseWheelEvent/#Mouse","title":"Mouse","text":"<p>The mouse instance in relative mode or nil</p> <p><code>property Mouse: TSdlMouse read GetMouse</code></p> <p>Type: <code>TSdlMouse</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseWheelEvent/#MouseX","title":"MouseX","text":"<p>X coordinate, relative to window</p> <p><code>property MouseX: Single read FHandle.mouse_x</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseWheelEvent/#MouseY","title":"MouseY","text":"<p>Y coordinate, relative to window</p> <p><code>property MouseY: Single read FHandle.mouse_y</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseWheelEvent/#Position","title":"Position","text":"<p>Position, relative to window</p> <p><code>property Position: TSdlPointF read GetPosition</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseWheelEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseWheelEvent/#Window","title":"Window","text":"<p>The window with mouse focus, if any</p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseWheelEvent/#WindowID","title":"WindowID","text":"<p>The ID of the window with mouse focus, if any</p> <p><code>property WindowID: TSdlWindowID read FHandle.windowID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseWheelEvent/#X","title":"X","text":"<p>The amount scrolled horizontally, positive to the right and negative to the left</p> <p><code>property X: Single read FHandle.x</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlMouseWheelEvent/#Y","title":"Y","text":"<p>The amount scrolled vertically, positive away from the user and negative toward the user</p> <p><code>property Y: Single read FHandle.y</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenAxisEvent/","title":"TSdlPenAxisEvent","text":"<p>Pressure-sensitive pen pressure / angle event structure (Event.PenAxis.* )</p> <p>You might get some of these events even if the pen isn't touching the tablet. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenAxisEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlPenAxisEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenAxisEvent/#properties","title":"Properties","text":"Name Description Axis Axis that has changed Kind Event kind (TSdlEventKind.PenAxis) PenID The pen instance id PenState Complete pen input state at time of event Position Position, relative to window Timestamp In nanoseconds, populated using SdlGetTicksNS Value New value of axis Window The window with pen focus, if any WindowID The ID of the window with pen focus, if any X X coordinate, relative to window Y Y coordinate, relative to window"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenAxisEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenAxisEvent/#Axis","title":"Axis","text":"<p>Axis that has changed</p> <p><code>property Axis: TSdlPenAxis read GetAxis</code></p> <p>Type: <code>TSdlPenAxis</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenAxisEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.PenAxis)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenAxisEvent/#PenID","title":"PenID","text":"<p>The pen instance id</p> <p><code>property PenID: TSdlPenID read FHandle.which</code></p> <p>Type: <code>TSdlPenID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenAxisEvent/#PenState","title":"PenState","text":"<p>Complete pen input state at time of event</p> <p><code>property PenState: TSdlPenInputFlags read GetPenState</code></p> <p>Type: <code>TSdlPenInputFlags</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenAxisEvent/#Position","title":"Position","text":"<p>Position, relative to window</p> <p><code>property Position: TSdlPointF read GetPosition</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenAxisEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenAxisEvent/#Value","title":"Value","text":"<p>New value of axis</p> <p><code>property Value: Single read FHandle.value</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenAxisEvent/#Window","title":"Window","text":"<p>The window with pen focus, if any</p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenAxisEvent/#WindowID","title":"WindowID","text":"<p>The ID of the window with pen focus, if any</p> <p><code>property WindowID: TSdlWindowID read FHandle.windowID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenAxisEvent/#X","title":"X","text":"<p>X coordinate, relative to window</p> <p><code>property X: Single read FHandle.x</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenAxisEvent/#Y","title":"Y","text":"<p>Y coordinate, relative to window</p> <p><code>property Y: Single read FHandle.y</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenButtonEvent/","title":"TSdlPenButtonEvent","text":"<p>Pressure-sensitive pen button event structure (Event.PenButton.* )</p> <p>This is for buttons on the pen itself that the user might click. The pen itself pressing down to draw triggers a TSdlEventKind.PenDown event instead. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenButtonEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlPenButtonEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenButtonEvent/#properties","title":"Properties","text":"Name Description Button The pen button index (first button is 1). IsDown True if the button is pressed Kind Event kind (TSdlEventKind.PenButtonUp/Down) PenID The pen instance id PenState Complete pen input state at time of event Position Position, relative to window Timestamp In nanoseconds, populated using SdlGetTicksNS Window The window with pen focus, if any WindowID The ID of the window with pen focus, if any X X coordinate, relative to window Y Y coordinate, relative to window"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenButtonEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenButtonEvent/#Button","title":"Button","text":"<p>The pen button index (first button is 1).</p> <p><code>property Button: Byte read FHandle.button</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenButtonEvent/#IsDown","title":"IsDown","text":"<p>True if the button is pressed</p> <p><code>property IsDown: Boolean read FHandle.down</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenButtonEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.PenButtonUp/Down)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenButtonEvent/#PenID","title":"PenID","text":"<p>The pen instance id</p> <p><code>property PenID: TSdlPenID read FHandle.which</code></p> <p>Type: <code>TSdlPenID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenButtonEvent/#PenState","title":"PenState","text":"<p>Complete pen input state at time of event</p> <p><code>property PenState: TSdlPenInputFlags read GetPenState</code></p> <p>Type: <code>TSdlPenInputFlags</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenButtonEvent/#Position","title":"Position","text":"<p>Position, relative to window</p> <p><code>property Position: TSdlPointF read GetPosition</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenButtonEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenButtonEvent/#Window","title":"Window","text":"<p>The window with pen focus, if any</p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenButtonEvent/#WindowID","title":"WindowID","text":"<p>The ID of the window with pen focus, if any</p> <p><code>property WindowID: TSdlWindowID read FHandle.windowID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenButtonEvent/#X","title":"X","text":"<p>X coordinate, relative to window</p> <p><code>property X: Single read FHandle.x</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenButtonEvent/#Y","title":"Y","text":"<p>Y coordinate, relative to window</p> <p><code>property Y: Single read FHandle.y</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenMotionEvent/","title":"TSdlPenMotionEvent","text":"<p>Pressure-sensitive pen motion event structure (Event.PenMotion.* )</p> <p>Depending on the hardware, you may get motion events when the pen is not touching a tablet, for tracking a pen even when it isn't drawing. You should listen for TSdlEventKind.PenDown and TSdlEventKind.PenUp events, or check <code>TSdlPenInputFlags.Down in PenState</code> to decide if a pen is \"drawing\" when dealing with pen motion. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenMotionEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlPenMotionEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenMotionEvent/#properties","title":"Properties","text":"Name Description Kind Event kind (TSdlEventKind.PenMotion) PenID The pen instance id PenState Complete pen input state at time of event Position Position, relative to window Timestamp In nanoseconds, populated using SdlGetTicksNS Window The window with pen focus, if any WindowID The ID of the window with pen focus, if any X X coordinate, relative to window Y Y coordinate, relative to window"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenMotionEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenMotionEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.PenMotion)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenMotionEvent/#PenID","title":"PenID","text":"<p>The pen instance id</p> <p><code>property PenID: TSdlPenID read FHandle.which</code></p> <p>Type: <code>TSdlPenID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenMotionEvent/#PenState","title":"PenState","text":"<p>Complete pen input state at time of event</p> <p><code>property PenState: TSdlPenInputFlags read GetPenState</code></p> <p>Type: <code>TSdlPenInputFlags</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenMotionEvent/#Position","title":"Position","text":"<p>Position, relative to window</p> <p><code>property Position: TSdlPointF read GetPosition</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenMotionEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenMotionEvent/#Window","title":"Window","text":"<p>The window with pen focus, if any</p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenMotionEvent/#WindowID","title":"WindowID","text":"<p>The ID of the window with pen focus, if any</p> <p><code>property WindowID: TSdlWindowID read FHandle.windowID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenMotionEvent/#X","title":"X","text":"<p>X coordinate, relative to window</p> <p><code>property X: Single read FHandle.x</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenMotionEvent/#Y","title":"Y","text":"<p>Y coordinate, relative to window</p> <p><code>property Y: Single read FHandle.y</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenProximityEvent/","title":"TSdlPenProximityEvent","text":"<p>Pressure-sensitive pen proximity event structure (Event.PenProximity.* )</p> <p>When a pen becomes visible to the system (it is close enough to a tablet, etc), SDL will send an TSdlEventKind.PenProximityIn event with the new pen's ID. This ID is valid until the pen leaves proximity again (has been removed from the tablet's area, the tablet has been unplugged, etc). If the same pen reenters proximity again, it will be given a new ID.</p> <p>Note that \"proximity\" means \"close enough for the tablet to know the tool is there.\" The pen touching and lifting off from the tablet while not leaving the area are handled by TSdlEventKind.PenDown and TSdlEventKind.PenUp. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenProximityEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlPenProximityEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenProximityEvent/#properties","title":"Properties","text":"Name Description Kind Event kind (TSdlEventKind.PenProximityIn/Out) PenID The pen instance id Timestamp In nanoseconds, populated using SdlGetTicksNS Window The window with pen focus, if any WindowID The ID of the window with pen focus, if any"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenProximityEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenProximityEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.PenProximityIn/Out)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenProximityEvent/#PenID","title":"PenID","text":"<p>The pen instance id</p> <p><code>property PenID: TSdlPenID read FHandle.which</code></p> <p>Type: <code>TSdlPenID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenProximityEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenProximityEvent/#Window","title":"Window","text":"<p>The window with pen focus, if any</p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenProximityEvent/#WindowID","title":"WindowID","text":"<p>The ID of the window with pen focus, if any</p> <p><code>property WindowID: TSdlWindowID read FHandle.windowID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenTouchEvent/","title":"TSdlPenTouchEvent","text":"<p>Pressure-sensitive pen touched event structure (Event.PenTouch.* )</p> <p>These events come when a pen touches a surface (a tablet, etc), or lifts off from one. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenTouchEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlPenTouchEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenTouchEvent/#properties","title":"Properties","text":"Name Description IsDown True if the pen is touching or false if the pen is lifted off IsEraserUsed True if eraser end is used (not all pens support this). Kind Event kind (TSdlEventKind.PenUp/Down) PenID The pen instance id PenState Complete pen input state at time of event Position Position, relative to window Timestamp In nanoseconds, populated using SdlGetTicksNS Window The window with pen focus, if any WindowID The ID of the window with pen focus, if any X X coordinate, relative to window Y Y coordinate, relative to window"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenTouchEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenTouchEvent/#IsDown","title":"IsDown","text":"<p>True if the pen is touching or false if the pen is lifted off</p> <p><code>property IsDown: Boolean read FHandle.down</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenTouchEvent/#IsEraserUsed","title":"IsEraserUsed","text":"<p>True if eraser end is used (not all pens support this).</p> <p><code>property IsEraserUsed: Boolean read FHandle.eraser</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenTouchEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.PenUp/Down)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenTouchEvent/#PenID","title":"PenID","text":"<p>The pen instance id</p> <p><code>property PenID: TSdlPenID read FHandle.which</code></p> <p>Type: <code>TSdlPenID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenTouchEvent/#PenState","title":"PenState","text":"<p>Complete pen input state at time of event</p> <p><code>property PenState: TSdlPenInputFlags read GetPenState</code></p> <p>Type: <code>TSdlPenInputFlags</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenTouchEvent/#Position","title":"Position","text":"<p>Position, relative to window</p> <p><code>property Position: TSdlPointF read GetPosition</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenTouchEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenTouchEvent/#Window","title":"Window","text":"<p>The window with pen focus, if any</p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenTouchEvent/#WindowID","title":"WindowID","text":"<p>The ID of the window with pen focus, if any</p> <p><code>property WindowID: TSdlWindowID read FHandle.windowID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenTouchEvent/#X","title":"X","text":"<p>X coordinate, relative to window</p> <p><code>property X: Single read FHandle.x</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlPenTouchEvent/#Y","title":"Y","text":"<p>Y coordinate, relative to window</p> <p><code>property Y: Single read FHandle.y</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlQuitEvent/","title":"TSdlQuitEvent","text":"<p>The \"quit requested\" event </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlQuitEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlQuitEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlQuitEvent/#properties","title":"Properties","text":"Name Description Kind Event kind (TSdlEventKind.Quit) Timestamp In nanoseconds, populated using SdlGetTicksNS"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlQuitEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlQuitEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.Quit)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlQuitEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlRenderEvent/","title":"TSdlRenderEvent","text":"<p>Renderer event structure (Event.Render.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlRenderEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlRenderEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlRenderEvent/#properties","title":"Properties","text":"Name Description Kind Event kind (TSdlEventKind.Render*) Timestamp In nanoseconds, populated using SdlGetTicksNS Window The window containing the renderer in question. WindowID The ID of the window containing the renderer in question."},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlRenderEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlRenderEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.Render*)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlRenderEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlRenderEvent/#Window","title":"Window","text":"<p>The window containing the renderer in question.</p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlRenderEvent/#WindowID","title":"WindowID","text":"<p>The ID of the window containing the renderer in question.</p> <p><code>property WindowID: TSdlWindowID read FHandle.windowID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlSensorEvent/","title":"TSdlSensorEvent","text":"<p>Sensor event structure (Event.Sensor.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlSensorEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlSensorEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlSensorEvent/#properties","title":"Properties","text":"Name Description Data Up to 6 values from the sensor - additional values can be queried using TSdlSensor.GetData Kind Event kind (TSdlEventKind.SensorUpdate) SensorID The instance ID of the sensor SensorTimestamp The timestamp of the sensor reading in nanoseconds, not necessarily synchronized with the system clock Timestamp In nanoseconds, populated using SdlGetTicksNS"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlSensorEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlSensorEvent/#Data","title":"Data","text":"<p>Up to 6 values from the sensor - additional values can be queried using TSdlSensor.GetData</p> <p><code>property Data[const AIndex: Integer]: Single read GetData</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlSensorEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.SensorUpdate)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlSensorEvent/#SensorID","title":"SensorID","text":"<p>The instance ID of the sensor</p> <p><code>property SensorID: TSdlSensorID read GetSensorID</code></p> <p>Type: <code>TSdlSensorID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlSensorEvent/#SensorTimestamp","title":"SensorTimestamp","text":"<p>The timestamp of the sensor reading in nanoseconds, not necessarily synchronized with the system clock</p> <p><code>property SensorTimestamp: UInt64 read FHandle.sensor_timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlSensorEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingCandidatesEvent/","title":"TSdlTextEditingCandidatesEvent","text":"<p>Keyboard IME candidates event structure (Event.TextCandidates.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingCandidatesEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlTextEditingCandidatesEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingCandidatesEvent/#properties","title":"Properties","text":"Name Description Candidates Array of candidates, or nil if there are no candidates available CandidatesPtr Pointer to the list of candidates, or nil if there are no candidates available IsHorizontal True if the list is horizontal, False if it's vertical Kind Event kind (TSdlEventKind.TextEditingCandidates) NumCandidates The number of strings in <code>CandidatesPtr</code> and <code>Candidates</code> SelectedCandidate The index of the selected candidate, or -1 if no candidate is selected Timestamp In nanoseconds, populated using SdlGetTicksNS Window The window with keyboard focus, if any WindowID The ID of the window with keyboard focus, if any"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingCandidatesEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingCandidatesEvent/#Candidates","title":"Candidates","text":"<p>Array of candidates, or nil if there are no candidates available</p> <p><code>property Candidates: TArray&lt;String&gt; read GetCandidates</code></p> <p>Type: <code>TArray&lt;String&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingCandidatesEvent/#CandidatesPtr","title":"CandidatesPtr","text":"<p>Pointer to the list of candidates, or nil if there are no candidates available</p> <p><code>property CandidatesPtr: PPUTF8Char read FHandle.candidates</code></p> <p>Type: <code>PPUTF8Char</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingCandidatesEvent/#IsHorizontal","title":"IsHorizontal","text":"<p>True if the list is horizontal, False if it's vertical</p> <p><code>property IsHorizontal: Boolean read FHandle.horizontal</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingCandidatesEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.TextEditingCandidates)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingCandidatesEvent/#NumCandidates","title":"NumCandidates","text":"<p>The number of strings in <code>CandidatesPtr</code> and <code>Candidates</code></p> <p><code>property NumCandidates: Integer read FHandle.num_candidates</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingCandidatesEvent/#SelectedCandidate","title":"SelectedCandidate","text":"<p>The index of the selected candidate, or -1 if no candidate is selected</p> <p><code>property SelectedCandidate: Integer read FHandle.selected_candidate</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingCandidatesEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingCandidatesEvent/#Window","title":"Window","text":"<p>The window with keyboard focus, if any</p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingCandidatesEvent/#WindowID","title":"WindowID","text":"<p>The ID of the window with keyboard focus, if any</p> <p><code>property WindowID: TSdlWindowID read FHandle.windowID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingEvent/","title":"TSdlTextEditingEvent","text":"<p>Keyboard text editing event structure (Event.TextEdit.* )</p> <p>The start cursor is the position, in UTF-8 characters, where new typing will be inserted into the editing text. The length is the number of UTF-8 characters that will be replaced by new typing. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlTextEditingEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingEvent/#properties","title":"Properties","text":"Name Description Kind Event kind (TSdlEventKind.TextEditing) Length The length of selected editing text, or -1 if not set Start The start cursor of selected editing text, or -1 if not set Text The editing text TextPtr Pointer to the editing text Timestamp In nanoseconds, populated using SdlGetTicksNS Window The window with keyboard focus, if any WindowID The ID of the window with keyboard focus, if any"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.TextEditing)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingEvent/#Length","title":"Length","text":"<p>The length of selected editing text, or -1 if not set</p> <p><code>property Length: Integer read FHandle.length</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingEvent/#Start","title":"Start","text":"<p>The start cursor of selected editing text, or -1 if not set</p> <p><code>property Start: Integer read FHandle.start</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingEvent/#Text","title":"Text","text":"<p>The editing text</p> <p><code>property Text: String read GetText</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingEvent/#TextPtr","title":"TextPtr","text":"<p>Pointer to the editing text</p> <p><code>property TextPtr: PUTF8Char read FHandle.text</code></p> <p>Type: <code>PUTF8Char</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingEvent/#Window","title":"Window","text":"<p>The window with keyboard focus, if any</p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextEditingEvent/#WindowID","title":"WindowID","text":"<p>The ID of the window with keyboard focus, if any</p> <p><code>property WindowID: TSdlWindowID read FHandle.windowID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextInputEvent/","title":"TSdlTextInputEvent","text":"<p>Keyboard text input event structure (Event.TextInput.* )</p> <p>This event will never be delivered unless text input is enabled by calling TSdlWindow.StartTextInput. Text input is disabled by default! </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextInputEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlTextInputEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextInputEvent/#see-also","title":"See Also","text":"<ul> <li>TSdlWindow.StartTextInput</li> <li>TSdlWindow.StopTextInput</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextInputEvent/#properties","title":"Properties","text":"Name Description Kind Event kind (TSdlEventKind.TextInput) Text The input text TextPtr Pointer to the input text Timestamp In nanoseconds, populated using SdlGetTicksNS Window The window with keyboard focus, if any WindowID The ID of the window with keyboard focus, if any"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextInputEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextInputEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.TextInput)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextInputEvent/#Text","title":"Text","text":"<p>The input text</p> <p><code>property Text: String read GetText</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextInputEvent/#TextPtr","title":"TextPtr","text":"<p>Pointer to the input text</p> <p><code>property TextPtr: PUTF8Char read FHandle.text</code></p> <p>Type: <code>PUTF8Char</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextInputEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextInputEvent/#Window","title":"Window","text":"<p>The window with keyboard focus, if any</p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTextInputEvent/#WindowID","title":"WindowID","text":"<p>The ID of the window with keyboard focus, if any</p> <p><code>property WindowID: TSdlWindowID read FHandle.windowID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/","title":"TSdlTouchFingerEvent","text":"<p>Touch finger event structure (Event.Finger.* )</p> <p>Coordinates in this event are normalized. <code>X</code> and <code>Y</code> are normalized to a range between 0.0 and 1.0, relative to the window, so (0,0) is the top left and (1,1) is the bottom right. Delta coordinates <code>DX</code> and <code>DY</code> are normalized in the ranges of -1.0 (traversed all the way from the bottom or right to all the way up or left) to 1.0 (traversed all the way from the top or left to all the way down or right).</p> <p>Note that while the coordinates are normalized, they are not clamped, which means in some circumstances you can get a value outside of this range. For example, a renderer using logical presentation might give a negative value when the touch is in the letterboxing. Some platforms might report a touch outside of the window, which will also be outside of the range. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlTouchFingerEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/#properties","title":"Properties","text":"Name Description Delta Normalized in the range (-1...1, -1...1) DX Normalized in the range -1...1 DY Normalized in the range -1...1 FingerID Kind Event kind (TSdlEventKind.Finger*) Position Normalized in the range (0...1, 0...1) Pressure Normalized in the range 0...1 Timestamp In nanoseconds, populated using SdlGetTicksNS Touch The touch device Window The window underneath the finger, if any WindowID The ID of the window underneath the finger, if any X Normalized in the range 0...1 Y Normalized in the range 0...1"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/#Delta","title":"Delta","text":"<p>Normalized in the range (-1...1, -1...1)</p> <p><code>property Delta: TSdlPointF read GetDelta</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/#DX","title":"DX","text":"<p>Normalized in the range -1...1</p> <p><code>property DX: Single read FHandle.dx</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/#DY","title":"DY","text":"<p>Normalized in the range -1...1</p> <p><code>property DY: Single read FHandle.dy</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/#FingerID","title":"FingerID","text":"<p><code>property FingerID: TSdlFingerID read FHandle.fingerID</code></p> <p>Type: <code>TSdlFingerID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.Finger*)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/#Position","title":"Position","text":"<p>Normalized in the range (0...1, 0...1)</p> <p><code>property Position: TSdlPointF read GetPosition</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/#Pressure","title":"Pressure","text":"<p>Normalized in the range 0...1</p> <p><code>property Pressure: Single read FHandle.pressure</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/#Touch","title":"Touch","text":"<p>The touch device</p> <p><code>property Touch: TSdlTouch read GetTouch</code></p> <p>Type: <code>TSdlTouch</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/#Window","title":"Window","text":"<p>The window underneath the finger, if any</p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/#WindowID","title":"WindowID","text":"<p>The ID of the window underneath the finger, if any</p> <p><code>property WindowID: TSdlWindowID read FHandle.windowID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/#X","title":"X","text":"<p>Normalized in the range 0...1</p> <p><code>property X: Single read FHandle.x</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlTouchFingerEvent/#Y","title":"Y","text":"<p>Normalized in the range 0...1</p> <p><code>property Y: Single read FHandle.y</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlUserEvent/","title":"TSdlUserEvent","text":"<p>A user-defined event type (event.user.* )</p> <p>This event is unique; it is never created by SDL, but only by the application. The event can be pushed onto the event queue using TSdlEvents.Push. The contents of the record members are completely up to the programmer; the only requirement is that 'Kind' is a value obtained from TSdlEvents.Register. </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlUserEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlUserEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlUserEvent/#properties","title":"Properties","text":"Name Description Code User defined event code Data1 User defined data pointer Data2 User defined data pointer Kind Event kind (registered with TSdlEvents.Register) Timestamp In nanoseconds, populated using SdlGetTicksNS Window The associated window, if any WindowID The ID of the associated window, if any"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlUserEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlUserEvent/#Code","title":"Code","text":"<p>User defined event code</p> <p><code>property Code: Integer read FHandle.code</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlUserEvent/#Data1","title":"Data1","text":"<p>User defined data pointer</p> <p><code>property Data1: Pointer read FHandle.data1</code></p> <p>Type: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlUserEvent/#Data2","title":"Data2","text":"<p>User defined data pointer</p> <p><code>property Data2: Pointer read FHandle.data2</code></p> <p>Type: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlUserEvent/#Kind","title":"Kind","text":"<p>Event kind (registered with TSdlEvents.Register)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlUserEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlUserEvent/#Window","title":"Window","text":"<p>The associated window, if any</p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlUserEvent/#WindowID","title":"WindowID","text":"<p>The ID of the associated window, if any</p> <p><code>property WindowID: TSdlWindowID read FHandle.windowID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlWindowEvent/","title":"TSdlWindowEvent","text":"<p>Window state change event data (Event.Window.* ) </p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlWindowEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlWindowEvent = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlWindowEvent/#properties","title":"Properties","text":"Name Description Data1 Event dependent data Data2 Event dependent data Kind Event kind (TSdlEventKind.Window*) Timestamp In nanoseconds, populated using SdlGetTicksNS Window The associated window WindowID The ID associated window"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlWindowEvent/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlWindowEvent/#Data1","title":"Data1","text":"<p>Event dependent data</p> <p><code>property Data1: Integer read FHandle.data1</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlWindowEvent/#Data2","title":"Data2","text":"<p>Event dependent data</p> <p><code>property Data2: Integer read FHandle.data2</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlWindowEvent/#Kind","title":"Kind","text":"<p>Event kind (TSdlEventKind.Window*)</p> <p><code>property Kind: TSdlEventKind read GetKind</code></p> <p>Type: <code>TSdlEventKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlWindowEvent/#Timestamp","title":"Timestamp","text":"<p>In nanoseconds, populated using SdlGetTicksNS</p> <p><code>property Timestamp: UInt64 read FHandle.timestamp</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlWindowEvent/#Window","title":"Window","text":"<p>The associated window</p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/classes/TSdlWindowEvent/#WindowID","title":"WindowID","text":"<p>The ID associated window</p> <p><code>property WindowID: TSdlWindowID read FHandle.windowID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/types/PSdlEvent/","title":"PSdlEvent","text":""},{"location":"Reference/Neslib.Sdl3.Events/types/PSdlEvent/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type PSdlEvent = ^TSdlEvent\n</code></pre> <p>Base type: <code>TSdlEvent</code></p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventAction/","title":"TSdlEventAction","text":"<p>The type of action to request from TSdlEvents.Peep. </p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventAction/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlEventAction = (Add, Peek, Get)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventAction/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventAction/#add-sdl_addevent","title":"<code>Add = SDL_ADDEVENT</code>","text":"<p>Add events to the back of the queue.</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventAction/#peek-sdl_peekevent","title":"<code>Peek = SDL_PEEKEVENT</code>","text":"<p>Check but don't remove events from the queue front.</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventAction/#get-sdl_getevent","title":"<code>Get = SDL_GETEVENT</code>","text":"<p>Retrieve/remove events from the front of the queue.</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventFilter/","title":"TSdlEventFilter","text":"<p>A function type used for callbacks that watch the event queue. </p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventFilter/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlEventFilter = function(const AEvent: TSdlEvent): Boolean of object\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventFilter/#parameters","title":"Parameters","text":"<p><code>AEvent</code>: <code>TSdlEvent</code> : The event that triggered the callback.</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventFilter/#returns","title":"Returns","text":"<p><code>Boolean</code>: True to permit event to be added to the queue, and False to disallow it. When used with TSdlEvents.AddWatch, the return value is ignored.</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventFilter/#see-also","title":"See Also","text":"<ul> <li>TSdlEvents.SetFilter</li> <li>TSdlEvents.AddWatch</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventFilter/#remarks","title":"Remarks","text":"<p>SDL may call this callback at any time from any thread; the application is responsible for locking resources the callback touches that need to be </p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/","title":"TSdlEventKind","text":"<p>The types of events that can be delivered. </p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Events</p> <pre><code>type TSdlEventKind = (First, Quit, Terminating, LowMemory, WillEnterBackground, DidEnterBackground, WillEnterForeground, DidEnterForeground, LocaleChanged, SystemThemeChanged, DisplayOrientation, DisplayAdded, DisplayRemoved, DisplayMoved, DisplayDesktopModeChanged...)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#first-sdl_event_first","title":"<code>First = SDL_EVENT_FIRST</code>","text":"<p>Unused (do not remove)</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#quit-sdl_event_quit","title":"<code>Quit = SDL_EVENT_QUIT</code>","text":"<p>User-requested quit</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#terminating-sdl_event_terminating","title":"<code>Terminating = SDL_EVENT_TERMINATING</code>","text":"<p>The application is being terminated by the OS. This event must be handled in a callback set with TSdlEvents.AddWatch. Called on iOS in </p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#lowmemory-sdl_event_low_memory","title":"<code>LowMemory = SDL_EVENT_LOW_MEMORY</code>","text":"<p>The application is low on memory, free memory if possible. This event must be handled in a callback set with TSdlEvents.AddWatch. Called on iOS in applicationDidReceiveMemoryWarning(). Called on Android in onTrimMemory(). </p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#willenterbackground-sdl_event_will_enter_background","title":"<code>WillEnterBackground = SDL_EVENT_WILL_ENTER_BACKGROUND</code>","text":"<p>The application is about to enter the background. This event must be handled in a callback set with TSdlEvents.AddWatch. Called on iOS in applicationWillResignActive(). Called on Android in onPause(). </p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#didenterbackground-sdl_event_did_enter_background","title":"<code>DidEnterBackground = SDL_EVENT_DID_ENTER_BACKGROUND</code>","text":"<p>The application did enter the background and may not get CPU for some time. This event must be handled in a callback set with TSdlEvents.AddWatch. Called on iOS in applicationDidEnterBackground(). Called on Android in onPause(). </p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#willenterforeground-sdl_event_will_enter_foreground","title":"<code>WillEnterForeground = SDL_EVENT_WILL_ENTER_FOREGROUND</code>","text":"<p>The application is about to enter the foreground. This event must be handled in a callback set with TSdlEvents.AddWatch. Called on iOS in applicationWillEnterForeground(). Called on Android in onResume(). </p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#didenterforeground-sdl_event_did_enter_foreground","title":"<code>DidEnterForeground = SDL_EVENT_DID_ENTER_FOREGROUND</code>","text":"<p>The application is now interactive. This event must be handled in a callback set with TSdlEvents.AddWatch. Called on iOS in applicationDidBecomeActive(). Called on Android in onResume(). </p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#localechanged-sdl_event_locale_changed","title":"<code>LocaleChanged = SDL_EVENT_LOCALE_CHANGED</code>","text":"<p>The user's locale preferences have changed.</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#systemthemechanged-sdl_event_system_theme_changed","title":"<code>SystemThemeChanged = SDL_EVENT_SYSTEM_THEME_CHANGED</code>","text":"<p>The system theme changed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#displayorientation-sdl_event_display_orientation","title":"<code>DisplayOrientation = SDL_EVENT_DISPLAY_ORIENTATION</code>","text":"<p>Display orientation has changed to Data1</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#displayadded-sdl_event_display_added","title":"<code>DisplayAdded = SDL_EVENT_DISPLAY_ADDED</code>","text":"<p>Display has been added to the system</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#displayremoved-sdl_event_display_removed","title":"<code>DisplayRemoved = SDL_EVENT_DISPLAY_REMOVED</code>","text":"<p>Display has been removed from the system</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#displaymoved-sdl_event_display_moved","title":"<code>DisplayMoved = SDL_EVENT_DISPLAY_MOVED</code>","text":"<p>Display has changed position</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#displaydesktopmodechanged-sdl_event_display_desktop_mode_changed","title":"<code>DisplayDesktopModeChanged = SDL_EVENT_DISPLAY_DESKTOP_MODE_CHANGED</code>","text":"<p>Display has changed desktop mode</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#displaycurrentmodechanged-sdl_event_display_current_mode_changed","title":"<code>DisplayCurrentModeChanged = SDL_EVENT_DISPLAY_CURRENT_MODE_CHANGED</code>","text":"<p>Display has changed current mode</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#displaycontentscalechanged-sdl_event_display_content_scale_changed","title":"<code>DisplayContentScaleChanged = SDL_EVENT_DISPLAY_CONTENT_SCALE_CHANGED</code>","text":"<p>Display has changed content scale</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#displayfirst-sdl_event_display_first","title":"<code>DisplayFirst = SDL_EVENT_DISPLAY_FIRST</code>","text":""},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#displaylast-sdl_event_display_last","title":"<code>DisplayLast = SDL_EVENT_DISPLAY_LAST</code>","text":""},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowshown-sdl_event_window_shown","title":"<code>WindowShown = SDL_EVENT_WINDOW_SHOWN</code>","text":"<p>Window has been shown</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowhidden-sdl_event_window_hidden","title":"<code>WindowHidden = SDL_EVENT_WINDOW_HIDDEN</code>","text":"<p>Window has been hidden</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowexposed-sdl_event_window_exposed","title":"<code>WindowExposed = SDL_EVENT_WINDOW_EXPOSED</code>","text":"<p>Window has been exposed and should be redrawn, and can be redrawn directly from event watchers for this event</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowmoved-sdl_event_window_moved","title":"<code>WindowMoved = SDL_EVENT_WINDOW_MOVED</code>","text":"<p>Window has been moved to Data1, Data2</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowresized-sdl_event_window_resized","title":"<code>WindowResized = SDL_EVENT_WINDOW_RESIZED</code>","text":"<p>Window has been resized to Data1 x Data2</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowpixelsizechanged-sdl_event_window_pixel_size_changed","title":"<code>WindowPixelSizeChanged = SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED</code>","text":"<p>The pixel size of the window has changed to Data1 x Data2</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowmetalviewresized-sdl_event_window_metal_view_resized","title":"<code>WindowMetalViewResized = SDL_EVENT_WINDOW_METAL_VIEW_RESIZED</code>","text":"<p>The pixel size of a Metal view associated with the window has changed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowminimized-sdl_event_window_minimized","title":"<code>WindowMinimized = SDL_EVENT_WINDOW_MINIMIZED</code>","text":"<p>Window has been minimized</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowmaximized-sdl_event_window_maximized","title":"<code>WindowMaximized = SDL_EVENT_WINDOW_MAXIMIZED</code>","text":"<p>Window has been maximized</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowrestored-sdl_event_window_restored","title":"<code>WindowRestored = SDL_EVENT_WINDOW_RESTORED</code>","text":"<p>Window has been restored to normal size and position</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowmouseenter-sdl_event_window_mouse_enter","title":"<code>WindowMouseEnter = SDL_EVENT_WINDOW_MOUSE_ENTER</code>","text":"<p>Window has gained mouse focus</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowmouseleave-sdl_event_window_mouse_leave","title":"<code>WindowMouseLeave = SDL_EVENT_WINDOW_MOUSE_LEAVE</code>","text":"<p>Window has lost mouse focus</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowfocusgained-sdl_event_window_focus_gained","title":"<code>WindowFocusGained = SDL_EVENT_WINDOW_FOCUS_GAINED</code>","text":"<p>Window has gained keyboard focus</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowfocuslost-sdl_event_window_focus_lost","title":"<code>WindowFocusLost = SDL_EVENT_WINDOW_FOCUS_LOST</code>","text":"<p>Window has lost keyboard focus</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowcloserequested-sdl_event_window_close_requested","title":"<code>WindowCloseRequested = SDL_EVENT_WINDOW_CLOSE_REQUESTED</code>","text":"<p>The window manager requests that the window be closed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowhittest-sdl_event_window_hit_test","title":"<code>WindowHitTest = SDL_EVENT_WINDOW_HIT_TEST</code>","text":"<p>Window had a hit test that wasn't TSdlHitTestResult.Normal</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowiccprofchanged-sdl_event_window_iccprof_changed","title":"<code>WindowIccProfChanged = SDL_EVENT_WINDOW_ICCPROF_CHANGED</code>","text":"<p>The ICC profile of the window's display has changed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowdisplaychanged-sdl_event_window_display_changed","title":"<code>WindowDisplayChanged = SDL_EVENT_WINDOW_DISPLAY_CHANGED</code>","text":"<p>Window has been moved to display data1</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowdisplayscalechanged-sdl_event_window_display_scale_changed","title":"<code>WindowDisplayScaleChanged = SDL_EVENT_WINDOW_DISPLAY_SCALE_CHANGED</code>","text":"<p>Window display scale has been changed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowsafeareachanged-sdl_event_window_safe_area_changed","title":"<code>WindowSafeAreaChanged = SDL_EVENT_WINDOW_SAFE_AREA_CHANGED</code>","text":"<p>The window safe area has been changed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowoccluded-sdl_event_window_occluded","title":"<code>WindowOccluded = SDL_EVENT_WINDOW_OCCLUDED</code>","text":"<p>The window has been occluded</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowenterfullscreen-sdl_event_window_enter_fullscreen","title":"<code>WindowEnterFullscreen = SDL_EVENT_WINDOW_ENTER_FULLSCREEN</code>","text":"<p>The window has entered fullscreen mode</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowleavefullscreen-sdl_event_window_leave_fullscreen","title":"<code>WindowLeaveFullscreen = SDL_EVENT_WINDOW_LEAVE_FULLSCREEN</code>","text":"<p>The window has left fullscreen mode</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowdestroyed-sdl_event_window_destroyed","title":"<code>WindowDestroyed = SDL_EVENT_WINDOW_DESTROYED</code>","text":"<p>The window with the associated ID is being or has been destroyed. If this message is being handled in an event watcher, the window handle is still valid and can still be used to retrieve any properties associated with the window. Otherwise, the handle has already been destroyed and all resources associated with it are invalid</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowhdrstatechanged-sdl_event_window_hdr_state_changed","title":"<code>WindowHdrStateChanged = SDL_EVENT_WINDOW_HDR_STATE_CHANGED</code>","text":"<p>Window HDR properties have changed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowfirst-sdl_event_window_first","title":"<code>WindowFirst = SDL_EVENT_WINDOW_FIRST</code>","text":""},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#windowlast-sdl_event_window_last","title":"<code>WindowLast = SDL_EVENT_WINDOW_LAST</code>","text":""},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#keydown-sdl_event_key_down","title":"<code>KeyDown = SDL_EVENT_KEY_DOWN</code>","text":"<p>Key pressed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#keyup-sdl_event_key_up","title":"<code>KeyUp = SDL_EVENT_KEY_UP</code>","text":"<p>Key released</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#textediting-sdl_event_text_editing","title":"<code>TextEditing = SDL_EVENT_TEXT_EDITING</code>","text":"<p>Keyboard text editing (composition)</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#textinput-sdl_event_text_input","title":"<code>TextInput = SDL_EVENT_TEXT_INPUT</code>","text":"<p>Keyboard text input</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#keymapchanged-sdl_event_keymap_changed","title":"<code>KeymapChanged = SDL_EVENT_KEYMAP_CHANGED</code>","text":"<p>Keymap changed due to a system event such as an input language or keyboard layout change.</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#keyboardadded-sdl_event_keyboard_added","title":"<code>KeyboardAdded = SDL_EVENT_KEYBOARD_ADDED</code>","text":"<p>A new keyboard has been inserted into the system</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#keyboardremoved-sdl_event_keyboard_removed","title":"<code>KeyboardRemoved = SDL_EVENT_KEYBOARD_REMOVED</code>","text":"<p>A keyboard has been removed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#texteditingcandidates-sdl_event_text_editing_candidates","title":"<code>TextEditingCandidates = SDL_EVENT_TEXT_EDITING_CANDIDATES</code>","text":"<p>Keyboard text editing candidates</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#mousemotion-sdl_event_mouse_motion","title":"<code>MouseMotion = SDL_EVENT_MOUSE_MOTION</code>","text":"<p>Mouse moved</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#mousebuttondown-sdl_event_mouse_button_down","title":"<code>MouseButtonDown = SDL_EVENT_MOUSE_BUTTON_DOWN</code>","text":"<p>Mouse button pressed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#mousebuttonup-sdl_event_mouse_button_up","title":"<code>MouseButtonUp = SDL_EVENT_MOUSE_BUTTON_UP</code>","text":"<p>Mouse button released</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#mousewheel-sdl_event_mouse_wheel","title":"<code>MouseWheel = SDL_EVENT_MOUSE_WHEEL</code>","text":"<p>Mouse wheel motion</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#mouseadded-sdl_event_mouse_added","title":"<code>MouseAdded = SDL_EVENT_MOUSE_ADDED</code>","text":"<p>A new mouse has been inserted into the system</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#mouseremoved-sdl_event_mouse_removed","title":"<code>MouseRemoved = SDL_EVENT_MOUSE_REMOVED</code>","text":"<p>A mouse has been removed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#joystickaxismotion-sdl_event_joystick_axis_motion","title":"<code>JoystickAxisMotion = SDL_EVENT_JOYSTICK_AXIS_MOTION</code>","text":"<p>Joystick axis motion</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#joystickballmotion-sdl_event_joystick_ball_motion","title":"<code>JoystickBallMotion = SDL_EVENT_JOYSTICK_BALL_MOTION</code>","text":"<p>Joystick trackball motion</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#joystickhatmotion-sdl_event_joystick_hat_motion","title":"<code>JoystickHatMotion = SDL_EVENT_JOYSTICK_HAT_MOTION</code>","text":"<p>Joystick hat position change</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#joystickbuttondown-sdl_event_joystick_button_down","title":"<code>JoystickButtonDown = SDL_EVENT_JOYSTICK_BUTTON_DOWN</code>","text":"<p>Joystick button pressed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#joystickbuttonup-sdl_event_joystick_button_up","title":"<code>JoystickButtonUp = SDL_EVENT_JOYSTICK_BUTTON_UP</code>","text":"<p>Joystick button released</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#joystickadded-sdl_event_joystick_added","title":"<code>JoystickAdded = SDL_EVENT_JOYSTICK_ADDED</code>","text":"<p>A new joystick has been inserted into the system</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#joystickremoved-sdl_event_joystick_removed","title":"<code>JoystickRemoved = SDL_EVENT_JOYSTICK_REMOVED</code>","text":"<p>An opened joystick has been removed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#joystickbatteryupdated-sdl_event_joystick_battery_updated","title":"<code>JoystickBatteryUpdated = SDL_EVENT_JOYSTICK_BATTERY_UPDATED</code>","text":"<p>Joystick battery level change</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#joystickupdatecomplete-sdl_event_joystick_update_complete","title":"<code>JoystickUpdateComplete = SDL_EVENT_JOYSTICK_UPDATE_COMPLETE</code>","text":"<p>Joystick update is complete</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#gamepadaxismotion-sdl_event_gamepad_axis_motion","title":"<code>GamepadAxisMotion = SDL_EVENT_GAMEPAD_AXIS_MOTION</code>","text":"<p>Gamepad axis motion</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#gamepadbuttondown-sdl_event_gamepad_button_down","title":"<code>GamepadButtonDown = SDL_EVENT_GAMEPAD_BUTTON_DOWN</code>","text":"<p>Gamepad button pressed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#gamepadbuttonup-sdl_event_gamepad_button_up","title":"<code>GamepadButtonUp = SDL_EVENT_GAMEPAD_BUTTON_UP</code>","text":"<p>Gamepad button released</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#gamepadadded-sdl_event_gamepad_added","title":"<code>GamepadAdded = SDL_EVENT_GAMEPAD_ADDED</code>","text":"<p>A new gamepad has been inserted into the system</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#gamepadremoved-sdl_event_gamepad_removed","title":"<code>GamepadRemoved = SDL_EVENT_GAMEPAD_REMOVED</code>","text":"<p>A gamepad has been removed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#gamepadremapped-sdl_event_gamepad_remapped","title":"<code>GamepadRemapped = SDL_EVENT_GAMEPAD_REMAPPED</code>","text":"<p>The gamepad mapping was updated</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#gamepadtouchpaddown-sdl_event_gamepad_touchpad_down","title":"<code>GamepadTouchpadDown = SDL_EVENT_GAMEPAD_TOUCHPAD_DOWN</code>","text":"<p>Gamepad touchpad was touched</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#gamepadtouchpadmotion-sdl_event_gamepad_touchpad_motion","title":"<code>GamepadTouchpadMotion = SDL_EVENT_GAMEPAD_TOUCHPAD_MOTION</code>","text":"<p>Gamepad touchpad finger was moved</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#gamepadtouchpadup-sdl_event_gamepad_touchpad_up","title":"<code>GamepadTouchpadUp = SDL_EVENT_GAMEPAD_TOUCHPAD_UP</code>","text":"<p>Gamepad touchpad finger was lifted</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#gamepadsensorupdate-sdl_event_gamepad_sensor_update","title":"<code>GamepadSensorUpdate = SDL_EVENT_GAMEPAD_SENSOR_UPDATE</code>","text":"<p>Gamepad sensor was updated</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#gamepadupdatecomplete-sdl_event_gamepad_update_complete","title":"<code>GamepadUpdateComplete = SDL_EVENT_GAMEPAD_UPDATE_COMPLETE</code>","text":"<p>Gamepad update is complete</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#gamepadsteamhandleupdated-sdl_event_gamepad_steam_handle_updated","title":"<code>GamepadSteamHandleUpdated = SDL_EVENT_GAMEPAD_STEAM_HANDLE_UPDATED</code>","text":"<p>Gamepad Steam handle has changed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#fingerdown-sdl_event_finger_down","title":"<code>FingerDown = SDL_EVENT_FINGER_DOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#finger-sdl_event_finger_up","title":"<code>Finger = SDL_EVENT_FINGER_UP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#fingermotion-sdl_event_finger_motion","title":"<code>FingerMotion = SDL_EVENT_FINGER_MOTION</code>","text":""},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#fingercanceled-sdl_event_finger_canceled","title":"<code>FingerCanceled = SDL_EVENT_FINGER_CANCELED</code>","text":""},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#clipboardupdate-sdl_event_clipboard_update","title":"<code>ClipboardUpdate = SDL_EVENT_CLIPBOARD_UPDATE</code>","text":"<p>The clipboard or primary selection changed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#dropfile-sdl_event_drop_file","title":"<code>DropFile = SDL_EVENT_DROP_FILE</code>","text":"<p>The system requests a file open</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#droptext-sdl_event_drop_text","title":"<code>DropText = SDL_EVENT_DROP_TEXT</code>","text":"<p>text/plain drag-and-drop event</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#dropbegin-sdl_event_drop_begin","title":"<code>DropBegin = SDL_EVENT_DROP_BEGIN</code>","text":"<p>A new set of drops is beginning (NULL filename)</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#dropcomplete-sdl_event_drop_complete","title":"<code>DropComplete = SDL_EVENT_DROP_COMPLETE</code>","text":"<p>Current set of drops is now complete (NULL filename)</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#dropposition-sdl_event_drop_position","title":"<code>DropPosition = SDL_EVENT_DROP_POSITION</code>","text":"<p>Position while moving over the window</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#audiodeviceadded-sdl_event_audio_device_added","title":"<code>AudioDeviceAdded = SDL_EVENT_AUDIO_DEVICE_ADDED</code>","text":"<p>A new audio device is available</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#audiodeviceremoved-sdl_event_audio_device_removed","title":"<code>AudioDeviceRemoved = SDL_EVENT_AUDIO_DEVICE_REMOVED</code>","text":"<p>An audio device has been removed.</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#audiodeviceformatchanged-sdl_event_audio_device_format_changed","title":"<code>AudioDeviceFormatChanged = SDL_EVENT_AUDIO_DEVICE_FORMAT_CHANGED</code>","text":"<p>An audio device's format has been changed by the system.</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#sensorupdate-sdl_event_sensor_update","title":"<code>SensorUpdate = SDL_EVENT_SENSOR_UPDATE</code>","text":"<p>A sensor was updated</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#penproximityin-sdl_event_pen_proximity_in","title":"<code>PenProximityIn = SDL_EVENT_PEN_PROXIMITY_IN</code>","text":"<p>Pressure-sensitive pen has become available</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#penproximityout-sdl_event_pen_proximity_out","title":"<code>PenProximityOut = SDL_EVENT_PEN_PROXIMITY_OUT</code>","text":"<p>Pressure-sensitive pen has become unavailable</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#pendown-sdl_event_pen_down","title":"<code>PenDown = SDL_EVENT_PEN_DOWN</code>","text":"<p>Pressure-sensitive pen touched drawing surface</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#penup-sdl_event_pen_up","title":"<code>PenUp = SDL_EVENT_PEN_UP</code>","text":"<p>Pressure-sensitive pen stopped touching drawing surface</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#penbuttondown-sdl_event_pen_button_down","title":"<code>PenButtonDown = SDL_EVENT_PEN_BUTTON_DOWN</code>","text":"<p>Pressure-sensitive pen button pressed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#penbuttonup-sdl_event_pen_button_up","title":"<code>PenButtonUp = SDL_EVENT_PEN_BUTTON_UP</code>","text":"<p>Pressure-sensitive pen button released</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#penmotion-sdl_event_pen_motion","title":"<code>PenMotion = SDL_EVENT_PEN_MOTION</code>","text":"<p>Pressure-sensitive pen is moving on the tablet</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#penaxis-sdl_event_pen_axis","title":"<code>PenAxis = SDL_EVENT_PEN_AXIS</code>","text":"<p>Pressure-sensitive pen angle/pressure/etc changed</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#cameradeviceadded-sdl_event_camera_device_added","title":"<code>CameraDeviceAdded = SDL_EVENT_CAMERA_DEVICE_ADDED</code>","text":"<p>A new camera device is available</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#cameradeviceremoved-sdl_event_camera_device_removed","title":"<code>CameraDeviceRemoved = SDL_EVENT_CAMERA_DEVICE_REMOVED</code>","text":"<p>A camera device has been removed.</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#cameradeviceapproved-sdl_event_camera_device_approved","title":"<code>CameraDeviceApproved = SDL_EVENT_CAMERA_DEVICE_APPROVED</code>","text":"<p>A camera device has been approved for use by the user.</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#cameradevicedenied-sdl_event_camera_device_denied","title":"<code>CameraDeviceDenied = SDL_EVENT_CAMERA_DEVICE_DENIED</code>","text":"<p>A camera device has been denied for use by the user.</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#rendertargetsresert-sdl_event_render_targets_reset","title":"<code>RenderTargetsResert = SDL_EVENT_RENDER_TARGETS_RESET</code>","text":"<p>The render targets have been reset and their contents need to be updated</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#renderdevicereset-sdl_event_render_device_reset","title":"<code>RenderDeviceReset = SDL_EVENT_RENDER_DEVICE_RESET</code>","text":"<p>The device has been reset and all textures need to be recreated</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#renderdevicelost-sdl_event_render_device_lost","title":"<code>RenderDeviceLost = SDL_EVENT_RENDER_DEVICE_LOST</code>","text":"<p>The device has been lost and can't be recovered.</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#pollsentinel-sdl_event_poll_sentinel","title":"<code>PollSentinel = SDL_EVENT_POLL_SENTINEL</code>","text":"<p>Signals the end of an event poll cycle</p>"},{"location":"Reference/Neslib.Sdl3.Events/types/TSdlEventKind/#last-sdl_event_last","title":"<code>Last = SDL_EVENT_LAST</code>","text":"<p>This last event is only for bounding internal arrays </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/","title":"Neslib.Sdl3.Gpu","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/#classes-records","title":"Classes &amp; Records","text":"Name Description TSdlGpuBlitInfo A record containing parameters for a blit command. TSdlGpuBlitRegion A record specifying a region of a texture used in the blit operation. TSdlGpuBuffer A buffer used for vertices, indices, indirect draw commands, and general compute data. TSdlGpuBufferBinding A record specifying parameters in a buffer binding call. TSdlGpuBufferCreateInfo A record specifying the parameters of a buffer. TSdlGpuBufferLocation A record specifying a location in a buffer. TSdlGpuBufferRegion A record specifying a region of a buffer. TSdlGpuColorTargetBlendState A record specifying the blend state of a color target. TSdlGpuColorTargetDescription A record specifying the parameters of color targets used in a graphics pipeline. TSdlGpuColorTargetInfo A record specifying the parameters of a color target used by a render pass. TSdlGpuCommandBuffer A command buffer. TSdlGpuComputePass A compute pass. TSdlGpuComputePipeline A compute pipeline. Used during compute passes. TSdlGpuComputePipelineCreateInfo A record specifying the parameters of a compute pipeline state. TSdlGpuCopyPass A copy pass. TSdlGpuDepthStencilState A record specifying the parameters of the graphics pipeline depth stencil state. TSdlGpuDepthStencilTargetInfo A structure specifying the parameters of a depth-stencil target used by a render pass. TSdlGpuDevice The SDL_GPU context. TSdlGpuDriver A GPU driver compiled into SDL. TSdlGpuFence A fence. TSdlGpuGraphicsPipeline A graphics pipeline. Used during render passes. TSdlGpuGraphicsPipelineCreateInfo A record specifying the parameters of a graphics pipeline state. TSdlGpuGraphicsPipelineTargetInfo A record specifying the descriptions of render targets used in a graphics pipeline. TSdlGpuIndexedIndirectDrawCommand A record specifying the parameters of an indexed indirect draw command. TSdlGpuIndirectDispatchCommand A record specifying the parameters of an indexed dispatch command. TSdlGpuIndirectDrawCommand A record specifying the parameters of an indirect draw command. TSdlGpuMultisampleState A record specifying the parameters of the graphics pipeline multisample state. TSdlGpuRasterizerState A record specifying the parameters of the graphics pipeline rasterizer state. TSdlGpuRenderPass A render pass. TSdlGpuSampler A sampler. TSdlGpuSamplerCreateInfo A record specifying the parameters of a sampler. TSdlGpuShader A compiled shader object. TSdlGpuShaderCreateInfo A record specifying code and metadata for creating a shader object. TSdlGpuStencilOpState A record specifying the stencil operation state of a graphics pipeline. TSdlGpuStorageBufferReadWriteBinding A record specifying parameters related to binding buffers in a compute pass. TSdlGpuStorageTextureReadWriteBinding A record specifying parameters related to binding textures in a compute pass. TSdlGpuTexture A texture. TSdlGpuTextureCreateInfo A record specifying the parameters of a texture. TSdlGpuTextureLocation A record specifying a location in a texture. TSdlGpuTextureRegion A record specifying a region of a texture. TSdlGpuTextureSamplerBinding A record specifying parameters in a sampler binding call. TSdlGpuTextureTransferInfo A record specifying parameters related to transferring data to or from a texture. TSdlGpuTransferBuffer A transfer buffer used for transferring data to and from the device. TSdlGpuTransferBufferCreateInfo A record specifying the parameters of a transfer buffer. TSdlGpuTransferBufferLocation A record specifying a location in a transfer buffer. TSdlGpuVertexAttribute A record specifying a vertex attribute. TSdlGpuVertexBufferDescription A record specifying the parameters of vertex buffers used in a graphics pipeline. TSdlGpuVertexInputState A record specifying the parameters of a graphics pipeline vertex input state. TSdlGpuViewport A record specifying a viewport."},{"location":"Reference/Neslib.Sdl3.Gpu/#types","title":"Types","text":"Name Description PSdlGpuBlitRegion PSdlGpuColorTargetBlendState PSdlGpuDepthStencilState PSdlGpuGraphicsPipelineCreateInfo PSdlGpuMultisampleState PSdlGpuRasterizerState PSdlGpuStencilOpState TSdlGpuBlendFactor Specifies a blending factor to be used when pixels in a render target are blended with existing pixels in the texture. TSdlGpuBlendOp Specifies the operator to be used when pixels in a render target are blended with existing pixels in the texture. TSdlGpuBufferUsageFlag Specifies how a buffer is intended to be used by the client. TSdlGpuBufferUsageFlags TSdlGpuColorComponentFlag Specifies which color components are written in a graphics pipeline. TSdlGpuColorComponentFlags TSdlGpuCompareOp Specifies a comparison operator for depth, stencil and sampler operations. TSdlGpuCubeMapFace Specifies the face of a cube map. TSdlGpuCullMode Specifies the facing direction in which triangle faces will be culled. TSdlGpuFillMode Specifies the fill mode of the graphics pipeline. TSdlGpuFilter Specifies a filter operation used by a sampler. TSdlGpuFrontFace Specifies the vertex winding that will cause a triangle to be determined to be front-facing. TSdlGpuIndexElementSize Specifies the size of elements in an index buffer. TSdlGpuLoadOp Specifies how the contents of a texture attached to a render pass are treated at the beginning of the render pass. TSdlGpuPresentMode Specifies the timing that will be used to present swapchain textures to the OS. TSdlGpuPrimitiveType Specifies the primitive topology of a graphics pipeline. TSdlGpuSampleCount Specifies the sample count of a texture. TSdlGpuSamplerAddressMode Specifies behavior of texture sampling when the coordinates exceed the 0-1 range. TSdlGpuSamplerMipmapMode Specifies a mipmap mode used by a sampler. TSdlGpuShaderFormat Specifies the format of shader code. TSdlGpuShaderFormats TSdlGpuShaderStage Specifies which stage a shader program corresponds to. TSdlGpuStencilOp Specifies what happens to a stored stencil value if stencil tests fail or pass. TSdlGpuStoreOp Specifies how the contents of a texture attached to a render pass are treated at the end of the render pass. TSdlGpuSwapchainComposition Specifies the texture format and colorspace of the swapchain textures. TSdlGpuTextureFormat Specifies the pixel format of a texture. TSdlGpuTextureKind Specifies the type of a texture. TSdlGpuTextureUsageFlag Specifies how a texture is intended to be used by the client. TSdlGpuTextureUsageFlags TSdlGpuTransferBufferUsage Specifies how a transfer buffer is intended to be used by the client. TSdlGpuVertexElementFormat Specifies the format of a vertex attribute. TSdlGpuVertexInputRate Specifies the rate at which vertex attributes are pulled from buffers."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitInfo/","title":"TSdlGpuBlitInfo","text":"<p>A record containing parameters for a blit command. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitInfo/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuBlitInfo = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitInfo/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.Blit</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitInfo/#properties","title":"Properties","text":"Name Description ClearColor The color to clear the destination region to before the blit. Ignored if LoadOp is not TSdlGpuLoadOp.Clear. Cycle true cycles the destination texture if it is already bound. Destination The destination region for the blit. Filter The filter mode used when blitting. FlipMode The flip mode for the source region. LoadOp What is done with the contents of the destination before the blit. Source The source region for the blit."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitInfo/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitInfo/#ClearColor","title":"ClearColor","text":"<p>The color to clear the destination region to before the blit. Ignored if LoadOp is not TSdlGpuLoadOp.Clear. </p> <p><code>property ClearColor: TSdlColorF read GetClearColor write SetClearColor</code></p> <p>Type: <code>TSdlColorF</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitInfo/#Cycle","title":"Cycle","text":"<p>true cycles the destination texture if it is already bound. </p> <p><code>property Cycle: Boolean read FHandle.cycle write FHandle.cycle</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitInfo/#Destination","title":"Destination","text":"<p>The destination region for the blit. </p> <p><code>property Destination: PSdlGpuBlitRegion read GetDestination</code></p> <p>Type: <code>PSdlGpuBlitRegion</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitInfo/#Filter","title":"Filter","text":"<p>The filter mode used when blitting. </p> <p><code>property Filter: TSdlGpuFilter read GetFilter write SetFilter</code></p> <p>Type: <code>TSdlGpuFilter</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitInfo/#FlipMode","title":"FlipMode","text":"<p>The flip mode for the source region. </p> <p><code>property FlipMode: TSdlFlipMode read GetFlipMode write SetFlipMode</code></p> <p>Type: <code>TSdlFlipMode</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitInfo/#LoadOp","title":"LoadOp","text":"<p>What is done with the contents of the destination before the blit. </p> <p><code>property LoadOp: TSdlGpuLoadOp read GetLoadOp write SetLoadOp</code></p> <p>Type: <code>TSdlGpuLoadOp</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitInfo/#Source","title":"Source","text":"<p>The source region for the blit. </p> <p><code>property Source: PSdlGpuBlitRegion read GetSource</code></p> <p>Type: <code>PSdlGpuBlitRegion</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitRegion/","title":"TSdlGpuBlitRegion","text":"<p>A record specifying a region of a texture used in the blit operation. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitRegion/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuBlitRegion = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitRegion/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.Blit</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitRegion/#properties","title":"Properties","text":"Name Description H The height of the region. LayerOrDepthPlane The layer index or depth plane of the region. This value is treated as a layer index on 2D array and cube textures, and as a depth plane on 3D MipLevel The mip level index of the region. Texture The texture. W The width of the region. X The left offset of the region. Y The top offset of the region."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitRegion/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitRegion/#H","title":"H","text":"<p>The height of the region. </p> <p><code>property H: Integer read FHandle.h write FHandle.h</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitRegion/#LayerOrDepthPlane","title":"LayerOrDepthPlane","text":"<p>The layer index or depth plane of the region. This value is treated as a layer index on 2D array and cube textures, and as a depth plane on 3D </p> <p><code>property LayerOrDepthPlane: Integer read FHandle.layer_or_depth_plane write FHandle.layer_or_depth_plane</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitRegion/#MipLevel","title":"MipLevel","text":"<p>The mip level index of the region. </p> <p><code>property MipLevel: Integer read FHandle.mip_level write FHandle.mip_level</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitRegion/#Texture","title":"Texture","text":"<p>The texture. </p> <p><code>property Texture: TSdlGpuTexture read GetTexture write SetTexture</code></p> <p>Type: <code>TSdlGpuTexture</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitRegion/#W","title":"W","text":"<p>The width of the region. </p> <p><code>property W: Integer read FHandle.w write FHandle.w</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitRegion/#X","title":"X","text":"<p>The left offset of the region. </p> <p><code>property X: Integer read FHandle.x write FHandle.x</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBlitRegion/#Y","title":"Y","text":"<p>The top offset of the region. </p> <p><code>property Y: Integer read FHandle.y write FHandle.y</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBuffer/","title":"TSdlGpuBuffer","text":"<p>A buffer used for vertices, indices, indirect draw commands, and general compute data. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBuffer/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuBuffer = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBuffer/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuDevice.CreateBuffer</li> <li>TSdlGpuCopyPass.UploadToBuffer</li> <li>TSdlGpuCopyPass.DownloadFromBuffer</li> <li>TSdlGpuCopyPass.CopyBufferToBuffer</li> <li>TSdlGpuRenderPass.BindVertexBuffers</li> <li>TSdlGpuRenderPass.BindIndexBuffer</li> <li>TSdlGpuRenderPass.BindVertexStorageBuffers</li> <li>TSdlGpuRenderPass.BindFragmentStorageBuffers</li> <li>TSdlGpuRenderPass.DrawPrimitives</li> <li>TSdlGpuComputePass.BindStorageBuffers</li> <li>TSdlGpuComputePass.Dispatch</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBuffer/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBuffer/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBuffer/#Equal","title":"Equal(TSdlGpuBuffer, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGpuBuffer; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBuffer/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuBuffer</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBuffer/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBuffer/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlGpuBuffer; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBuffer/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBuffer/#returns_1","title":"Returns","text":"<p><code>TSdlGpuBuffer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBuffer/#NotEqual","title":"NotEqual(TSdlGpuBuffer, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGpuBuffer; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBuffer/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuBuffer</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBuffer/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferBinding/","title":"TSdlGpuBufferBinding","text":"<p>A record specifying parameters in a buffer binding call. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferBinding/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuBufferBinding = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferBinding/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuRenderPass.BindVertexBuffers</li> <li>TSdlGpuRenderPass.BindIndexBuffer</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferBinding/#properties","title":"Properties","text":"Name Description Buffer The buffer to bind. Must have been created with TSdlGpuBufferUsage.Vertex for TSdlGpuRenderPass.BindVertexBuffers, or TSdlGpuBufferUsage.Index  for TSdlGpuRenderPass.BindIndexBuffer. Offset The starting byte of the data to bind in the buffer."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferBinding/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferBinding/#Buffer","title":"Buffer","text":"<p>The buffer to bind. Must have been created with TSdlGpuBufferUsage.Vertex for TSdlGpuRenderPass.BindVertexBuffers, or TSdlGpuBufferUsage.Index  for TSdlGpuRenderPass.BindIndexBuffer. </p> <p><code>property Buffer: TSdlGpuBuffer read GetBuffer write SetBuffer</code></p> <p>Type: <code>TSdlGpuBuffer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferBinding/#Offset","title":"Offset","text":"<p>The starting byte of the data to bind in the buffer. </p> <p><code>property Offset: Integer read FHandle.offset write FHandle.offset</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferCreateInfo/","title":"TSdlGpuBufferCreateInfo","text":"<p>A record specifying the parameters of a buffer.</p> <p>Note that certain combinations are invalid, for example Vertex and Index. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferCreateInfo/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuBufferCreateInfo = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferCreateInfo/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuBuffer</li> <li>TSdlGpuBufferUsageFlags</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferCreateInfo/#properties","title":"Properties","text":"Name Description Props A properties ID for extensions. Should be 0 if no extensions are needed. Size The size in bytes of the buffer. Usage How the buffer is intended to be used by the client."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferCreateInfo/#methods","title":"Methods","text":"Name Description Create Create with default values. Init Init with default values."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferCreateInfo/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferCreateInfo/#Props","title":"Props","text":"<p>A properties ID for extensions. Should be 0 if no extensions are needed. </p> <p><code>property Props: TSdlProperties read GetProps write SetProps</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferCreateInfo/#Size","title":"Size","text":"<p>The size in bytes of the buffer. </p> <p><code>property Size: Integer read FHandle.size write FHandle.size</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferCreateInfo/#Usage","title":"Usage","text":"<p>How the buffer is intended to be used by the client. </p> <p><code>property Usage: TSdlGpuBufferUsageFlags read GetUsage write SetUsage</code></p> <p>Type: <code>TSdlGpuBufferUsageFlags</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferCreateInfo/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferCreateInfo/#Create","title":"Create","text":"<p>Create with default values. </p> <p><code>class function Create: TSdlGpuBufferCreateInfo; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferCreateInfo/#returns","title":"Returns","text":"<p><code>TSdlGpuBufferCreateInfo</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferCreateInfo/#Init","title":"Init","text":"<p>Init with default values. </p> <p><code>procedure Init; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferLocation/","title":"TSdlGpuBufferLocation","text":"<p>A record specifying a location in a buffer.</p> <p>Used when copying data between buffers. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferLocation/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuBufferLocation = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferLocation/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCopyPass.CopyBufferToBuffer</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferLocation/#properties","title":"Properties","text":"Name Description Buffer The buffer. Offset The starting byte within the buffer."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferLocation/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferLocation/#Buffer","title":"Buffer","text":"<p>The buffer. </p> <p><code>property Buffer: TSdlGpuBuffer read GetBuffer write SetBuffer</code></p> <p>Type: <code>TSdlGpuBuffer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferLocation/#Offset","title":"Offset","text":"<p>The starting byte within the buffer. </p> <p><code>property Offset: Integer read FHandle.offset write FHandle.offset</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferRegion/","title":"TSdlGpuBufferRegion","text":"<p>A record specifying a region of a buffer.</p> <p>Used when transferring data to or from buffers. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferRegion/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuBufferRegion = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferRegion/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCopyPass.UploadToBuffer</li> <li>TSdlGpuCopyPass.DownloadFromBuffer</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferRegion/#properties","title":"Properties","text":"Name Description Buffer The buffer. Offset The starting byte within the buffer. Size The size in bytes of the region."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferRegion/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferRegion/#Buffer","title":"Buffer","text":"<p>The buffer. </p> <p><code>property Buffer: TSdlGpuBuffer read GetBuffer write SetBuffer</code></p> <p>Type: <code>TSdlGpuBuffer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferRegion/#Offset","title":"Offset","text":"<p>The starting byte within the buffer. </p> <p><code>property Offset: Integer read FHandle.offset write FHandle.offset</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuBufferRegion/#Size","title":"Size","text":"<p>The size in bytes of the region. </p> <p><code>property Size: Integer read FHandle.size write FHandle.size</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetBlendState/","title":"TSdlGpuColorTargetBlendState","text":"<p>A record specifying the blend state of a color target. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetBlendState/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuColorTargetBlendState = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetBlendState/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuColorTargetDescription</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetBlendState/#properties","title":"Properties","text":"Name Description AlphaBlendOp The blend operation for the alpha component. BlendEnabled Whether blending is enabled for the color target. ColorBlendOp The blend operation for the RGB components. ColorWriteMask A bitmask specifying which of the RGBA components are enabled for writing. Writes to all channels if enable_color_write_mask is false. ColorWriteMaskEnabled Whether the color write mask is enabled. DstAlphaBlendFctor The value to be multiplied by the destination alpha. DstColorBlendFactor The value to be multiplied by the destination RGB value. SrcAlphaBlendFactor The value to be multiplied by the source alpha. SrcColorBlendFactor The value to be multiplied by the source RGB value."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetBlendState/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetBlendState/#AlphaBlendOp","title":"AlphaBlendOp","text":"<p>The blend operation for the alpha component. </p> <p><code>property AlphaBlendOp: TSdlGpuBlendOp read GetAlphaBlendOp write SetAlphaBlendOp</code></p> <p>Type: <code>TSdlGpuBlendOp</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetBlendState/#BlendEnabled","title":"BlendEnabled","text":"<p>Whether blending is enabled for the color target. </p> <p><code>property BlendEnabled: Boolean read FHandle.enable_blend write FHandle.enable_blend</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetBlendState/#ColorBlendOp","title":"ColorBlendOp","text":"<p>The blend operation for the RGB components. </p> <p><code>property ColorBlendOp: TSdlGpuBlendOp read GetColorBlendOp write SetColorBlendOp</code></p> <p>Type: <code>TSdlGpuBlendOp</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetBlendState/#ColorWriteMask","title":"ColorWriteMask","text":"<p>A bitmask specifying which of the RGBA components are enabled for writing. Writes to all channels if enable_color_write_mask is false. </p> <p><code>property ColorWriteMask: TSdlGpuColorComponentFlags read GetColorWriteMask write SetColorWriteMask</code></p> <p>Type: <code>TSdlGpuColorComponentFlags</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetBlendState/#ColorWriteMaskEnabled","title":"ColorWriteMaskEnabled","text":"<p>Whether the color write mask is enabled. </p> <p><code>property ColorWriteMaskEnabled: Boolean read FHandle.enable_color_write_mask write FHandle.enable_color_write_mask</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetBlendState/#DstAlphaBlendFctor","title":"DstAlphaBlendFctor","text":"<p>The value to be multiplied by the destination alpha. </p> <p><code>property DstAlphaBlendFctor: TSdlGpuBlendFactor read GetDstAlphaBlendFctor write SetDstAlphaBlendFctor</code></p> <p>Type: <code>TSdlGpuBlendFactor</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetBlendState/#DstColorBlendFactor","title":"DstColorBlendFactor","text":"<p>The value to be multiplied by the destination RGB value. </p> <p><code>property DstColorBlendFactor: TSdlGpuBlendFactor read GetDstColorBlendFactor write SetDstColorBlendFactor</code></p> <p>Type: <code>TSdlGpuBlendFactor</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetBlendState/#SrcAlphaBlendFactor","title":"SrcAlphaBlendFactor","text":"<p>The value to be multiplied by the source alpha. </p> <p><code>property SrcAlphaBlendFactor: TSdlGpuBlendFactor read GetSrcAlphaBlendFactor write SetSrcAlphaBlendFactor</code></p> <p>Type: <code>TSdlGpuBlendFactor</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetBlendState/#SrcColorBlendFactor","title":"SrcColorBlendFactor","text":"<p>The value to be multiplied by the source RGB value. </p> <p><code>property SrcColorBlendFactor: TSdlGpuBlendFactor read GetSrcColorBlendFactor write SetSrcColorBlendFactor</code></p> <p>Type: <code>TSdlGpuBlendFactor</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetDescription/","title":"TSdlGpuColorTargetDescription","text":"<p>A record specifying the parameters of color targets used in a graphics pipeline. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetDescription/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuColorTargetDescription = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetDescription/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipelineTargetInfo</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetDescription/#properties","title":"Properties","text":"Name Description BlendState The blend state to be used for the color target. Format The pixel format of the texture to be used as a color target."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetDescription/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetDescription/#BlendState","title":"BlendState","text":"<p>The blend state to be used for the color target. </p> <p><code>property BlendState: PSdlGpuColorTargetBlendState read GetBlendState</code></p> <p>Type: <code>PSdlGpuColorTargetBlendState</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetDescription/#Format","title":"Format","text":"<p>The pixel format of the texture to be used as a color target. </p> <p><code>property Format: TSdlGpuTextureFormat read GetFormat write SetFormat</code></p> <p>Type: <code>TSdlGpuTextureFormat</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetInfo/","title":"TSdlGpuColorTargetInfo","text":"<p>A record specifying the parameters of a color target used by a render pass.</p> <p>The LoadOp field determines what is done with the texture at the beginning of the render pass.</p> <ul> <li>Load: Loads the data currently in the texture. Not recommended for multisample textures as it requires significant memory bandwidth.</li> <li>Clear: Clears the texture to a single color.</li> <li>DontCare: The driver will do whatever it wants with the texture memory. This is a good option if you know that every single pixel will be touched in the render pass.</li> </ul> <p>The StoreOp field determines what is done with the color results of the render pass.</p> <ul> <li>Store: Stores the results of the render pass in the texture. Not recommended for multisample textures as it requires significant memory bandwidth.</li> <li>DontCare: The driver will do whatever it wants with the texture memory. This is often a good option for depth/stencil textures.</li> <li>Resolve: Resolves a multisample texture into resolve_texture, which must have a sample count of 1. Then the driver may discard the multisample texture memory. This is the most performant method of resolving a multisample target.</li> <li>ResolveAndStore: Resolves a multisample texture into the ResolveTexture, which must have a sample count of 1. Then the driver stores the multisample texture's contents. Not recommended as it requires significant memory bandwidth. </li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetInfo/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuColorTargetInfo = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetInfo/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.BeginRenderPass</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetInfo/#properties","title":"Properties","text":"Name Description ClearColor The color to clear the color target to at the start of the render pass. Ignored if TSdlGpuLoadOp.Clear is not used. Cycle True cycles the texture if the texture is bound and LoadOp is not Load. CycleResolveTexture True cycles the resolve texture if the resolve texture is bound. Ignored if a Resolve* StoreOp is not used. LayerOrDepthPlane The layer index or depth plane to use as a color target. This value is treated as a layer index on 2D array and cube textures, and as a depth plane on 3D textures. LoadOp What is done with the contents of the color target at the beginning of the render pass. MipLevel The mip level to use as a color target. ResolveLayer The layer index of the resolve texture to use for the resolve operation. Ignored if a Resolve* StoreOp is not used. ResolveMipLevel The mip level of the resolve texture to use for the resolve operation. Ignored if a Resolve* StoreOp is not used. ResolveTexture The texture that will receive the results of a multisample resolve operation. Ignored if a Resolve* StoreOp is not used. StoreOp What is done with the results of the render pass. Texture The texture that will be used as a color target by a render pass."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetInfo/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetInfo/#ClearColor","title":"ClearColor","text":"<p>The color to clear the color target to at the start of the render pass. Ignored if TSdlGpuLoadOp.Clear is not used. </p> <p><code>property ClearColor: TSdlColorF read GetClearColor write SetClearColor</code></p> <p>Type: <code>TSdlColorF</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetInfo/#Cycle","title":"Cycle","text":"<p>True cycles the texture if the texture is bound and LoadOp is not Load. </p> <p><code>property Cycle: Boolean read FHandle.cycle write FHandle.cycle</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetInfo/#CycleResolveTexture","title":"CycleResolveTexture","text":"<p>True cycles the resolve texture if the resolve texture is bound. Ignored if a Resolve* StoreOp is not used. </p> <p><code>property CycleResolveTexture: Boolean read FHandle.cycle_resolve_texture write FHandle.cycle_resolve_texture</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetInfo/#LayerOrDepthPlane","title":"LayerOrDepthPlane","text":"<p>The layer index or depth plane to use as a color target. This value is treated as a layer index on 2D array and cube textures, and as a depth plane on 3D textures. </p> <p><code>property LayerOrDepthPlane: Integer read FHandle.layer_or_depth_plane write FHandle.layer_or_depth_plane</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetInfo/#LoadOp","title":"LoadOp","text":"<p>What is done with the contents of the color target at the beginning of the render pass. </p> <p><code>property LoadOp: TSdlGpuLoadOp read GetLoadOp write SetLoadOp</code></p> <p>Type: <code>TSdlGpuLoadOp</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetInfo/#MipLevel","title":"MipLevel","text":"<p>The mip level to use as a color target. </p> <p><code>property MipLevel: Integer read FHandle.mip_level write FHandle.mip_level</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetInfo/#ResolveLayer","title":"ResolveLayer","text":"<p>The layer index of the resolve texture to use for the resolve operation. Ignored if a Resolve* StoreOp is not used. </p> <p><code>property ResolveLayer: Integer read FHandle.resolve_layer write FHandle.resolve_layer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetInfo/#ResolveMipLevel","title":"ResolveMipLevel","text":"<p>The mip level of the resolve texture to use for the resolve operation. Ignored if a Resolve* StoreOp is not used. </p> <p><code>property ResolveMipLevel: Integer read FHandle.resolve_mip_level write FHandle.resolve_mip_level</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetInfo/#ResolveTexture","title":"ResolveTexture","text":"<p>The texture that will receive the results of a multisample resolve operation. Ignored if a Resolve* StoreOp is not used. </p> <p><code>property ResolveTexture: TSdlGpuTexture read GetResolveTexture write SetResolveTexture</code></p> <p>Type: <code>TSdlGpuTexture</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetInfo/#StoreOp","title":"StoreOp","text":"<p>What is done with the results of the render pass. </p> <p><code>property StoreOp: TSdlGpuStoreOp read GetStoreOp write SetStoreOp</code></p> <p>Type: <code>TSdlGpuStoreOp</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuColorTargetInfo/#Texture","title":"Texture","text":"<p>The texture that will be used as a color target by a render pass. </p> <p><code>property Texture: TSdlGpuTexture read GetTexture write SetTexture</code></p> <p>Type: <code>TSdlGpuTexture</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/","title":"TSdlGpuCommandBuffer","text":"<p>A command buffer.</p> <p>Most state is managed via command buffers. When setting state using a command buffer, that state is local to the command buffer.</p> <p>Commands only begin execution on the GPU once Submit is called. Once the command buffer is submitted, it is no longer valid to use it.</p> <p>Command buffers are executed in submission order. If you submit command buffer A and then command buffer B all commands in A will begin executing before any command in B begins executing.</p> <p>In multi-threading scenarios, you should only access a command buffer on the thread you acquired it from. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuCommandBuffer = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuDevice.AcquireCommandBuffer</li> <li>TSdlGpuCommandBuffer.Submit</li> <li>TSdlGpuCommandBuffer.SubmitAndAcquireFence</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#methods","title":"Methods","text":"Name Description AcquireSwapchainTexture Acquire a texture to use in presentation. BeginComputePass Begins a compute pass on a command buffer. BeginCopyPass Begins a copy pass on a command buffer. BeginRenderPass(TArray&lt;TSdlGpuColorTargetInfo&gt;, TSdlGpuDepthStencilTargetInfo) Begins a render pass on a command buffer. BeginRenderPass(TArray&lt;TSdlGpuColorTargetInfo&gt;) Begins a render pass on a command buffer. Blit Blits from a source texture region to a destination texture region. Cancel Cancels the command buffer. GenerateMipmaps Generates mipmaps for the given texture. InsertDebugLabel Inserts an arbitrary string label into the command buffer callstream. PopDebugGroup Ends the most-recently pushed debug group. PushComputeUniformData(Integer, Pointer, Integer) Pushes data to a uniform slot on the command buffer. PushComputeUniformData(Integer, TBytes) Pushes data to a uniform slot on the command buffer. PushDebugGroup Begins a debug group with an arbitary name. PushFragmentUniformData(Integer, Pointer, Integer) Pushes data to a fragment uniform slot on the command buffer. PushFragmentUniformData(Integer, TBytes) Pushes data to a fragment uniform slot on the command buffer. PushVertexUniformData(Integer, Pointer, Integer) Pushes data to a vertex uniform slot on the command buffer. PushVertexUniformData(Integer, TBytes) Pushes data to a vertex uniform slot on the command buffer. Submit Submits the command buffer so its commands can be processed on the GPU. SubmitAndAcquireFence Submits the command buffer so its commands can be processed on the GPU, and acquires a fence associated with the command buffer. WaitAndAcquireSwapchainTexture Blocks the thread until a swapchain texture is available to be acquired, and then acquires it."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#Equal","title":"Equal(TSdlGpuCommandBuffer, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGpuCommandBuffer; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuCommandBuffer</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlGpuCommandBuffer; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#returns_1","title":"Returns","text":"<p><code>TSdlGpuCommandBuffer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#NotEqual","title":"NotEqual(TSdlGpuCommandBuffer, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGpuCommandBuffer; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuCommandBuffer</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#AcquireSwapchainTexture","title":"AcquireSwapchainTexture(TSdlWindow, TSdlGpuTexture, Integer, Integer)","text":"<p>Acquire a texture to use in presentation.</p> <p>When a swapchain texture is acquired on a command buffer, it will automatically be submitted for presentation when the command buffer is submitted. The swapchain texture should only be referenced by the command buffer used to acquire it.</p> <p>This method will fill the swapchain texture handle with nil if too many frames are in flight. This is not an error.</p> <p>If you use this method, it is possible to create a situation where many command buffers are allocated while the rendering context waits for the GPU to catch up, which will cause memory usage to grow. You should use WaitAndAcquireSwapchainTexture unless you know what you are doing with timing.</p> <p>The swapchain texture is managed by the implementation and must not be freed by the user. You MUST NOT call this method from any thread other than the one that created the window. </p> <p><code>procedure AcquireSwapchainTexture(const AWindow: TSdlWindow; out ASwapchainTexture: TSdlGpuTexture; out ASwapchainTextureWidth, ASwapchainTextureHeight: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_3","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : A window that has been claimed.</p> <p><code>ASwapchainTexture</code>: <code>TSdlGpuTexture</code> : Will be set to a swapchain texture.</p> <p><code>ASwapchainTextureWidth</code>: <code>Integer</code> : Will be set to the swapchain texture width.</p> <p><code>ASwapchainTextureHeight</code>: <code>Integer</code> : Will be set to the swapchain texture height.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#see-also_1","title":"See Also","text":"<ul> <li>TSdlGpuDevice.ClaimWindow</li> <li>Submit</li> <li>SubmitAndAcquireFence</li> <li>Cancel</li> <li>TSdlWindow.GetSizeInPixels</li> <li>TSdlGpuDevice.WaitForSwapchain</li> <li>WaitAndAcquireSwapchainTexture</li> <li>TSdlGpuDevice.SetAllowedFramesInFlight</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#remarks","title":"Remarks","text":"<p>This method should only be called from the thread that created the window. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#BeginComputePass","title":"BeginComputePass(TArray&lt;TSdlGpuStorageTextureReadWriteBinding&gt;, TArray&lt;TSdlGpuStorageBufferReadWriteBinding&gt;)","text":"<p>Begins a compute pass on a command buffer.</p> <p>A compute pass is defined by a set of texture subresources and buffers that may be written to by compute pipelines. These textures and buffers must have been created with TSdlGpuTextureUsage.ComputeStorageWrite or TSdlGpuTextureUsage.ComputeStorageSimultaneousReadWrite. If you do not create a texture with TSdlGpuTextureUsage.ComputeStorageSimultaneousReadWrite, you must not read from the texture in the compute pass. All operations related to compute pipelines must take place inside of a compute pass. You must not begin another compute pass, or a render pass or copy pass before ending the compute pass.</p> <p>A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT implicitly synchronized. This means you may cause data races by both reading and writing a resource region in a compute pass, or by writing multiple times to a resource region. If your compute work depends on reading the completed output from a previous dispatch, you MUST end the current compute pass and begin a new one before you can safely access the data. Otherwise you will receive unexpected results. Reading and writing a texture in the same compute pass is only supported by specific texture formats. Make sure you check the format support! </p> <p><code>function BeginComputePass(const AStorageTextureBindings, AStorageBufferBindings: TArray&lt;TSdlGpuStorageBufferReadWriteBinding&gt;): TSdlGpuComputePass; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_4","title":"Parameters","text":"<p><code>AStorageTextureBindings</code>: <code>TArray&lt;TSdlGpuStorageTextureReadWriteBinding&gt;</code> : An array of writeable storage texture binding records.</p> <p><code>AStorageBufferBindings</code>: <code>TArray&lt;TSdlGpuStorageBufferReadWriteBinding&gt;</code> : An array of writeable storage buffer binding records.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#returns_3","title":"Returns","text":"<p><code>TSdlGpuComputePass</code>: A compute pass.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#see-also_2","title":"See Also","text":"<ul> <li>TSdlGpuComputePass.Finish</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#BeginCopyPass","title":"BeginCopyPass","text":"<p>Begins a copy pass on a command buffer.</p> <p>All operations related to copying to or from buffers or textures take place inside a copy pass. You must not begin another copy pass, or a render pass or compute pass before ending the copy pass. </p> <p><code>function BeginCopyPass: TSdlGpuCopyPass; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#returns_4","title":"Returns","text":"<p><code>TSdlGpuCopyPass</code>: A copy pass.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#BeginRenderPass_0","title":"BeginRenderPass(TArray&lt;TSdlGpuColorTargetInfo&gt;, TSdlGpuDepthStencilTargetInfo)","text":"<p>Begins a render pass on a command buffer.</p> <p>A render pass consists of a set of texture subresources (or depth slices in the 3D texture case) which will be rendered to during the render pass, along with corresponding clear values and load/store operations. All operations related to graphics pipelines must take place inside of a render pass. A default viewport and scissor state are automatically set when this is called. You cannot begin another render pass, or begin a compute pass or copy pass until you have ended the render pass. </p> <p><code>function BeginRenderPass(const AColorTargetInfos: TArray&lt;TSdlGpuColorTargetInfo&gt;; const ADepthStencilTargetInfo: TSdlGpuDepthStencilTargetInfo): TSdlGpuRenderPass; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_5","title":"Parameters","text":"<p><code>AColorTargetInfos</code>: <code>TArray&lt;TSdlGpuColorTargetInfo&gt;</code> : An array of texture subresources with corresponding clear values and load/store ops.</p> <p><code>ADepthStencilTargetInfo</code>: <code>TSdlGpuDepthStencilTargetInfo</code> : Texture subresource with corresponding clear value and load/store ops, may be nil.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#returns_5","title":"Returns","text":"<p><code>TSdlGpuRenderPass</code>: A render pass.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#see-also_3","title":"See Also","text":"<ul> <li>TSdlGpuRenderPass.Finish</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#BeginRenderPass_1","title":"BeginRenderPass(TArray&lt;TSdlGpuColorTargetInfo&gt;)","text":"<p>Begins a render pass on a command buffer.</p> <p>A render pass consists of a set of texture subresources (or depth slices in the 3D texture case) which will be rendered to during the render pass, along with corresponding clear values and load/store operations. All operations related to graphics pipelines must take place inside of a render pass. A default viewport and scissor state are automatically set when this is called. You cannot begin another render pass, or begin a compute pass or copy pass until you have ended the render pass. </p> <p><code>function BeginRenderPass(const AColorTargetInfos: TArray&lt;TSdlGpuColorTargetInfo&gt;): TSdlGpuRenderPass; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_6","title":"Parameters","text":"<p><code>AColorTargetInfos</code>: <code>TArray&lt;TSdlGpuColorTargetInfo&gt;</code> : An array of texture subresources with corresponding clear values and load/store ops.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#returns_6","title":"Returns","text":"<p><code>TSdlGpuRenderPass</code>: A render pass.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#see-also_4","title":"See Also","text":"<ul> <li>TSdlGpuRenderPass.Finish</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#Blit","title":"Blit(TSdlGpuBlitInfo)","text":"<p>Blits from a source texture region to a destination texture region.</p> <p>This function must not be called inside of any pass. </p> <p><code>procedure Blit(const AInfo: TSdlGpuBlitInfo); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_7","title":"Parameters","text":"<p><code>AInfo</code>: <code>TSdlGpuBlitInfo</code> : The blit info struct containing the blit parameters.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#Cancel","title":"Cancel","text":"<p>Cancels the command buffer.</p> <p>None of the enqueued commands are executed.</p> <p>It is an error to call this method after a swapchain texture has been acquired.</p> <p>This must be called from the thread the command buffer was acquired on.</p> <p>You must not reference the command buffer after calling this method. </p> <p><code>procedure Cancel; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#see-also_5","title":"See Also","text":"<ul> <li>WaitAndAcquireSwapchainTexture</li> <li>TSdlGpuDevice.AcquireCommandBuffer</li> <li>AcquireSwapchainTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#GenerateMipmaps","title":"GenerateMipmaps(TSdlGpuTexture)","text":"<p>Generates mipmaps for the given texture.</p> <p>This function must not be called inside of any pass. </p> <p><code>procedure GenerateMipmaps(const ATexture: TSdlGpuTexture); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_8","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlGpuTexture</code> : A texture with more than 1 mip level.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#InsertDebugLabel","title":"InsertDebugLabel(String)","text":"<p>Inserts an arbitrary string label into the command buffer callstream.</p> <p>Useful for debugging. </p> <p><code>procedure InsertDebugLabel(const AText: String); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_9","title":"Parameters","text":"<p><code>AText</code>: <code>String</code> : A string constant to insert as the label.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#PopDebugGroup","title":"PopDebugGroup","text":"<p>Ends the most-recently pushed debug group. </p> <p><code>procedure PopDebugGroup; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#see-also_6","title":"See Also","text":"<ul> <li>PushDebugGroup</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#PushComputeUniformData_0","title":"PushComputeUniformData(Integer, Pointer, Integer)","text":"<p>Pushes data to a uniform slot on the command buffer.</p> <p>Subsequent draw calls will use this uniform data. </p> <p><code>procedure PushComputeUniformData(const ASlotIndex: Integer; const AData: Pointer; const ASize: Integer); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_10","title":"Parameters","text":"<p><code>ASlotIndex</code>: <code>Integer</code> : The uniform slot to push data to.</p> <p><code>AData</code>: <code>Pointer</code> : Pointer to client data to write.</p> <p><code>ASize</code>: <code>Integer</code> : Size of the data to write.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#PushComputeUniformData_1","title":"PushComputeUniformData(Integer, TBytes)","text":"<p>Pushes data to a uniform slot on the command buffer.</p> <p>Subsequent draw calls will use this uniform data. </p> <p><code>procedure PushComputeUniformData(const ASlotIndex: Integer; const AData: TBytes); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_11","title":"Parameters","text":"<p><code>ASlotIndex</code>: <code>Integer</code> : The uniform slot to push data to.</p> <p><code>AData</code>: <code>TBytes</code> : Client data to write.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#PushDebugGroup","title":"PushDebugGroup(String)","text":"<p>Begins a debug group with an arbitary name.</p> <p>Used for denoting groups of calls when viewing the command buffer callstream in a graphics debugging tool.</p> <p>Each call to PushDebugGroup must have a corresponding call to PopDebugGroup.</p> <p>On some backends (e.g. Metal), pushing a debug group during a render/blit/compute pass will create a group that is scoped to the native pass rather than the command buffer. For best results, if you push a debug group during a pass, always pop it in the same pass. </p> <p><code>procedure PushDebugGroup(const AName: String); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_12","title":"Parameters","text":"<p><code>AName</code>: <code>String</code> : A string constant that names the group.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#see-also_7","title":"See Also","text":"<ul> <li>PopDebugGroup</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#PushFragmentUniformData_0","title":"PushFragmentUniformData(Integer, Pointer, Integer)","text":"<p>Pushes data to a fragment uniform slot on the command buffer.</p> <p>Subsequent draw calls will use this uniform data. </p> <p><code>procedure PushFragmentUniformData(const ASlotIndex: Integer; const AData: Pointer; const ASize: Integer); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_13","title":"Parameters","text":"<p><code>ASlotIndex</code>: <code>Integer</code> : The fragment uniform slot to push data to.</p> <p><code>AData</code>: <code>Pointer</code> : Pointer to client data to write.</p> <p><code>ASize</code>: <code>Integer</code> : Size of the data to write.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#PushFragmentUniformData_1","title":"PushFragmentUniformData(Integer, TBytes)","text":"<p>Pushes data to a fragment uniform slot on the command buffer.</p> <p>Subsequent draw calls will use this uniform data. </p> <p><code>procedure PushFragmentUniformData(const ASlotIndex: Integer; const AData: TBytes); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_14","title":"Parameters","text":"<p><code>ASlotIndex</code>: <code>Integer</code> : The fragment uniform slot to push data to.</p> <p><code>AData</code>: <code>TBytes</code> : Client data to write.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#PushVertexUniformData_0","title":"PushVertexUniformData(Integer, Pointer, Integer)","text":"<p>Pushes data to a vertex uniform slot on the command buffer.</p> <p>Subsequent draw calls will use this uniform data. </p> <p><code>procedure PushVertexUniformData(const ASlotIndex: Integer; const AData: Pointer; const ASize: Integer); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_15","title":"Parameters","text":"<p><code>ASlotIndex</code>: <code>Integer</code> : The vertex uniform slot to push data to.</p> <p><code>AData</code>: <code>Pointer</code> : Pointer to client data to write.</p> <p><code>ASize</code>: <code>Integer</code> : Size of the data to write.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#PushVertexUniformData_1","title":"PushVertexUniformData(Integer, TBytes)","text":"<p>Pushes data to a vertex uniform slot on the command buffer.</p> <p>Subsequent draw calls will use this uniform data. </p> <p><code>procedure PushVertexUniformData(const ASlotIndex: Integer; const AData: TBytes); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_16","title":"Parameters","text":"<p><code>ASlotIndex</code>: <code>Integer</code> : The vertex uniform slot to push data to.</p> <p><code>AData</code>: <code>TBytes</code> : Client data to write.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#Submit","title":"Submit","text":"<p>Submits the command buffer so its commands can be processed on the GPU.</p> <p>It is invalid to use the command buffer after this is called.</p> <p>This must be called from the thread the command buffer was acquired on.</p> <p>All commands in the submission are guaranteed to begin executing before any command in a subsequent submission begins executing. </p> <p><code>procedure Submit; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#see-also_8","title":"See Also","text":"<ul> <li>TSdlGpuDevice.AcquireCommandBuffer</li> <li>WaitAndAcquireSwapchainTexture</li> <li>AcquireSwapchainTexture</li> <li>SubmitAndAcquireFence</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#SubmitAndAcquireFence","title":"SubmitAndAcquireFence","text":"<p>Submits the command buffer so its commands can be processed on the GPU, and acquires a fence associated with the command buffer.</p> <p>You must release this fence when it is no longer needed or it will cause a leak. It is invalid to use the command buffer after this is called.</p> <p>This must be called from the thread the command buffer was acquired on.</p> <p>All commands in the submission are guaranteed to begin executing before any command in a subsequent submission begins executing. </p> <p><code>function SubmitAndAcquireFence: TSdlGpuFence; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#returns_7","title":"Returns","text":"<p><code>TSdlGpuFence</code>: A fence associated with the command buffer.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#see-also_9","title":"See Also","text":"<ul> <li>TSdlGpuDevice.AcquireCommandBuffer</li> <li>WaitAndAcquireSwapchainTexture</li> <li>AcquireSwapchainTexture</li> <li>Submit</li> <li>TSdlGpuDevice.ReleaseFence</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#WaitAndAcquireSwapchainTexture","title":"WaitAndAcquireSwapchainTexture(TSdlWindow, TSdlGpuTexture, Integer, Integer)","text":"<p>Blocks the thread until a swapchain texture is available to be acquired, and then acquires it.</p> <p>When a swapchain texture is acquired on a command buffer, it will automatically be submitted for presentation when the command buffer is submitted. The swapchain texture should only be referenced by the command buffer used to acquire it. It is an error to call Cancel after a swapchain texture is acquired.</p> <p>This method can fill the swapchain texture handle with nil in certain cases, for example if the window is minimized. This is not an error. You should always make sure to check whether the pointer is nil before actually using it.</p> <p>The swapchain texture is managed by the implementation and must not be freed by the user. You MUST NOT call this method from any thread other than the one that created the window. </p> <p><code>procedure WaitAndAcquireSwapchainTexture(const AWindow: TSdlWindow; out ASwapchainTexture: TSdlGpuTexture; out ASwapchainTextureWidth, ASwapchainTextureHeight: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#parameters_17","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : A window that has been claimed.</p> <p><code>ASwapchainTexture</code>: <code>TSdlGpuTexture</code> : Is set to a swapchain texture.</p> <p><code>ASwapchainTextureWidth</code>: <code>Integer</code> : Is set to the swapchain texture width.</p> <p><code>ASwapchainTextureHeight</code>: <code>Integer</code> : Is set to the swapchain texture height.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#see-also_10","title":"See Also","text":"<ul> <li>Submit</li> <li>SubmitAndAcquireFence</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCommandBuffer/#remarks_1","title":"Remarks","text":"<p>This method should only be called from the thread that created the window. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/","title":"TSdlGpuComputePass","text":"<p>A compute pass.</p> <p>This handle is transient and should not be held or referenced after Finish is called. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuComputePass = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.BeginComputePass</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#methods","title":"Methods","text":"Name Description BindPipeline Binds a compute pipeline on a command buffer for use in compute dispatch. BindSamplers Binds texture-sampler pairs for use on the compute shader. BindStorageBuffers Binds storage buffers as readonly for use on the compute pipeline. BindStorageTextures Binds storage textures as readonly for use on the compute pipeline. Dispatch(TSdlGpuBuffer, Integer) Dispatches compute work with parameters set from a buffer. Dispatch(Integer, Integer, Integer) Dispatches compute work. Finish Ends the current compute pass."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#Equal","title":"Equal(TSdlGpuComputePass, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGpuComputePass; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuComputePass</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlGpuComputePass; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#returns_1","title":"Returns","text":"<p><code>TSdlGpuComputePass</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#NotEqual","title":"NotEqual(TSdlGpuComputePass, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGpuComputePass; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuComputePass</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#BindPipeline","title":"BindPipeline(TSdlGpuComputePipeline)","text":"<p>Binds a compute pipeline on a command buffer for use in compute dispatch. </p> <p><code>procedure BindPipeline(const AComputePipeline: TSdlGpuComputePipeline); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#parameters_3","title":"Parameters","text":"<p><code>AComputePipeline</code>: <code>TSdlGpuComputePipeline</code> : A compute pipeline to bind.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#BindSamplers","title":"BindSamplers(Integer, TArray&lt;TSdlGpuTextureSamplerBinding&gt;)","text":"<p>Binds texture-sampler pairs for use on the compute shader.</p> <p>The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER. </p> <p><code>procedure BindSamplers(const AFirstSlot: Integer; const ATextureSamplerBindings: TArray&lt;TSdlGpuTextureSamplerBinding&gt;); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#parameters_4","title":"Parameters","text":"<p><code>AFirstSlot</code>: <code>Integer</code> : The compute sampler slot to begin binding from.</p> <p><code>ATextureSamplerBindings</code>: <code>TArray&lt;TSdlGpuTextureSamplerBinding&gt;</code> : An array of texture-sampler binding record.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#BindStorageBuffers","title":"BindStorageBuffers(Integer, TArray&lt;TSdlGpuBuffer&gt;)","text":"<p>Binds storage buffers as readonly for use on the compute pipeline.</p> <p>These buffers must have been created with TSdlGpuBufferUsage.ComputeStorageRead. </p> <p><code>procedure BindStorageBuffers(const AFirstSlot: Integer; const AStorageBuffers: TArray&lt;TSdlGpuBuffer&gt;); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#parameters_5","title":"Parameters","text":"<p><code>AFirstSlot</code>: <code>Integer</code> : The compute storage buffer slot to begin binding from.</p> <p><code>AStorageBuffers</code>: <code>TArray&lt;TSdlGpuBuffer&gt;</code> : An array of storage buffer binding records.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#BindStorageTextures","title":"BindStorageTextures(Integer, TArray&lt;TSdlGpuTexture&gt;)","text":"<p>Binds storage textures as readonly for use on the compute pipeline.</p> <p>These textures must have been created with TSdlGpuTextureUsage.ComputeStorageRead. </p> <p><code>procedure BindStorageTextures(const AFirstSlot: Integer; const AStorageTextures: TArray&lt;TSdlGpuTexture&gt;); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#parameters_6","title":"Parameters","text":"<p><code>AFirstSlot</code>: <code>Integer</code> : The compute storage texture slot to begin binding from.</p> <p><code>AStorageTextures</code>: <code>TArray&lt;TSdlGpuTexture&gt;</code> : An array of storage textures.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#Dispatch_0","title":"Dispatch(TSdlGpuBuffer, Integer)","text":"<p>Dispatches compute work with parameters set from a buffer.</p> <p>The buffer layout should match the layout of TSdlGpuIndirectDispatchCommand. You must not call this method before binding a compute pipeline.</p> <p>A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and the dispatches write to the same resource region as each other, there is no guarantee of which order the writes will occur. If the write order matters, you MUST end the compute pass and begin another one. </p> <p><code>procedure Dispatch(const ABuffer: TSdlGpuBuffer; const AOffset: Integer); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#parameters_7","title":"Parameters","text":"<p><code>ABuffer</code>: <code>TSdlGpuBuffer</code> : A buffer containing dispatch parameters.</p> <p><code>AOffset</code>: <code>Integer</code> : The offset to start reading from the dispatch buffer.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#Dispatch_1","title":"Dispatch(Integer, Integer, Integer)","text":"<p>Dispatches compute work.</p> <p>You must not call this method before binding a compute pipeline.</p> <p>A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and the dispatches write to the same resource region as each other, there is no guarantee of which order the writes will occur. If the write order matters, you MUST end the compute pass and begin another one. </p> <p><code>procedure Dispatch(const AGroupCountX, AGroupCountY, AGroupCountZ: Integer); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#parameters_8","title":"Parameters","text":"<p><code>AGroupCountX</code>: <code>Integer</code> : Number of local workgroups to dispatch in the X dimension.</p> <p><code>AGroupCountY</code>: <code>Integer</code> : Number of local workgroups to dispatch in the Y dimension.</p> <p><code>AGroupCountZ</code>: <code>Integer</code> : Number of local workgroups to dispatch in the Z dimension.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePass/#Finish","title":"Finish","text":"<p>Ends the current compute pass.</p> <p>All bound compute state on the command buffer is unset. The compute pass handle is now invalid. </p> <p><code>procedure Finish; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipeline/","title":"TSdlGpuComputePipeline","text":"<p>A compute pipeline. Used during compute passes. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipeline/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuComputePipeline = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipeline/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuComputePass.BindPipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipeline/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipeline/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipeline/#Equal","title":"Equal(TSdlGpuComputePipeline, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGpuComputePipeline; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipeline/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuComputePipeline</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipeline/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipeline/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlGpuComputePipeline; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipeline/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipeline/#returns_1","title":"Returns","text":"<p><code>TSdlGpuComputePipeline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipeline/#NotEqual","title":"NotEqual(TSdlGpuComputePipeline, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGpuComputePipeline; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipeline/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuComputePipeline</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipeline/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/","title":"TSdlGpuComputePipelineCreateInfo","text":"<p>A record specifying the parameters of a compute pipeline state. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuComputePipelineCreateInfo = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuComputePipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#remarks","title":"Remarks","text":"<p>This struct is available since SDL 3.2.0. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#properties","title":"Properties","text":"Name Description Code The compute shader code. EntryPoint The entry point function name for the shader. Format The format of the compute shader code. NumReadonlyStorageBuffers The number of readonly storage buffers defined in the shader. NumReadonlyStorageTextures The number of readonly storage textures defined in the shader. NumReadWriteStorageBuffers The number of read-write storage buffers defined in the shader. NumReadWriteStorageTextures The number of read-write storage textures defined in the shader. NumSamplers The number of samplers defined in the shader. NumUniformBuffers The number of uniform buffers defined in the shader. Props A properties ID for extensions. Should be nil if no extensions are needed. ThreadCountX The number of threads in the X dimension. This should match the value in the shader. ThreadCountY The number of threads in the Y dimension. This should match the value in the shader. ThreadCountZ The number of threads in the Z dimension. This should match the value in the shader."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#methods","title":"Methods","text":"Name Description Create Create with default values. Init Init with default values."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#Code","title":"Code","text":"<p>The compute shader code. </p> <p><code>property Code: TBytes read FCode write SetCode</code></p> <p>Type: <code>TBytes</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#EntryPoint","title":"EntryPoint","text":"<p>The entry point function name for the shader. </p> <p><code>property EntryPoint: String read GetEntryPoint write SetEntryPoint</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#Format","title":"Format","text":"<p>The format of the compute shader code. </p> <p><code>property Format: TSdlGpuShaderFormat read GetFormat write SetFormat</code></p> <p>Type: <code>TSdlGpuShaderFormat</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#NumReadonlyStorageBuffers","title":"NumReadonlyStorageBuffers","text":"<p>The number of readonly storage buffers defined in the shader. </p> <p><code>property NumReadonlyStorageBuffers: Integer read FHandle.num_readonly_storage_buffers write FHandle.num_readonly_storage_buffers</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#NumReadonlyStorageTextures","title":"NumReadonlyStorageTextures","text":"<p>The number of readonly storage textures defined in the shader. </p> <p><code>property NumReadonlyStorageTextures: Integer read FHandle.num_readonly_storage_textures write FHandle.num_readonly_storage_textures</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#NumReadWriteStorageBuffers","title":"NumReadWriteStorageBuffers","text":"<p>The number of read-write storage buffers defined in the shader. </p> <p><code>property NumReadWriteStorageBuffers: Integer read FHandle.num_readwrite_storage_buffers write FHandle.num_readwrite_storage_buffers</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#NumReadWriteStorageTextures","title":"NumReadWriteStorageTextures","text":"<p>The number of read-write storage textures defined in the shader. </p> <p><code>property NumReadWriteStorageTextures: Integer read FHandle.num_readwrite_storage_textures write FHandle.num_readwrite_storage_textures</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#NumSamplers","title":"NumSamplers","text":"<p>The number of samplers defined in the shader. </p> <p><code>property NumSamplers: Integer read FHandle.num_samplers write FHandle.num_samplers</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#NumUniformBuffers","title":"NumUniformBuffers","text":"<p>The number of uniform buffers defined in the shader. </p> <p><code>property NumUniformBuffers: Integer read FHandle.num_uniform_buffers write FHandle.num_uniform_buffers</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#Props","title":"Props","text":"<p>A properties ID for extensions. Should be nil if no extensions are needed. </p> <p><code>property Props: TSdlProperties read GetProps write SetProps</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#ThreadCountX","title":"ThreadCountX","text":"<p>The number of threads in the X dimension. This should match the value in the shader. </p> <p><code>property ThreadCountX: Integer read FHandle.threadcount_x write FHandle.threadcount_x</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#ThreadCountY","title":"ThreadCountY","text":"<p>The number of threads in the Y dimension. This should match the value in the shader. </p> <p><code>property ThreadCountY: Integer read FHandle.threadcount_y write FHandle.threadcount_y</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#ThreadCountZ","title":"ThreadCountZ","text":"<p>The number of threads in the Z dimension. This should match the value in the shader. </p> <p><code>property ThreadCountZ: Integer read FHandle.threadcount_z write FHandle.threadcount_z</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#Create","title":"Create","text":"<p>Create with default values. </p> <p><code>class function Create: TSdlGpuComputePipelineCreateInfo; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#returns","title":"Returns","text":"<p><code>TSdlGpuComputePipelineCreateInfo</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuComputePipelineCreateInfo/#Init","title":"Init","text":"<p>Init with default values. </p> <p><code>procedure Init; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/","title":"TSdlGpuCopyPass","text":"<p>A copy pass.</p> <p>This handle is transient and should not be held or referenced after Finish is called. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuCopyPass = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.BeginCopyPass</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#methods","title":"Methods","text":"Name Description CopyBufferToBuffer Performs a buffer-to-buffer copy. CopyTextureToTexture Performs a texture-to-texture copy. DownloadFromBuffer Copies data from a buffer to a transfer buffer on the GPU timeline. DownloadFromTexture Copies data from a texture to a transfer buffer on the GPU timeline. Finish Ends the current copy pass. UploadToBuffer Uploads data from a transfer buffer to a buffer. UploadToTexture Uploads data from a transfer buffer to a texture."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#Equal","title":"Equal(TSdlGpuCopyPass, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGpuCopyPass; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuCopyPass</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlGpuCopyPass; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#returns_1","title":"Returns","text":"<p><code>TSdlGpuCopyPass</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#NotEqual","title":"NotEqual(TSdlGpuCopyPass, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGpuCopyPass; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuCopyPass</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#CopyBufferToBuffer","title":"CopyBufferToBuffer(TSdlGpuBufferLocation, TSdlGpuBufferLocation, Integer, Boolean)","text":"<p>Performs a buffer-to-buffer copy.</p> <p>This copy occurs on the GPU timeline. You may assume the copy has finished in subsequent commands. </p> <p><code>procedure CopyBufferToBuffer(const ASource, ADestination: TSdlGpuBufferLocation; const ASize: Integer; const ACycle: Boolean); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#parameters_3","title":"Parameters","text":"<p><code>ASource</code>: <code>TSdlGpuBufferLocation</code> : The buffer and offset to copy from.</p> <p><code>ADestination</code>: <code>TSdlGpuBufferLocation</code> : The buffer and offset to copy to.</p> <p><code>ASize</code>: <code>Integer</code> : The length of the buffer to copy.</p> <p><code>ACycle</code>: <code>Boolean</code> : If True, cycles the destination buffer if it is already bound, otherwise overwrites the data.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#remarks","title":"Remarks","text":"<p>This function is available since SDL 3.2.0. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#CopyTextureToTexture","title":"CopyTextureToTexture(TSdlGpuTextureLocation, TSdlGpuTextureLocation, Integer, Integer, Integer, Boolean)","text":"<p>Performs a texture-to-texture copy.</p> <p>This copy occurs on the GPU timeline. You may assume the copy has finished in subsequent commands. </p> <p><code>procedure CopyTextureToTexture(const ASource, ADestination: TSdlGpuTextureLocation; const AW, AH, AD: Integer; const ACycle: Boolean); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#parameters_4","title":"Parameters","text":"<p><code>ASource</code>: <code>TSdlGpuTextureLocation</code> : A source texture region.</p> <p><code>ADestination</code>: <code>TSdlGpuTextureLocation</code> : A destination texture region.</p> <p><code>AW</code>: <code>Integer</code> : The width of the region to copy.</p> <p><code>AH</code>: <code>Integer</code> : The height of the region to copy.</p> <p><code>AD</code>: <code>Integer</code> : The depth of the region to copy.</p> <p><code>ACycle</code>: <code>Boolean</code> : If True, cycles the destination texture if the destination texture is bound, otherwise overwrites the data.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#DownloadFromBuffer","title":"DownloadFromBuffer(TSdlGpuBufferRegion, TSdlGpuTransferBufferLocation)","text":"<p>Copies data from a buffer to a transfer buffer on the GPU timeline.</p> <p>This data is not guaranteed to be copied until the command buffer fence is signaled. </p> <p><code>procedure DownloadFromBuffer(const ASource: TSdlGpuBufferRegion; const ADestination: TSdlGpuTransferBufferLocation); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#parameters_5","title":"Parameters","text":"<p><code>ASource</code>: <code>TSdlGpuBufferRegion</code> : The source buffer with offset and size.</p> <p><code>ADestination</code>: <code>TSdlGpuTransferBufferLocation</code> : The destination transfer buffer with offset.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#DownloadFromTexture","title":"DownloadFromTexture(TSdlGpuTextureRegion, TSdlGpuTextureTransferInfo)","text":"<p>Copies data from a texture to a transfer buffer on the GPU timeline.</p> <p>This data is not guaranteed to be copied until the command buffer fence is signaled. </p> <p><code>procedure DownloadFromTexture(const ASource: TSdlGpuTextureRegion; const ADestination: TSdlGpuTextureTransferInfo); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#parameters_6","title":"Parameters","text":"<p><code>ASource</code>: <code>TSdlGpuTextureRegion</code> : The source texture region.</p> <p><code>ADestination</code>: <code>TSdlGpuTextureTransferInfo</code> : The destination transfer buffer with image layout information.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#Finish","title":"Finish","text":"<p>Ends the current copy pass. </p> <p><code>procedure Finish; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#UploadToBuffer","title":"UploadToBuffer(TSdlGpuTransferBufferLocation, TSdlGpuBufferRegion, Boolean)","text":"<p>Uploads data from a transfer buffer to a buffer.</p> <p>The upload occurs on the GPU timeline. You may assume that the upload has finished in subsequent commands. </p> <p><code>procedure UploadToBuffer(const ASource: TSdlGpuTransferBufferLocation; const ADestination: TSdlGpuBufferRegion; const ACycle: Boolean); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#parameters_7","title":"Parameters","text":"<p><code>ASource</code>: <code>TSdlGpuTransferBufferLocation</code> : The source transfer buffer with offset.</p> <p><code>ADestination</code>: <code>TSdlGpuBufferRegion</code> : The destination buffer with offset and size.</p> <p><code>ACycle</code>: <code>Boolean</code> : If true, cycles the buffer if it is already bound, otherwise overwrites the data.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#UploadToTexture","title":"UploadToTexture(TSdlGpuTextureTransferInfo, TSdlGpuTextureRegion, Boolean)","text":"<p>Uploads data from a transfer buffer to a texture.</p> <p>The upload occurs on the GPU timeline. You may assume that the upload has finished in subsequent commands.</p> <p>You must align the data in the transfer buffer to a multiple of the texel size of the texture format. </p> <p><code>procedure UploadToTexture(const ASource: TSdlGpuTextureTransferInfo; const ADestination: TSdlGpuTextureRegion; const ACycle: Boolean); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuCopyPass/#parameters_8","title":"Parameters","text":"<p><code>ASource</code>: <code>TSdlGpuTextureTransferInfo</code> : The source transfer buffer with image layout information.</p> <p><code>ADestination</code>: <code>TSdlGpuTextureRegion</code> : The destination texture region.</p> <p><code>ACycle</code>: <code>Boolean</code> : If true, cycles the texture if the texture is bound, otherwise overwrites the data.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilState/","title":"TSdlGpuDepthStencilState","text":"<p>A record specifying the parameters of the graphics pipeline depth stencil state. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilState/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuDepthStencilState = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilState/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipelineCreateInfo</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilState/#properties","title":"Properties","text":"Name Description BackStencilState The stencil op state for back-facing triangles. CompareMask Selects the bits of the stencil values participating in the stencil test. CompareOp The comparison operator used for depth testing. DepthTestEnabled True enables the depth test. DepthWriteEnabled True enables depth writes. Depth writes are always disabled when this is false. FrontStencilState The stencil op state for front-facing triangles. StencilTestEnabled True enables the stencil test. WriteMask Selects the bits of the stencil values updated by the stencil test."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilState/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilState/#BackStencilState","title":"BackStencilState","text":"<p>The stencil op state for back-facing triangles. </p> <p><code>property BackStencilState: PSdlGpuStencilOpState read GetBackStencilState</code></p> <p>Type: <code>PSdlGpuStencilOpState</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilState/#CompareMask","title":"CompareMask","text":"<p>Selects the bits of the stencil values participating in the stencil test. </p> <p><code>property CompareMask: Byte read FHandle.compare_mask write FHandle.compare_mask</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilState/#CompareOp","title":"CompareOp","text":"<p>The comparison operator used for depth testing. </p> <p><code>property CompareOp: TSdlGpuCompareOp read GetCompareOp write SetCompareOp</code></p> <p>Type: <code>TSdlGpuCompareOp</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilState/#DepthTestEnabled","title":"DepthTestEnabled","text":"<p>True enables the depth test. </p> <p><code>property DepthTestEnabled: Boolean read FHandle.enable_depth_test write FHandle.enable_depth_test</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilState/#DepthWriteEnabled","title":"DepthWriteEnabled","text":"<p>True enables depth writes. Depth writes are always disabled when this is false. </p> <p><code>property DepthWriteEnabled: Boolean read FHandle.enable_depth_write write FHandle.enable_depth_write</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilState/#FrontStencilState","title":"FrontStencilState","text":"<p>The stencil op state for front-facing triangles. </p> <p><code>property FrontStencilState: PSdlGpuStencilOpState read GetFrontStencilState</code></p> <p>Type: <code>PSdlGpuStencilOpState</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilState/#StencilTestEnabled","title":"StencilTestEnabled","text":"<p>True enables the stencil test. </p> <p><code>property StencilTestEnabled: Boolean read FHandle.enable_stencil_test write FHandle.enable_stencil_test</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilState/#WriteMask","title":"WriteMask","text":"<p>Selects the bits of the stencil values updated by the stencil test. </p> <p><code>property WriteMask: Byte read FHandle.write_mask write FHandle.write_mask</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilTargetInfo/","title":"TSdlGpuDepthStencilTargetInfo","text":"<p>A structure specifying the parameters of a depth-stencil target used by a render pass.</p> <p>The LoadOp field determines what is done with the depth contents of the texture at the beginning of the render pass.</p> <ul> <li>Load: Loads the depth values currently in the texture.</li> <li>Clear: Clears the texture to a single depth.</li> <li>DontCare: The driver will do whatever it wants with the memory. This is a good option if you know that every single pixel will be touched in the render pass.</li> </ul> <p>The StoreOp field determines what is done with the depth results of the render pass.</p> <ul> <li>Store: Stores the depth results in the texture.</li> <li>DontCare: The driver will do whatever it wants with the depth results. This is often a good option for depth/stencil textures that don't need to be reused again.</li> </ul> <p>The StencilLoadOp field determines what is done with the stencil contents of the texture at the beginning of the render pass.</p> <ul> <li>Load: Loads the stencil values currently in the texture.</li> <li>Clear: Clears the stencil values to a single value.</li> <li>DontCare: The driver will do whatever it wants with the memory. This is a good option if you know that every single pixel will be touched in the render pass.</li> </ul> <p>The StencilStoreOp field determines what is done with the stencil results of the render pass.</p> <ul> <li>Store: Stores the stencil results in the texture.</li> <li>DontCare: The driver will do whatever it wants with the stencil results. This is often a good option for depth/stencil textures that don't need to be reused again.</li> </ul> <p>Note that depth/stencil targets do not support multisample resolves. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilTargetInfo/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuDepthStencilTargetInfo = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilTargetInfo/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.BeginRenderPass</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilTargetInfo/#properties","title":"Properties","text":"Name Description ClearDepth The value to clear the depth component to at the beginning of the render pass. Ignored if TSdlGpuLoadOp.Clear is not used. ClearStencil The value to clear the stencil component to at the beginning of the render pass. Ignored if TSdlGpuLoadOp.Clear is not used. Cycle True cycles the texture if the texture is bound and any load ops are not Load. LoadOp What is done with the depth contents at the beginning of the render pass. StencilLoadOp What is done with the stencil contents at the beginning of the render pass. StencilStoreOp What is done with the stencil results of the render pass. StoreOp What is done with the depth results of the render pass. Texture The texture that will be used as the depth stencil target by the render pass."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilTargetInfo/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilTargetInfo/#ClearDepth","title":"ClearDepth","text":"<p>The value to clear the depth component to at the beginning of the render pass. Ignored if TSdlGpuLoadOp.Clear is not used. </p> <p><code>property ClearDepth: Single read FHandle.clear_depth write FHandle.clear_depth</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilTargetInfo/#ClearStencil","title":"ClearStencil","text":"<p>The value to clear the stencil component to at the beginning of the render pass. Ignored if TSdlGpuLoadOp.Clear is not used. </p> <p><code>property ClearStencil: Byte read FHandle.clear_stencil write FHandle.clear_stencil</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilTargetInfo/#Cycle","title":"Cycle","text":"<p>True cycles the texture if the texture is bound and any load ops are not Load. </p> <p><code>property Cycle: Boolean read FHandle.cycle write FHandle.cycle</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilTargetInfo/#LoadOp","title":"LoadOp","text":"<p>What is done with the depth contents at the beginning of the render pass. </p> <p><code>property LoadOp: TSdlGpuLoadOp read GetLoadOp write SetLoadOp</code></p> <p>Type: <code>TSdlGpuLoadOp</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilTargetInfo/#StencilLoadOp","title":"StencilLoadOp","text":"<p>What is done with the stencil contents at the beginning of the render pass. </p> <p><code>property StencilLoadOp: TSdlGpuLoadOp read GetStencilLoadOp write SetStencilLoadOp</code></p> <p>Type: <code>TSdlGpuLoadOp</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilTargetInfo/#StencilStoreOp","title":"StencilStoreOp","text":"<p>What is done with the stencil results of the render pass. </p> <p><code>property StencilStoreOp: TSdlGpuStoreOp read GetStencilStoreOp write SetStencilStoreOp</code></p> <p>Type: <code>TSdlGpuStoreOp</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilTargetInfo/#StoreOp","title":"StoreOp","text":"<p>What is done with the depth results of the render pass. </p> <p><code>property StoreOp: TSdlGpuStoreOp read GetStoreOp write SetStoreOp</code></p> <p>Type: <code>TSdlGpuStoreOp</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDepthStencilTargetInfo/#Texture","title":"Texture","text":"<p>The texture that will be used as the depth stencil target by the render pass. </p> <p><code>property Texture: TSdlGpuTexture read GetTexture write SetTexture</code></p> <p>Type: <code>TSdlGpuTexture</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/","title":"TSdlGpuDevice","text":"<p>The SDL_GPU context. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuDevice = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#properties","title":"Properties","text":"Name Description Driver The backend driver used to create this GPU context. Formats The supported shader formats for this GPU context."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#constructors","title":"Constructors","text":"Name Description Create(TSdlProperties) Creates a GPU context. Create(TSdlGpuShaderFormats, TSdlGpuDriver, Boolean) Creates a GPU context. Create(TSdlGpuShaderFormats, Boolean) Creates a GPU context."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#methods","title":"Methods","text":"Name Description AcquireCommandBuffer Acquire a command buffer. ClaimWindow Claims a window, creating a swapchain structure for it. CreateBuffer Creates a buffer object to be used in graphics or compute workflows. CreateComputePipeline Creates a pipeline object to be used in a compute workflow. CreateGraphicsPipeline Creates a pipeline object to be used in a graphics workflow. CreateSampler Creates a sampler object to be used when binding textures in a graphics workflow. CreateShader Creates a shader to be used when creating a graphics pipeline. CreateTexture Creates a texture object to be used in graphics or compute workflows. CreateTransferBuffer Creates a transfer buffer to be used when uploading to or downloading from graphics resources. Free Destroys the GPU context. GetSwapchainTextureFormat Obtains the texture format of the swapchain for the given window. MapTransferBuffer Maps a transfer buffer into application address space. QueryFence Checks the status of a fence. ReleaseBuffer Frees the given buffer as soon as it is safe to do so. ReleaseComputePipeline Frees the given compute pipeline as soon as it is safe to do so. ReleaseFence Releases a fence obtained from TSdlGpuCommandBuffer.SubmitAndAcquireFence. ReleaseGraphicsPipeline Frees the given graphics pipeline as soon as it is safe to do so. ReleaseSampler Frees the given sampler as soon as it is safe to do so. ReleaseShader Frees the given shader as soon as it is safe to do so. ReleaseTexture Frees the given texture as soon as it is safe to do so. ReleaseTransferBuffer Frees the given transfer buffer as soon as it is safe to do so. ReleaseWindow Unclaims a window, destroying its swapchain structure. SetAllowedFramesInFlight Configures the maximum allowed number of frames in flight. SetBufferName Sets an arbitrary string constant to label a buffer. SetSwapchainParameters Changes the swapchain parameters for the given claimed window. SetTextureName Sets an arbitrary string constant to label a texture. TextureSupportsFormat Determines whether a texture format is supported for a given type and usage. TextureSupportsSampleCount Determines if a sample count for a texture format is supported. UnmapTransferBuffer Unmaps a previously mapped transfer buffer. WaitForFences Blocks the thread until the given fences are signaled. WaitForIdle Blocks the thread until the GPU is completely idle. WaitForSwapchain Blocks the thread until a swapchain texture is available to be acquired. WindowSupportsPresentMode Determines whether a presentation mode is supported by the window. WindowSupportsSwapchainComposition Determines whether a swapchain composition is supported by the window."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#Driver","title":"Driver","text":"<p>The backend driver used to create this GPU context. </p> <p><code>property Driver: TSdlGpuDriver read GetDriver</code></p> <p>Type: <code>TSdlGpuDriver</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#Formats","title":"Formats","text":"<p>The supported shader formats for this GPU context. </p> <p><code>property Formats: TSdlGpuShaderFormats read GetFormats</code></p> <p>Type: <code>TSdlGpuShaderFormats</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#Create_0","title":"<code>Create</code>","text":"<p>Creates a GPU context.</p> <p>These are the supported properties:</p> <ul> <li><code>TSdlProperty.GpuDeviceCreateDebugMode</code>: enable debug mode properties and validations, defaults to True.</li> <li><code>TSdlProperty.GpuDeviceCreatePreferLowPower</code>: enable to prefer energy efficiency over maximum GPU performance, defaults to False.</li> <li><code>TSdlProperty.GpuDeviceCreateName</code>: the name of the GPU driver to use, if a specific one is desired.</li> </ul> <p>These are the current shader format properties:</p> <ul> <li><code>TSdlProperty.GpuDeviceCreateShadersPrivate</code>: The app is able to provide shaders for an NDA platform.</li> <li><code>TSdlProperty.GpuDeviceCreateShadersSpirV</code>: The app is able to provide SPIR-V shaders if applicable.</li> <li><code>TSdlProperty.GpuDeviceCreateShadersDxbc</code>: The app is able to provide DXBC shaders if applicable</li> <li><code>TSdlProperty.GpuDeviceCreateShadersDxil</code>: The app is able to provide DXIL shaders if applicable.</li> <li><code>TSdlProperty.GpuDeviceCreateShadersMsl</code>: The app is able to provide MSL shaders if applicable.</li> <li><code>TSdlProperty.GpuDeviceCreateShadersMetalLib</code>: The app is able to provide Metal shader libraries if applicable.</li> </ul> <p>With the D3D12 renderer:</p> <ul> <li><code>TSdlProperty.GpuDeviceCreateD3D12SemanticName</code>: the prefix to use for all vertex semantics, default is 'TEXCOORD'. </li> </ul> <p><code>constructor Create(const AProps: TSdlProperties); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters","title":"Parameters","text":"<p><code>AProps</code>: <code>TSdlProperties</code> : The properties to use.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also","title":"See Also","text":"<ul> <li>Formats</li> <li>Driver</li> <li>TSdlGpuDriver.SupportsProperties</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#Create_1","title":"<code>Create</code>","text":"<p>Creates a GPU context. </p> <p><code>constructor Create(const AFormats: TSdlGpuShaderFormats; const ADriver: TSdlGpuDriver; const ADebugMode: Boolean = False{$ENDIF}); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_1","title":"Parameters","text":"<p><code>AFormats</code>: <code>TSdlGpuShaderFormats</code> : Which shader formats the app is able to provide.</p> <p><code>ADriver</code>: <code>TSdlGpuDriver</code> : The preferred GPU driver to use.</p> <p><code>ADebugMode</code>: <code>Boolean = False{$ENDIF}</code> : (Optional) True to enable debug mode properties and validations. If not given, this will be True in when the app is compiled in DEBUG mode, or False otherwise</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_1","title":"See Also","text":"<ul> <li>Formats</li> <li>Driver</li> <li>TSdlGpuDriver.SupportsFormats</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#Create_2","title":"<code>Create</code>","text":"<p>Creates a GPU context. </p> <p><code>constructor Create(const AFormats: TSdlGpuShaderFormats; const ADebugMode: Boolean = False{$ENDIF}); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_2","title":"Parameters","text":"<p><code>AFormats</code>: <code>TSdlGpuShaderFormats</code> : Which shader formats the app is able to provide.</p> <p><code>ADebugMode</code>: <code>Boolean = False{$ENDIF}</code> : (Optional) True to enable debug mode properties and validations. If not given, this will be True in when the app is compiled in DEBUG mode, or False otherwise</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_2","title":"See Also","text":"<ul> <li>Formats</li> <li>Driver</li> <li>TSdlGpuDriver.SupportsFormats</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#Equal","title":"Equal(TSdlGpuDevice, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGpuDevice; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_3","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuDevice</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlGpuDevice; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_4","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_1","title":"Returns","text":"<p><code>TSdlGpuDevice</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#NotEqual","title":"NotEqual(TSdlGpuDevice, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGpuDevice; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_5","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuDevice</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#AcquireCommandBuffer","title":"AcquireCommandBuffer","text":"<p>Acquire a command buffer.</p> <p>This command buffer is managed by the implementation and should not be freed by the user. The command buffer may only be used on the thread it was acquired on. The command buffer should be submitted on the thread it was acquired on.</p> <p>It is valid to acquire multiple command buffers on the same thread at once. In fact a common design pattern is to acquire two command buffers per frame where one is dedicated to render and compute passes and the other is dedicated to copy passes and other preparatory work such as generating mipmaps. Interleaving commands between the two command buffers reduces the total amount of passes overall which improves rendering performance. </p> <p><code>function AcquireCommandBuffer: TSdlGpuCommandBuffer; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_3","title":"Returns","text":"<p><code>TSdlGpuCommandBuffer</code>: A command buffer.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_3","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.Submit</li> <li>TSdlGpuCommandBuffer.SubmitAndAcquireFence</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#ClaimWindow","title":"ClaimWindow(TSdlWindow)","text":"<p>Claims a window, creating a swapchain structure for it.</p> <p>This must be called before TSdlGpuCommandBuffer.AcquireSwapchainTexture is called using the window. You should only call this method from the thread that created the window.</p> <p>The swapchain will be created with TSdlGpuSwapchainComposition.Sdr and TSdlGpuPresentMode.VSync. If you want to have different swapchain parameters, you must call SetSwapchainParameters after claiming the window. </p> <p><code>procedure ClaimWindow(const AWindow: TSdlWindow); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_6","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : A TSdlWindow.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_4","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.WaitAndAcquireSwapchainTexture</li> <li>ReleaseWindow</li> <li>WindowSupportsPresentMode</li> <li>WindowSupportsSwapchainComposition</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#remarks","title":"Remarks","text":"<p>This method should only be called from the thread that created the window. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#CreateBuffer","title":"CreateBuffer(TSdlGpuBufferCreateInfo)","text":"<p>Creates a buffer object to be used in graphics or compute workflows.</p> <p>The contents of this buffer are undefined until data is written to the buffer.</p> <p>Note that certain combinations of usage flags are invalid. For example, a buffer cannot have both the Vertex and Index flags.</p> <p>For better understanding of underlying concepts and memory management with SDL GPU API, you may refer this blog post.</p> <p>There are optional properties that can be provided through <code>Props</code>. These are the supported properties:</p> <ul> <li><code>TSdlProperty.GpuBufferCreateName</code>: a name that can be displayed in debugging tools. </li> </ul> <p><code>function CreateBuffer(const ACreateInfo: TSdlGpuBufferCreateInfo): TSdlGpuBuffer; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_6","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_7","title":"Parameters","text":"<p><code>ACreateInfo</code>: <code>TSdlGpuBufferCreateInfo</code> : A record describing the state of the buffer to create.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_4","title":"Returns","text":"<p><code>TSdlGpuBuffer</code>: A buffer object.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_5","title":"See Also","text":"<ul> <li>TSdlGpuCopyPass.UploadToBuffer</li> <li>TSdlGpuCopyPass.DownloadFromBuffer</li> <li>TSdlGpuCopyPass.CopyBufferToBuffer</li> <li>TSdlGpuRenderPass.BindVertexBuffers</li> <li>TSdlGpuRenderPass.BindIndexBuffer</li> <li>TSdlGpuRenderPass.BindVertexStorageBuffers</li> <li>TSdlGpuRenderPass.BindFragmentStorageBuffers</li> <li>TSdlGpuRenderPass.DrawPrimitives</li> <li>TSdlGpuComputePass.BindStorageBuffers</li> <li>TSdlGpuComputePass.Dispatch</li> <li>ReleaseBuffer</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#CreateComputePipeline","title":"CreateComputePipeline(TSdlGpuComputePipelineCreateInfo)","text":"<p>Creates a pipeline object to be used in a compute workflow.</p> <p>Shader resource bindings must be authored to follow a particular order depending on the shader format.</p> <p>For SPIR-V shaders, use the following resource sets:</p> <ul> <li>0: Sampled textures, followed by read-only storage textures, followed by read-only storage buffers</li> <li>1: Read-write storage textures, followed by read-write storage buffers</li> <li>2: Uniform buffers</li> </ul> <p>For DXBC and DXIL shaders, use the following register order:</p> <ul> <li>(t[n], space0): Sampled textures, followed by read-only storage textures, followed by read-only storage buffers</li> <li>(u[n], space1): Read-write storage textures, followed by read-write storage buffers</li> <li>(b[n], space2): Uniform buffers</li> </ul> <p>For MSL/metallib, use the following order:</p> <ul> <li>[[buffer]]: Uniform buffers, followed by read-only storage buffers, followed by read-write storage buffers</li> <li>[[texture]]: Sampled textures, followed by read-only storage textures, followed by read-write storage textures</li> </ul> <p>There are optional properties that can be provided through <code>Props</code>. These are the supported properties:</p> <ul> <li><code>TSdlProperty.GpuComputePipelineCreateName</code>: a name that can be displayed in debugging tools. </li> </ul> <p><code>function CreateComputePipeline(const ACreateInfo: TSdlGpuComputePipelineCreateInfo): TSdlGpuComputePipeline; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_7","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_8","title":"Parameters","text":"<p><code>ACreateInfo</code>: <code>TSdlGpuComputePipelineCreateInfo</code> : A record describing the state of the compute pipeline to create.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_5","title":"Returns","text":"<p><code>TSdlGpuComputePipeline</code>: A compute pipeline object.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_6","title":"See Also","text":"<ul> <li>TSdlGpuComputePass.BindStorageBuffers</li> <li>ReleaseComputePipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#CreateGraphicsPipeline","title":"CreateGraphicsPipeline(TSdlGpuGraphicsPipelineCreateInfo)","text":"<p>Creates a pipeline object to be used in a graphics workflow.</p> <p>There are optional properties that can be provided through <code>Props</code>. These are the supported properties:</p> <ul> <li><code>TSdlProperty.GpuGraphicsPipelineCreateName</code>: a name that can be displayed in debugging tools. </li> </ul> <p><code>function CreateGraphicsPipeline(const ACreateInfo: TSdlGpuGraphicsPipelineCreateInfo): TSdlGpuGraphicsPipeline; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_8","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_9","title":"Parameters","text":"<p><code>ACreateInfo</code>: <code>TSdlGpuGraphicsPipelineCreateInfo</code> : A record describing the state of the graphics pipeline to create.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_6","title":"Returns","text":"<p><code>TSdlGpuGraphicsPipeline</code>: A graphics pipeline object.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_7","title":"See Also","text":"<ul> <li>TSdlGpuShader</li> <li>TSdlGpuRenderPass.BindPipeline</li> <li>ReleaseGraphicsPipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#CreateSampler","title":"CreateSampler(TSdlGpuSamplerCreateInfo)","text":"<p>Creates a sampler object to be used when binding textures in a graphics workflow.</p> <p>There are optional properties that can be provided through <code>Props</code>. These are the supported properties:</p> <ul> <li><code>TSdlProperty.GpuSamplerCreateName</code>: a name that can be displayed in debugging tools. </li> </ul> <p><code>function CreateSampler(const ACreateInfo: TSdlGpuSamplerCreateInfo): TSdlGpuSampler; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_9","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_10","title":"Parameters","text":"<p><code>ACreateInfo</code>: <code>TSdlGpuSamplerCreateInfo</code> : A record describing the state of the sampler to create.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_7","title":"Returns","text":"<p><code>TSdlGpuSampler</code>: A sampler object.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_8","title":"See Also","text":"<ul> <li>TSdlGpuRenderPass.BindVertexSamplers</li> <li>TSdlGpuRenderPass.BindFragmentSamplers</li> <li>ReleaseSampler</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#CreateShader","title":"CreateShader(TSdlGpuShaderCreateInfo)","text":"<p>Creates a shader to be used when creating a graphics pipeline.</p> <p>Shader resource bindings must be authored to follow a particular order depending on the shader format.</p> <p>For SPIR-V shaders, use the following resource sets:</p> <p>For vertex shaders:</p> <ul> <li>0: Sampled textures, followed by storage textures, followed by storage buffers</li> <li>1: Uniform buffers</li> </ul> <p>For fragment shaders:</p> <ul> <li>2: Sampled textures, followed by storage textures, followed by storage buffers</li> <li>3: Uniform buffers</li> </ul> <p>For DXBC and DXIL shaders, use the following register order:</p> <p>For vertex shaders:</p> <ul> <li>(t[n], space0): Sampled textures, followed by storage textures, followed by storage buffers</li> <li>(s[n], space0): Samplers with indices corresponding to the sampled textures</li> <li>(b[n], space1): Uniform buffers</li> </ul> <p>For pixel shaders:</p> <ul> <li>(t[n], space2): Sampled textures, followed by storage textures, followed by storage buffers</li> <li>(s[n], space2): Samplers with indices corresponding to the sampled textures</li> <li>(b[n], space3): Uniform buffers</li> </ul> <p>For MSL/metallib, use the following order:</p> <ul> <li>[[texture]]: Sampled textures, followed by storage textures</li> <li>[[sampler]]: Samplers with indices corresponding to the sampled textures</li> <li>[[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0 is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on. Rather than manually authoring vertex buffer indices, use the [[stage_in]] attribute which will automatically use the vertex input information from the SDL_GPUGraphicsPipeline.</li> </ul> <p>Shader semantics other than system-value semantics do not matter in D3D12 and for ease of use the SDL implementation assumes that non system-value semantics will all be TEXCOORD. If you are using HLSL as the shader source language, your vertex semantics should start at TEXCOORD0 and increment like so: TEXCOORD1, TEXCOORD2, etc. If you wish to change the semantic prefix to something other than TEXCOORD you can use TSdlProperty.GpuDeviceCreateD3D12SemanticName with TSdlGpuDevice.Create.</p> <p>There are optional properties that can be provided through <code>Props</code>. These are the supported properties:</p> <ul> <li><code>TSdlProperty.GpuShaderCreateName</code>: a name that can be displayed in debugging tools. </li> </ul> <p><code>function CreateShader(const ACreateInfo: TSdlGpuShaderCreateInfo): TSdlGpuShader; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_10","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_11","title":"Parameters","text":"<p><code>ACreateInfo</code>: <code>TSdlGpuShaderCreateInfo</code> : A record describing the state of the shader to create.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_8","title":"Returns","text":"<p><code>TSdlGpuShader</code>: A shader object.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_9","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipeline</li> <li>ReleaseShader</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#CreateTexture","title":"CreateTexture(TSdlGpuTextureCreateInfo)","text":"<p>Creates a texture object to be used in graphics or compute workflows.</p> <p>The contents of this texture are undefined until data is written to the texture.</p> <p>Note that certain combinations of usage flags are invalid. For example, a texture cannot have both the Sampler and GraphicsStorageRead flags.</p> <p>If you request a sample count higher than the hardware supports, the implementation will automatically fall back to the highest available sample count.</p> <p>There are optional properties that can be provided through TSdlGpuTextureCreateInfo's <code>Props</code>. These are the supported properties:</p> <ul> <li><code>TSdlProperty.GpuTextureCreateD3D12ClearR</code>: (Direct3D 12 only) if the texture usage is TSdlGpuTextureUsage.ColorTarget, clear the texture to a color with this red intensity. Defaults to zero.</li> <li><code>TSdlProperty.GpuTextureCreateD3D12ClearG</code>: (Direct3D 12 only) if the texture usage is TSdlGpuTextureUsage.ColorTarget, clear the texture to a color with this green intensity. Defaults to zero.</li> <li><code>TSdlProperty.GpuTextureCreateD3D12ClearB</code>: (Direct3D 12 only) if the texture usage is TSdlGpuTextureUsage.ColorTarget, clear the texture to a color with this blue intensity. Defaults to zero.</li> <li><code>TSdlProperty.GpuTextureCreateD3D12ClearA</code>: (Direct3D 12 only) if the texture usage is TSdlGpuTextureUsage.ColorTarget, clear the texture to a color with this alpha intensity. Defaults to zero.</li> <li><code>TSdlProperty.GpuTextureCreateD3D12ClearDepth</code>: (Direct3D 12 only) if the texture usage is TSdlGpuTextureUsage.DepthStencilTarget, clear the texture to a depth of this value. Defaults to zero.</li> <li><code>TSdlProperty.GpuTextureCreateD3D12ClearStencil</code>: (Direct3D 12 only) if the texture usage is TSdlGpuTextureUsage.DepthStencilTarget, clear the texture to a stencil of this value. Defaults to zero.</li> <li><code>TSdlProperty.GpuTextureCreateName</code>: a name that can be displayed in debugging tools. </li> </ul> <p><code>function CreateTexture(const ACreateInfo: TSdlGpuTextureCreateInfo): TSdlGpuTexture; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_11","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_12","title":"Parameters","text":"<p><code>ACreateInfo</code>: <code>TSdlGpuTextureCreateInfo</code> : A record describing the state of the texture to create.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_9","title":"Returns","text":"<p><code>TSdlGpuTexture</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_10","title":"See Also","text":"<ul> <li>TSdlGpuCopyPass.UploadToTexture</li> <li>TSdlGpuCopyPass.DownloadFromTexture</li> <li>TSdlGpuRenderPass.BindVertexSamplers</li> <li>TSdlGpuRenderPass.BindVertexStorageTextures</li> <li>TSdlGpuRenderPass.BindFragmentSamplers</li> <li>TSdlGpuRenderPass.BindFragmentStorageTextures</li> <li>TSdlGpuComputePass.BindStorageTextures</li> <li>TSdlGpuCommandBuffer.Blit</li> <li>ReleaseTexture</li> <li>TextureSupportsFormat</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#CreateTransferBuffer","title":"CreateTransferBuffer(TSdlGpuTransferBufferCreateInfo)","text":"<p>Creates a transfer buffer to be used when uploading to or downloading from graphics resources.</p> <p>Download buffers can be particularly expensive to create, so it is good practice to reuse them if data will be downloaded regularly.</p> <p>There are optional properties that can be provided through <code>Props</code>. These are the supported properties:</p> <ul> <li><code>TSdlProperty.GpuTransferBufferCreateName</code>: a name that can be displayed in debugging tools. </li> </ul> <p><code>function CreateTransferBuffer(const ACreateInfo: TSdlGpuTransferBufferCreateInfo): TSdlGpuTransferBuffer; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_12","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_13","title":"Parameters","text":"<p><code>ACreateInfo</code>: <code>TSdlGpuTransferBufferCreateInfo</code> : A record describing the state of the transfer buffer to create.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_10","title":"Returns","text":"<p><code>TSdlGpuTransferBuffer</code>: A transfer buffer.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_11","title":"See Also","text":"<ul> <li>TSdlGpuCopyPass.UploadToBuffer</li> <li>TSdlGpuCopyPass.DownloadFromBuffer</li> <li>TSdlGpuCopyPass.UploadToTexture</li> <li>TSdlGpuCopyPass.DownloadFromTexture</li> <li>ReleaseTransferBuffer</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#Free","title":"Free","text":"<p>Destroys the GPU context. </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#GetSwapchainTextureFormat","title":"GetSwapchainTextureFormat(TSdlWindow)","text":"<p>Obtains the texture format of the swapchain for the given window.</p> <p>Note that this format can change if the swapchain parameters change. </p> <p><code>function GetSwapchainTextureFormat(const AWindow: TSdlWindow): TSdlGpuTextureFormat; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_14","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : A TSdlWindow that has been claimed.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_11","title":"Returns","text":"<p><code>TSdlGpuTextureFormat</code>: The texture format of the swapchain.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#MapTransferBuffer","title":"MapTransferBuffer(TSdlGpuTransferBuffer, Boolean)","text":"<p>Maps a transfer buffer into application address space.</p> <p>You must unmap the transfer buffer before encoding upload commands. </p> <p><code>function MapTransferBuffer(const ATransferBuffer: TSdlGpuTransferBuffer; const ACycle: Boolean): Pointer; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_13","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_15","title":"Parameters","text":"<p><code>ATransferBuffer</code>: <code>TSdlGpuTransferBuffer</code> : A transfer buffer.</p> <p><code>ACycle</code>: <code>Boolean</code> : If True, cycles the transfer buffer if it is already bound.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_12","title":"Returns","text":"<p><code>Pointer</code>: The address of the mapped transfer buffer memory.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#QueryFence","title":"QueryFence(TSdlGpuFence)","text":"<p>Checks the status of a fence. </p> <p><code>function QueryFence(const AFence: TSdlGpuFence): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_16","title":"Parameters","text":"<p><code>AFence</code>: <code>TSdlGpuFence</code> : A fence.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_13","title":"Returns","text":"<p><code>Boolean</code>: True if the fence is signaled, False if it is not.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_12","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.SubmitAndAcquireFence</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#ReleaseBuffer","title":"ReleaseBuffer(TSdlGpuBuffer)","text":"<p>Frees the given buffer as soon as it is safe to do so.</p> <p>You must not reference the buffer after calling this method. </p> <p><code>procedure ReleaseBuffer(const ABuffer: TSdlGpuBuffer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_17","title":"Parameters","text":"<p><code>ABuffer</code>: <code>TSdlGpuBuffer</code> : A buffer to be destroyed.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#ReleaseComputePipeline","title":"ReleaseComputePipeline(TSdlGpuComputePipeline)","text":"<p>Frees the given compute pipeline as soon as it is safe to do so.</p> <p>You must not reference the compute pipeline after calling this method. </p> <p><code>procedure ReleaseComputePipeline(const AComputePipeline: TSdlGpuComputePipeline); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_18","title":"Parameters","text":"<p><code>AComputePipeline</code>: <code>TSdlGpuComputePipeline</code> : A compute pipeline to be destroyed.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#ReleaseFence","title":"ReleaseFence(TSdlGpuFence)","text":"<p>Releases a fence obtained from TSdlGpuCommandBuffer.SubmitAndAcquireFence. </p> <p><code>procedure ReleaseFence(const AFence: TSdlGpuFence); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_19","title":"Parameters","text":"<p><code>AFence</code>: <code>TSdlGpuFence</code> : A fence.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_13","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.SubmitAndAcquireFence</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#ReleaseGraphicsPipeline","title":"ReleaseGraphicsPipeline(TSdlGpuGraphicsPipeline)","text":"<p>Frees the given graphics pipeline as soon as it is safe to do so.</p> <p>You must not reference the graphics pipeline after calling this method. </p> <p><code>procedure ReleaseGraphicsPipeline(const AGraphicsPipeline: TSdlGpuGraphicsPipeline); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_20","title":"Parameters","text":"<p><code>AGraphicsPipeline</code>: <code>TSdlGpuGraphicsPipeline</code> : a graphics pipeline to be destroyed.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#ReleaseSampler","title":"ReleaseSampler(TSdlGpuSampler)","text":"<p>Frees the given sampler as soon as it is safe to do so.</p> <p>You must not reference the sampler after calling this method. </p> <p><code>procedure ReleaseSampler(const ASampler: TSdlGpuSampler); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_21","title":"Parameters","text":"<p><code>ASampler</code>: <code>TSdlGpuSampler</code> : A sampler to be destroyed.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#ReleaseShader","title":"ReleaseShader(TSdlGpuShader)","text":"<p>Frees the given shader as soon as it is safe to do so.</p> <p>You must not reference the shader after calling this method. </p> <p><code>procedure ReleaseShader(const AShader: TSdlGpuShader); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_22","title":"Parameters","text":"<p><code>AShader</code>: <code>TSdlGpuShader</code> : A shader to be destroyed.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#ReleaseTexture","title":"ReleaseTexture(TSdlGpuTexture)","text":"<p>Frees the given texture as soon as it is safe to do so.</p> <p>You must not reference the texture after calling this method. </p> <p><code>procedure ReleaseTexture(const ATexture: TSdlGpuTexture); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_23","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlGpuTexture</code> : A texture to be destroyed.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#ReleaseTransferBuffer","title":"ReleaseTransferBuffer(TSdlGpuTransferBuffer)","text":"<p>Frees the given transfer buffer as soon as it is safe to do so.</p> <p>You must not reference the transfer buffer after calling this methpd. </p> <p><code>procedure ReleaseTransferBuffer(const ATransferBuffer: TSdlGpuTransferBuffer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_24","title":"Parameters","text":"<p><code>ATransferBuffer</code>: <code>TSdlGpuTransferBuffer</code> : a transfer buffer to be destroyed.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#ReleaseWindow","title":"ReleaseWindow(TSdlWindow)","text":"<p>Unclaims a window, destroying its swapchain structure. </p> <p><code>procedure ReleaseWindow(const AWindow: TSdlWindow); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_25","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : A TSdlWindow that has been claimed.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_14","title":"See Also","text":"<ul> <li>ClaimWindow</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#SetAllowedFramesInFlight","title":"SetAllowedFramesInFlight(Integer)","text":"<p>Configures the maximum allowed number of frames in flight.</p> <p>The default value when the device is created is 2. This means that after you have submitted 2 frames for presentation, if the GPU has not finished working on the first frame, TSdlGpuCommandBuffer.AcquireSwapchainTexture will fill the swapchain texture pointer with nil, and TSdlGpuCommandBuffer.WaitAndAcquireSwapchainTexture will block.</p> <p>Higher values increase throughput at the expense of visual latency. Lower values decrease visual latency at the expense of throughput.</p> <p>Note that calling this function will stall and flush the command queue to prevent synchronization issues.</p> <p>The minimum value of allowed frames in flight is 1, and the maximum is 3. </p> <p><code>procedure SetAllowedFramesInFlight(const AAllowedFramesInFlight: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_14","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_26","title":"Parameters","text":"<p><code>AAllowedFramesInFlight</code>: <code>Integer</code> : The maximum number of frames that can be pending on the GPU.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#SetBufferName","title":"SetBufferName(TSdlGpuBuffer, String)","text":"<p>Sets an arbitrary string constant to label a buffer.</p> <p>You should use TSdlProperty.GpuBufferCreateName with CreateBuffer instead of this method to avoid thread safety issues. </p> <p><code>procedure SetBufferName(const ABuffer: TSdlGpuBuffer; const AName: String); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_27","title":"Parameters","text":"<p><code>ABuffer</code>: <code>TSdlGpuBuffer</code> : A buffer to attach the name to.</p> <p><code>AName</code>: <code>String</code> : A string constant to mark as the name of the buffer.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_15","title":"See Also","text":"<ul> <li>CreateBuffer</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#remarks_1","title":"Remarks","text":"<p>This method is not thread safe, you must make sure the buffer is not simultaneously used by any other thread. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#SetSwapchainParameters","title":"SetSwapchainParameters(TSdlWindow, TSdlGpuSwapchainComposition, TSdlGpuPresentMode)","text":"<p>Changes the swapchain parameters for the given claimed window.</p> <p>This method will fail if the requested present mode or swapchain composition are unsupported by the device. Check if the parameters are supported via WindowSupportsPresentMode / WindowSupportsSwapchainComposition prior to calling this method.</p> <p>TSdlGpuPresentMode.VSync and TSdlGpuSwapchainComposition.Sdr are always supported. </p> <p><code>procedure SetSwapchainParameters(const AWindow: TSdlWindow; const ASwapchainComposition: TSdlGpuSwapchainComposition; const APresentMode: TSdlGpuPresentMode); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_15","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_28","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : A TSdlWindow that has been claimed.</p> <p><code>ASwapchainComposition</code>: <code>TSdlGpuSwapchainComposition</code> : The desired composition of the swapchain.</p> <p><code>APresentMode</code>: <code>TSdlGpuPresentMode</code> : The desired present mode for the swapchain.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_16","title":"See Also","text":"<ul> <li>WindowSupportsPresentMode</li> <li>WindowSupportsSwapchainComposition</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#SetTextureName","title":"SetTextureName(TSdlGpuTexture, String)","text":"<p>Sets an arbitrary string constant to label a texture.</p> <p>You should use TSdlProperty.GpuTextureCreateName with CreateTexture instead of this method to avoid thread safety issues. </p> <p><code>procedure SetTextureName(const ATexture: TSdlGpuTexture; const AName: String); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_29","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlGpuTexture</code> : A texture to attach the name to.</p> <p><code>AName</code>: <code>String</code> : A string constant to mark as the name of the texture.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_17","title":"See Also","text":"<ul> <li>CreateTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#remarks_2","title":"Remarks","text":"<p>This method is not thread safe, you must make sure the texture is not simultaneously used by any other thread. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#TextureSupportsFormat","title":"TextureSupportsFormat(TSdlGpuTextureFormat, TSdlGpuTextureKind, TSdlGpuTextureUsageFlags)","text":"<p>Determines whether a texture format is supported for a given type and usage. </p> <p><code>function TextureSupportsFormat(const AFormat: TSdlGpuTextureFormat; const AKind: TSdlGpuTextureKind; const AUsages: TSdlGpuTextureUsageFlags): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_30","title":"Parameters","text":"<p><code>AFormat</code>: <code>TSdlGpuTextureFormat</code> : The texture format to check.</p> <p><code>AKind</code>: <code>TSdlGpuTextureKind</code> : The type of texture (2D, 3D, Cube).</p> <p><code>AUsages</code>: <code>TSdlGpuTextureUsageFlags</code> : The usage scenarios to check.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_14","title":"Returns","text":"<p><code>Boolean</code>: Whether the texture format is supported for this type and usage.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#TextureSupportsSampleCount","title":"TextureSupportsSampleCount(TSdlGpuTextureFormat, TSdlGpuSampleCount)","text":"<p>Determines if a sample count for a texture format is supported. </p> <p><code>function TextureSupportsSampleCount(const AFormat: TSdlGpuTextureFormat; const ASampleCount: TSdlGpuSampleCount): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_31","title":"Parameters","text":"<p><code>AFormat</code>: <code>TSdlGpuTextureFormat</code> : The texture format to check.</p> <p><code>ASampleCount</code>: <code>TSdlGpuSampleCount</code> : The sample count to check.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_15","title":"Returns","text":"<p><code>Boolean</code>: A hardware-specific version of min(preferred, possible).</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#UnmapTransferBuffer","title":"UnmapTransferBuffer(TSdlGpuTransferBuffer)","text":"<p>Unmaps a previously mapped transfer buffer. </p> <p><code>procedure UnmapTransferBuffer(const ATransferBuffer: TSdlGpuTransferBuffer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_32","title":"Parameters","text":"<p><code>ATransferBuffer</code>: <code>TSdlGpuTransferBuffer</code> : A previously mapped transfer buffer.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#WaitForFences","title":"WaitForFences(Boolean, TArray&lt;TSdlGpuFence&gt;)","text":"<p>Blocks the thread until the given fences are signaled. </p> <p><code>procedure WaitForFences(const AWaitAll: Boolean; const AFences: TArray&lt;TSdlGpuFence&gt;); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_16","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_33","title":"Parameters","text":"<p><code>AWaitAll</code>: <code>Boolean</code> : If False, wait for any fence to be signaled, if True, wait for all fences to be signaled.</p> <p><code>AFences</code>: <code>TArray&lt;TSdlGpuFence&gt;</code> : An array of fences to wait on.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_18","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.SubmitAndAcquireFence</li> <li>WaitForIdle</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#WaitForIdle","title":"WaitForIdle","text":"<p>Blocks the thread until the GPU is completely idle. </p> <p><code>procedure WaitForIdle; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_17","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_19","title":"See Also","text":"<ul> <li>WaitForFences</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#WaitForSwapchain","title":"WaitForSwapchain(TSdlWindow)","text":"<p>Blocks the thread until a swapchain texture is available to be acquired. </p> <p><code>procedure WaitForSwapchain(const AWindow: TSdlWindow); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#exceptions_18","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_34","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : A window that has been claimed.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_20","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.AcquireSwapchainTexture</li> <li>TSdlGpuCommandBuffer.WaitAndAcquireSwapchainTexture</li> <li>SetAllowedFramesInFlight</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#remarks_3","title":"Remarks","text":"<p>This method should only be called from the thread that created the window. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#WindowSupportsPresentMode","title":"WindowSupportsPresentMode(TSdlWindow, TSdlGpuPresentMode)","text":"<p>Determines whether a presentation mode is supported by the window.</p> <p>The window must be claimed before calling this function. </p> <p><code>function WindowSupportsPresentMode(const AWindow: TSdlWindow; const APresentMode: TSdlGpuPresentMode): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_35","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : A TSdlWindow.</p> <p><code>APresentMode</code>: <code>TSdlGpuPresentMode</code> : The presentation mode to check.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_16","title":"Returns","text":"<p><code>Boolean</code>: True if supported, False if unsupported.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_21","title":"See Also","text":"<ul> <li>ClaimWindow</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#WindowSupportsSwapchainComposition","title":"WindowSupportsSwapchainComposition(TSdlWindow, TSdlGpuSwapchainComposition)","text":"<p>Determines whether a swapchain composition is supported by the window.</p> <p>The window must be claimed before calling this method. </p> <p><code>function WindowSupportsSwapchainComposition(const AWindow: TSdlWindow; const ASwapchainComposition: TSdlGpuSwapchainComposition): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#parameters_36","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : A TSdlWindow.</p> <p><code>ASwapchainComposition</code>: <code>TSdlGpuSwapchainComposition</code> : The swapchain composition to check.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#returns_17","title":"Returns","text":"<p><code>Boolean</code>: True if supported, False if unsupported.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDevice/#see-also_22","title":"See Also","text":"<ul> <li>ClaimWindow</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/","title":"TSdlGpuDriver","text":"<p>A GPU driver compiled into SDL. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuDriver = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#properties","title":"Properties","text":"Name Description Count The number of GPU drivers compiled into SDL. Default The default GPU driver. This driver does not have a name. Drivers The GPU drivers compiled into SDL. Name Get the name of a built in GPU driver."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#methods","title":"Methods","text":"Name Description CreateDevice Creates a GPU context. SupportsFormats Checks for GPU runtime support. SupportsProperties Checks for GPU runtime support."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#Count","title":"Count","text":"<p>The number of GPU drivers compiled into SDL. </p> <p><code>class property Count: Integer read GetCount</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#see-also","title":"See Also","text":"<ul> <li>Drivers</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#Default","title":"Default","text":"<p>The default GPU driver. This driver does not have a name. </p> <p><code>class property Default: TSdlGpuDriver read GetDefault</code></p> <p>Type: <code>TSdlGpuDriver</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#Drivers","title":"Drivers","text":"<p>The GPU drivers compiled into SDL. </p> <p><code>class property Drivers[const AIndex: Integer]: TSdlGpuDriver read GetDriver; default</code></p> <p>Type: <code>TSdlGpuDriver</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#see-also_1","title":"See Also","text":"<ul> <li>Count</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#Name","title":"Name","text":"<p>Get the name of a built in GPU driver.</p> <p>The GPU drivers are presented in the order in which they are normally checked during initialization.</p> <p>The names of drivers are all simple, low-ASCII identifiers, like \"vulkan\", \"metal\" or \"direct3d12\". These never have Unicode characters, and are not meant to be proper names.</p> <p>Note that the default driver (Default) does not have a name. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#see-also_2","title":"See Also","text":"<ul> <li>Default</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#CreateDevice","title":"CreateDevice(TSdlGpuShaderFormats, Boolean)","text":"<p>Creates a GPU context. </p> <p><code>function CreateDevice(const AFormats: TSdlGpuShaderFormats; const ADebugMode: Boolean = False{$ENDIF}): TSdlGpuDevice</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#parameters","title":"Parameters","text":"<p><code>AFormats</code>: <code>TSdlGpuShaderFormats</code> : Which shader formats the app is able to provide.</p> <p><code>ADebugMode</code>: <code>Boolean = False{$ENDIF}</code> : (Optional) True to enable debug mode properties and validations. If not given, this will be True in when the app is compiled in DEBUG mode, or False otherwise</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#returns","title":"Returns","text":"<p><code>TSdlGpuDevice</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#see-also_3","title":"See Also","text":"<ul> <li>TSdlGpuDevice.Formats</li> <li>TSdlGpuDevice.Driver</li> <li>TSdlGpuDriver.SupportsFormats</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#SupportsFormats","title":"SupportsFormats(TSdlGpuShaderFormats)","text":"<p>Checks for GPU runtime support. </p> <p><code>function SupportsFormats(const AFormats: TSdlGpuShaderFormats): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#parameters_1","title":"Parameters","text":"<p><code>AFormats</code>: <code>TSdlGpuShaderFormats</code> : Which shader formats the app is able to provide.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#returns_1","title":"Returns","text":"<p><code>Boolean</code>: True if supported, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#see-also_4","title":"See Also","text":"<ul> <li>TSdlGpuDevice</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#SupportsProperties","title":"SupportsProperties(TSdlProperties)","text":"<p>Checks for GPU runtime support. </p> <p><code>class function SupportsProperties(const AProps: TSdlProperties): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#parameters_2","title":"Parameters","text":"<p><code>AProps</code>: <code>TSdlProperties</code> : The properties to use.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#returns_2","title":"Returns","text":"<p><code>Boolean</code>: True if supported, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuDriver/#see-also_5","title":"See Also","text":"<ul> <li>TSdlGpuDevice</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuFence/","title":"TSdlGpuFence","text":"<p>A fence. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuFence/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuFence = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuFence/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.SubmitAndAcquireFence</li> <li>TSdlGpuDevice.QueryFence</li> <li>TSdlGpuDevice.WaitForFences</li> <li>TSdlGpuDevice.ReleaseFence</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuFence/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuFence/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuFence/#Equal","title":"Equal(TSdlGpuFence, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGpuFence; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuFence/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuFence</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuFence/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuFence/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlGpuFence; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuFence/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuFence/#returns_1","title":"Returns","text":"<p><code>TSdlGpuFence</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuFence/#NotEqual","title":"NotEqual(TSdlGpuFence, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGpuFence; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuFence/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuFence</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuFence/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipeline/","title":"TSdlGpuGraphicsPipeline","text":"<p>A graphics pipeline. Used during render passes. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipeline/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuGraphicsPipeline = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipeline/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuRenderPass.BindPipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipeline/#remarks","title":"Remarks","text":"<p>This struct is available since SDL 3.2.0. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipeline/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipeline/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipeline/#Equal","title":"Equal(TSdlGpuGraphicsPipeline, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGpuGraphicsPipeline; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipeline/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuGraphicsPipeline</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipeline/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipeline/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlGpuGraphicsPipeline; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipeline/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipeline/#returns_1","title":"Returns","text":"<p><code>TSdlGpuGraphicsPipeline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipeline/#NotEqual","title":"NotEqual(TSdlGpuGraphicsPipeline, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGpuGraphicsPipeline; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipeline/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuGraphicsPipeline</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipeline/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/","title":"TSdlGpuGraphicsPipelineCreateInfo","text":"<p>A record specifying the parameters of a graphics pipeline state. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuGraphicsPipelineCreateInfo = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipeline</li> <li>TSdlGpuVertexInputState</li> <li>TSdlGpuPrimitiveType</li> <li>TSdlGpuRasterizerState</li> <li>TSdlGpuMultisampleState</li> <li>TSdlGpuDepthStencilState</li> <li>TSdlGpuGraphicsPipelineTargetInfo</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#properties","title":"Properties","text":"Name Description DepthStencilState The depth-stencil state of the graphics pipeline. FragmentShader The fragment shader used by the graphics pipeline. MultisampleState The multisample state of the graphics pipeline. PrimitiveType The primitive topology of the graphics pipeline. Props A properties ID for extensions. Should be nil if no extensions are needed. RasterizerState The rasterizer state of the graphics pipeline. TargetInfo Formats and blend modes for the render targets of the graphics pipeline. VertexInputState The vertex layout of the graphics pipeline. VertexShader The vertex shader used by the graphics pipeline."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#methods","title":"Methods","text":"Name Description Create Create with default values. Init Init with default values."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#DepthStencilState","title":"DepthStencilState","text":"<p>The depth-stencil state of the graphics pipeline. </p> <p><code>property DepthStencilState: PSdlGpuDepthStencilState read GetDepthStencilState</code></p> <p>Type: <code>PSdlGpuDepthStencilState</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#FragmentShader","title":"FragmentShader","text":"<p>The fragment shader used by the graphics pipeline. </p> <p><code>property FragmentShader: TSdlGpuShader read GetFragmentShader write SetFragmentShader</code></p> <p>Type: <code>TSdlGpuShader</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#MultisampleState","title":"MultisampleState","text":"<p>The multisample state of the graphics pipeline. </p> <p><code>property MultisampleState: PSdlGpuMultisampleState read GetMultisampleState</code></p> <p>Type: <code>PSdlGpuMultisampleState</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#PrimitiveType","title":"PrimitiveType","text":"<p>The primitive topology of the graphics pipeline. </p> <p><code>property PrimitiveType: TSdlGpuPrimitiveType read GetPrimitiveType write SetPrimitiveType</code></p> <p>Type: <code>TSdlGpuPrimitiveType</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#Props","title":"Props","text":"<p>A properties ID for extensions. Should be nil if no extensions are needed. </p> <p><code>property Props: TSdlProperties read GetProps write SetProps</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#RasterizerState","title":"RasterizerState","text":"<p>The rasterizer state of the graphics pipeline. </p> <p><code>property RasterizerState: PSdlGpuRasterizerState read GetRasterizerState</code></p> <p>Type: <code>PSdlGpuRasterizerState</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#TargetInfo","title":"TargetInfo","text":"<p>Formats and blend modes for the render targets of the graphics pipeline. </p> <p><code>property TargetInfo: TSdlGpuGraphicsPipelineTargetInfo read GetTargetInfo write SetTargetInfo</code></p> <p>Type: <code>TSdlGpuGraphicsPipelineTargetInfo</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#VertexInputState","title":"VertexInputState","text":"<p>The vertex layout of the graphics pipeline. </p> <p><code>property VertexInputState: TSdlGpuVertexInputState read GetVertexInputState write SetVertexInputState</code></p> <p>Type: <code>TSdlGpuVertexInputState</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#VertexShader","title":"VertexShader","text":"<p>The vertex shader used by the graphics pipeline. </p> <p><code>property VertexShader: TSdlGpuShader read GetVertexShader write SetVertexShader</code></p> <p>Type: <code>TSdlGpuShader</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#Create","title":"Create","text":"<p>Create with default values. </p> <p><code>class function Create: TSdlGpuGraphicsPipelineCreateInfo; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#returns","title":"Returns","text":"<p><code>TSdlGpuGraphicsPipelineCreateInfo</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineCreateInfo/#Init","title":"Init","text":"<p>Init with default values. </p> <p><code>procedure Init; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineTargetInfo/","title":"TSdlGpuGraphicsPipelineTargetInfo","text":"<p>A record specifying the descriptions of render targets used in a graphics pipeline. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineTargetInfo/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuGraphicsPipelineTargetInfo = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineTargetInfo/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipelineCreateInfo</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineTargetInfo/#properties","title":"Properties","text":"Name Description ColorTargetDescriptions An array of color target descriptions. DepthStencilFormat The pixel format of the depth-stencil target. HasDepthStencilTarget True specifies that the pipeline uses a depth-stencil target."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineTargetInfo/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineTargetInfo/#ColorTargetDescriptions","title":"ColorTargetDescriptions","text":"<p>An array of color target descriptions. </p> <p><code>property ColorTargetDescriptions: TArray&lt;TSdlGpuColorTargetDescription&gt; read FColorTargetDescriptions write SetColorTargetDescriptions</code></p> <p>Type: <code>TArray&lt;TSdlGpuColorTargetDescription&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineTargetInfo/#DepthStencilFormat","title":"DepthStencilFormat","text":"<p>The pixel format of the depth-stencil target. </p> <p><code>property DepthStencilFormat: TSdlGpuTextureFormat read GetDepthStencilFormat write SetDepthStencilFormat</code></p> <p>Type: <code>TSdlGpuTextureFormat</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuGraphicsPipelineTargetInfo/#HasDepthStencilTarget","title":"HasDepthStencilTarget","text":"<p>True specifies that the pipeline uses a depth-stencil target. </p> <p><code>property HasDepthStencilTarget: Boolean read FHandle.has_depth_stencil_target write FHandle.has_depth_stencil_target</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndexedIndirectDrawCommand/","title":"TSdlGpuIndexedIndirectDrawCommand","text":"<p>A record specifying the parameters of an indexed indirect draw command.</p> <p>Note that the <code>FirstVertex</code> and <code>FirstInstance</code> fields are NOT compatible with built-in vertex/instance ID variables in shaders (for example, SV_VertexID); GPU APIs and shader languages do not define these built-in variables consistently, so if your shader depends on them, the only way to keep behavior consistent and portable is to always pass 0 for the correlating parameter in the draw calls. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndexedIndirectDrawCommand/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuIndexedIndirectDrawCommand = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndexedIndirectDrawCommand/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuRenderPass.DrawIndexedPrimitives</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndexedIndirectDrawCommand/#fields","title":"Fields","text":"Name Description FirstIndex The base index within the index buffer. FirstInstance The ID of the first instance to draw. NumIndices The number of indices to draw per instance. NumInstances The number of instances to draw. VertexOffset The value added to the vertex index before indexing into the vertex buffer."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndexedIndirectDrawCommand/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndexedIndirectDrawCommand/#FirstIndex","title":"FirstIndex","text":"<p>The base index within the index buffer. </p> <p><code>var FirstIndex: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndexedIndirectDrawCommand/#FirstInstance","title":"FirstInstance","text":"<p>The ID of the first instance to draw. </p> <p><code>var FirstInstance: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndexedIndirectDrawCommand/#NumIndices","title":"NumIndices","text":"<p>The number of indices to draw per instance. </p> <p><code>var NumIndices: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndexedIndirectDrawCommand/#NumInstances","title":"NumInstances","text":"<p>The number of instances to draw. </p> <p><code>var NumInstances: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndexedIndirectDrawCommand/#VertexOffset","title":"VertexOffset","text":"<p>The value added to the vertex index before indexing into the vertex buffer. </p> <p><code>var VertexOffset: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDispatchCommand/","title":"TSdlGpuIndirectDispatchCommand","text":"<p>A record specifying the parameters of an indexed dispatch command. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDispatchCommand/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuIndirectDispatchCommand = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDispatchCommand/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuComputePass.Dispatch</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDispatchCommand/#fields","title":"Fields","text":"Name Description GroupCountX The number of local workgroups to dispatch in the X dimension. GroupCountY The number of local workgroups to dispatch in the Y dimension. GroupCountZ The number of local workgroups to dispatch in the Z dimension."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDispatchCommand/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDispatchCommand/#GroupCountX","title":"GroupCountX","text":"<p>The number of local workgroups to dispatch in the X dimension. </p> <p><code>var GroupCountX: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDispatchCommand/#GroupCountY","title":"GroupCountY","text":"<p>The number of local workgroups to dispatch in the Y dimension. </p> <p><code>var GroupCountY: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDispatchCommand/#GroupCountZ","title":"GroupCountZ","text":"<p>The number of local workgroups to dispatch in the Z dimension. </p> <p><code>var GroupCountZ: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDrawCommand/","title":"TSdlGpuIndirectDrawCommand","text":"<p>A record specifying the parameters of an indirect draw command.</p> <p>Note that the <code>FirstVertex</code> and <code>FirstInstance</code> fields are NOT compatible with built-in vertex/instance ID variables in shaders (for example, SV_VertexID); GPU APIs and shader languages do not define these built-in variables consistently, so if your shader depends on them, the only way to keep behavior consistent and portable is to always pass 0 for the correlating parameter in the draw calls. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDrawCommand/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuIndirectDrawCommand = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDrawCommand/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuRenderPass.DrawPrimitives</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDrawCommand/#fields","title":"Fields","text":"Name Description FirstInstance The ID of the first instance to draw. FirstVertex The index of the first vertex to draw. NumInstances The number of instances to draw. NumVertices The number of vertices to draw."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDrawCommand/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDrawCommand/#FirstInstance","title":"FirstInstance","text":"<p>The ID of the first instance to draw. </p> <p><code>var FirstInstance: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDrawCommand/#FirstVertex","title":"FirstVertex","text":"<p>The index of the first vertex to draw. </p> <p><code>var FirstVertex: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDrawCommand/#NumInstances","title":"NumInstances","text":"<p>The number of instances to draw. </p> <p><code>var NumInstances: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuIndirectDrawCommand/#NumVertices","title":"NumVertices","text":"<p>The number of vertices to draw. </p> <p><code>var NumVertices: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuMultisampleState/","title":"TSdlGpuMultisampleState","text":"<p>A record specifying the parameters of the graphics pipeline multisample state. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuMultisampleState/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuMultisampleState = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuMultisampleState/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipelineCreateInfo</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuMultisampleState/#remarks","title":"Remarks","text":"<p>This struct is available since SDL 3.2.0. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuMultisampleState/#properties","title":"Properties","text":"Name Description MaskEnabled Enables sample masking. SampleCount The number of samples to be used in rasterization. SampleMask Determines which samples get updated in the render targets. Treated as $FFFFFFFF if MaskEnabled is False."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuMultisampleState/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuMultisampleState/#MaskEnabled","title":"MaskEnabled","text":"<p>Enables sample masking. </p> <p><code>property MaskEnabled: Boolean read FHandle.enable_mask write FHandle.enable_mask</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuMultisampleState/#SampleCount","title":"SampleCount","text":"<p>The number of samples to be used in rasterization. </p> <p><code>property SampleCount: TSdlGpuSampleCount read GetSampleCount write SetSampleCount</code></p> <p>Type: <code>TSdlGpuSampleCount</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuMultisampleState/#SampleMask","title":"SampleMask","text":"<p>Determines which samples get updated in the render targets. Treated as $FFFFFFFF if MaskEnabled is False. </p> <p><code>property SampleMask: Integer read FHandle.sample_mask write FHandle.sample_mask</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRasterizerState/","title":"TSdlGpuRasterizerState","text":"<p>A record specifying the parameters of the graphics pipeline rasterizer state.</p> <p>NOTE: Some backend APIs (D3D11/12) will enable depth clamping even if enable_depth_clip is true. If you rely on this clamp+clip behavior, consider enabling depth clip and then manually clamping depth in your fragment shaders on Metal and Vulkan. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRasterizerState/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuRasterizerState = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRasterizerState/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipelineCreateInfo</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRasterizerState/#properties","title":"Properties","text":"Name Description CullMode The facing direction in which triangles will be culled. DepthBiasClamp The maximum depth bias of a fragment. DepthBiasConstantFactor A scalar factor controlling the depth value added to each fragment. DepthBiasEnabled True to bias fragment depth values. DepthBiasSlopeFactor A scalar factor applied to a fragment's slope in depth calculations. DepthClipEnabled True to enable depth clip, False to enable depth clamp. FillMode Whether polygons will be filled in or drawn as lines. FrontFace The vertex winding that will cause a triangle to be determined as front-facing."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRasterizerState/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRasterizerState/#CullMode","title":"CullMode","text":"<p>The facing direction in which triangles will be culled. </p> <p><code>property CullMode: TSdlGpuCullMode read GetCullMode write SetCullMode</code></p> <p>Type: <code>TSdlGpuCullMode</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRasterizerState/#DepthBiasClamp","title":"DepthBiasClamp","text":"<p>The maximum depth bias of a fragment. </p> <p><code>property DepthBiasClamp: Single read FHandle.depth_bias_clamp write FHandle.depth_bias_clamp</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRasterizerState/#DepthBiasConstantFactor","title":"DepthBiasConstantFactor","text":"<p>A scalar factor controlling the depth value added to each fragment. </p> <p><code>property DepthBiasConstantFactor: Single read FHandle.depth_bias_constant_factor write FHandle.depth_bias_constant_factor</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRasterizerState/#DepthBiasEnabled","title":"DepthBiasEnabled","text":"<p>True to bias fragment depth values. </p> <p><code>property DepthBiasEnabled: Boolean read FHandle.enable_depth_bias write FHandle.enable_depth_bias</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRasterizerState/#DepthBiasSlopeFactor","title":"DepthBiasSlopeFactor","text":"<p>A scalar factor applied to a fragment's slope in depth calculations. </p> <p><code>property DepthBiasSlopeFactor: Single read FHandle.depth_bias_slope_factor write FHandle.depth_bias_slope_factor</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRasterizerState/#DepthClipEnabled","title":"DepthClipEnabled","text":"<p>True to enable depth clip, False to enable depth clamp. </p> <p><code>property DepthClipEnabled: Boolean read FHandle.enable_depth_clip write FHandle.enable_depth_clip</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRasterizerState/#FillMode","title":"FillMode","text":"<p>Whether polygons will be filled in or drawn as lines. </p> <p><code>property FillMode: TSdlGpuFillMode read GetFillMode write SetFillMode</code></p> <p>Type: <code>TSdlGpuFillMode</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRasterizerState/#FrontFace","title":"FrontFace","text":"<p>The vertex winding that will cause a triangle to be determined as front-facing. </p> <p><code>property FrontFace: TSdlGpuFrontFace read GetFrontFace write SetFrontFace</code></p> <p>Type: <code>TSdlGpuFrontFace</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/","title":"TSdlGpuRenderPass","text":"<p>A render pass.</p> <p>This handle is transient and should not be held or referenced after Finish is called. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuRenderPass = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.BeginRenderPass</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#methods","title":"Methods","text":"Name Description BindFragmentSamplers Binds texture-sampler pairs for use on the fragment shader. BindFragmentStorageBuffers Binds storage buffers for use on the fragment shader. BindFragmentStorageTextures Binds storage textures for use on the fragment shader. BindIndexBuffer Binds an index buffer on a command buffer for use with subsequent draw calls. BindPipeline Binds a graphics pipeline on a render pass to be used in rendering. BindVertexBuffers Binds vertex buffers on a command buffer for use with subsequent draw calls. BindVertexSamplers Binds texture-sampler pairs for use on the vertex shader. BindVertexStorageBuffers Binds storage buffers for use on the vertex shader. BindVertexStorageTextures Binds storage textures for use on the vertex shader. DrawIndexedPrimitives(TSdlGpuBuffer, Integer, Integer) Draws data using bound graphics state with an index buffer enabled and with draw parameters set from a buffer. DrawIndexedPrimitives(Integer, Integer, Integer, Integer, Integer) Draws data using bound graphics state with an index buffer and instancing enabled. DrawPrimitives(TSdlGpuBuffer, Integer, Integer) Draws data using bound graphics state and with draw parameters set from a buffer. DrawPrimitives(Integer, Integer, Integer, Integer) Draws data using bound graphics state. Finish Ends the render pass. SetBlendConstants Sets the current blend constants on a command buffer. Used with <code>TSdlGpuBlendFactor.ConstantColor</code> and <code>TSdlGpuBlendFactor.OneMinusConstantColor</code>. SetScissor Sets the current scissor state on a command buffer. SetStencilReference Sets the current stencil reference value on a command buffer. SetViewport Sets the current viewport state on a command buffer."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#Equal","title":"Equal(TSdlGpuRenderPass, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGpuRenderPass; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuRenderPass</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlGpuRenderPass; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#returns_1","title":"Returns","text":"<p><code>TSdlGpuRenderPass</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#NotEqual","title":"NotEqual(TSdlGpuRenderPass, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGpuRenderPass; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuRenderPass</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#BindFragmentSamplers","title":"BindFragmentSamplers(Integer, TArray&lt;TSdlGpuTextureSamplerBinding&gt;)","text":"<p>Binds texture-sampler pairs for use on the fragment shader.</p> <p>The textures must have been created with TSdlGpuTextureUsage.Sampler. </p> <p><code>procedure BindFragmentSamplers(const AFirstSlot: Integer; const ATextureSamplerBindings: TArray&lt;TSdlGpuTextureSamplerBinding&gt;); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_3","title":"Parameters","text":"<p><code>AFirstSlot</code>: <code>Integer</code> : The fragment sampler slot to begin binding from.</p> <p><code>ATextureSamplerBindings</code>: <code>TArray&lt;TSdlGpuTextureSamplerBinding&gt;</code> : An array of texture-sampler binding records.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#BindFragmentStorageBuffers","title":"BindFragmentStorageBuffers(Integer, TArray&lt;TSdlGpuBuffer&gt;)","text":"<p>Binds storage buffers for use on the fragment shader.</p> <p>These buffers must have been created with TSdlGpuBufferUsage.GraphicsStorageRead. </p> <p><code>procedure BindFragmentStorageBuffers(const AFirstSlot: Integer; const AStorageBuffers: TArray&lt;TSdlGpuBuffer&gt;); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_4","title":"Parameters","text":"<p><code>AFirstSlot</code>: <code>Integer</code> : The fragment storage buffer slot to begin binding from.</p> <p><code>AStorageBuffers</code>: <code>TArray&lt;TSdlGpuBuffer&gt;</code> : An array of storage buffers.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#BindFragmentStorageTextures","title":"BindFragmentStorageTextures(Integer, TArray&lt;TSdlGpuTexture&gt;)","text":"<p>Binds storage textures for use on the fragment shader.</p> <p>These textures must have been created with TSdlGpuTextureUsage.GraphicsStorageRead. </p> <p><code>procedure BindFragmentStorageTextures(const AFirstSlot: Integer; const AStorageTextures: TArray&lt;TSdlGpuTexture&gt;); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_5","title":"Parameters","text":"<p><code>AFirstSlot</code>: <code>Integer</code> : The fragment storage texture slot to begin binding from.</p> <p><code>AStorageTextures</code>: <code>TArray&lt;TSdlGpuTexture&gt;</code> : An array of storage textures.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#BindIndexBuffer","title":"BindIndexBuffer(TSdlGpuBufferBinding, TSdlGpuIndexElementSize)","text":"<p>Binds an index buffer on a command buffer for use with subsequent draw calls. </p> <p><code>procedure BindIndexBuffer(const ABinding: TSdlGpuBufferBinding; const AIndexElementSize: TSdlGpuIndexElementSize); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_6","title":"Parameters","text":"<p><code>ABinding</code>: <code>TSdlGpuBufferBinding</code> : A record containing an index buffer and offset.</p> <p><code>AIndexElementSize</code>: <code>TSdlGpuIndexElementSize</code> : Whether the index values in the buffer are 16- or 32-bit.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#BindPipeline","title":"BindPipeline(TSdlGpuGraphicsPipeline)","text":"<p>Binds a graphics pipeline on a render pass to be used in rendering.</p> <p>A graphics pipeline must be bound before making any draw calls. </p> <p><code>procedure BindPipeline(const AGraphicsPipeline: TSdlGpuGraphicsPipeline); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_7","title":"Parameters","text":"<p><code>AGraphicsPipeline</code>: <code>TSdlGpuGraphicsPipeline</code> : The graphics pipeline to bind.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#BindVertexBuffers","title":"BindVertexBuffers(Integer, TArray&lt;TSdlGpuBufferBinding&gt;)","text":"<p>Binds vertex buffers on a command buffer for use with subsequent draw calls. </p> <p><code>procedure BindVertexBuffers(const AFirstSlot: Integer; const ABindings: TArray&lt;TSdlGpuBufferBinding&gt;); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_8","title":"Parameters","text":"<p><code>AFirstSlot</code>: <code>Integer</code> : The vertex buffer slot to begin binding from.</p> <p><code>ABindings</code>: <code>TArray&lt;TSdlGpuBufferBinding&gt;</code> : An array of TSdlGpuBufferBinding records containing vertex buffers and offset values.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#BindVertexSamplers","title":"BindVertexSamplers(Integer, TArray&lt;TSdlGpuTextureSamplerBinding&gt;)","text":"<p>Binds texture-sampler pairs for use on the vertex shader.</p> <p>The textures must have been created with TSdlGpuTextureUsage.Sampler. </p> <p><code>procedure BindVertexSamplers(const AFirstSlot: Integer; const ATextureSamplerBindings: TArray&lt;TSdlGpuTextureSamplerBinding&gt;); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_9","title":"Parameters","text":"<p><code>AFirstSlot</code>: <code>Integer</code> : The vertex sampler slot to begin binding from.</p> <p><code>ATextureSamplerBindings</code>: <code>TArray&lt;TSdlGpuTextureSamplerBinding&gt;</code> : An array of texture-sampler binding records.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#BindVertexStorageBuffers","title":"BindVertexStorageBuffers(Integer, TArray&lt;TSdlGpuBuffer&gt;)","text":"<p>Binds storage buffers for use on the vertex shader.</p> <p>These buffers must have been created with TSdlGpuBufferUsage.GraphicsStorageRead. </p> <p><code>procedure BindVertexStorageBuffers(const AFirstSlot: Integer; const AStorageBuffers: TArray&lt;TSdlGpuBuffer&gt;); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_10","title":"Parameters","text":"<p><code>AFirstSlot</code>: <code>Integer</code> : The vertex storage buffer slot to begin binding from.</p> <p><code>AStorageBuffers</code>: <code>TArray&lt;TSdlGpuBuffer&gt;</code> : An array of buffers.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#BindVertexStorageTextures","title":"BindVertexStorageTextures(Integer, TArray&lt;TSdlGpuTexture&gt;)","text":"<p>Binds storage textures for use on the vertex shader.</p> <p>These textures must have been created with TSdlGpuTextureUsage.GraphicsStorageRead. </p> <p><code>procedure BindVertexStorageTextures(const AFirstSlot: Integer; const AStorageTextures: TArray&lt;TSdlGpuTexture&gt;); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_11","title":"Parameters","text":"<p><code>AFirstSlot</code>: <code>Integer</code> : The vertex storage texture slot to begin binding from.</p> <p><code>AStorageTextures</code>: <code>TArray&lt;TSdlGpuTexture&gt;</code> : An array of storage textures.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#DrawIndexedPrimitives_0","title":"DrawIndexedPrimitives(TSdlGpuBuffer, Integer, Integer)","text":"<p>Draws data using bound graphics state with an index buffer enabled and with draw parameters set from a buffer.</p> <p>The buffer must consist of tightly-packed draw parameter sets that each match the layout of TSdlGpuIndexedIndirectDrawCommand. You must not call this method before binding a graphics pipeline. </p> <p><code>procedure DrawIndexedPrimitives(const ABuffer: TSdlGpuBuffer; const AOffset, ADrawCount: Integer); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_12","title":"Parameters","text":"<p><code>ABuffer</code>: <code>TSdlGpuBuffer</code> : A buffer containing draw parameters.</p> <p><code>AOffset</code>: <code>Integer</code> : The offset to start reading from the draw buffer.</p> <p><code>ADrawCount</code>: <code>Integer</code> : The number of draw parameter sets that should be read from the draw buffer.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#remarks","title":"Remarks","text":"<p>This function is available since SDL 3.2.0. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#DrawIndexedPrimitives_1","title":"DrawIndexedPrimitives(Integer, Integer, Integer, Integer, Integer)","text":"<p>Draws data using bound graphics state with an index buffer and instancing enabled.</p> <p>You must not call this method before binding a graphics pipeline.</p> <p>Note that the <code>AFirstVertex</code> and <code>AFirstInstance</code> parameters are NOT compatible with built-in vertex/instance ID variables in shaders (for example, SV_VertexID); GPU APIs and shader languages do not define these built-in variables consistently, so if your shader depends on them, the only way to keep behavior consistent and portable is to always pass 0 for the correlating parameter in the draw calls. </p> <p><code>procedure DrawIndexedPrimitives(const ANumIndices, ANumInstances, AFirstIndex, AVertexOffset, AFirstInstance: Integer); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_13","title":"Parameters","text":"<p><code>ANumIndices</code>: <code>Integer</code> : The number of indices to draw per instance.</p> <p><code>ANumInstances</code>: <code>Integer</code> : The number of instances to draw.</p> <p><code>AFirstIndex</code>: <code>Integer</code> : The starting index within the index buffer.</p> <p><code>AVertexOffset</code>: <code>Integer</code> : Value added to vertex index before indexing into the vertex buffer.</p> <p><code>AFirstInstance</code>: <code>Integer</code> : The ID of the first instance to draw.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#DrawPrimitives_0","title":"DrawPrimitives(TSdlGpuBuffer, Integer, Integer)","text":"<p>Draws data using bound graphics state and with draw parameters set from a buffer.</p> <p>The buffer must consist of tightly-packed draw parameter sets that each match the layout of TSdlGpuIndirectDrawCommand. You must not call this method before binding a graphics pipeline. </p> <p><code>procedure DrawPrimitives(const ABuffer: TSdlGpuBuffer; const AOffset, ADrawCount: Integer); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_14","title":"Parameters","text":"<p><code>ABuffer</code>: <code>TSdlGpuBuffer</code> : A buffer containing draw parameters.</p> <p><code>AOffset</code>: <code>Integer</code> : The offset to start reading from the draw buffer.</p> <p><code>ADrawCount</code>: <code>Integer</code> : The number of draw parameter sets that should be read from the draw buffer.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#DrawPrimitives_1","title":"DrawPrimitives(Integer, Integer, Integer, Integer)","text":"<p>Draws data using bound graphics state.</p> <p>You must not call this method before binding a graphics pipeline.</p> <p>Note that the <code>AFirstVertex</code> and <code>AFirstInstance</code> parameters are NOT compatible with built-in vertex/instance ID variables in shaders (for example, SV_VertexID); GPU APIs and shader languages do not define these built-in variables consistently, so if your shader depends on them, the only way to keep behavior consistent and portable is to always pass 0 for the correlating parameter in the draw calls. </p> <p><code>procedure DrawPrimitives(const ANumVertices, ANumInstances, AFirstVertex, AFirstInstance: Integer); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_15","title":"Parameters","text":"<p><code>ANumVertices</code>: <code>Integer</code> : The number of vertices to draw.</p> <p><code>ANumInstances</code>: <code>Integer</code> : The number of instances that will be drawn.</p> <p><code>AFirstVertex</code>: <code>Integer</code> : The index of the first vertex to draw.</p> <p><code>AFirstInstance</code>: <code>Integer</code> : The ID of the first instance to draw.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#Finish","title":"Finish","text":"<p>Ends the render pass.</p> <p>All bound graphics state on the render pass command buffer is unset. The render pass is now invalid. </p> <p><code>procedure Finish; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#SetBlendConstants","title":"SetBlendConstants(TSdlColorF)","text":"<p>Sets the current blend constants on a command buffer. Used with <code>TSdlGpuBlendFactor.ConstantColor</code> and <code>TSdlGpuBlendFactor.OneMinusConstantColor</code>. </p> <p><code>procedure SetBlendConstants(const ABlendConstants: TSdlColorF); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_16","title":"Parameters","text":"<p><code>ABlendConstants</code>: <code>TSdlColorF</code> : The blend constant color.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#see-also_1","title":"See Also","text":"<ul> <li>TSdlGpuBlendFactor</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#SetScissor","title":"SetScissor(TSdlRect)","text":"<p>Sets the current scissor state on a command buffer. </p> <p><code>procedure SetScissor(const AScissor: TSdlRect); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_17","title":"Parameters","text":"<p><code>AScissor</code>: <code>TSdlRect</code> : The scissor area to set.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#SetStencilReference","title":"SetStencilReference(Byte)","text":"<p>Sets the current stencil reference value on a command buffer. </p> <p><code>procedure SetStencilReference(const AReference: Byte); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_18","title":"Parameters","text":"<p><code>AReference</code>: <code>Byte</code> : The stencil reference value to set.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#SetViewport","title":"SetViewport(TSdlGpuViewport)","text":"<p>Sets the current viewport state on a command buffer. </p> <p><code>procedure SetViewport(const AViewport: TSdlGpuViewport); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuRenderPass/#parameters_19","title":"Parameters","text":"<p><code>AViewport</code>: <code>TSdlGpuViewport</code> : The viewport to set.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSampler/","title":"TSdlGpuSampler","text":"<p>A sampler. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSampler/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuSampler = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSampler/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuRenderPass.BindVertexSamplers</li> <li>TSdlGpuRenderPass.BindFragmentSamplers</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSampler/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSampler/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSampler/#Equal","title":"Equal(TSdlGpuSampler, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGpuSampler; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSampler/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuSampler</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSampler/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSampler/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlGpuSampler; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSampler/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSampler/#returns_1","title":"Returns","text":"<p><code>TSdlGpuSampler</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSampler/#NotEqual","title":"NotEqual(TSdlGpuSampler, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGpuSampler; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSampler/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuSampler</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSampler/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/","title":"TSdlGpuSamplerCreateInfo","text":"<p>A record specifying the parameters of a sampler. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuSamplerCreateInfo = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuSampler</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#properties","title":"Properties","text":"Name Description AddressModeU The addressing mode for U coordinates outside [0, 1). AddressModeV The addressing mode for V coordinates outside [0, 1). AddressModeW The addressing mode for W coordinates outside [0, 1). AnisotropyEnabled True to enable anisotropic filtering. CompareEnabled True to enable comparison against a reference value during lookups. CompareOp The comparison operator to apply to fetched data before filtering. MagFilter The magnification filter to apply to lookups. MaxAnisotropy The anisotropy value clamp used by the sampler. If enable_anisotropy is false, this is ignored. MaxLod Clamps the maximum of the computed LOD value. MinFilter The minification filter to apply to lookups. MinLod Clamps the minimum of the computed LOD value. MipLodBias The bias to be added to mipmap LOD calculation. MipmapMode The mipmap filter to apply to lookups. Props A properties ID for extensions. Should be 0 if no extensions are needed."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#methods","title":"Methods","text":"Name Description Create Create with default values. Init Init with default values."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#AddressModeU","title":"AddressModeU","text":"<p>The addressing mode for U coordinates outside [0, 1). </p> <p><code>property AddressModeU: TSdlGpuSamplerAddressMode read GetAddressModeU write SetAddressModeU</code></p> <p>Type: <code>TSdlGpuSamplerAddressMode</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#AddressModeV","title":"AddressModeV","text":"<p>The addressing mode for V coordinates outside [0, 1). </p> <p><code>property AddressModeV: TSdlGpuSamplerAddressMode read GetAddressModeV write SetAddressModeV</code></p> <p>Type: <code>TSdlGpuSamplerAddressMode</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#AddressModeW","title":"AddressModeW","text":"<p>The addressing mode for W coordinates outside [0, 1). </p> <p><code>property AddressModeW: TSdlGpuSamplerAddressMode read GetAddressModeW write SetAddressModeW</code></p> <p>Type: <code>TSdlGpuSamplerAddressMode</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#AnisotropyEnabled","title":"AnisotropyEnabled","text":"<p>True to enable anisotropic filtering. </p> <p><code>property AnisotropyEnabled: Boolean read FHandle.enable_anisotropy write FHandle.enable_anisotropy</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#CompareEnabled","title":"CompareEnabled","text":"<p>True to enable comparison against a reference value during lookups. </p> <p><code>property CompareEnabled: Boolean read FHandle.enable_compare write FHandle.enable_compare</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#CompareOp","title":"CompareOp","text":"<p>The comparison operator to apply to fetched data before filtering. </p> <p><code>property CompareOp: TSdlGpuCompareOp read GetCompareOp write SetCompareOp</code></p> <p>Type: <code>TSdlGpuCompareOp</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#MagFilter","title":"MagFilter","text":"<p>The magnification filter to apply to lookups. </p> <p><code>property MagFilter: TSdlGpuFilter read GetMagFilter write SetMagFilter</code></p> <p>Type: <code>TSdlGpuFilter</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#MaxAnisotropy","title":"MaxAnisotropy","text":"<p>The anisotropy value clamp used by the sampler. If enable_anisotropy is false, this is ignored. </p> <p><code>property MaxAnisotropy: Single read FHandle.max_anisotropy write FHandle.max_anisotropy</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#MaxLod","title":"MaxLod","text":"<p>Clamps the maximum of the computed LOD value. </p> <p><code>property MaxLod: Single read FHandle.max_lod write FHandle.max_lod</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#MinFilter","title":"MinFilter","text":"<p>The minification filter to apply to lookups. </p> <p><code>property MinFilter: TSdlGpuFilter read GetMinFilter write SetMinFilter</code></p> <p>Type: <code>TSdlGpuFilter</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#MinLod","title":"MinLod","text":"<p>Clamps the minimum of the computed LOD value. </p> <p><code>property MinLod: Single read FHandle.min_lod write FHandle.min_lod</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#MipLodBias","title":"MipLodBias","text":"<p>The bias to be added to mipmap LOD calculation. </p> <p><code>property MipLodBias: Single read FHandle.mip_lod_bias write FHandle.mip_lod_bias</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#MipmapMode","title":"MipmapMode","text":"<p>The mipmap filter to apply to lookups. </p> <p><code>property MipmapMode: TSdlGpuSamplerMipmapMode read GetMipmapMode write SetMipmapMode</code></p> <p>Type: <code>TSdlGpuSamplerMipmapMode</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#Props","title":"Props","text":"<p>A properties ID for extensions. Should be 0 if no extensions are needed. </p> <p><code>property Props: TSdlProperties read GetProps write SetProps</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#Create","title":"Create","text":"<p>Create with default values. </p> <p><code>class function Create: TSdlGpuSamplerCreateInfo; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#returns","title":"Returns","text":"<p><code>TSdlGpuSamplerCreateInfo</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuSamplerCreateInfo/#Init","title":"Init","text":"<p>Init with default values. </p> <p><code>procedure Init; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShader/","title":"TSdlGpuShader","text":"<p>A compiled shader object. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShader/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuShader = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShader/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShader/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShader/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShader/#Equal","title":"Equal(TSdlGpuShader, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGpuShader; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShader/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuShader</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShader/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShader/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlGpuShader; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShader/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShader/#returns_1","title":"Returns","text":"<p><code>TSdlGpuShader</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShader/#NotEqual","title":"NotEqual(TSdlGpuShader, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGpuShader; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShader/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuShader</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShader/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/","title":"TSdlGpuShaderCreateInfo","text":"<p>A record specifying code and metadata for creating a shader object. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuShaderCreateInfo = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuShader</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#properties","title":"Properties","text":"Name Description Code The shader code. EntryPoint The entry point function name for the shader. Format The format of the shader code. NumSamplers The number of samplers defined in the shader. NumStorageBuffers The number of storage buffers defined in the shader. NumStorageTextures The number of storage textures defined in the shader. NumUniformBuffers The number of uniform buffers defined in the shader. Props A properties ID for extensions. Should be 0 if no extensions are needed. Stage The stage the shader program corresponds to."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#methods","title":"Methods","text":"Name Description Create Create with default values. Init Init with default values."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#Code","title":"Code","text":"<p>The shader code. </p> <p><code>property Code: TBytes read FCode write SetCode</code></p> <p>Type: <code>TBytes</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#EntryPoint","title":"EntryPoint","text":"<p>The entry point function name for the shader. </p> <p><code>property EntryPoint: String read GetEntryPoint write SetEntryPoint</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#Format","title":"Format","text":"<p>The format of the shader code. </p> <p><code>property Format: TSdlGpuShaderFormat read GetFormat write SetFormat</code></p> <p>Type: <code>TSdlGpuShaderFormat</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#NumSamplers","title":"NumSamplers","text":"<p>The number of samplers defined in the shader. </p> <p><code>property NumSamplers: Integer read FHandle.num_samplers write FHandle.num_samplers</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#NumStorageBuffers","title":"NumStorageBuffers","text":"<p>The number of storage buffers defined in the shader. </p> <p><code>property NumStorageBuffers: Integer read FHandle.num_storage_buffers write FHandle.num_storage_buffers</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#NumStorageTextures","title":"NumStorageTextures","text":"<p>The number of storage textures defined in the shader. </p> <p><code>property NumStorageTextures: Integer read FHandle.num_storage_textures write FHandle.num_storage_textures</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#NumUniformBuffers","title":"NumUniformBuffers","text":"<p>The number of uniform buffers defined in the shader. </p> <p><code>property NumUniformBuffers: Integer read FHandle.num_uniform_buffers write FHandle.num_uniform_buffers</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#Props","title":"Props","text":"<p>A properties ID for extensions. Should be 0 if no extensions are needed. </p> <p><code>property Props: TSdlProperties read GetProps write SetProps</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#Stage","title":"Stage","text":"<p>The stage the shader program corresponds to. </p> <p><code>property Stage: TSdlGpuShaderStage read GetStage write SetStage</code></p> <p>Type: <code>TSdlGpuShaderStage</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#Create","title":"Create","text":"<p>Create with default values. </p> <p><code>class function Create: TSdlGpuShaderCreateInfo; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#returns","title":"Returns","text":"<p><code>TSdlGpuShaderCreateInfo</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuShaderCreateInfo/#Init","title":"Init","text":"<p>Init with default values. </p> <p><code>procedure Init; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStencilOpState/","title":"TSdlGpuStencilOpState","text":"<p>A record specifying the stencil operation state of a graphics pipeline. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStencilOpState/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuStencilOpState = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStencilOpState/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuDepthStencilState</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStencilOpState/#fields","title":"Fields","text":"Name Description CompareOp The comparison operator used in the stencil test. DepthFailOp The action performed on samples that pass the stencil test and fail the depth test. FailOp The action performed on samples that fail the stencil test. PassOp The action performed on samples that pass the depth and stencil tests."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStencilOpState/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStencilOpState/#CompareOp","title":"CompareOp","text":"<p>The comparison operator used in the stencil test. </p> <p><code>var CompareOp: TSdlGpuCompareOp</code></p> <p>Type: <code>TSdlGpuCompareOp</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStencilOpState/#DepthFailOp","title":"DepthFailOp","text":"<p>The action performed on samples that pass the stencil test and fail the depth test. </p> <p><code>var DepthFailOp: TSdlGpuStencilOp</code></p> <p>Type: <code>TSdlGpuStencilOp</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStencilOpState/#FailOp","title":"FailOp","text":"<p>The action performed on samples that fail the stencil test. </p> <p><code>var FailOp: TSdlGpuStencilOp</code></p> <p>Type: <code>TSdlGpuStencilOp</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStencilOpState/#PassOp","title":"PassOp","text":"<p>The action performed on samples that pass the depth and stencil tests. </p> <p><code>var PassOp: TSdlGpuStencilOp</code></p> <p>Type: <code>TSdlGpuStencilOp</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStorageBufferReadWriteBinding/","title":"TSdlGpuStorageBufferReadWriteBinding","text":"<p>A record specifying parameters related to binding buffers in a compute pass. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStorageBufferReadWriteBinding/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuStorageBufferReadWriteBinding = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStorageBufferReadWriteBinding/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.BeginComputePass</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStorageBufferReadWriteBinding/#properties","title":"Properties","text":"Name Description Buffer The buffer to bind. Must have been created with TSdlGpuBufferUsage.ComputeStorageWrite. Cycle True cycles the buffer if it is already bound."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStorageBufferReadWriteBinding/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStorageBufferReadWriteBinding/#Buffer","title":"Buffer","text":"<p>The buffer to bind. Must have been created with TSdlGpuBufferUsage.ComputeStorageWrite. </p> <p><code>property Buffer: TSdlGpuBuffer read GetBuffer write SetBuffer</code></p> <p>Type: <code>TSdlGpuBuffer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStorageBufferReadWriteBinding/#Cycle","title":"Cycle","text":"<p>True cycles the buffer if it is already bound.</p> <p><code>property Cycle: Boolean read FHandle.cycle write FHandle.cycle</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStorageTextureReadWriteBinding/","title":"TSdlGpuStorageTextureReadWriteBinding","text":"<p>A record specifying parameters related to binding textures in a compute pass. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStorageTextureReadWriteBinding/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuStorageTextureReadWriteBinding = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStorageTextureReadWriteBinding/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.BeginComputePass</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStorageTextureReadWriteBinding/#properties","title":"Properties","text":"Name Description Cycle True cycles the texture if it is already bound. Layer The layer index to bind. MipLevel The mip level index to bind. Texture The texture to bind. Must have been created with TSdlGpuTextureUsage.ComputeStorageWrite or TSdlGpuTextureUsage.ComputeStorageSimultaneousReadWrite."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStorageTextureReadWriteBinding/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStorageTextureReadWriteBinding/#Cycle","title":"Cycle","text":"<p>True cycles the texture if it is already bound. </p> <p><code>property Cycle: Boolean read FHandle.cycle write FHandle.cycle</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStorageTextureReadWriteBinding/#Layer","title":"Layer","text":"<p>The layer index to bind. </p> <p><code>property Layer: Integer read FHandle.layer write FHandle.layer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStorageTextureReadWriteBinding/#MipLevel","title":"MipLevel","text":"<p>The mip level index to bind. </p> <p><code>property MipLevel: Integer read FHandle.mip_level write FHandle.mip_level</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuStorageTextureReadWriteBinding/#Texture","title":"Texture","text":"<p>The texture to bind. Must have been created with TSdlGpuTextureUsage.ComputeStorageWrite or TSdlGpuTextureUsage.ComputeStorageSimultaneousReadWrite. </p> <p><code>property Texture: TSdlGpuTexture read GetTexture write SetTexture</code></p> <p>Type: <code>TSdlGpuTexture</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTexture/","title":"TSdlGpuTexture","text":"<p>A texture. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTexture/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuTexture = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTexture/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCopyPass.UploadToTexture</li> <li>TSdlGpuCopyPass.DownloadFromTexture</li> <li>TSdlGpuCopyPass.CopyTextureToTexture</li> <li>TSdlGpuRenderPass.BindVertexSamplers</li> <li>TSdlGpuRenderPass.BindVertexStorageTextures</li> <li>TSdlGpuRenderPass.BindFragmentSamplers</li> <li>TSdlGpuRenderPass.BindFragmentStorageTextures</li> <li>TSdlGpuComputePass.BindStorageTextures</li> <li>TSdlGpuCommandBuffer.GenerateMipmaps</li> <li>TSdlGpuCommandBuffer.Blit</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTexture/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTexture/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTexture/#Equal","title":"Equal(TSdlGpuTexture, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGpuTexture; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTexture/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuTexture</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTexture/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTexture/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlGpuTexture; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTexture/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTexture/#returns_1","title":"Returns","text":"<p><code>TSdlGpuTexture</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTexture/#NotEqual","title":"NotEqual(TSdlGpuTexture, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGpuTexture; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTexture/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuTexture</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTexture/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/","title":"TSdlGpuTextureCreateInfo","text":"<p>A record specifying the parameters of a texture.</p> <p>Note that certain usage combinations are invalid, for example Sampler and GraphicsStorage. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuTextureCreateInfo = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuTexture</li> <li>TSdlGpuTextureKind</li> <li>TSdlGpuTextureFormat</li> <li>TSdlGpuTextureUsageFlags</li> <li>TSdlGpuSampleCount</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#properties","title":"Properties","text":"Name Description Format The pixel format of the texture. Height The height of the texture. Kind The base dimensionality of the texture. LayerCountOrDepth The layer count or depth of the texture. This value is treated as a layer count on 2D array textures, and as a depth value on 3D textures. NumLevels The number of mip levels in the texture. Props A properties ID for extensions. Should be 0 if no extensions are needed. SampleCount The number of samples per texel. Only applies if the texture is used as a render target. Usage How the texture is intended to be used by the client. Width The width of the texture."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#methods","title":"Methods","text":"Name Description Create Create with default values. Init Init with default values."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#Format","title":"Format","text":"<p>The pixel format of the texture. </p> <p><code>property Format: TSdlGpuTextureFormat read GetFormat write SetFormat</code></p> <p>Type: <code>TSdlGpuTextureFormat</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#Height","title":"Height","text":"<p>The height of the texture. </p> <p><code>property Height: Integer read FHandle.height write FHandle.height</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#Kind","title":"Kind","text":"<p>The base dimensionality of the texture. </p> <p><code>property Kind: TSdlGpuTextureKind read GetKind write SetKind</code></p> <p>Type: <code>TSdlGpuTextureKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#LayerCountOrDepth","title":"LayerCountOrDepth","text":"<p>The layer count or depth of the texture. This value is treated as a layer count on 2D array textures, and as a depth value on 3D textures. </p> <p><code>property LayerCountOrDepth: Integer read FHandle.layer_count_or_depth write FHandle.layer_count_or_depth</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#NumLevels","title":"NumLevels","text":"<p>The number of mip levels in the texture. </p> <p><code>property NumLevels: Integer read FHandle.num_levels write FHandle.num_levels</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#Props","title":"Props","text":"<p>A properties ID for extensions. Should be 0 if no extensions are needed. </p> <p><code>property Props: TSdlProperties read GetProps write SetProps</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#SampleCount","title":"SampleCount","text":"<p>The number of samples per texel. Only applies if the texture is used as a render target. </p> <p><code>property SampleCount: TSdlGpuSampleCount read GetSampleCount write SetSampleCount</code></p> <p>Type: <code>TSdlGpuSampleCount</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#Usage","title":"Usage","text":"<p>How the texture is intended to be used by the client. </p> <p><code>property Usage: TSdlGpuTextureUsageFlags read GetUsage write SetUsage</code></p> <p>Type: <code>TSdlGpuTextureUsageFlags</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#Width","title":"Width","text":"<p>The width of the texture. </p> <p><code>property Width: Integer read FHandle.width write FHandle.width</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#Create","title":"Create","text":"<p>Create with default values. </p> <p><code>class function Create: TSdlGpuTextureCreateInfo; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#returns","title":"Returns","text":"<p><code>TSdlGpuTextureCreateInfo</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureCreateInfo/#Init","title":"Init","text":"<p>Init with default values. </p> <p><code>procedure Init; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureLocation/","title":"TSdlGpuTextureLocation","text":"<p>A record specifying a location in a texture.</p> <p>Used when copying data from one texture to another. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureLocation/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuTextureLocation = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureLocation/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCopyPass.CopyTextureToTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureLocation/#properties","title":"Properties","text":"Name Description Layer The layer index of the location. MipLevel The mip level index of the location. Texture The texture used in the copy operation. X The left offset of the location. Y The top offset of the location. Z The front offset of the location."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureLocation/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureLocation/#Layer","title":"Layer","text":"<p>The layer index of the location. </p> <p><code>property Layer: Integer read FHandle.layer write FHandle.layer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureLocation/#MipLevel","title":"MipLevel","text":"<p>The mip level index of the location. </p> <p><code>property MipLevel: Integer read FHandle.mip_level write FHandle.mip_level</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureLocation/#Texture","title":"Texture","text":"<p>The texture used in the copy operation. </p> <p><code>property Texture: TSdlGpuTexture read GetTexture write SetTexture</code></p> <p>Type: <code>TSdlGpuTexture</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureLocation/#X","title":"X","text":"<p>The left offset of the location. </p> <p><code>property X: Integer read FHandle.x write FHandle.x</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureLocation/#Y","title":"Y","text":"<p>The top offset of the location. </p> <p><code>property Y: Integer read FHandle.y write FHandle.y</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureLocation/#Z","title":"Z","text":"<p>The front offset of the location. </p> <p><code>property Z: Integer read FHandle.z write FHandle.z</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureRegion/","title":"TSdlGpuTextureRegion","text":"<p>A record specifying a region of a texture.</p> <p>Used when transferring data to or from a texture. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureRegion/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuTextureRegion = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureRegion/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCopyPass.UploadToTexture</li> <li>TSdlGpuCopyPass.DownloadFromTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureRegion/#properties","title":"Properties","text":"Name Description D The depth of the region. H The height of the region. Layer The layer index to transfer. MipLevel The mip level index to transfer. Texture The texture used in the copy operation. W The width of the region. X The left offset of the region. Y The top offset of the region. Z The front offset of the region."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureRegion/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureRegion/#D","title":"D","text":"<p>The depth of the region. </p> <p><code>property D: Integer read FHandle.d write FHandle.d</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureRegion/#H","title":"H","text":"<p>The height of the region. </p> <p><code>property H: Integer read FHandle.h write FHandle.h</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureRegion/#Layer","title":"Layer","text":"<p>The layer index to transfer. </p> <p><code>property Layer: Integer read FHandle.layer write FHandle.layer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureRegion/#MipLevel","title":"MipLevel","text":"<p>The mip level index to transfer. </p> <p><code>property MipLevel: Integer read FHandle.mip_level write FHandle.mip_level</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureRegion/#Texture","title":"Texture","text":"<p>The texture used in the copy operation. </p> <p><code>property Texture: TSdlGpuTexture read GetTexture write SetTexture</code></p> <p>Type: <code>TSdlGpuTexture</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureRegion/#W","title":"W","text":"<p>The width of the region. </p> <p><code>property W: Integer read FHandle.w write FHandle.w</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureRegion/#X","title":"X","text":"<p>The left offset of the region. </p> <p><code>property X: Integer read FHandle.x write FHandle.x</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureRegion/#Y","title":"Y","text":"<p>The top offset of the region. </p> <p><code>property Y: Integer read FHandle.y write FHandle.y</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureRegion/#Z","title":"Z","text":"<p>The front offset of the region. </p> <p><code>property Z: Integer read FHandle.z write FHandle.z</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureSamplerBinding/","title":"TSdlGpuTextureSamplerBinding","text":"<p>A record specifying parameters in a sampler binding call. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureSamplerBinding/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuTextureSamplerBinding = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureSamplerBinding/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuRenderPass.BindVertexSamplers</li> <li>TSdlGpuRenderPass.BindFragmentSamplers</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureSamplerBinding/#properties","title":"Properties","text":"Name Description Sampler The sampler to bind. Texture The texture to bind. Must have been created with TSdlGpuTextureUsage.Sampler."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureSamplerBinding/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureSamplerBinding/#Sampler","title":"Sampler","text":"<p>The sampler to bind. </p> <p><code>property Sampler: TSdlGpuSampler read GetSampler write SetSampler</code></p> <p>Type: <code>TSdlGpuSampler</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureSamplerBinding/#Texture","title":"Texture","text":"<p>The texture to bind. Must have been created with TSdlGpuTextureUsage.Sampler. </p> <p><code>property Texture: TSdlGpuTexture read GetTexture write SetTexture</code></p> <p>Type: <code>TSdlGpuTexture</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureTransferInfo/","title":"TSdlGpuTextureTransferInfo","text":"<p>A record specifying parameters related to transferring data to or from a texture. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureTransferInfo/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuTextureTransferInfo = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureTransferInfo/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCopyPass.UploadToTexture</li> <li>TSdlGpuCopyPass.DownloadFromTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureTransferInfo/#properties","title":"Properties","text":"Name Description Offset The starting byte of the image data in the transfer buffer. PixelsPerRow The number of pixels from one row to the next. RowsPerLayer The number of rows from one layer/depth-slice to the next. TransferBuffer The transfer buffer used in the transfer operation."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureTransferInfo/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureTransferInfo/#Offset","title":"Offset","text":"<p>The starting byte of the image data in the transfer buffer. </p> <p><code>property Offset: Integer read FHandle.offset write FHandle.offset</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureTransferInfo/#PixelsPerRow","title":"PixelsPerRow","text":"<p>The number of pixels from one row to the next. </p> <p><code>property PixelsPerRow: Integer read FHandle.pixels_per_row write FHandle.pixels_per_row</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureTransferInfo/#RowsPerLayer","title":"RowsPerLayer","text":"<p>The number of rows from one layer/depth-slice to the next. </p> <p><code>property RowsPerLayer: Integer read FHandle.rows_per_layer write FHandle.rows_per_layer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTextureTransferInfo/#TransferBuffer","title":"TransferBuffer","text":"<p>The transfer buffer used in the transfer operation. </p> <p><code>property TransferBuffer: TSdlGpuTransferBuffer read GetTransferBuffer write SetTransferBuffer</code></p> <p>Type: <code>TSdlGpuTransferBuffer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBuffer/","title":"TSdlGpuTransferBuffer","text":"<p>A transfer buffer used for transferring data to and from the device. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBuffer/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuTransferBuffer = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBuffer/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuDevice.MapTransferBuffer</li> <li>TSdlGpuDevice.UnmapTransferBuffer</li> <li>TSdlGpuCopyPass.UploadToBuffer</li> <li>TSdlGpuCopyPass.UploadToTexture</li> <li>TSdlGpuCopyPass.DownloadFromBuffer</li> <li>TSdlGpuCopyPass.DownloadFromTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBuffer/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBuffer/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBuffer/#Equal","title":"Equal(TSdlGpuTransferBuffer, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGpuTransferBuffer; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBuffer/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuTransferBuffer</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBuffer/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBuffer/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlGpuTransferBuffer; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBuffer/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBuffer/#returns_1","title":"Returns","text":"<p><code>TSdlGpuTransferBuffer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBuffer/#NotEqual","title":"NotEqual(TSdlGpuTransferBuffer, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGpuTransferBuffer; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBuffer/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGpuTransferBuffer</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBuffer/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferCreateInfo/","title":"TSdlGpuTransferBufferCreateInfo","text":"<p>A record specifying the parameters of a transfer buffer. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferCreateInfo/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuTransferBufferCreateInfo = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferCreateInfo/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuTransferBuffer</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferCreateInfo/#properties","title":"Properties","text":"Name Description Props A properties ID for extensions. Should be 0 if no extensions are needed. Size The size in bytes of the transfer buffer. Usage How the transfer buffer is intended to be used by the client."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferCreateInfo/#methods","title":"Methods","text":"Name Description Create Create with default values. Init Init with default values."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferCreateInfo/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferCreateInfo/#Props","title":"Props","text":"<p>A properties ID for extensions. Should be 0 if no extensions are needed. </p> <p><code>property Props: TSdlProperties read GetProps write SetProps</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferCreateInfo/#Size","title":"Size","text":"<p>The size in bytes of the transfer buffer. </p> <p><code>property Size: Integer read FHandle.size write FHandle.size</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferCreateInfo/#Usage","title":"Usage","text":"<p>How the transfer buffer is intended to be used by the client. </p> <p><code>property Usage: TSdlGpuTransferBufferUsage read GetUsage write SetUsage</code></p> <p>Type: <code>TSdlGpuTransferBufferUsage</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferCreateInfo/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferCreateInfo/#Create","title":"Create","text":"<p>Create with default values. </p> <p><code>class function Create: TSdlGpuTransferBufferCreateInfo; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferCreateInfo/#returns","title":"Returns","text":"<p><code>TSdlGpuTransferBufferCreateInfo</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferCreateInfo/#Init","title":"Init","text":"<p>Init with default values. </p> <p><code>procedure Init; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferLocation/","title":"TSdlGpuTransferBufferLocation","text":"<p>A record specifying a location in a transfer buffer.</p> <p>Used when transferring buffer data to or from a transfer buffer. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferLocation/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuTransferBufferLocation = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferLocation/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCopyPass.UploadToTexture</li> <li>TSdlGpuCopyPass.DownloadFromTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferLocation/#properties","title":"Properties","text":"Name Description Offset The starting byte of the buffer data in the transfer buffer. TransferBuffer The transfer buffer used in the transfer operation."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferLocation/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferLocation/#Offset","title":"Offset","text":"<p>The starting byte of the buffer data in the transfer buffer. </p> <p><code>property Offset: Integer read FHandle.offset write FHandle.offset</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuTransferBufferLocation/#TransferBuffer","title":"TransferBuffer","text":"<p>The transfer buffer used in the transfer operation. </p> <p><code>property TransferBuffer: TSdlGpuTransferBuffer read GetTransferBuffer write SetTransferBuffer</code></p> <p>Type: <code>TSdlGpuTransferBuffer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexAttribute/","title":"TSdlGpuVertexAttribute","text":"<p>A record specifying a vertex attribute.</p> <p>All vertex attribute locations provided to an TSdlGpuVertexInputState must be unique. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexAttribute/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuVertexAttribute = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexAttribute/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuVertexBufferDescription</li> <li>TSdlGpuVertexInputState</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexAttribute/#properties","title":"Properties","text":"Name Description BufferSlot The binding slot of the associated vertex buffer. Format The size and type of the attribute data. Location The shader input location index. Offset The byte offset of this attribute relative to the start of the vertex element."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexAttribute/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexAttribute/#BufferSlot","title":"BufferSlot","text":"<p>The binding slot of the associated vertex buffer. </p> <p><code>property BufferSlot: Integer read FHandle.buffer_slot write FHandle.buffer_slot</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexAttribute/#Format","title":"Format","text":"<p>The size and type of the attribute data. </p> <p><code>property Format: TSdlGpuVertexElementFormat read GetFormat write SetFormat</code></p> <p>Type: <code>TSdlGpuVertexElementFormat</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexAttribute/#Location","title":"Location","text":"<p>The shader input location index. </p> <p><code>property Location: Integer read FHandle.location write FHandle.location</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexAttribute/#Offset","title":"Offset","text":"<p>The byte offset of this attribute relative to the start of the vertex element. </p> <p><code>property Offset: Integer read FHandle.offset write FHandle.offset</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexBufferDescription/","title":"TSdlGpuVertexBufferDescription","text":"<p>A record specifying the parameters of vertex buffers used in a graphics pipeline.</p> <p>When you call TSdlGpuRenderPass.BindVertexBuffers, you specify the binding slots of the vertex buffers. For example if you called TSdlGpuRenderPass.BindVertexBuffers with a AFirstSlot of 2 and ANumBindings of 3, the binding slots 2, 3, 4 would be used by the vertex buffers you pass in.</p> <p>Vertex attributes are linked to buffers via the BufferSlot field of TSdlGpuVertexAttribute. For example, if an attribute has a buffer_slot of 0, then that attribute belongs to the vertex buffer bound at slot 0. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexBufferDescription/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuVertexBufferDescription = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexBufferDescription/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuVertexAttribute</li> <li>TSdlGpuVertexInputState</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexBufferDescription/#properties","title":"Properties","text":"Name Description InputRate Whether attribute addressing is a function of the vertex index or instance index. InstanceStepRate The number of instances to draw using the same per-instance data before advancing in the instance buffer by one element. Ignored unless input_rate is SDL_GPU_VERTEXINPUTRATE_INSTANCE Pitch The byte pitch between consecutive elements of the vertex buffer. Slot The binding slot of the vertex buffer."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexBufferDescription/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexBufferDescription/#InputRate","title":"InputRate","text":"<p>Whether attribute addressing is a function of the vertex index or instance index. </p> <p><code>property InputRate: TSdlGpuVertexInputRate read GetInputRate write SetInputRate</code></p> <p>Type: <code>TSdlGpuVertexInputRate</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexBufferDescription/#InstanceStepRate","title":"InstanceStepRate","text":"<p>The number of instances to draw using the same per-instance data before advancing in the instance buffer by one element. Ignored unless input_rate is SDL_GPU_VERTEXINPUTRATE_INSTANCE </p> <p><code>property InstanceStepRate: Integer read FHandle.instance_step_rate write FHandle.instance_step_rate</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexBufferDescription/#Pitch","title":"Pitch","text":"<p>The byte pitch between consecutive elements of the vertex buffer. </p> <p><code>property Pitch: Integer read FHandle.pitch write FHandle.pitch</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexBufferDescription/#Slot","title":"Slot","text":"<p>The binding slot of the vertex buffer. </p> <p><code>property Slot: Integer read FHandle.slot write FHandle.slot</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexInputState/","title":"TSdlGpuVertexInputState","text":"<p>A record specifying the parameters of a graphics pipeline vertex input state. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexInputState/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuVertexInputState = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexInputState/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipelineCreateInfo</li> <li>TSdlGpuVertexBufferDescription</li> <li>TSdlGpuVertexAttribute</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexInputState/#properties","title":"Properties","text":"Name Description VertexAttributes An array of vertex attribute descriptions. VertexBufferDescriptions An array of vertex buffer descriptions."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexInputState/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexInputState/#VertexAttributes","title":"VertexAttributes","text":"<p>An array of vertex attribute descriptions. </p> <p><code>property VertexAttributes: TArray&lt;TSdlGpuVertexAttribute&gt; read FVertexAttributes write SetVertexAttributes</code></p> <p>Type: <code>TArray&lt;TSdlGpuVertexAttribute&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuVertexInputState/#VertexBufferDescriptions","title":"VertexBufferDescriptions","text":"<p>An array of vertex buffer descriptions. </p> <p><code>property VertexBufferDescriptions: TArray&lt;TSdlGpuVertexBufferDescription&gt; read FVertexBufferDescriptions write SetVertexBufferDescriptions</code></p> <p>Type: <code>TArray&lt;TSdlGpuVertexBufferDescription&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuViewport/","title":"TSdlGpuViewport","text":"<p>A record specifying a viewport. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuViewport/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuViewport = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuViewport/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuRenderPass.SetViewport</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuViewport/#fields","title":"Fields","text":"Name Description H The height of the viewport. MaxDepth The maximum depth of the viewport. MinDepth The minimum depth of the viewport. W The width of the viewport. X The left offset of the viewport. Y The top offset of the viewport."},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuViewport/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuViewport/#H","title":"H","text":"<p>The height of the viewport. </p> <p><code>var H: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuViewport/#MaxDepth","title":"MaxDepth","text":"<p>The maximum depth of the viewport. </p> <p><code>var MaxDepth: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuViewport/#MinDepth","title":"MinDepth","text":"<p>The minimum depth of the viewport. </p> <p><code>var MinDepth: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuViewport/#W","title":"W","text":"<p>The width of the viewport. </p> <p><code>var W: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuViewport/#X","title":"X","text":"<p>The left offset of the viewport. </p> <p><code>var X: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/classes/TSdlGpuViewport/#Y","title":"Y","text":"<p>The top offset of the viewport. </p> <p><code>var Y: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/PSdlGpuBlitRegion/","title":"PSdlGpuBlitRegion","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/PSdlGpuBlitRegion/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type PSdlGpuBlitRegion = ^TSdlGpuBlitRegion\n</code></pre> <p>Base type: <code>TSdlGpuBlitRegion</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/PSdlGpuColorTargetBlendState/","title":"PSdlGpuColorTargetBlendState","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/PSdlGpuColorTargetBlendState/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type PSdlGpuColorTargetBlendState = ^TSdlGpuColorTargetBlendState\n</code></pre> <p>Base type: <code>TSdlGpuColorTargetBlendState</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/PSdlGpuDepthStencilState/","title":"PSdlGpuDepthStencilState","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/PSdlGpuDepthStencilState/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type PSdlGpuDepthStencilState = ^TSdlGpuDepthStencilState\n</code></pre> <p>Base type: <code>TSdlGpuDepthStencilState</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/PSdlGpuGraphicsPipelineCreateInfo/","title":"PSdlGpuGraphicsPipelineCreateInfo","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/PSdlGpuGraphicsPipelineCreateInfo/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type PSdlGpuGraphicsPipelineCreateInfo = ^TSdlGpuGraphicsPipelineCreateInfo\n</code></pre> <p>Base type: <code>TSdlGpuGraphicsPipelineCreateInfo</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/PSdlGpuMultisampleState/","title":"PSdlGpuMultisampleState","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/PSdlGpuMultisampleState/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type PSdlGpuMultisampleState = ^TSdlGpuMultisampleState\n</code></pre> <p>Base type: <code>TSdlGpuMultisampleState</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/PSdlGpuRasterizerState/","title":"PSdlGpuRasterizerState","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/PSdlGpuRasterizerState/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type PSdlGpuRasterizerState = ^TSdlGpuRasterizerState\n</code></pre> <p>Base type: <code>TSdlGpuRasterizerState</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/PSdlGpuStencilOpState/","title":"PSdlGpuStencilOpState","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/PSdlGpuStencilOpState/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type PSdlGpuStencilOpState = ^TSdlGpuStencilOpState\n</code></pre> <p>Base type: <code>TSdlGpuStencilOpState</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/","title":"TSdlGpuBlendFactor","text":"<p>Specifies a blending factor to be used when pixels in a render target are blended with existing pixels in the texture.</p> <p>The source color is the value written by the fragment shader. The destination color is the value currently existing in the texture. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuBlendFactor = (Invalid, Zero, One, SrcColor, OneMinusSrcColor, DstColor, OneMinusDstColor, SrcAlpha, OneMinusSrcAlpha, DstAlpha, OneMinusDstAlpha, ConstantColor, OneMinusConstantColor, SrcAlphaSaturate)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#invalid-sdl_gpu_blendfactor_invalid","title":"<code>Invalid = SDL_GPU_BLENDFACTOR_INVALID</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#zero-sdl_gpu_blendfactor_zero","title":"<code>Zero = SDL_GPU_BLENDFACTOR_ZERO</code>","text":"<p>0 </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#one-sdl_gpu_blendfactor_one","title":"<code>One = SDL_GPU_BLENDFACTOR_ONE</code>","text":"<p>1 </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#srccolor-sdl_gpu_blendfactor_src_color","title":"<code>SrcColor = SDL_GPU_BLENDFACTOR_SRC_COLOR</code>","text":"<p>Source color </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#oneminussrccolor-sdl_gpu_blendfactor_one_minus_src_color","title":"<code>OneMinusSrcColor = SDL_GPU_BLENDFACTOR_ONE_MINUS_SRC_COLOR</code>","text":"<p>1 - Source color </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#dstcolor-sdl_gpu_blendfactor_dst_color","title":"<code>DstColor = SDL_GPU_BLENDFACTOR_DST_COLOR</code>","text":"<p>Destination color </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#oneminusdstcolor-sdl_gpu_blendfactor_one_minus_dst_color","title":"<code>OneMinusDstColor = SDL_GPU_BLENDFACTOR_ONE_MINUS_DST_COLOR</code>","text":"<p>1 - Destination color </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#srcalpha-sdl_gpu_blendfactor_src_alpha","title":"<code>SrcAlpha = SDL_GPU_BLENDFACTOR_SRC_ALPHA</code>","text":"<p>Source alpha </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#oneminussrcalpha-sdl_gpu_blendfactor_one_minus_src_alpha","title":"<code>OneMinusSrcAlpha = SDL_GPU_BLENDFACTOR_ONE_MINUS_SRC_ALPHA</code>","text":"<p>1 - Source alpha </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#dstalpha-sdl_gpu_blendfactor_dst_alpha","title":"<code>DstAlpha = SDL_GPU_BLENDFACTOR_DST_ALPHA</code>","text":"<p>Destination alpha </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#oneminusdstalpha-sdl_gpu_blendfactor_one_minus_dst_alpha","title":"<code>OneMinusDstAlpha = SDL_GPU_BLENDFACTOR_ONE_MINUS_DST_ALPHA</code>","text":"<p>1 - Destination alpha </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#constantcolor-sdl_gpu_blendfactor_constant_color","title":"<code>ConstantColor = SDL_GPU_BLENDFACTOR_CONSTANT_COLOR</code>","text":"<p>Blend constant </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#oneminusconstantcolor-sdl_gpu_blendfactor_one_minus_constant_color","title":"<code>OneMinusConstantColor = SDL_GPU_BLENDFACTOR_ONE_MINUS_CONSTANT_COLOR</code>","text":"<p>1 - Blend constant </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendFactor/#srcalphasaturate-sdl_gpu_blendfactor_src_alpha_saturate","title":"<code>SrcAlphaSaturate = SDL_GPU_BLENDFACTOR_SRC_ALPHA_SATURATE</code>","text":"<p>Min(Source alpha, 1 - Destination alpha) </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendOp/","title":"TSdlGpuBlendOp","text":"<p>Specifies the operator to be used when pixels in a render target are blended with existing pixels in the texture.</p> <p>The source color is the value written by the fragment shader. The destination color is the value currently existing in the texture. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendOp/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuBlendOp = (Invalid, Add, Subtract, ReverseSubtract, Min, Max)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendOp/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendOp/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendOp/#invalid-sdl_gpu_blendop_invalid","title":"<code>Invalid = SDL_GPU_BLENDOP_INVALID</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendOp/#add-sdl_gpu_blendop_add","title":"<code>Add = SDL_GPU_BLENDOP_ADD</code>","text":"<p>(Source * SourceFactor) + (Destination * DestinationFactor) </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendOp/#subtract-sdl_gpu_blendop_subtract","title":"<code>Subtract = SDL_GPU_BLENDOP_SUBTRACT</code>","text":"<p>(Source * SourceFactor) - (Destination * DestinationFactor) </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendOp/#reversesubtract-sdl_gpu_blendop_reverse_subtract","title":"<code>ReverseSubtract = SDL_GPU_BLENDOP_REVERSE_SUBTRACT</code>","text":"<p>(Destination * DestinationFactor) - (Source * SourceFactor) </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendOp/#min-sdl_gpu_blendop_min","title":"<code>Min = SDL_GPU_BLENDOP_MIN</code>","text":"<p>Min(Source, Destination) </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBlendOp/#max-sdl_gpu_blendop_max","title":"<code>Max = SDL_GPU_BLENDOP_MAX</code>","text":"<p>Max(Source, Destination) </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBufferUsageFlag/","title":"TSdlGpuBufferUsageFlag","text":"<p>Specifies how a buffer is intended to be used by the client.</p> <p>A buffer must have at least one usage flag. Note that some usage flag combinations are invalid.</p> <p>Unlike textures, [Read, Write] can be used for simultaneous read-write usage. The same data synchronization concerns as textures apply. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBufferUsageFlag/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuBufferUsageFlag = (Vertex, Index, Indirect, GraphicsStorageRead, ComputeStorageRead, ComputeStorageWrite)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBufferUsageFlag/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuBuffer</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBufferUsageFlag/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBufferUsageFlag/#vertex-0","title":"<code>Vertex = 0</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBufferUsageFlag/#index-1","title":"<code>Index = 1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBufferUsageFlag/#indirect-2","title":"<code>Indirect = 2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBufferUsageFlag/#graphicsstorageread-3","title":"<code>GraphicsStorageRead = 3</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBufferUsageFlag/#computestorageread-4","title":"<code>ComputeStorageRead = 4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBufferUsageFlag/#computestoragewrite-5","title":"<code>ComputeStorageWrite = 5</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBufferUsageFlags/","title":"TSdlGpuBufferUsageFlags","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuBufferUsageFlags/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuBufferUsageFlags = set of TSdlGpuBufferUsageFlag\n</code></pre> <p>Base type: <code>TSdlGpuBufferUsageFlag</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuColorComponentFlag/","title":"TSdlGpuColorComponentFlag","text":"<p>Specifies which color components are written in a graphics pipeline. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuColorComponentFlag/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuColorComponentFlag = (R, G, B, A)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuColorComponentFlag/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuColorComponentFlag/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuColorComponentFlag/#r-0","title":"<code>R = 0</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuColorComponentFlag/#g-1","title":"<code>G = 1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuColorComponentFlag/#b-2","title":"<code>B = 2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuColorComponentFlag/#a-3","title":"<code>A = 3</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuColorComponentFlags/","title":"TSdlGpuColorComponentFlags","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuColorComponentFlags/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuColorComponentFlags = set of TSdlGpuColorComponentFlag\n</code></pre> <p>Base type: <code>TSdlGpuColorComponentFlag</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCompareOp/","title":"TSdlGpuCompareOp","text":"<p>Specifies a comparison operator for depth, stencil and sampler operations. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCompareOp/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuCompareOp = (Invalid, Never, Less, Equal, LessOrEqual, Greater, NotEqual, GreaterOrEqual, Always)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCompareOp/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCompareOp/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCompareOp/#invalid-sdl_gpu_compareop_invalid","title":"<code>Invalid = SDL_GPU_COMPAREOP_INVALID</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCompareOp/#never-sdl_gpu_compareop_never","title":"<code>Never = SDL_GPU_COMPAREOP_NEVER</code>","text":"<p>The comparison always evaluates false. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCompareOp/#less-sdl_gpu_compareop_less","title":"<code>Less = SDL_GPU_COMPAREOP_LESS</code>","text":"<p>The comparison evaluates reference </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCompareOp/#equal-sdl_gpu_compareop_equal","title":"<code>Equal = SDL_GPU_COMPAREOP_EQUAL</code>","text":"<p>The comparison evaluates reference = test. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCompareOp/#lessorequal-sdl_gpu_compareop_less_or_equal","title":"<code>LessOrEqual = SDL_GPU_COMPAREOP_LESS_OR_EQUAL</code>","text":"<p>The comparison evaluates reference </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCompareOp/#greater-sdl_gpu_compareop_greater","title":"<code>Greater = SDL_GPU_COMPAREOP_GREATER</code>","text":"<p>The comparison evaluates reference &gt; test. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCompareOp/#notequal-sdl_gpu_compareop_not_equal","title":"<code>NotEqual = SDL_GPU_COMPAREOP_NOT_EQUAL</code>","text":"<p>The comparison evaluates reference &lt;&gt;test. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCompareOp/#greaterorequal-sdl_gpu_compareop_greater_or_equal","title":"<code>GreaterOrEqual = SDL_GPU_COMPAREOP_GREATER_OR_EQUAL</code>","text":"<p>The comparison evalutes reference &gt;= test. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCompareOp/#always-sdl_gpu_compareop_always","title":"<code>Always = SDL_GPU_COMPAREOP_ALWAYS</code>","text":"<p>The comparison always evaluates true. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCubeMapFace/","title":"TSdlGpuCubeMapFace","text":"<p>Specifies the face of a cube map.</p> <p>Can be passed in as the layer field in texture-related structs. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCubeMapFace/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuCubeMapFace = (PositiveX, NegativeX, PositiveY, NegativeY, PositiveZ, NegativeZ)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCubeMapFace/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCubeMapFace/#positivex-sdl_gpu_cubemapface_positivex","title":"<code>PositiveX = SDL_GPU_CUBEMAPFACE_POSITIVEX</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCubeMapFace/#negativex-sdl_gpu_cubemapface_negativex","title":"<code>NegativeX = SDL_GPU_CUBEMAPFACE_NEGATIVEX</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCubeMapFace/#positivey-sdl_gpu_cubemapface_positivey","title":"<code>PositiveY = SDL_GPU_CUBEMAPFACE_POSITIVEY</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCubeMapFace/#negativey-sdl_gpu_cubemapface_negativey","title":"<code>NegativeY = SDL_GPU_CUBEMAPFACE_NEGATIVEY</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCubeMapFace/#positivez-sdl_gpu_cubemapface_positivez","title":"<code>PositiveZ = SDL_GPU_CUBEMAPFACE_POSITIVEZ</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCubeMapFace/#negativez-sdl_gpu_cubemapface_negativez","title":"<code>NegativeZ = SDL_GPU_CUBEMAPFACE_NEGATIVEZ</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCullMode/","title":"TSdlGpuCullMode","text":"<p>Specifies the facing direction in which triangle faces will be culled. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCullMode/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuCullMode = (None, Front, Back)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCullMode/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCullMode/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCullMode/#none-sdl_gpu_cullmode_none","title":"<code>None = SDL_GPU_CULLMODE_NONE</code>","text":"<p>No triangles are culled. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCullMode/#front-sdl_gpu_cullmode_front","title":"<code>Front = SDL_GPU_CULLMODE_FRONT</code>","text":"<p>Front-facing triangles are culled. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuCullMode/#back-sdl_gpu_cullmode_back","title":"<code>Back = SDL_GPU_CULLMODE_BACK</code>","text":"<p>Back-facing triangles are culled. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFillMode/","title":"TSdlGpuFillMode","text":"<p>Specifies the fill mode of the graphics pipeline. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFillMode/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuFillMode = (Fill, Line)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFillMode/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFillMode/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFillMode/#fill-sdl_gpu_fillmode_fill","title":"<code>Fill = SDL_GPU_FILLMODE_FILL</code>","text":"<p>Polygons will be rendered via rasterization. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFillMode/#line-sdl_gpu_fillmode_line","title":"<code>Line = SDL_GPU_FILLMODE_LINE</code>","text":"<p>Polygon edges will be drawn as line segments. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFilter/","title":"TSdlGpuFilter","text":"<p>Specifies a filter operation used by a sampler. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFilter/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuFilter = (Nearest, Linear)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFilter/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuSampler</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFilter/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFilter/#nearest-sdl_gpu_filter_nearest","title":"<code>Nearest = SDL_GPU_FILTER_NEAREST</code>","text":"<p>Point filtering. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFilter/#linear-sdl_gpu_filter_linear","title":"<code>Linear = SDL_GPU_FILTER_LINEAR</code>","text":"<p>Linear filtering. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFrontFace/","title":"TSdlGpuFrontFace","text":"<p>Specifies the vertex winding that will cause a triangle to be determined to be front-facing. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFrontFace/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuFrontFace = (CounterClockwise, Clockwise)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFrontFace/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFrontFace/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFrontFace/#counterclockwise-sdl_gpu_frontface_counter_clockwise","title":"<code>CounterClockwise = SDL_GPU_FRONTFACE_COUNTER_CLOCKWISE</code>","text":"<p>A triangle with counter-clockwise vertex winding will be considered front-facing. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuFrontFace/#clockwise-sdl_gpu_frontface_clockwise","title":"<code>Clockwise = SDL_GPU_FRONTFACE_CLOCKWISE</code>","text":"<p>A triangle with clockwise vertex winding will be considered front-facing. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuIndexElementSize/","title":"TSdlGpuIndexElementSize","text":"<p>Specifies the size of elements in an index buffer. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuIndexElementSize/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuIndexElementSize = (Unsigned16Bit, Unsigned32Bit)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuIndexElementSize/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuIndexElementSize/#remarks","title":"Remarks","text":"<p>This enum is available since SDL 3.2.0. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuIndexElementSize/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuIndexElementSize/#unsigned16bit-sdl_gpu_indexelementsize_16bit","title":"<code>Unsigned16Bit = SDL_GPU_INDEXELEMENTSIZE_16BIT</code>","text":"<p>The index elements are 16-bit. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuIndexElementSize/#unsigned32bit-sdl_gpu_indexelementsize_32bit","title":"<code>Unsigned32Bit = SDL_GPU_INDEXELEMENTSIZE_32BIT</code>","text":"<p>The index elements are 32-bit. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuLoadOp/","title":"TSdlGpuLoadOp","text":"<p>Specifies how the contents of a texture attached to a render pass are treated at the beginning of the render pass. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuLoadOp/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuLoadOp = (Load, Clear, DontCare)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuLoadOp/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.BeginRenderPass</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuLoadOp/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuLoadOp/#load-sdl_gpu_loadop_load","title":"<code>Load = SDL_GPU_LOADOP_LOAD</code>","text":"<p>The previous contents of the texture will be preserved. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuLoadOp/#clear-sdl_gpu_loadop_clear","title":"<code>Clear = SDL_GPU_LOADOP_CLEAR</code>","text":"<p>The contents of the texture will be cleared to a color. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuLoadOp/#dontcare-sdl_gpu_loadop_dont_care","title":"<code>DontCare = SDL_GPU_LOADOP_DONT_CARE</code>","text":"<p>The previous contents of the texture need not be preserved. The contents will be undefined. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuPresentMode/","title":"TSdlGpuPresentMode","text":"<p>Specifies the timing that will be used to present swapchain textures to the OS.</p> <p>VSync mode will always be supported. Immediate and Mailbox modes may not be supported on certain systems.</p> <p>It is recommended to query TSdlGpuDevice.WindowSupportsPresentMode after claiming the window if you wish to change the present mode to Immediate or Mailbox.</p> <ul> <li>VSync: Waits for vblank before presenting. No tearing is possible. If there is a pending image to present, the new image is enqueued for presentation. Disallows tearing at the cost of visual latency.</li> <li>Immediate: Immediately presents. Lowest latency option, but tearing may occur.</li> <li>Mailbox: Waits for vblank before presenting. No tearing is possible. If there is a pending image to present, the pending image is replaced by the new image. Similar to VSync, but with reduced visual latency. </li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuPresentMode/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuPresentMode = (VSync, Immediate, Mailbox)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuPresentMode/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuDevice.SetSwapchainParameters</li> <li>TSdlGpuDevice.WindowSupportsPresentMode</li> <li>TSdlGpuCommandBuffer.WaitAndAcquireSwapchainTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuPresentMode/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuPresentMode/#vsync-sdl_gpu_presentmode_vsync","title":"<code>VSync = SDL_GPU_PRESENTMODE_VSYNC</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuPresentMode/#immediate-sdl_gpu_presentmode_immediate","title":"<code>Immediate = SDL_GPU_PRESENTMODE_IMMEDIATE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuPresentMode/#mailbox-sdl_gpu_presentmode_mailbox","title":"<code>Mailbox = SDL_GPU_PRESENTMODE_MAILBOX</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuPrimitiveType/","title":"TSdlGpuPrimitiveType","text":"<p>Specifies the primitive topology of a graphics pipeline.</p> <p>If you are using PointList you must include a point size output in the vertex shader.</p> <ul> <li>For HLSL compiling to SPIRV you must decorate a float output with [[vk::builtin(\"PointSize\")]].</li> <li>For GLSL you must set the gl_PointSize builtin.</li> <li>For MSL you must include a float output with the [[point_size]] decorator.</li> </ul> <p>Note that sized point topology is totally unsupported on D3D12. Any size other than 1 will be ignored. In general, you should avoid using point topology for both compatibility and performance reasons. You WILL regret using it. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuPrimitiveType/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuPrimitiveType = (TriangleList, TriangleStrip, LineList, LineStrip, PointList)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuPrimitiveType/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuPrimitiveType/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuPrimitiveType/#trianglelist-sdl_gpu_primitivetype_trianglelist","title":"<code>TriangleList = SDL_GPU_PRIMITIVETYPE_TRIANGLELIST</code>","text":"<p>A series of separate triangles. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuPrimitiveType/#trianglestrip-sdl_gpu_primitivetype_trianglestrip","title":"<code>TriangleStrip = SDL_GPU_PRIMITIVETYPE_TRIANGLESTRIP</code>","text":"<p>A series of connected triangles. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuPrimitiveType/#linelist-sdl_gpu_primitivetype_linelist","title":"<code>LineList = SDL_GPU_PRIMITIVETYPE_LINELIST</code>","text":"<p>A series of separate lines. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuPrimitiveType/#linestrip-sdl_gpu_primitivetype_linestrip","title":"<code>LineStrip = SDL_GPU_PRIMITIVETYPE_LINESTRIP</code>","text":"<p>A series of connected lines. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuPrimitiveType/#pointlist-sdl_gpu_primitivetype_pointlist","title":"<code>PointList = SDL_GPU_PRIMITIVETYPE_POINTLIST</code>","text":"<p>A series of separate points. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSampleCount/","title":"TSdlGpuSampleCount","text":"<p>Specifies the sample count of a texture.</p> <p>Used in multisampling. Note that this value only applies when the texture is used as a render target. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSampleCount/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuSampleCount = (One, Two, Four, Eight)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSampleCount/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuTexture</li> <li>TSdlGpuDevice.TextureSupportsSampleCount</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSampleCount/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSampleCount/#one-sdl_gpu_samplecount_1","title":"<code>One = SDL_GPU_SAMPLECOUNT_1</code>","text":"<p>No multisampling. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSampleCount/#two-sdl_gpu_samplecount_2","title":"<code>Two = SDL_GPU_SAMPLECOUNT_2</code>","text":"<p>MSAA 2x </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSampleCount/#four-sdl_gpu_samplecount_4","title":"<code>Four = SDL_GPU_SAMPLECOUNT_4</code>","text":"<p>MSAA 4x </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSampleCount/#eight-sdl_gpu_samplecount_8","title":"<code>Eight = SDL_GPU_SAMPLECOUNT_8</code>","text":"<p>MSAA 8x </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSamplerAddressMode/","title":"TSdlGpuSamplerAddressMode","text":"<p>Specifies behavior of texture sampling when the coordinates exceed the 0-1 range. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSamplerAddressMode/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuSamplerAddressMode = (&amp;Repeat, MirroredRepeat, ClampToEdge)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSamplerAddressMode/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuSampler</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSamplerAddressMode/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSamplerAddressMode/#repeat-sdl_gpu_sampleraddressmode_repeat","title":"<code>&amp;Repeat = SDL_GPU_SAMPLERADDRESSMODE_REPEAT</code>","text":"<p>Specifies that the coordinates will wrap around. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSamplerAddressMode/#mirroredrepeat-sdl_gpu_sampleraddressmode_mirrored_repeat","title":"<code>MirroredRepeat = SDL_GPU_SAMPLERADDRESSMODE_MIRRORED_REPEAT</code>","text":"<p>Specifies that the coordinates will wrap around mirrored. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSamplerAddressMode/#clamptoedge-sdl_gpu_sampleraddressmode_clamp_to_edge","title":"<code>ClampToEdge = SDL_GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE</code>","text":"<p>Specifies that the coordinates will clamp to the 0-1 range. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSamplerMipmapMode/","title":"TSdlGpuSamplerMipmapMode","text":"<p>Specifies a mipmap mode used by a sampler. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSamplerMipmapMode/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuSamplerMipmapMode = (Nearest, Linear)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSamplerMipmapMode/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuSampler</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSamplerMipmapMode/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSamplerMipmapMode/#nearest-sdl_gpu_samplermipmapmode_nearest","title":"<code>Nearest = SDL_GPU_SAMPLERMIPMAPMODE_NEAREST</code>","text":"<p>Point filtering. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSamplerMipmapMode/#linear-sdl_gpu_samplermipmapmode_linear","title":"<code>Linear = SDL_GPU_SAMPLERMIPMAPMODE_LINEAR</code>","text":"<p>Linear filtering. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderFormat/","title":"TSdlGpuShaderFormat","text":"<p>Specifies the format of shader code.</p> <p>Each format corresponds to a specific backend that accepts it. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderFormat/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuShaderFormat = (&amp;Private, SpirV, Dxbc, Dxil, Msl, MetalLib)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderFormat/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuShader</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderFormat/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderFormat/#private-0","title":"<code>&amp;Private = 0</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderFormat/#spirv-1","title":"<code>SpirV = 1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderFormat/#dxbc-2","title":"<code>Dxbc = 2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderFormat/#dxil-3","title":"<code>Dxil = 3</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderFormat/#msl-4","title":"<code>Msl = 4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderFormat/#metallib-5","title":"<code>MetalLib = 5</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderFormats/","title":"TSdlGpuShaderFormats","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderFormats/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuShaderFormats = set of TSdlGpuShaderFormat\n</code></pre> <p>Base type: <code>TSdlGpuShaderFormat</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderStage/","title":"TSdlGpuShaderStage","text":"<p>Specifies which stage a shader program corresponds to. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderStage/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuShaderStage = (Vertex, Fragment)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderStage/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuShader</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderStage/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderStage/#vertex-sdl_gpu_shaderstage_vertex","title":"<code>Vertex = SDL_GPU_SHADERSTAGE_VERTEX</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuShaderStage/#fragment-sdl_gpu_shaderstage_fragment","title":"<code>Fragment = SDL_GPU_SHADERSTAGE_FRAGMENT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStencilOp/","title":"TSdlGpuStencilOp","text":"<p>Specifies what happens to a stored stencil value if stencil tests fail or pass. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStencilOp/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuStencilOp = (Invalid, Keep, Zero, Replace, IncrementAndClamp, DecrementAndClamp, Invert, IncrementAndWrap, DecrementAndWrap)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStencilOp/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStencilOp/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStencilOp/#invalid-sdl_gpu_stencilop_invalid","title":"<code>Invalid = SDL_GPU_STENCILOP_INVALID</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStencilOp/#keep-sdl_gpu_stencilop_keep","title":"<code>Keep = SDL_GPU_STENCILOP_KEEP</code>","text":"<p>Keeps the current value. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStencilOp/#zero-sdl_gpu_stencilop_zero","title":"<code>Zero = SDL_GPU_STENCILOP_ZERO</code>","text":"<p>Sets the value to 0. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStencilOp/#replace-sdl_gpu_stencilop_replace","title":"<code>Replace = SDL_GPU_STENCILOP_REPLACE</code>","text":"<p>Sets the value to reference. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStencilOp/#incrementandclamp-sdl_gpu_stencilop_increment_and_clamp","title":"<code>IncrementAndClamp = SDL_GPU_STENCILOP_INCREMENT_AND_CLAMP</code>","text":"<p>Increments the current value and clamps to the maximum value. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStencilOp/#decrementandclamp-sdl_gpu_stencilop_decrement_and_clamp","title":"<code>DecrementAndClamp = SDL_GPU_STENCILOP_DECREMENT_AND_CLAMP</code>","text":"<p>Decrements the current value and clamps to 0. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStencilOp/#invert-sdl_gpu_stencilop_invert","title":"<code>Invert = SDL_GPU_STENCILOP_INVERT</code>","text":"<p>Bitwise-inverts the current value. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStencilOp/#incrementandwrap-sdl_gpu_stencilop_increment_and_wrap","title":"<code>IncrementAndWrap = SDL_GPU_STENCILOP_INCREMENT_AND_WRAP</code>","text":"<p>Increments the current value and wraps back to 0. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStencilOp/#decrementandwrap-sdl_gpu_stencilop_decrement_and_wrap","title":"<code>DecrementAndWrap = SDL_GPU_STENCILOP_DECREMENT_AND_WRAP</code>","text":"<p>Decrements the current value and wraps to the maximum value. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStoreOp/","title":"TSdlGpuStoreOp","text":"<p>Specifies how the contents of a texture attached to a render pass are treated at the end of the render pass. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStoreOp/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuStoreOp = (Store, DontCare, Resolve, ResolveAndStore)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStoreOp/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuCommandBuffer.BeginRenderPass</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStoreOp/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStoreOp/#store-sdl_gpu_storeop_store","title":"<code>Store = SDL_GPU_STOREOP_STORE</code>","text":"<p>The contents generated during the render pass will be written to memory. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStoreOp/#dontcare-sdl_gpu_storeop_dont_care","title":"<code>DontCare = SDL_GPU_STOREOP_DONT_CARE</code>","text":"<p>The contents generated during the render pass are not needed and may be discarded. The contents will be undefined. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStoreOp/#resolve-sdl_gpu_storeop_resolve","title":"<code>Resolve = SDL_GPU_STOREOP_RESOLVE</code>","text":"<p>The multisample contents generated during the render pass will be resolved to a non-multisample texture. The contents in the multisample texture may then be discarded and will be undefined. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuStoreOp/#resolveandstore-sdl_gpu_storeop_resolve_and_store","title":"<code>ResolveAndStore = SDL_GPU_STOREOP_RESOLVE_AND_STORE</code>","text":"<p>The multisample contents generated during the render pass will be resolved to a non-multisample texture. The contents in the multisample texture will be written to memory. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSwapchainComposition/","title":"TSdlGpuSwapchainComposition","text":"<p>Specifies the texture format and colorspace of the swapchain textures.</p> <p>Sdr will always be supported. Other compositions may not be supported on certain systems.</p> <p>It is recommended to query TSdlGpuDevice.WindowSupportsSwapchainComposition after claiming the window if you wish to change the swapchain composition from Sdr.</p> <ul> <li>Sdr: B8G8R8A8 or R8G8B8A8 swapchain. Pixel values are in sRGB encoding.</li> <li>SdrLinear: B8G8R8A8Srgb or R8G8B8A8Srgb swapchain. Pixel values are stored in memory in sRGB encoding but accessed in shaders in \"linear sRGB\" encoding which is sRGB but with a linear transfer function.</li> <li>HdrExtendedLinear: R16G16B16A16Float swapchain. Pixel values are in extended linear sRGB encoding and permits values outside of the [0, 1] range.</li> <li>Hdr10ST2084: A2R10G10B10 or A2B10G10R10 swapchain. Pixel values are in BT.2020 ST2084 (PQ) encoding. </li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSwapchainComposition/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuSwapchainComposition = (Sdr, SdrLinear, HdrExtendedLinear, Hdr10ST2084)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSwapchainComposition/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuDevice.SetSwapchainParameters</li> <li>TSdlGpuDevice.WindowSupportsSwapchainComposition</li> <li>TSdlGpuCommandBuffer.WaitAndAcquireSwapchainTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSwapchainComposition/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSwapchainComposition/#sdr-sdl_gpu_swapchaincomposition_sdr","title":"<code>Sdr = SDL_GPU_SWAPCHAINCOMPOSITION_SDR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSwapchainComposition/#sdrlinear-sdl_gpu_swapchaincomposition_sdr_linear","title":"<code>SdrLinear = SDL_GPU_SWAPCHAINCOMPOSITION_SDR_LINEAR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSwapchainComposition/#hdrextendedlinear-sdl_gpu_swapchaincomposition_hdr_extended_linear","title":"<code>HdrExtendedLinear = SDL_GPU_SWAPCHAINCOMPOSITION_HDR_EXTENDED_LINEAR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuSwapchainComposition/#hdr10st2084-sdl_gpu_swapchaincomposition_hdr10_st2084","title":"<code>Hdr10ST2084 = SDL_GPU_SWAPCHAINCOMPOSITION_HDR10_ST2084</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/","title":"TSdlGpuTextureFormat","text":"<p>Specifies the pixel format of a texture.</p> <p>Texture format support varies depending on driver, hardware, and usage flags. In general, you should use TSdlGpuDevice.SupportedTextureFormats to query if a format is supported before using it. However, there are a few guaranteed formats.</p> <p>For Sampler usage, the following formats are universally supported:</p> <ul> <li>R8G8B8A8UNorm</li> <li>B8G8R8A8UNorm</li> <li>R8UNorm</li> <li>R8SNorm</li> <li>R8G8UNorm</li> <li>R8G8SNorm</li> <li>R8G8B8A8SNorm</li> <li>R16Float</li> <li>R16G16Float</li> <li>R16G16B16A16Float</li> <li>R32Float</li> <li>R32G32Float</li> <li>R32G32B32A32Float</li> <li>R11G11B10Float</li> <li>R8G8B8A8UNormSrgb</li> <li>B8G8R8A8UNormSrgb</li> <li>D16UNorm</li> </ul> <p>For ColorTarget usage, the following formats are universally supported:</p> <ul> <li>R8G8B8A8UNorm</li> <li>B8G8R8A8UNorm</li> <li>R8UNorm</li> <li>R16Float</li> <li>R16G16Float</li> <li>R16G16B16A16Float</li> <li>R32Float</li> <li>R32G32Float</li> <li>R32G32B32A32Float</li> <li>R11G11B10Float</li> <li>R8UInt</li> <li>R8G8UInt</li> <li>R8G8B8A8UInt</li> <li>R16UInt</li> <li>R16G16UInt</li> <li>R16G16B16A16UInt</li> <li>R8Int</li> <li>R8G8Int</li> <li>R8G8B8A8Int</li> <li>R16Int</li> <li>R16G16Int</li> <li>R16G16B16A16Int</li> <li>R8G8B8A8UNormSrgb</li> <li>B8G8R8A8UNormSrgb</li> </ul> <p>For Storage usages, the following formats are universally supported:</p> <ul> <li>R8G8B8A8UNorm</li> <li>R8G8B8A8SNorm</li> <li>R16G16B16A16Float</li> <li>R32Float</li> <li>R32G32Float</li> <li>R32G32B32A32Float</li> <li>R8G8B8A8UInt</li> <li>R16G16B16A16UInt</li> <li>R8G8B8A8OInt</li> <li>R16G16B16A16Int</li> </ul> <p>For DepthStencilTarget usage, the following formats are universally supported:</p> <ul> <li>D16UNorm</li> <li>Either (but not necessarily both!) D24UNorm or D32Float</li> <li>Either (but not necessarily both!) D24UNormS8UInt or D32FloatS8UInt</li> </ul> <p>Unless D16UNorm is sufficient for your purposes, always check which of D24/D32 is supported before creating a depth-stencil texture! </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuTextureFormat = (Invalid, A8UNorm, R8UNorm, R8G8UNorm, R8G8B8A8UNorm, R16UNorm, R16G16UNorm, R16G16B16A16UNorm, R10G10B10A2UNorm, B5G6R5UNorm, B5G5R5A1UNorm, B4G4R4A4UNorm, B8G8R8A8UNorm, BC1RgbaUNorm, BC2RgbaUNorm...)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuTexture</li> <li>TSdlGpuDevice.TextureSupportsFormat</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#invalid-sdl_gpu_textureformat_invalid","title":"<code>Invalid = SDL_GPU_TEXTUREFORMAT_INVALID</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#a8unorm-sdl_gpu_textureformat_a8_unorm","title":"<code>A8UNorm = SDL_GPU_TEXTUREFORMAT_A8_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r8unorm-sdl_gpu_textureformat_r8_unorm","title":"<code>R8UNorm = SDL_GPU_TEXTUREFORMAT_R8_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r8g8unorm-sdl_gpu_textureformat_r8g8_unorm","title":"<code>R8G8UNorm = SDL_GPU_TEXTUREFORMAT_R8G8_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r8g8b8a8unorm-sdl_gpu_textureformat_r8g8b8a8_unorm","title":"<code>R8G8B8A8UNorm = SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r16unorm-sdl_gpu_textureformat_r16_unorm","title":"<code>R16UNorm = SDL_GPU_TEXTUREFORMAT_R16_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r16g16unorm-sdl_gpu_textureformat_r16g16_unorm","title":"<code>R16G16UNorm = SDL_GPU_TEXTUREFORMAT_R16G16_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r16g16b16a16unorm-sdl_gpu_textureformat_r16g16b16a16_unorm","title":"<code>R16G16B16A16UNorm = SDL_GPU_TEXTUREFORMAT_R16G16B16A16_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r10g10b10a2unorm-sdl_gpu_textureformat_r10g10b10a2_unorm","title":"<code>R10G10B10A2UNorm = SDL_GPU_TEXTUREFORMAT_R10G10B10A2_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#b5g6r5unorm-sdl_gpu_textureformat_b5g6r5_unorm","title":"<code>B5G6R5UNorm = SDL_GPU_TEXTUREFORMAT_B5G6R5_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#b5g5r5a1unorm-sdl_gpu_textureformat_b5g5r5a1_unorm","title":"<code>B5G5R5A1UNorm = SDL_GPU_TEXTUREFORMAT_B5G5R5A1_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#b4g4r4a4unorm-sdl_gpu_textureformat_b4g4r4a4_unorm","title":"<code>B4G4R4A4UNorm = SDL_GPU_TEXTUREFORMAT_B4G4R4A4_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#b8g8r8a8unorm-sdl_gpu_textureformat_b8g8r8a8_unorm","title":"<code>B8G8R8A8UNorm = SDL_GPU_TEXTUREFORMAT_B8G8R8A8_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#bc1rgbaunorm-sdl_gpu_textureformat_bc1_rgba_unorm","title":"<code>BC1RgbaUNorm = SDL_GPU_TEXTUREFORMAT_BC1_RGBA_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#bc2rgbaunorm-sdl_gpu_textureformat_bc2_rgba_unorm","title":"<code>BC2RgbaUNorm = SDL_GPU_TEXTUREFORMAT_BC2_RGBA_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#bc3rgbaunorm-sdl_gpu_textureformat_bc3_rgba_unorm","title":"<code>BC3RgbaUNorm = SDL_GPU_TEXTUREFORMAT_BC3_RGBA_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#bc4runorm-sdl_gpu_textureformat_bc4_r_unorm","title":"<code>BC4RUNorm = SDL_GPU_TEXTUREFORMAT_BC4_R_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#bc5rgunorm-sdl_gpu_textureformat_bc5_rg_unorm","title":"<code>BC5RGUNorm = SDL_GPU_TEXTUREFORMAT_BC5_RG_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#bc7rgbaunorm-sdl_gpu_textureformat_bc7_rgba_unorm","title":"<code>BC7RgbaUNorm = SDL_GPU_TEXTUREFORMAT_BC7_RGBA_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#bc6hrgbfloat-sdl_gpu_textureformat_bc6h_rgb_float","title":"<code>BC6HRgbFloat = SDL_GPU_TEXTUREFORMAT_BC6H_RGB_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#bc6hrgbufloat-sdl_gpu_textureformat_bc6h_rgb_ufloat","title":"<code>BC6HRgbUFloat = SDL_GPU_TEXTUREFORMAT_BC6H_RGB_UFLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r8snorm-sdl_gpu_textureformat_r8_snorm","title":"<code>R8SNorm = SDL_GPU_TEXTUREFORMAT_R8_SNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r8g8snorm-sdl_gpu_textureformat_r8g8_snorm","title":"<code>R8G8SNorm = SDL_GPU_TEXTUREFORMAT_R8G8_SNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r8g8b8a8snorm-sdl_gpu_textureformat_r8g8b8a8_snorm","title":"<code>R8G8B8A8SNorm = SDL_GPU_TEXTUREFORMAT_R8G8B8A8_SNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r16snorm-sdl_gpu_textureformat_r16_snorm","title":"<code>R16SNorm = SDL_GPU_TEXTUREFORMAT_R16_SNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r16g16snorm-sdl_gpu_textureformat_r16g16_snorm","title":"<code>R16G16SNorm = SDL_GPU_TEXTUREFORMAT_R16G16_SNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r16g16b16a16snorm-sdl_gpu_textureformat_r16g16b16a16_snorm","title":"<code>R16G16B16A16SNorm = SDL_GPU_TEXTUREFORMAT_R16G16B16A16_SNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r16float-sdl_gpu_textureformat_r16_float","title":"<code>R16Float = SDL_GPU_TEXTUREFORMAT_R16_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r16g16float-sdl_gpu_textureformat_r16g16_float","title":"<code>R16G16Float = SDL_GPU_TEXTUREFORMAT_R16G16_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r16g16b16a16float-sdl_gpu_textureformat_r16g16b16a16_float","title":"<code>R16G16B16A16Float = SDL_GPU_TEXTUREFORMAT_R16G16B16A16_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r32float-sdl_gpu_textureformat_r32_float","title":"<code>R32Float = SDL_GPU_TEXTUREFORMAT_R32_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r32g32float-sdl_gpu_textureformat_r32g32_float","title":"<code>R32G32Float = SDL_GPU_TEXTUREFORMAT_R32G32_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r32g32b32a32float-sdl_gpu_textureformat_r32g32b32a32_float","title":"<code>R32G32B32A32Float = SDL_GPU_TEXTUREFORMAT_R32G32B32A32_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r11g11b10ufloat-sdl_gpu_textureformat_r11g11b10_ufloat","title":"<code>R11G11B10UFloat = SDL_GPU_TEXTUREFORMAT_R11G11B10_UFLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r8uint-sdl_gpu_textureformat_r8_uint","title":"<code>R8UInt = SDL_GPU_TEXTUREFORMAT_R8_UINT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r8g8uint-sdl_gpu_textureformat_r8g8_uint","title":"<code>R8G8UInt = SDL_GPU_TEXTUREFORMAT_R8G8_UINT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r8g8b8a8uint-sdl_gpu_textureformat_r8g8b8a8_uint","title":"<code>R8G8B8A8UInt = SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UINT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r16uint-sdl_gpu_textureformat_r16_uint","title":"<code>R16UInt = SDL_GPU_TEXTUREFORMAT_R16_UINT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r16g16uint-sdl_gpu_textureformat_r16g16_uint","title":"<code>R16G16UInt = SDL_GPU_TEXTUREFORMAT_R16G16_UINT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r16g16b16a16uint-sdl_gpu_textureformat_r16g16b16a16_uint","title":"<code>R16G16B16A16UInt = SDL_GPU_TEXTUREFORMAT_R16G16B16A16_UINT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r32uint-sdl_gpu_textureformat_r32_uint","title":"<code>R32UInt = SDL_GPU_TEXTUREFORMAT_R32_UINT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r32g32uint-sdl_gpu_textureformat_r32g32_uint","title":"<code>R32G32UInt = SDL_GPU_TEXTUREFORMAT_R32G32_UINT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r32g32b32a32uint-sdl_gpu_textureformat_r32g32b32a32_uint","title":"<code>R32G32B32A32UInt = SDL_GPU_TEXTUREFORMAT_R32G32B32A32_UINT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r8int-sdl_gpu_textureformat_r8_int","title":"<code>R8Int = SDL_GPU_TEXTUREFORMAT_R8_INT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r8g8int-sdl_gpu_textureformat_r8g8_int","title":"<code>R8G8Int = SDL_GPU_TEXTUREFORMAT_R8G8_INT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r8g8b8a8int-sdl_gpu_textureformat_r8g8b8a8_int","title":"<code>R8G8B8A8Int = SDL_GPU_TEXTUREFORMAT_R8G8B8A8_INT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r16int-sdl_gpu_textureformat_r16_int","title":"<code>R16Int = SDL_GPU_TEXTUREFORMAT_R16_INT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r16g16int-sdl_gpu_textureformat_r16g16_int","title":"<code>R16G16Int = SDL_GPU_TEXTUREFORMAT_R16G16_INT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r16g16b16a16int-sdl_gpu_textureformat_r16g16b16a16_int","title":"<code>R16G16B16A16Int = SDL_GPU_TEXTUREFORMAT_R16G16B16A16_INT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r32int-sdl_gpu_textureformat_r32_int","title":"<code>R32Int = SDL_GPU_TEXTUREFORMAT_R32_INT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r32g32int-sdl_gpu_textureformat_r32g32_int","title":"<code>R32G32Int = SDL_GPU_TEXTUREFORMAT_R32G32_INT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r32g32b32a32int-sdl_gpu_textureformat_r32g32b32a32_int","title":"<code>R32G32B32A32Int = SDL_GPU_TEXTUREFORMAT_R32G32B32A32_INT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#r8g8b8a8unormsrgb-sdl_gpu_textureformat_r8g8b8a8_unorm_srgb","title":"<code>R8G8B8A8UNormSrgb = SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#b8g8r8a8unormsrgb-sdl_gpu_textureformat_b8g8r8a8_unorm_srgb","title":"<code>B8G8R8A8UNormSrgb = SDL_GPU_TEXTUREFORMAT_B8G8R8A8_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#bc1rgbaunormsrgb-sdl_gpu_textureformat_bc1_rgba_unorm_srgb","title":"<code>BC1RgbaUNormSrgb = SDL_GPU_TEXTUREFORMAT_BC1_RGBA_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#bc2rgbaunormsrgb-sdl_gpu_textureformat_bc2_rgba_unorm_srgb","title":"<code>BC2RgbaUNormSrgb = SDL_GPU_TEXTUREFORMAT_BC2_RGBA_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#bc3rgbaunormsrgb-sdl_gpu_textureformat_bc3_rgba_unorm_srgb","title":"<code>BC3RgbaUNormSrgb = SDL_GPU_TEXTUREFORMAT_BC3_RGBA_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#bc7rgbaunormsrgb-sdl_gpu_textureformat_bc7_rgba_unorm_srgb","title":"<code>BC7RgbaUNormSrgb = SDL_GPU_TEXTUREFORMAT_BC7_RGBA_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#d16unorm-sdl_gpu_textureformat_d16_unorm","title":"<code>D16UNorm = SDL_GPU_TEXTUREFORMAT_D16_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#d24unorm-sdl_gpu_textureformat_d24_unorm","title":"<code>D24UNorm = SDL_GPU_TEXTUREFORMAT_D24_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#d32float-sdl_gpu_textureformat_d32_float","title":"<code>D32Float = SDL_GPU_TEXTUREFORMAT_D32_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#d24unorms8uint-sdl_gpu_textureformat_d24_unorm_s8_uint","title":"<code>D24UNormS8UInt = SDL_GPU_TEXTUREFORMAT_D24_UNORM_S8_UINT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#d32floats8uint-sdl_gpu_textureformat_d32_float_s8_uint","title":"<code>D32FloatS8UInt = SDL_GPU_TEXTUREFORMAT_D32_FLOAT_S8_UINT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc4x4unorm-sdl_gpu_textureformat_astc_4x4_unorm","title":"<code>Astc4x4UNorm = SDL_GPU_TEXTUREFORMAT_ASTC_4x4_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc5x4unorm-sdl_gpu_textureformat_astc_5x4_unorm","title":"<code>Astc5x4UNorm = SDL_GPU_TEXTUREFORMAT_ASTC_5x4_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc5x5unorm-sdl_gpu_textureformat_astc_5x5_unorm","title":"<code>Astc5x5UNorm = SDL_GPU_TEXTUREFORMAT_ASTC_5x5_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc6x5unorm-sdl_gpu_textureformat_astc_6x5_unorm","title":"<code>Astc6x5UNorm = SDL_GPU_TEXTUREFORMAT_ASTC_6x5_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc6x6unorm-sdl_gpu_textureformat_astc_6x6_unorm","title":"<code>Astc6x6UNorm = SDL_GPU_TEXTUREFORMAT_ASTC_6x6_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc8x5unorm-sdl_gpu_textureformat_astc_8x5_unorm","title":"<code>Astc8x5UNorm = SDL_GPU_TEXTUREFORMAT_ASTC_8x5_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc8x6unorm-sdl_gpu_textureformat_astc_8x6_unorm","title":"<code>Astc8x6UNorm = SDL_GPU_TEXTUREFORMAT_ASTC_8x6_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc8x8unorm-sdl_gpu_textureformat_astc_8x8_unorm","title":"<code>Astc8x8UNorm = SDL_GPU_TEXTUREFORMAT_ASTC_8x8_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc10x5unorm-sdl_gpu_textureformat_astc_10x5_unorm","title":"<code>Astc10x5UNorm = SDL_GPU_TEXTUREFORMAT_ASTC_10x5_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc10x6unorm-sdl_gpu_textureformat_astc_10x6_unorm","title":"<code>Astc10x6UNorm = SDL_GPU_TEXTUREFORMAT_ASTC_10x6_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc10x8unorm-sdl_gpu_textureformat_astc_10x8_unorm","title":"<code>Astc10x8UNorm = SDL_GPU_TEXTUREFORMAT_ASTC_10x8_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc10x10unorm-sdl_gpu_textureformat_astc_10x10_unorm","title":"<code>Astc10x10UNorm = SDL_GPU_TEXTUREFORMAT_ASTC_10x10_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc12x10unorm-sdl_gpu_textureformat_astc_12x10_unorm","title":"<code>Astc12x10UNorm = SDL_GPU_TEXTUREFORMAT_ASTC_12x10_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc12x12unorm-sdl_gpu_textureformat_astc_12x12_unorm","title":"<code>Astc12x12UNorm = SDL_GPU_TEXTUREFORMAT_ASTC_12x12_UNORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc4x4unormsrgb-sdl_gpu_textureformat_astc_4x4_unorm_srgb","title":"<code>Astc4x4UNormSrgb = SDL_GPU_TEXTUREFORMAT_ASTC_4x4_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc5x4unormsrgb-sdl_gpu_textureformat_astc_5x4_unorm_srgb","title":"<code>Astc5x4UNormSrgb = SDL_GPU_TEXTUREFORMAT_ASTC_5x4_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc5x5unormsrgb-sdl_gpu_textureformat_astc_5x5_unorm_srgb","title":"<code>Astc5x5UNormSrgb = SDL_GPU_TEXTUREFORMAT_ASTC_5x5_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc6x5unormsrgb-sdl_gpu_textureformat_astc_6x5_unorm_srgb","title":"<code>Astc6x5UNormSrgb = SDL_GPU_TEXTUREFORMAT_ASTC_6x5_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc6x6unormsrgb-sdl_gpu_textureformat_astc_6x6_unorm_srgb","title":"<code>Astc6x6UNormSrgb = SDL_GPU_TEXTUREFORMAT_ASTC_6x6_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc8x5unormsrgb-sdl_gpu_textureformat_astc_8x5_unorm_srgb","title":"<code>Astc8x5UNormSrgb = SDL_GPU_TEXTUREFORMAT_ASTC_8x5_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc8x6unormsrgb-sdl_gpu_textureformat_astc_8x6_unorm_srgb","title":"<code>Astc8x6UNormSrgb = SDL_GPU_TEXTUREFORMAT_ASTC_8x6_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc8x8unormsrgb-sdl_gpu_textureformat_astc_8x8_unorm_srgb","title":"<code>Astc8x8UNormSrgb = SDL_GPU_TEXTUREFORMAT_ASTC_8x8_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc10x5unormsrgb-sdl_gpu_textureformat_astc_10x5_unorm_srgb","title":"<code>Astc10x5UNormSrgb = SDL_GPU_TEXTUREFORMAT_ASTC_10x5_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc10x6unormsrgb-sdl_gpu_textureformat_astc_10x6_unorm_srgb","title":"<code>Astc10x6UNormSrgb = SDL_GPU_TEXTUREFORMAT_ASTC_10x6_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc10x8unormsrgb-sdl_gpu_textureformat_astc_10x8_unorm_srgb","title":"<code>Astc10x8UNormSrgb = SDL_GPU_TEXTUREFORMAT_ASTC_10x8_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc10x10unormsrgb-sdl_gpu_textureformat_astc_10x10_unorm_srgb","title":"<code>Astc10x10UNormSrgb = SDL_GPU_TEXTUREFORMAT_ASTC_10x10_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc12x10unormsrgb-sdl_gpu_textureformat_astc_12x10_unorm_srgb","title":"<code>Astc12x10UNormSrgb = SDL_GPU_TEXTUREFORMAT_ASTC_12x10_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc12x12unormsrgb-sdl_gpu_textureformat_astc_12x12_unorm_srgb","title":"<code>Astc12x12UNormSrgb = SDL_GPU_TEXTUREFORMAT_ASTC_12x12_UNORM_SRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc4x4float-sdl_gpu_textureformat_astc_4x4_float","title":"<code>Astc4x4Float = SDL_GPU_TEXTUREFORMAT_ASTC_4x4_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc5x4float-sdl_gpu_textureformat_astc_5x4_float","title":"<code>Astc5x4Float = SDL_GPU_TEXTUREFORMAT_ASTC_5x4_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc5x5float-sdl_gpu_textureformat_astc_5x5_float","title":"<code>Astc5x5Float = SDL_GPU_TEXTUREFORMAT_ASTC_5x5_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc6x5float-sdl_gpu_textureformat_astc_6x5_float","title":"<code>Astc6x5Float = SDL_GPU_TEXTUREFORMAT_ASTC_6x5_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc6x6float-sdl_gpu_textureformat_astc_6x6_float","title":"<code>Astc6x6Float = SDL_GPU_TEXTUREFORMAT_ASTC_6x6_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc8x5float-sdl_gpu_textureformat_astc_8x5_float","title":"<code>Astc8x5Float = SDL_GPU_TEXTUREFORMAT_ASTC_8x5_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc8x6float-sdl_gpu_textureformat_astc_8x6_float","title":"<code>Astc8x6Float = SDL_GPU_TEXTUREFORMAT_ASTC_8x6_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc8x8float-sdl_gpu_textureformat_astc_8x8_float","title":"<code>Astc8x8Float = SDL_GPU_TEXTUREFORMAT_ASTC_8x8_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc10x5float-sdl_gpu_textureformat_astc_10x5_float","title":"<code>Astc10x5Float = SDL_GPU_TEXTUREFORMAT_ASTC_10x5_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc10x6float-sdl_gpu_textureformat_astc_10x6_float","title":"<code>Astc10x6Float = SDL_GPU_TEXTUREFORMAT_ASTC_10x6_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc10x8float-sdl_gpu_textureformat_astc_10x8_float","title":"<code>Astc10x8Float = SDL_GPU_TEXTUREFORMAT_ASTC_10x8_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc10x10float-sdl_gpu_textureformat_astc_10x10_float","title":"<code>Astc10x10Float = SDL_GPU_TEXTUREFORMAT_ASTC_10x10_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc12x10float-sdl_gpu_textureformat_astc_12x10_float","title":"<code>Astc12x10Float = SDL_GPU_TEXTUREFORMAT_ASTC_12x10_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#astc12x12float-sdl_gpu_textureformat_astc_12x12_float","title":"<code>Astc12x12Float = SDL_GPU_TEXTUREFORMAT_ASTC_12x12_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#properties","title":"Properties","text":"Name Description TexelBlockSize The texel block size for the texture format."},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#methods","title":"Methods","text":"Name Description CalculateSize Calculate the size in bytes of a texture format with dimensions."},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#TexelBlockSize","title":"TexelBlockSize","text":"<p>The texel block size for the texture format. </p> <p><code>property TexelBlockSize: Integer read GetTexelBlockSize</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#see-also_1","title":"See Also","text":"<ul> <li>TSdlGpuCopyPass.UploadToTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#CalculateSize","title":"CalculateSize(Integer, Integer, Integer)","text":"<p>Calculate the size in bytes of a texture format with dimensions. </p> <p><code>function CalculateSize(const AWidth, AHeight, ADepthOrLayerCount: Integer): Integer; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#parameters","title":"Parameters","text":"<p><code>AWidth</code>: <code>Integer</code> : Width in pixels.</p> <p><code>AHeight</code>: <code>Integer</code> : Height in pixels.</p> <p><code>ADepthOrLayerCount</code>: <code>Integer</code> : Depth for 3D textures or layer count otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureFormat/#returns","title":"Returns","text":"<p><code>Integer</code>: The size of a texture with this format and dimensions.</p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureKind/","title":"TSdlGpuTextureKind","text":"<p>Specifies the type of a texture. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureKind/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuTextureKind = (TwoD, TwoDArray, ThreeD, Cube, CubeArray)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureKind/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureKind/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureKind/#twod-sdl_gpu_texturetype_2d","title":"<code>TwoD = SDL_GPU_TEXTURETYPE_2D</code>","text":"<p>The texture is a 2-dimensional image. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureKind/#twodarray-sdl_gpu_texturetype_2d_array","title":"<code>TwoDArray = SDL_GPU_TEXTURETYPE_2D_ARRAY</code>","text":"<p>The texture is a 2-dimensional array image. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureKind/#threed-sdl_gpu_texturetype_3d","title":"<code>ThreeD = SDL_GPU_TEXTURETYPE_3D</code>","text":"<p>The texture is a 3-dimensional image. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureKind/#cube-sdl_gpu_texturetype_cube","title":"<code>Cube = SDL_GPU_TEXTURETYPE_CUBE</code>","text":"<p>The texture is a cube image. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureKind/#cubearray-sdl_gpu_texturetype_cube_array","title":"<code>CubeArray = SDL_GPU_TEXTURETYPE_CUBE_ARRAY</code>","text":"<p>The texture is a cube array image. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureUsageFlag/","title":"TSdlGpuTextureUsageFlag","text":"<p>Specifies how a texture is intended to be used by the client.</p> <p>A texture must have at least one usage flag. Note that some usage flag combinations are invalid.</p> <p>With regards to compute storage usage, [Read, Write] means that you can have shader A that only writes into the texture and shader B that only reads from the texture and bind the same texture to either shader respectively. Simultaneous means that you can do reads and writes within the same shader or compute pass. It also implies that atomic ops can be used, since those are read-modify-write operations. If you use Simultaneous, you are responsible for avoiding data races, as there is no data synchronization within a compute pass. Note that Simultaneous usage is only supported by a limited number of texture formats. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureUsageFlag/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuTextureUsageFlag = (Sampler, ColorTarget, DepthStencilTarget, GraphicsStorageRead, ComputeStorageRead, ComputeStorageWrite, ComputeStorageSimultaneousReadWrite)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureUsageFlag/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureUsageFlag/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureUsageFlag/#sampler-0","title":"<code>Sampler = 0</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureUsageFlag/#colortarget-1","title":"<code>ColorTarget = 1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureUsageFlag/#depthstenciltarget-2","title":"<code>DepthStencilTarget = 2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureUsageFlag/#graphicsstorageread-3","title":"<code>GraphicsStorageRead = 3</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureUsageFlag/#computestorageread-4","title":"<code>ComputeStorageRead = 4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureUsageFlag/#computestoragewrite-5","title":"<code>ComputeStorageWrite = 5</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureUsageFlag/#computestoragesimultaneousreadwrite-6","title":"<code>ComputeStorageSimultaneousReadWrite = 6</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureUsageFlags/","title":"TSdlGpuTextureUsageFlags","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTextureUsageFlags/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuTextureUsageFlags = set of TSdlGpuTextureUsageFlag\n</code></pre> <p>Base type: <code>TSdlGpuTextureUsageFlag</code></p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTransferBufferUsage/","title":"TSdlGpuTransferBufferUsage","text":"<p>Specifies how a transfer buffer is intended to be used by the client.</p> <p>Note that mapping and copying FROM an upload transfer buffer or TO a download transfer buffer is undefined behavior. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTransferBufferUsage/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuTransferBufferUsage = (Upload, Download)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTransferBufferUsage/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuTransferBuffer</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTransferBufferUsage/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTransferBufferUsage/#upload-sdl_gpu_transferbufferusage_upload","title":"<code>Upload = SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuTransferBufferUsage/#download-sdl_gpu_transferbufferusage_download","title":"<code>Download = SDL_GPU_TRANSFERBUFFERUSAGE_DOWNLOAD</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/","title":"TSdlGpuVertexElementFormat","text":"<p>Specifies the format of a vertex attribute. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuVertexElementFormat = (Invalid, Int, Int2, Int3, Int4, UInt, UInt2, UInt3, UInt4, Float, Float2, Float3, Float4, Byte2, Byte4...)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#invalid-sdl_gpu_vertexelementformat_invalid","title":"<code>Invalid = SDL_GPU_VERTEXELEMENTFORMAT_INVALID</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#int-sdl_gpu_vertexelementformat_int","title":"<code>Int = SDL_GPU_VERTEXELEMENTFORMAT_INT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#int2-sdl_gpu_vertexelementformat_int2","title":"<code>Int2 = SDL_GPU_VERTEXELEMENTFORMAT_INT2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#int3-sdl_gpu_vertexelementformat_int3","title":"<code>Int3 = SDL_GPU_VERTEXELEMENTFORMAT_INT3</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#int4-sdl_gpu_vertexelementformat_int4","title":"<code>Int4 = SDL_GPU_VERTEXELEMENTFORMAT_INT4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#uint-sdl_gpu_vertexelementformat_uint","title":"<code>UInt = SDL_GPU_VERTEXELEMENTFORMAT_UINT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#uint2-sdl_gpu_vertexelementformat_uint2","title":"<code>UInt2 = SDL_GPU_VERTEXELEMENTFORMAT_UINT2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#uint3-sdl_gpu_vertexelementformat_uint3","title":"<code>UInt3 = SDL_GPU_VERTEXELEMENTFORMAT_UINT3</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#uint4-sdl_gpu_vertexelementformat_uint4","title":"<code>UInt4 = SDL_GPU_VERTEXELEMENTFORMAT_UINT4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#float-sdl_gpu_vertexelementformat_float","title":"<code>Float = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#float2-sdl_gpu_vertexelementformat_float2","title":"<code>Float2 = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#float3-sdl_gpu_vertexelementformat_float3","title":"<code>Float3 = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT3</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#float4-sdl_gpu_vertexelementformat_float4","title":"<code>Float4 = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#byte2-sdl_gpu_vertexelementformat_byte2","title":"<code>Byte2 = SDL_GPU_VERTEXELEMENTFORMAT_BYTE2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#byte4-sdl_gpu_vertexelementformat_byte4","title":"<code>Byte4 = SDL_GPU_VERTEXELEMENTFORMAT_BYTE4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#ubyte2-sdl_gpu_vertexelementformat_ubyte2","title":"<code>UByte2 = SDL_GPU_VERTEXELEMENTFORMAT_UBYTE2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#ubyte4-sdl_gpu_vertexelementformat_ubyte4","title":"<code>UByte4 = SDL_GPU_VERTEXELEMENTFORMAT_UBYTE4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#byte2norm-sdl_gpu_vertexelementformat_byte2_norm","title":"<code>Byte2Norm = SDL_GPU_VERTEXELEMENTFORMAT_BYTE2_NORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#byte4norm-sdl_gpu_vertexelementformat_byte4_norm","title":"<code>Byte4Norm = SDL_GPU_VERTEXELEMENTFORMAT_BYTE4_NORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#ubyte2norm-sdl_gpu_vertexelementformat_ubyte2_norm","title":"<code>UByte2Norm = SDL_GPU_VERTEXELEMENTFORMAT_UBYTE2_NORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#ubyte4norm-sdl_gpu_vertexelementformat_ubyte4_norm","title":"<code>UByte4Norm = SDL_GPU_VERTEXELEMENTFORMAT_UBYTE4_NORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#short2-sdl_gpu_vertexelementformat_short2","title":"<code>Short2 = SDL_GPU_VERTEXELEMENTFORMAT_SHORT2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#short4-sdl_gpu_vertexelementformat_short4","title":"<code>Short4 = SDL_GPU_VERTEXELEMENTFORMAT_SHORT4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#ushort2-sdl_gpu_vertexelementformat_ushort2","title":"<code>UShort2 = SDL_GPU_VERTEXELEMENTFORMAT_USHORT2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#ushort4-sdl_gpu_vertexelementformat_ushort4","title":"<code>UShort4 = SDL_GPU_VERTEXELEMENTFORMAT_USHORT4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#short2norm-sdl_gpu_vertexelementformat_short2_norm","title":"<code>Short2Norm = SDL_GPU_VERTEXELEMENTFORMAT_SHORT2_NORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#short4norm-sdl_gpu_vertexelementformat_short4_norm","title":"<code>Short4Norm = SDL_GPU_VERTEXELEMENTFORMAT_SHORT4_NORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#ushort2norm-sdl_gpu_vertexelementformat_ushort2_norm","title":"<code>UShort2Norm = SDL_GPU_VERTEXELEMENTFORMAT_USHORT2_NORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#ushort4norm-sdl_gpu_vertexelementformat_ushort4_norm","title":"<code>UShort4Norm = SDL_GPU_VERTEXELEMENTFORMAT_USHORT4_NORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#half2-sdl_gpu_vertexelementformat_half2","title":"<code>Half2 = SDL_GPU_VERTEXELEMENTFORMAT_HALF2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexElementFormat/#half4-sdl_gpu_vertexelementformat_half4","title":"<code>Half4 = SDL_GPU_VERTEXELEMENTFORMAT_HALF4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexInputRate/","title":"TSdlGpuVertexInputRate","text":"<p>Specifies the rate at which vertex attributes are pulled from buffers. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexInputRate/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Gpu</p> <pre><code>type TSdlGpuVertexInputRate = (Vertex, Intance)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexInputRate/#see-also","title":"See Also","text":"<ul> <li>TSdlGpuGraphicsPipeline</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexInputRate/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexInputRate/#vertex-sdl_gpu_vertexinputrate_vertex","title":"<code>Vertex = SDL_GPU_VERTEXINPUTRATE_VERTEX</code>","text":"<p>Attribute addressing is a function of the vertex index. </p>"},{"location":"Reference/Neslib.Sdl3.Gpu/types/TSdlGpuVertexInputRate/#intance-sdl_gpu_vertexinputrate_instance","title":"<code>Intance = SDL_GPU_VERTEXINPUTRATE_INSTANCE</code>","text":"<p>Attribute addressing is a function of the instance index. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/","title":"Neslib.Sdl3.Haptic","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/#classes-records","title":"Classes &amp; Records","text":"Name Description TSdlHaptic The haptic record used to identify an SDL haptic. TSdlHapticCondition A record containing a template for a Condition effect. TSdlHapticConstant A record containing a template for a Constant effect. TSdlHapticCustom A record containing a template for the TSdlHapticKind.Custom effect. TSdlHapticDirection Structure that represents a haptic direction. TSdlHapticEffect The generic template for any haptic effect. TSdlHapticID This is a unique ID for a haptic device for the time it is connected to the system, and is never reused for the lifetime of the application. TSdlHapticLeftRight A record containing a template for a Left/Right effect. TSdlHapticPeriodic A record containing a template for a Periodic effect. TSdlHapticRamp A record containing a template for a Ramp effect."},{"location":"Reference/Neslib.Sdl3.Haptic/#types","title":"Types","text":"Name Description PSdlHapticDirection TSdlHapticDirectionKind Types of haptic directions TSdlHapticEffectID A haptic effect ID TSdlHapticFeature Haptic features. TSdlHapticFeatures TSdlHapticKind Types of effects."},{"location":"Reference/Neslib.Sdl3.Haptic/#routines","title":"Routines","text":"Name Description SdlIsJoystickHaptic Query if a joystick has haptic features. SdlIsMouseHaptic Query whether or not the current mouse has haptic capabilities."},{"location":"Reference/Neslib.Sdl3.Haptic/#constants","title":"Constants","text":"Name Description SDL_HAPTIC_INFINITY Used to play a device an infinite number of times."},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/","title":"TSdlHaptic","text":"<p>The haptic record used to identify an SDL haptic. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>type TSdlHaptic = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#properties","title":"Properties","text":"Name Description Features The haptic device's supported features. ID The instance ID of this opened haptic device. IsRumbleSupported Whether rumble is supported on this haptic device. MaxEffects The number of effects a haptic device can store. MaxEffectsPlaying The number of effects a haptic device can play at the same time. Name The implementation dependent name of this haptic device, or an empty string if no name can be found. NumAxes The number of haptic axes the device has."},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#methods","title":"Methods","text":"Name Description Close Close the haptic device previously opened. CreateEffect Create a new haptic effect on this device. FreeEffect Destroy a haptic effect on this device. From Get the haptic device associated with an instance ID, if it has been opened. GetEffectStatus Get the status of the current effect on this haptic device. InitRumble Initialize the haptic device for simple rumble playback. IsEffectSupported Check to see if an effect is supported by the haptic device. Open Open a haptic device for use. OpenFromJoystick Open a haptic device for use from a joystick device. OpenFromMouse Try to open a haptic device from the current mouse. Pause Pause the haptic device. PlayRumble Run a simple rumble effect on the haptic device. Resume Resume the haptic device. RunEffect Run the haptic effect on this haptic device. SetAutoCenter Set the global autocenter of the device. SetGain Set the global gain of the haptic device. StopEffect Stop the haptic effect on this device. StopEffects Stop all the currently playing effects on the haptic device. StopRumble Stop the simple rumble on the haptic device. UpdateEffect Update the properties of an effect."},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#Features","title":"Features","text":"<p>The haptic device's supported features. </p> <p><code>property Features: TSdlHapticFeatures read GetFeatures</code></p> <p>Type: <code>TSdlHapticFeatures</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also","title":"See Also","text":"<ul> <li>IsEffectSupported</li> <li>MaxEffects</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#ID","title":"ID","text":"<p>The instance ID of this opened haptic device. </p> <p><code>property ID: TSdlHapticID read GetID</code></p> <p>Type: <code>TSdlHapticID</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#IsRumbleSupported","title":"IsRumbleSupported","text":"<p>Whether rumble is supported on this haptic device. </p> <p><code>property IsRumbleSupported: Boolean read GetIsRumbleSupported</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_1","title":"See Also","text":"<ul> <li>InitRumble</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#MaxEffects","title":"MaxEffects","text":"<p>The number of effects a haptic device can store.</p> <p>On some platforms this isn't fully supported, and therefore is an approximation. Always check to see if your created effect was actually created and do not rely solely on this property. </p> <p><code>property MaxEffects: Integer read GetMaxEffects</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_2","title":"See Also","text":"<ul> <li>MaxEffectsPlaying</li> <li>Features</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#MaxEffectsPlaying","title":"MaxEffectsPlaying","text":"<p>The number of effects a haptic device can play at the same time.</p> <p>This is not supported on all platforms, but will always return a value. </p> <p><code>property MaxEffectsPlaying: Integer read GetMaxEffectsPlaying</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_3","title":"See Also","text":"<ul> <li>MaxEffects</li> <li>Features</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#Name","title":"Name","text":"<p>The implementation dependent name of this haptic device, or an empty string if no name can be found. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_4","title":"See Also","text":"<ul> <li>TSdlHapticID.Name</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#NumAxes","title":"NumAxes","text":"<p>The number of haptic axes the device has.</p> <p>The number of haptic axes might be useful if working with the TSdlHapticDirection effect. </p> <p><code>property NumAxes: Integer read GetNumAxes</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#Equal","title":"Equal(TSdlHaptic, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlHaptic; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlHaptic</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlHaptic; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#returns_1","title":"Returns","text":"<p><code>TSdlHaptic</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#NotEqual","title":"NotEqual(TSdlHaptic, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlHaptic; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlHaptic</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#Close","title":"Close","text":"<p>Close the haptic device previously opened. </p> <p><code>procedure Close; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_5","title":"See Also","text":"<ul> <li>Open</li> <li>OpenFromMouse</li> <li>OpenFromJoystick</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#CreateEffect","title":"CreateEffect(TSdlHapticEffect)","text":"<p>Create a new haptic effect on this device. </p> <p><code>function CreateEffect(const AEffect: TSdlHapticEffect): TSdlHapticEffectID; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#parameters_3","title":"Parameters","text":"<p><code>AEffect</code>: <code>TSdlHapticEffect</code> : A TSdlHapticEffect record containing the properties of the effect to create.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#returns_3","title":"Returns","text":"<p><code>TSdlHapticEffectID</code>: The effect ID.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_6","title":"See Also","text":"<ul> <li>FreeEffect</li> <li>RunEffect</li> <li>UpdateEffect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#FreeEffect","title":"FreeEffect(TSdlHapticEffectID)","text":"<p>Destroy a haptic effect on this device.</p> <p>This will stop the effect if it's running. Effects are automatically destroyed when the device is closed. </p> <p><code>procedure FreeEffect(const AEffect: TSdlHapticEffectID); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#parameters_4","title":"Parameters","text":"<p><code>AEffect</code>: <code>TSdlHapticEffectID</code> : The ID of the haptic effect to destroy.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_7","title":"See Also","text":"<ul> <li>CreateEffect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#From","title":"From(TSdlHapticID)","text":"<p>Get the haptic device associated with an instance ID, if it has been opened. </p> <p><code>class function From(const AInstanceID: TSdlHapticID): TSdlHaptic; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_6","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure (eg. if it hasn't been opened yet).</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#parameters_5","title":"Parameters","text":"<p><code>AInstanceID</code>: <code>TSdlHapticID</code> : The instance ID to get the haptic device for.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#returns_4","title":"Returns","text":"<p><code>TSdlHaptic</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#GetEffectStatus","title":"GetEffectStatus(TSdlHapticEffectID)","text":"<p>Get the status of the current effect on this haptic device.</p> <p>Device must support the TSdlHapticFeature.Status feature. </p> <p><code>function GetEffectStatus(const AEffect: TSdlHapticEffectID): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#parameters_6","title":"Parameters","text":"<p><code>AEffect</code>: <code>TSdlHapticEffectID</code> : The ID of the haptic effect to query its status.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#returns_5","title":"Returns","text":"<p><code>Boolean</code>: True if it is playing, False if it isn't playing or haptic status isn't supported.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_8","title":"See Also","text":"<ul> <li>Features</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#InitRumble","title":"InitRumble","text":"<p>Initialize the haptic device for simple rumble playback. </p> <p><code>procedure InitRumble; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_7","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_9","title":"See Also","text":"<ul> <li>PlayRumble</li> <li>StopRumble</li> <li>IsRumbleSupported</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#IsEffectSupported","title":"IsEffectSupported(TSdlHapticEffect)","text":"<p>Check to see if an effect is supported by the haptic device. </p> <p><code>function IsEffectSupported(const AEffect: TSdlHapticEffect): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#parameters_7","title":"Parameters","text":"<p><code>AEffect</code>: <code>TSdlHapticEffect</code> : The desired effect to query.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#returns_6","title":"Returns","text":"<p><code>Boolean</code>: True if the effect is supported or False if it isn't.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_10","title":"See Also","text":"<ul> <li>TSdlHapticEffect</li> <li>Features</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#Open","title":"Open(TSdlHapticID)","text":"<p>Open a haptic device for use.</p> <p>When opening a haptic device, its gain will be set to maximum and autocenter will be disabled. To modify these values use TSdlHaptic.SetGain and TSdlHaptic.SetAutoCenter. </p> <p><code>class function Open(const AInstanceID: TSdlHapticID): TSdlHaptic; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_8","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#parameters_8","title":"Parameters","text":"<p><code>AInstanceID</code>: <code>TSdlHapticID</code> : The haptic device instance ID.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#returns_7","title":"Returns","text":"<p><code>TSdlHaptic</code>: The haptic device.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_11","title":"See Also","text":"<ul> <li>TSdlHapticID.Open</li> <li>TSdlHaptic.Close</li> <li>TSdlHapticID.Devices</li> <li>TSdlHaptic.SetAutoCenter</li> <li>TSdlHaptic.SetGain</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#OpenFromJoystick","title":"OpenFromJoystick(TSdlJoystick)","text":"<p>Open a haptic device for use from a joystick device.</p> <p>You must still close the haptic device separately. It will not be closed with the joystick.</p> <p>When opened from a joystick you should first close the haptic device before closing the joystick device. If not, on some implementations the haptic device will also get unallocated and you'll be unable to use force feedback on that device. </p> <p><code>class function OpenFromJoystick(const AJoystick: TSdlJoystick): TSdlHaptic; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_9","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#parameters_9","title":"Parameters","text":"<p><code>AJoystick</code>: <code>TSdlJoystick</code> : The joystick to create a haptic device from.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#returns_8","title":"Returns","text":"<p><code>TSdlHaptic</code>: The haptic device.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_12","title":"See Also","text":"<ul> <li>Close</li> <li>SdlIsJoystickHaptic</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#OpenFromMouse","title":"OpenFromMouse","text":"<p>Try to open a haptic device from the current mouse. </p> <p><code>class function OpenFromMouse: TSdlHaptic; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_10","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#returns_9","title":"Returns","text":"<p><code>TSdlHaptic</code>: The haptic device.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_13","title":"See Also","text":"<ul> <li>Close</li> <li>SdlIsMouseHaptic</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#Pause","title":"Pause","text":"<p>Pause the haptic device.</p> <p>Device must support the <code>TSdlHapticFeature.Pause</code> feature. Call Resume to resume playback.</p> <p>Do not modify the effects nor add new ones while the device is paused. That can cause all sorts of weird errors. </p> <p><code>procedure Pause; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_11","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_14","title":"See Also","text":"<ul> <li>Resume</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#PlayRumble","title":"PlayRumble(Single, Integer)","text":"<p>Run a simple rumble effect on the haptic device. </p> <p><code>procedure PlayRumble(const AStrength: Single; const ALengthMs: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_12","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#parameters_10","title":"Parameters","text":"<p><code>AStrength</code>: <code>Single</code> : Strength of the rumble to play as a 0-1 float value.</p> <p><code>ALengthMs</code>: <code>Integer</code> : Length of the rumble to play in milliseconds.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_15","title":"See Also","text":"<ul> <li>InitRumble</li> <li>StopRumble</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#Resume","title":"Resume","text":"<p>Resume the haptic device.</p> <p>Call to unpause after Pause. </p> <p><code>procedure Resume; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_13","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_16","title":"See Also","text":"<ul> <li>Pause</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#RunEffect","title":"RunEffect(TSdlHapticEffectID, Cardinal)","text":"<p>Run the haptic effect on this haptic device.</p> <p>To repeat the effect over and over indefinitely, set <code>AIterations</code> to <code>SDL_HAPTIC_INFINITY</code>. (Repeats the envelope - attack and fade.) To make one instance of the effect last indefinitely (so the effect does not fade), set the effect's <code>Length</code> in its record to <code>SDL_HAPTIC_INFINITY</code> instead. </p> <p><code>procedure RunEffect(const AEffect: TSdlHapticEffectID; const AIterations: Cardinal); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_14","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#parameters_11","title":"Parameters","text":"<p><code>AEffect</code>: <code>TSdlHapticEffectID</code> : The ID of the haptic effect to run.</p> <p><code>AIterations</code>: <code>Cardinal</code> : The number of iterations to run the effect; use <code>SDL_HAPTIC_INFINITY</code> to repeat forever.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_17","title":"See Also","text":"<ul> <li>GetEffectStatus</li> <li>StopEffect</li> <li>StopEffects</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#SetAutoCenter","title":"SetAutoCenter(Integer)","text":"<p>Set the global autocenter of the device.</p> <p>Autocenter should be between 0 and 100. Setting it to 0 will disable autocentering.</p> <p>Device must support the TSdlHapticFeature.AutoCenter feature. </p> <p><code>procedure SetAutoCenter(const AAutoCenter: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_15","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#parameters_12","title":"Parameters","text":"<p><code>AAutoCenter</code>: <code>Integer</code> : Value to set autocenter to (0-100).</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_18","title":"See Also","text":"<ul> <li>Features</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#SetGain","title":"SetGain(Integer)","text":"<p>Set the global gain of the haptic device.</p> <p>Device must support the TSdlHapticFeature.Gain feature.</p> <p>The user may specify the maximum gain by setting the environment variable <code>SDL_HAPTIC_GAIN_MAX</code> which should be between 0 and 100. All calls to SetGain will scale linearly using <code>SDL_HAPTIC_GAIN_MAX</code> as the maximum. </p> <p><code>procedure SetGain(const AGain: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_16","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#parameters_13","title":"Parameters","text":"<p><code>AGain</code>: <code>Integer</code> : Value to set the gain to, should be between 0 and 100.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_19","title":"See Also","text":"<ul> <li>Features</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#StopEffect","title":"StopEffect(TSdlHapticEffectID)","text":"<p>Stop the haptic effect on this device. </p> <p><code>procedure StopEffect(const AEffect: TSdlHapticEffectID); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_17","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#parameters_14","title":"Parameters","text":"<p><code>AEffect</code>: <code>TSdlHapticEffectID</code> : The ID of the haptic effect to stop.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_20","title":"See Also","text":"<ul> <li>RunEffect</li> <li>StopEffects</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#StopEffects","title":"StopEffects","text":"<p>Stop all the currently playing effects on the haptic device. </p> <p><code>procedure StopEffects; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_18","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_21","title":"See Also","text":"<ul> <li>RunEffect</li> <li>StopEffect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#StopRumble","title":"StopRumble","text":"<p>Stop the simple rumble on the haptic device. </p> <p><code>procedure StopRumble; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_22","title":"See Also","text":"<ul> <li>PlayRumble</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#UpdateEffect","title":"UpdateEffect(TSdlHapticEffectID, TSdlHapticEffect)","text":"<p>Update the properties of an effect.</p> <p>Can be used dynamically, although behavior when dynamically changing direction may be strange. Specifically the effect may re-upload itself and start playing from the start. You also cannot change the type either when running UpdateEffect. </p> <p><code>procedure UpdateEffect(const AEffect: TSdlHapticEffectID; const AData: TSdlHapticEffect); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#exceptions_19","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#parameters_15","title":"Parameters","text":"<p><code>AEffect</code>: <code>TSdlHapticEffectID</code> : The identifier of the effect to update.</p> <p><code>AData</code>: <code>TSdlHapticEffect</code> : A TSdlHapticEffect structure containing the new effect properties to use.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHaptic/#see-also_23","title":"See Also","text":"<ul> <li>CreateEffect</li> <li>RunEffect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/","title":"TSdlHapticCondition","text":"<p>A record containing a template for a Condition effect.</p> <p>The record handles the following effects:</p> <ul> <li>TSdlHapticKind.Spring: Effect based on axes position.</li> <li>TSdlHapticKind.Damper: Effect based on axes velocity.</li> <li>TSdlHapticKind.Inertia: Effect based on axes acceleration.</li> <li>TSdlHapticKind.Friction: Effect based on axes movement.</li> </ul> <p>Direction is handled by condition internals instead of a direction member. The condition effect specific members have three parameters. The first refers to the X axis, the second refers to the Y axis and the third refers to the Z axis. The right terms refer to the positive side of the axis and the left terms refer to the negative side of the axis. Please refer to the SDL_HapticDirection diagram for which side is positive and which is negative. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>type TSdlHapticCondition = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/#see-also","title":"See Also","text":"<ul> <li>TSdlHapticDirection</li> <li>TSdlHapticKind</li> <li>TSdlHapticEffect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/#properties","title":"Properties","text":"Name Description Button Button that triggers the effect. Center Position of the dead zone; [0..2]. DeadBand Size of the dead zone; [0..2] max $FFFF: whole axis-range when 0-centered. Delay Delay before starting the effect. Direction Direction of the effect. Interval How soon it can be triggered again after button. Kind TSdlHapticKind.Spring, TSdlHapticKind.Damper, TSdlHapticKind.Inertia or TSdlHapticKind.Friction LeftCoeff How fast to increase the force towards the negative side; [0..2]. LeftSat Level when joystick is to the negative side; [0..2] max $FFFF. Length Duration of the effect in milliseconds. RightCoeff How fast to increase the force towards the positive side; [0..2]. RightSat Level when joystick is to the positive side; [0..2] max $FFFF."},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/#Button","title":"Button","text":"<p>Button that triggers the effect. </p> <p><code>property Button: Word read FHandle.button write FHandle.button</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/#Center","title":"Center","text":"<p>Position of the dead zone; [0..2]. </p> <p><code>property Center[const AIndex: Integer]: Smallint read GetCenter write SetCenter</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/#DeadBand","title":"DeadBand","text":"<p>Size of the dead zone; [0..2] max $FFFF: whole axis-range when 0-centered. </p> <p><code>property DeadBand[const AIndex: Integer]: Word read GetDeadBand write SetDeadBand</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/#Delay","title":"Delay","text":"<p>Delay before starting the effect. </p> <p><code>property Delay: Word read FHandle.delay write FHandle.delay</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/#Direction","title":"Direction","text":"<p>Direction of the effect. </p> <p><code>property Direction: PSdlHapticDirection read GetDirection</code></p> <p>Type: <code>PSdlHapticDirection</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/#Interval","title":"Interval","text":"<p>How soon it can be triggered again after button. </p> <p><code>property Interval: Word read FHandle.interval write FHandle.interval</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/#Kind","title":"Kind","text":"<p>TSdlHapticKind.Spring, TSdlHapticKind.Damper, TSdlHapticKind.Inertia or TSdlHapticKind.Friction </p> <p><code>property Kind: TSdlHapticKind read GetKind write SetKind</code></p> <p>Type: <code>TSdlHapticKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/#LeftCoeff","title":"LeftCoeff","text":"<p>How fast to increase the force towards the negative side; [0..2]. </p> <p><code>property LeftCoeff[const AIndex: Integer]: Smallint read GetLeftCoeff write SetLeftCoeff</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/#LeftSat","title":"LeftSat","text":"<p>Level when joystick is to the negative side; [0..2] max $FFFF. </p> <p><code>property LeftSat[const AIndex: Integer]: Word read GetLeftSat write SetLeftSat</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/#Length","title":"Length","text":"<p>Duration of the effect in milliseconds. </p> <p><code>property Length: Cardinal read FHandle.length write FHandle.length</code></p> <p>Type: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/#RightCoeff","title":"RightCoeff","text":"<p>How fast to increase the force towards the positive side; [0..2]. </p> <p><code>property RightCoeff[const AIndex: Integer]: Smallint read GetRightCoeff write SetRightCoeff</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCondition/#RightSat","title":"RightSat","text":"<p>Level when joystick is to the positive side; [0..2] max $FFFF. </p> <p><code>property RightSat[const AIndex: Integer]: Word read GetRightSat write SetRightSat</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticConstant/","title":"TSdlHapticConstant","text":"<p>A record containing a template for a Constant effect.</p> <p>This record is exclusively for the TSdlHapticKind.Constant effect.</p> <p>A constant effect applies a constant force in the specified direction to the joystick. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticConstant/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>type TSdlHapticConstant = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticConstant/#see-also","title":"See Also","text":"<ul> <li>TSdlHapticKind</li> <li>TSdlHapticEffect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticConstant/#properties","title":"Properties","text":"Name Description AttackLength Duration of the attack. AttackLevel Level at the start of the attack. Button Button that triggers the effect. Delay Delay before starting the effect. Direction Direction of the effect. FadeLength Duration of the fade. FadeLevel Level at the end of the fade. Interval How soon it can be triggered again after button. Kind TSdlHapticKind.Constant Length Duration of the effect in milliseconds. Level Strength of the constant effect."},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticConstant/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticConstant/#AttackLength","title":"AttackLength","text":"<p>Duration of the attack. </p> <p><code>property AttackLength: Word read FHandle.attack_length write FHandle.attack_length</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticConstant/#AttackLevel","title":"AttackLevel","text":"<p>Level at the start of the attack. </p> <p><code>property AttackLevel: Word read FHandle.attack_level write FHandle.attack_level</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticConstant/#Button","title":"Button","text":"<p>Button that triggers the effect. </p> <p><code>property Button: Word read FHandle.button write FHandle.button</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticConstant/#Delay","title":"Delay","text":"<p>Delay before starting the effect. </p> <p><code>property Delay: Word read FHandle.delay write FHandle.delay</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticConstant/#Direction","title":"Direction","text":"<p>Direction of the effect. </p> <p><code>property Direction: PSdlHapticDirection read GetDirection</code></p> <p>Type: <code>PSdlHapticDirection</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticConstant/#FadeLength","title":"FadeLength","text":"<p>Duration of the fade. </p> <p><code>property FadeLength: Word read FHandle.fade_length write FHandle.fade_length</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticConstant/#FadeLevel","title":"FadeLevel","text":"<p>Level at the end of the fade. </p> <p><code>property FadeLevel: Word read FHandle.fade_level write FHandle.fade_level</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticConstant/#Interval","title":"Interval","text":"<p>How soon it can be triggered again after button. </p> <p><code>property Interval: Word read FHandle.interval write FHandle.interval</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticConstant/#Kind","title":"Kind","text":"<p>TSdlHapticKind.Constant </p> <p><code>property Kind: TSdlHapticKind read GetKind write SetKind</code></p> <p>Type: <code>TSdlHapticKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticConstant/#Length","title":"Length","text":"<p>Duration of the effect in milliseconds. </p> <p><code>property Length: Cardinal read FHandle.length write FHandle.length</code></p> <p>Type: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticConstant/#Level","title":"Level","text":"<p>Strength of the constant effect. </p> <p><code>property Level: Smallint read FHandle.level write FHandle.level</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/","title":"TSdlHapticCustom","text":"<p>A record containing a template for the TSdlHapticKind.Custom effect.</p> <p>This record is exclusively for the TSdlHapticKind.Custom effect.</p> <p>A custom force feedback effect is much like a periodic effect, where the application can define its exact shape. You will have to allocate the data yourself. Data should consist of Channels * Samples UInt16 samples.</p> <p>If channels is one, the effect is rotated using the defined direction. Otherwise it uses the samples in data for the different axes. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>type TSdlHapticCustom = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#see-also","title":"See Also","text":"<ul> <li>TSdlHapticKind</li> <li>TSdlHapticEffect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#properties","title":"Properties","text":"Name Description AttackLength Duration of the attack. AttackLevel Level at the start of the attack. Button Button that triggers the effect. Channels Axes to use, minimum of one. Data Should contain channels*samples items. Delay Delay before starting the effect. Direction Direction of the effect. FadeLength Duration of the fade. FadeLevel Level at the end of the fade. Interval How soon it can be triggered again after button. Kind TSdlHapticKind.Custom Length Duration of the effect in milliseconds. Period Sample periods. Samples Amount of samples."},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#AttackLength","title":"AttackLength","text":"<p>Duration of the attack. </p> <p><code>property AttackLength: Word read FHandle.attack_length write FHandle.attack_length</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#AttackLevel","title":"AttackLevel","text":"<p>Level at the start of the attack. </p> <p><code>property AttackLevel: Word read FHandle.attack_level write FHandle.attack_level</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#Button","title":"Button","text":"<p>Button that triggers the effect. </p> <p><code>property Button: Word read FHandle.button write FHandle.button</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#Channels","title":"Channels","text":"<p>Axes to use, minimum of one. </p> <p><code>property Channels: Byte read FHandle.channels write FHandle.channels</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#Data","title":"Data","text":"<p>Should contain channels*samples items. </p> <p><code>property Data: PWord read FHandle.data write FHandle.data</code></p> <p>Type: <code>PWord</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#Delay","title":"Delay","text":"<p>Delay before starting the effect. </p> <p><code>property Delay: Word read FHandle.delay write FHandle.delay</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#Direction","title":"Direction","text":"<p>Direction of the effect. </p> <p><code>property Direction: PSdlHapticDirection read GetDirection</code></p> <p>Type: <code>PSdlHapticDirection</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#FadeLength","title":"FadeLength","text":"<p>Duration of the fade. </p> <p><code>property FadeLength: Word read FHandle.fade_length write FHandle.fade_length</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#FadeLevel","title":"FadeLevel","text":"<p>Level at the end of the fade. </p> <p><code>property FadeLevel: Word read FHandle.fade_level write FHandle.fade_level</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#Interval","title":"Interval","text":"<p>How soon it can be triggered again after button. </p> <p><code>property Interval: Word read FHandle.interval write FHandle.interval</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#Kind","title":"Kind","text":"<p>TSdlHapticKind.Custom </p> <p><code>property Kind: TSdlHapticKind read GetKind write SetKind</code></p> <p>Type: <code>TSdlHapticKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#Length","title":"Length","text":"<p>Duration of the effect in milliseconds. </p> <p><code>property Length: Cardinal read FHandle.length write FHandle.length</code></p> <p>Type: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#Period","title":"Period","text":"<p>Sample periods. </p> <p><code>property Period: Word read FHandle.period write FHandle.period</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticCustom/#Samples","title":"Samples","text":"<p>Amount of samples. </p> <p><code>property Samples: Word read FHandle.samples write FHandle.samples</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticDirection/","title":"TSdlHapticDirection","text":"<p>Structure that represents a haptic direction.</p> <p>This is the direction where the force comes from, instead of the direction in which the force is exerted.</p> <p>Directions can be specified by:</p> <ul> <li>TSdlHapticDirectionKind.Polar    : Specified by polar coordinates.</li> <li>TSdlHapticDirectionKind.Cartesian: Specified by cartesian coordinates.</li> <li>TSdlHapticDirectionKind.Spherical: Specified by spherical coordinates.</li> </ul> <p>Cardinal directions of the haptic device are relative to the positioning of the device. North is considered to be away from the user.</p> <p>The following diagram represents the cardinal directions:</p> <pre><code>                .--.\n                |__| .-------.\n                |=.| |.-----.|\n                |--| ||     ||\n                |  | |'-----'|\n                |__|~')_____('\n                  [ COMPUTER ]\n\n                    North (0,-1)\n                        ^\n                        |\n                        |\n  (-1,0)  West \u02c2----[ HAPTIC ]----\u02c3 East (1,0)\n                        |\n                        |\n                        v\n                     South (0,1)\n\n                     [ USER ]\n                       \\|||/\n                       (o o)\n                 ---ooO-(_)-Ooo---\n</code></pre> <p>If type is TSdlHapticDirectionKind.Polar, direction is encoded by hundredths of a degree starting north and turning clockwise. TSdlHapticDirectionKind.Polar only uses the first <code>Dir</code> property. The cardinal directions would be:</p> <ul> <li>North:     0 (0 degrees)</li> <li>East :  9000 (90 degrees)</li> <li>South: 18000 (180 degrees)</li> <li>West : 27000 (270 degrees)</li> </ul> <p>If type is TSdlHapticDirectionKind.Cartesian, direction is encoded by three positions (X axis, Y axis and Z axis (with 3 axes)). TSdlHapticDirectionKind.Cartesian uses the first three <code>Dir</code> properties. The cardinal directions would be:</p> <ul> <li>North:  0,-1, 0</li> <li>East :  1, 0, 0</li> <li>South:  0, 1, 0</li> <li>West : -1, 0, 0</li> </ul> <p>The Z axis represents the height of the effect if supported, otherwise it's unused. In cartesian encoding (1, 2) would be the same as (2, 4), you can use any multiple you want, only the direction matters.</p> <p>If type is TSdlHapticDirectionKind.Spherical, direction is encoded by two rotations. The first two <code>Dir</code> properties are used. The <code>Dir</code> properties are as follows (all values are in hundredths of degrees):</p> <ul> <li>Degrees from (1, 0) rotated towards (0, 1).</li> <li>Degrees towards (0, 0, 1) (device needs at least 3 axes).</li> </ul> <p>Example of force coming from the south with all encodings (force coming from the south means the user will have to pull the stick to counteract):</p> <pre><code>  var Direction: TSdlHapticDirection;\n\n  // Cartesian directions\n  Direction.Kind := TSdlHapticDirectionKind.Cartesian; // Using cartesian direction encoding.\n  Direction.Dir[0] := 0; // X position\n  Direction.Dir[1] := 1; // Y position\n  // Assuming the device has 2 axes, we don't need to specify third parameter.\n\n  // Polar directions\n  Direction.Kind := TSdlHapticDirectionKind.Polar; // We'll be using polar direction encoding.\n  Direction.Dir[0] := 18000; // Polar only uses first parameter\n\n  // Spherical coordinates\n  Direction.Kind := TSdlHapticDirectionKind.Spherical; // Spherical encoding\n  Direction.Dir[0] := 9000; // Since we only have two axes we don't need more parameters.\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticDirection/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>type TSdlHapticDirection = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticDirection/#see-also","title":"See Also","text":"<ul> <li>TSdlHapticDirectionKind</li> <li>TSdlHapticEffect</li> <li>TSdlHaptic.NumAxes</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticDirection/#properties","title":"Properties","text":"Name Description Dir The encoded direction. Kind The type of encoding."},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticDirection/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticDirection/#Dir","title":"Dir","text":"<p>The encoded direction. </p> <p><code>property Dir[const AIndex: Integer]: Integer read GetDir write SetDir</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticDirection/#Kind","title":"Kind","text":"<p>The type of encoding. </p> <p><code>property Kind: TSdlHapticDirectionKind read GetKind write SetKind</code></p> <p>Type: <code>TSdlHapticDirectionKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticEffect/","title":"TSdlHapticEffect","text":"<p>The generic template for any haptic effect.</p> <p>All values max at 32767 ($7FFF). Signed values also can be negative. Time values unless specified otherwise are in milliseconds.</p> <p>You can also pass SDL_HAPTIC_INFINITY to length instead of a 0-32767 value. Neither Delay, Interval, AttackLength nor FadeLength support SDL_HAPTIC_INFINITY. Fade will also not be used since effect never ends.</p> <p>Additionally, the TSdlHapticKind.Ramp effect does not support a duration of SDL_HAPTIC_INFINITY.</p> <p>Button triggers may not be supported on all devices, it is advised to not use them if possible. Buttons start at index 1 instead of index 0 like the joystick.</p> <p>If both AttackLength and FadeLevel are 0, the envelope is not used, otherwise both values are used.</p> <p>Common parts:</p> <pre><code>  // Replay - All effects have this\n  Length: Cardinal;   // Duration of effect (ms).\n  Delay: Word;        // Delay before starting effect.\n\n  // Trigger - All effects have this\n  Button: Word;       // Button that triggers effect.\n  Interval: Word;     // How soon before effect can be triggered again.\n\n  // Envelope - All effects except condition effects have this\n  AttackLength: Word; // Duration of the attack (ms).\n  AttackLevel: Word;  // Level at the start of the attack.\n  FadeLength: Word;   // Duration of the fade out (ms).\n  FadeLevel: Word;    // Level at the end of the fade.\n</code></pre> <p>Here we have an example of a constant effect evolution in time:</p> <pre><code>  Strength\n  ^\n  |\n  |    effect level --&gt;  _________________\n  |                     /                 \\\n  |                    /                   \\\n  |                   /                     \\\n  |                  /                       \\\n  | attack_level --&gt; |                        \\\n  |                  |                        |  \u02c2---  fade_level\n  |\n  +--------------------------------------------------&gt; Time\n                     [--]                 [---]\n                     attack_length        fade_length\n\n  [------------------][-----------------------]\n  delay               length\n</code></pre> <p>Note either the attack_level or the fade_level may be above the actual effect level. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticEffect/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>type TSdlHapticEffect = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticEffect/#see-also","title":"See Also","text":"<ul> <li>TSdlHapticConstant</li> <li>TSdlHapticPeriodic</li> <li>TSdlHapticCondition</li> <li>TSdlHapticRamp</li> <li>TSdlHapticLeftRight</li> <li>TSdlHapticCustom</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticEffect/#fields","title":"Fields","text":"Name Description Condition Condition effect. Constant Constant effect. Custom Custom effect. Kind Effect type, shared with all effects. LeftRight Left/Right effect. Periodic Periodic effect. Ramp Ramp effect."},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticEffect/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticEffect/#Condition","title":"Condition","text":"<p>Condition effect.</p> <p><code>var Condition: TSdlHapticCondition</code></p> <p>Type: <code>TSdlHapticCondition</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticEffect/#Constant","title":"Constant","text":"<p>Constant effect.</p> <p><code>var Constant: TSdlHapticConstant</code></p> <p>Type: <code>TSdlHapticConstant</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticEffect/#Custom","title":"Custom","text":"<p>Custom effect.</p> <p><code>var Custom: TSdlHapticCustom</code></p> <p>Type: <code>TSdlHapticCustom</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticEffect/#Kind","title":"Kind","text":"<p>Effect type, shared with all effects.</p> <p><code>var Kind: TSdlHapticKind</code></p> <p>Type: <code>TSdlHapticKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticEffect/#LeftRight","title":"LeftRight","text":"<p>Left/Right effect.</p> <p><code>var LeftRight: TSdlHapticLeftRight</code></p> <p>Type: <code>TSdlHapticLeftRight</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticEffect/#Periodic","title":"Periodic","text":"<p>Periodic effect.</p> <p><code>var Periodic: TSdlHapticPeriodic</code></p> <p>Type: <code>TSdlHapticPeriodic</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticEffect/#Ramp","title":"Ramp","text":"<p>Ramp effect.</p> <p><code>var Ramp: TSdlHapticRamp</code></p> <p>Type: <code>TSdlHapticRamp</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/","title":"TSdlHapticID","text":"<p>This is a unique ID for a haptic device for the time it is connected to the system, and is never reused for the lifetime of the application.</p> <p>If the haptic device is disconnected and reconnected, it will get a new ID.</p> <p>The value 0 is an invalid ID. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>type TSdlHapticID = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#properties","title":"Properties","text":"Name Description Devices A list of currently connected haptic devices. Name Get the implementation dependent name of the haptic device, or an empty string if no name can be found."},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>0</code>. Implicit Used to set the value to <code>0</code>. NotEqual Used to compare against <code>0</code>."},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#methods","title":"Methods","text":"Name Description Open Open a haptic device for use."},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#Devices","title":"Devices","text":"<p>A list of currently connected haptic devices. </p> <p><code>class property Devices: TArray&lt;TSdlHapticID&gt; read GetDevices</code></p> <p>Type: <code>TArray&lt;TSdlHapticID&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#see-also","title":"See Also","text":"<ul> <li>Open</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#Name","title":"Name","text":"<p>Get the implementation dependent name of the haptic device, or an empty string if no name can be found.</p> <p>This can be used before any haptic devices are opened. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#see-also_1","title":"See Also","text":"<ul> <li>TSdlHaptic.Name</li> <li>Open</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#Equal","title":"Equal(TSdlHapticID, Cardinal)","text":"<p>Used to compare against <code>0</code>. </p> <p><code>class operator Equal(const ALeft: TSdlHapticID; const ARight: Cardinal): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlHapticID</code></p> <p><code>ARight</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#Implicit","title":"Implicit(Cardinal)","text":"<p>Used to set the value to <code>0</code>. </p> <p><code>class operator Implicit(const AValue: Cardinal): TSdlHapticID; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#returns_1","title":"Returns","text":"<p><code>TSdlHapticID</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#NotEqual","title":"NotEqual(TSdlHapticID, Cardinal)","text":"<p>Used to compare against <code>0</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlHapticID; const ARight: Cardinal): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlHapticID</code></p> <p><code>ARight</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#Open","title":"Open","text":"<p>Open a haptic device for use.</p> <p>When opening a haptic device, its gain will be set to maximum and autocenter will be disabled. To modify these values use TSdlHaptic.SetGain and TSdlHaptic.SetAutoCenter. </p> <p><code>function Open: TSdlHaptic; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#returns_3","title":"Returns","text":"<p><code>TSdlHaptic</code>: The haptic device.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticID/#see-also_2","title":"See Also","text":"<ul> <li>TSdlHaptic.Open</li> <li>TSdlHaptic.Close</li> <li>TSdlHapticID.Devices</li> <li>TSdlHaptic.SetAutoCenter</li> <li>TSdlHaptic.SetGain</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticLeftRight/","title":"TSdlHapticLeftRight","text":"<p>A record containing a template for a Left/Right effect.</p> <p>This record is exclusively for the TSdlHapticKind.LeftRight effect.</p> <p>The Left/Right effect is used to explicitly control the large and small motors, commonly found in modern game controllers. The small (right) motor is high frequency, and the large (left) motor is low frequency. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticLeftRight/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>type TSdlHapticLeftRight = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticLeftRight/#see-also","title":"See Also","text":"<ul> <li>TSdlHapticKind</li> <li>TSdlHapticEffect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticLeftRight/#properties","title":"Properties","text":"Name Description Kind TSdlHapticKind.LeftRight LargeMagnitude Control of the large controller motor. Length Duration of the effect in milliseconds. SmallMagnitude Control of the small controller motor."},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticLeftRight/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticLeftRight/#Kind","title":"Kind","text":"<p>TSdlHapticKind.LeftRight </p> <p><code>property Kind: TSdlHapticKind read GetKind write SetKind</code></p> <p>Type: <code>TSdlHapticKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticLeftRight/#LargeMagnitude","title":"LargeMagnitude","text":"<p>Control of the large controller motor. </p> <p><code>property LargeMagnitude: Word read FHandle.large_magnitude write FHandle.large_magnitude</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticLeftRight/#Length","title":"Length","text":"<p>Duration of the effect in milliseconds. </p> <p><code>property Length: Cardinal read FHandle.length write FHandle.length</code></p> <p>Type: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticLeftRight/#SmallMagnitude","title":"SmallMagnitude","text":"<p>Control of the small controller motor. </p> <p><code>property SmallMagnitude: Word read FHandle.small_magnitude write FHandle.small_magnitude</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/","title":"TSdlHapticPeriodic","text":"<p>A record containing a template for a Periodic effect.</p> <p>The record handles the following effects:</p> <ul> <li>TSdlHapticKind.Sine</li> <li>TSdlHapticKind.Square</li> <li>TSdlHapticKind.Triangle</li> <li>TSdlHapticKind.SawToothUp</li> <li>TSdlHapticKind.SawToothDown</li> </ul> <p>A periodic effect consists in a wave-shaped effect that repeats itself over time. The type determines the shape of the wave and the parameters determine the dimensions of the wave.</p> <p>Phase is given by hundredth of a degree meaning that giving the phase a value of 9000 will displace it 25% of its period. Here are sample values:</p> <ul> <li>0    : No phase displacement.</li> <li>9000 : Displaced 25% of its period.</li> <li>18000: Displaced 50% of its period.</li> <li>27000: Displaced 75% of its period.</li> <li>36000: Displaced 100% of its period, same as 0, but 0 is preferred.</li> </ul> <p>Examples:</p> <pre><code>  TSdlHapticKind.Sine\n    __      __      __      __\n   /  \\    /  \\    /  \\    /\n  /    \\__/    \\__/    \\__/\n\n  TSdlHapticKind.Square\n   __    __    __    __    __\n  |  |  |  |  |  |  |  |  |  |\n  |  |__|  |__|  |__|  |__|  |\n\n  TSdlHapticKind.Triangle\n    /\\    /\\    /\\    /\\    /\\\n   /  \\  /  \\  /  \\  /  \\  /\n  /    \\/    \\/    \\/    \\/\n\n  TSdlHapticKind.SawToothUp\n    /|  /|  /|  /|  /|  /|  /|\n   / | / | / | / | / | / | / |\n  /  |/  |/  |/  |/  |/  |/  |\n\n  TSdlHapticKind.SawToothDown\n  \\  |\\  |\\  |\\  |\\  |\\  |\\  |\n   \\ | \\ | \\ | \\ | \\ | \\ | \\ |\n    \\|  \\|  \\|  \\|  \\|  \\|  \\|\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>type TSdlHapticPeriodic = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#see-also","title":"See Also","text":"<ul> <li>TSdlHapticKind</li> <li>TSdlHapticEffect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#properties","title":"Properties","text":"Name Description AttackLength Duration of the attack. AttackLevel Level at the start of the attack. Button Button that triggers the effect. Delay Delay before starting the effect. Direction Direction of the effect. FadeLength Duration of the fade. FadeLevel Level at the end of the fade. Interval How soon it can be triggered again after button. Kind TSdlHapticKind.Sine, TSdlHapticKind.Square, TSdlHapticKind.Triangle, TSdlHapticKind.SawToothUp or TSdlHapticKind.SawToothDown. Length Duration of the effect in milliseconds. Magnitude Peak value; if negative, equivalent to 180 degrees extra phase shift. Offset Mean value of the wave. Period Period of the wave. Phase Positive phase shift given by hundredth of a degree."},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#AttackLength","title":"AttackLength","text":"<p>Duration of the attack. </p> <p><code>property AttackLength: Word read FHandle.attack_length write FHandle.attack_length</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#AttackLevel","title":"AttackLevel","text":"<p>Level at the start of the attack. </p> <p><code>property AttackLevel: Word read FHandle.attack_level write FHandle.attack_level</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#Button","title":"Button","text":"<p>Button that triggers the effect. </p> <p><code>property Button: Word read FHandle.button write FHandle.button</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#Delay","title":"Delay","text":"<p>Delay before starting the effect. </p> <p><code>property Delay: Word read FHandle.delay write FHandle.delay</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#Direction","title":"Direction","text":"<p>Direction of the effect. </p> <p><code>property Direction: PSdlHapticDirection read GetDirection</code></p> <p>Type: <code>PSdlHapticDirection</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#FadeLength","title":"FadeLength","text":"<p>Duration of the fade. </p> <p><code>property FadeLength: Word read FHandle.fade_length write FHandle.fade_length</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#FadeLevel","title":"FadeLevel","text":"<p>Level at the end of the fade. </p> <p><code>property FadeLevel: Word read FHandle.fade_level write FHandle.fade_level</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#Interval","title":"Interval","text":"<p>How soon it can be triggered again after button. </p> <p><code>property Interval: Word read FHandle.interval write FHandle.interval</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#Kind","title":"Kind","text":"<p>TSdlHapticKind.Sine, TSdlHapticKind.Square, TSdlHapticKind.Triangle, TSdlHapticKind.SawToothUp or TSdlHapticKind.SawToothDown. </p> <p><code>property Kind: TSdlHapticKind read GetKind write SetKind</code></p> <p>Type: <code>TSdlHapticKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#Length","title":"Length","text":"<p>Duration of the effect in milliseconds. </p> <p><code>property Length: Cardinal read FHandle.length write FHandle.length</code></p> <p>Type: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#Magnitude","title":"Magnitude","text":"<p>Peak value; if negative, equivalent to 180 degrees extra phase shift. </p> <p><code>property Magnitude: Smallint read FHandle.magnitude write FHandle.magnitude</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#Offset","title":"Offset","text":"<p>Mean value of the wave. </p> <p><code>property Offset: Smallint read FHandle.offset write FHandle.offset</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#Period","title":"Period","text":"<p>Period of the wave. </p> <p><code>property Period: Word read FHandle.period write FHandle.period</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticPeriodic/#Phase","title":"Phase","text":"<p>Positive phase shift given by hundredth of a degree. </p> <p><code>property Phase: Word read FHandle.phase write FHandle.phase</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/","title":"TSdlHapticRamp","text":"<p>A record containing a template for a Ramp effect.</p> <p>This record is exclusively for the TSdlHapticKind.Ramp effect.</p> <p>The ramp effect starts at start strength and ends at end strength. It augments in linear fashion. If you use attack and fade with a ramp the effects get added to the ramp effect making the effect become quadratic instead of linear. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>type TSdlHapticRamp = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/#see-also","title":"See Also","text":"<ul> <li>TSdlHapticKind</li> <li>TSdlHapticEffect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/#properties","title":"Properties","text":"Name Description &amp;End Ending strength level. AttackLength Duration of the attack. AttackLevel Level at the start of the attack. Button Button that triggers the effect. Delay Delay before starting the effect. Direction Direction of the effect. FadeLength Duration of the fade. FadeLevel Level at the end of the fade. Interval How soon it can be triggered again after button. Kind TSdlHapticKind.Ramp Length Duration of the effect in milliseconds. Start Beginning strength level."},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/#&End","title":"&amp;End","text":"<p>Ending strength level. </p> <p><code>property &amp;End: Smallint read FHandle.&amp;end write FHandle.&amp;end</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/#AttackLength","title":"AttackLength","text":"<p>Duration of the attack. </p> <p><code>property AttackLength: Word read FHandle.attack_length write FHandle.attack_length</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/#AttackLevel","title":"AttackLevel","text":"<p>Level at the start of the attack. </p> <p><code>property AttackLevel: Word read FHandle.attack_level write FHandle.attack_level</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/#Button","title":"Button","text":"<p>Button that triggers the effect. </p> <p><code>property Button: Word read FHandle.button write FHandle.button</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/#Delay","title":"Delay","text":"<p>Delay before starting the effect. </p> <p><code>property Delay: Word read FHandle.delay write FHandle.delay</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/#Direction","title":"Direction","text":"<p>Direction of the effect. </p> <p><code>property Direction: PSdlHapticDirection read GetDirection</code></p> <p>Type: <code>PSdlHapticDirection</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/#FadeLength","title":"FadeLength","text":"<p>Duration of the fade. </p> <p><code>property FadeLength: Word read FHandle.fade_length write FHandle.fade_length</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/#FadeLevel","title":"FadeLevel","text":"<p>Level at the end of the fade. </p> <p><code>property FadeLevel: Word read FHandle.fade_level write FHandle.fade_level</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/#Interval","title":"Interval","text":"<p>How soon it can be triggered again after button. </p> <p><code>property Interval: Word read FHandle.interval write FHandle.interval</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/#Kind","title":"Kind","text":"<p>TSdlHapticKind.Ramp </p> <p><code>property Kind: TSdlHapticKind read GetKind write SetKind</code></p> <p>Type: <code>TSdlHapticKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/#Length","title":"Length","text":"<p>Duration of the effect in milliseconds. </p> <p><code>property Length: Cardinal read FHandle.length write FHandle.length</code></p> <p>Type: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/classes/TSdlHapticRamp/#Start","title":"Start","text":"<p>Beginning strength level. </p> <p><code>property Start: Smallint read FHandle.start write FHandle.start</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/constants/SDL_HAPTIC_INFINITY/","title":"SDL_HAPTIC_INFINITY","text":"<p>Used to play a device an infinite number of times. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/constants/SDL_HAPTIC_INFINITY/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>const SDL_HAPTIC_INFINITY = Neslib.Sdl3.Api.SDL_HAPTIC_INFINITY\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/constants/SDL_HAPTIC_INFINITY/#see-also","title":"See Also","text":"<ul> <li>TSdlHaptic.RunEffect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/routines/SdlIsJoystickHaptic/","title":"SdlIsJoystickHaptic","text":"<p>Query if a joystick has haptic features. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/routines/SdlIsJoystickHaptic/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>function SdlIsJoystickHaptic(const AJoystick: TSdlJoystick): Boolean; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/routines/SdlIsJoystickHaptic/#parameters","title":"Parameters","text":"<p><code>AJoystick</code>: <code>TSdlJoystick</code> : The joystick to test for haptic capabilities.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/routines/SdlIsJoystickHaptic/#returns","title":"Returns","text":"<p><code>Boolean</code>: True if the joystick is haptic or False if it isn't.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/routines/SdlIsJoystickHaptic/#see-also","title":"See Also","text":"<ul> <li>TSdlHaptic.Open</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/routines/SdlIsMouseHaptic/","title":"SdlIsMouseHaptic","text":"<p>Query whether or not the current mouse has haptic capabilities. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/routines/SdlIsMouseHaptic/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>function SdlIsMouseHaptic: Boolean; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/routines/SdlIsMouseHaptic/#returns","title":"Returns","text":"<p><code>Boolean</code>: True if the mouse is haptic or False if it isn't.</p>"},{"location":"Reference/Neslib.Sdl3.Haptic/routines/SdlIsMouseHaptic/#see-also","title":"See Also","text":"<ul> <li>TSdlHaptic.OpenFromMouse</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/PSdlHapticDirection/","title":"PSdlHapticDirection","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/types/PSdlHapticDirection/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>type PSdlHapticDirection = ^TSdlHapticDirection\n</code></pre> <p>Base type: <code>TSdlHapticDirection</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticDirectionKind/","title":"TSdlHapticDirectionKind","text":"<p>Types of haptic directions </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticDirectionKind/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>type TSdlHapticDirectionKind = (Polar, Cartesian, Spherical, SteeringAxis)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticDirectionKind/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticDirectionKind/#polar-sdl_haptic_polar","title":"<code>Polar = SDL_HAPTIC_POLAR</code>","text":"<p>Uses polar coordinates for the direction. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticDirectionKind/#cartesian-sdl_haptic_cartesian","title":"<code>Cartesian = SDL_HAPTIC_CARTESIAN</code>","text":"<p>Uses cartesian coordinates for the direction. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticDirectionKind/#spherical-sdl_haptic_spherical","title":"<code>Spherical = SDL_HAPTIC_SPHERICAL</code>","text":"<p>Uses spherical coordinates for the direction. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticDirectionKind/#steeringaxis-sdl_haptic_steering_axis","title":"<code>SteeringAxis = SDL_HAPTIC_STEERING_AXIS</code>","text":"<p>Use this value to play an effect on the steering wheel axis.</p> <p>This provides better compatibility across platforms and devices as SDL will guess the correct axis. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticEffectID/","title":"TSdlHapticEffectID","text":"<p>A haptic effect ID </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticEffectID/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>type TSdlHapticEffectID = Integer\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/","title":"TSdlHapticFeature","text":"<p>Haptic features. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>type TSdlHapticFeature = (Constant, Sine, Square, Triangle, SawToothUp, SawToothDown, Ramp, Spring, Damper, Inertia, Friction, LeftRight, Custom, Gain, AutoCenter...)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#constant-0","title":"<code>Constant = 0</code>","text":"<p>Supports constant haptic effect. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#sine-1","title":"<code>Sine = 1</code>","text":"<p>Supports periodic haptic effect that simulates sine waves. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#square-2","title":"<code>Square = 2</code>","text":"<p>Supports periodic haptic effect that simulates square waves. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#triangle-3","title":"<code>Triangle = 3</code>","text":"<p>Supports periodic haptic effect that simulates triangular waves. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#sawtoothup-4","title":"<code>SawToothUp = 4</code>","text":"<p>Supports periodic haptic effect that simulates saw tooth up waves. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#sawtoothdown-5","title":"<code>SawToothDown = 5</code>","text":"<p>Supports periodic haptic effect that simulates saw tooth down waves. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#ramp-6","title":"<code>Ramp = 6</code>","text":"<p>Supports ramp haptic effect. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#spring-7","title":"<code>Spring = 7</code>","text":"<p>Supports condition haptic effect that simulates a spring. Effect is based on the axes position. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#damper-8","title":"<code>Damper = 8</code>","text":"<p>Supports condition haptic effect that simulates dampening. Effect is based on the axes velocity. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#inertia-9","title":"<code>Inertia = 9</code>","text":"<p>Supports condition haptic effect that simulates inertia. Effect is based on the axes acceleration. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#friction-10","title":"<code>Friction = 10</code>","text":"<p>Supports condition haptic effect that simulates friction. Effect is based on the axes movement. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#leftright-11","title":"<code>LeftRight = 11</code>","text":"<p>Supports haptic effect for direct control over high/low frequency motors. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#custom-15","title":"<code>Custom = 15</code>","text":"<p>Supports user defined custom haptic effect. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#gain-16","title":"<code>Gain = 16</code>","text":"<p>Device supports setting the global gain. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#autocenter-17","title":"<code>AutoCenter = 17</code>","text":"<p>Device supports setting autocenter. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#status-18","title":"<code>Status = 18</code>","text":"<p>Device supports querying effect status. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeature/#pause-19","title":"<code>Pause = 19</code>","text":"<p>Devices supports being paused. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeatures/","title":"TSdlHapticFeatures","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticFeatures/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>type TSdlHapticFeatures = set of TSdlHapticFeature\n</code></pre> <p>Base type: <code>TSdlHapticFeature</code></p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticKind/","title":"TSdlHapticKind","text":"<p>Types of effects. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticKind/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Haptic</p> <pre><code>type TSdlHapticKind = (Constant, Sine, Square, Triangle, SawToothUp, SawToothDown, Ramp, Spring, Damper, Inertia, Friction, LeftRight, Custom)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticKind/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticKind/#constant-sdl_haptic_constant","title":"<code>Constant = SDL_HAPTIC_CONSTANT</code>","text":"<p>Constant haptic effect. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticKind/#sine-sdl_haptic_sine","title":"<code>Sine = SDL_HAPTIC_SINE</code>","text":"<p>Periodic haptic effect that simulates sine waves. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticKind/#square-sdl_haptic_square","title":"<code>Square = SDL_HAPTIC_SQUARE</code>","text":"<p>Periodic haptic effect that simulates square waves. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticKind/#triangle-sdl_haptic_triangle","title":"<code>Triangle = SDL_HAPTIC_TRIANGLE</code>","text":"<p>Periodic haptic effect that simulates triangular waves. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticKind/#sawtoothup-sdl_haptic_sawtoothup","title":"<code>SawToothUp = SDL_HAPTIC_SAWTOOTHUP</code>","text":"<p>Periodic haptic effect that simulates saw tooth up waves. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticKind/#sawtoothdown-sdl_haptic_sawtoothdown","title":"<code>SawToothDown = SDL_HAPTIC_SAWTOOTHDOWN</code>","text":"<p>Periodic haptic effect that simulates saw tooth down waves. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticKind/#ramp-sdl_haptic_ramp","title":"<code>Ramp = SDL_HAPTIC_RAMP</code>","text":"<p>Ramp haptic effect. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticKind/#spring-sdl_haptic_spring","title":"<code>Spring = SDL_HAPTIC_SPRING</code>","text":"<p>Condition haptic effect that simulates a spring. Effect is based on the axes position. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticKind/#damper-sdl_haptic_damper","title":"<code>Damper = SDL_HAPTIC_DAMPER</code>","text":"<p>Condition haptic effect that simulates dampening. Effect is based on the axes velocity. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticKind/#inertia-sdl_haptic_inertia","title":"<code>Inertia = SDL_HAPTIC_INERTIA</code>","text":"<p>Condition haptic effect that simulates inertia. Effect is based on the axes acceleration. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticKind/#friction-sdl_haptic_friction","title":"<code>Friction = SDL_HAPTIC_FRICTION</code>","text":"<p>Condition haptic effect that simulates friction. Effect is based on the axes movement. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticKind/#leftright-sdl_haptic_leftright","title":"<code>LeftRight = SDL_HAPTIC_LEFTRIGHT</code>","text":"<p>Haptic effect for direct control over high/low frequency motors. </p>"},{"location":"Reference/Neslib.Sdl3.Haptic/types/TSdlHapticKind/#custom-sdl_haptic_custom","title":"<code>Custom = SDL_HAPTIC_CUSTOM</code>","text":"<p>User defined custom haptic effect. </p>"},{"location":"Reference/Neslib.Sdl3.IO/","title":"Neslib.Sdl3.IO","text":""},{"location":"Reference/Neslib.Sdl3.IO/#classes-records","title":"Classes &amp; Records","text":"Name Description TSdlAsyncIO The asynchronous I/O operation structure. TSdlAsyncIOOutcome Information about a completed asynchronous I/O request. TSdlAsyncIOQueue A queue of completed asynchronous I/O tasks. TSdlDirectoryEntry An entry in a directory as returned by TSdlStorage.EnumerateDirectory. TSdlIOStream The read/write operation structure. TSdlIOStreamInterface The function pointers that drive a TSdlIOStream. TSdlPathInfo Information about a path on the filesystem. TSdlStorage An abstract interface for filesystem access. TSdlStorageInterface Function interface for TSdlStorage."},{"location":"Reference/Neslib.Sdl3.IO/#types","title":"Types","text":"Name Description TSdlAsyncIOResult Possible outcomes of an asynchronous I/O task. TSdlAsyncIOTaskKind Types of asynchronous I/O tasks. TSdlIOStatus TSdlIOStream status, set by a read or write operation. TSdlIOWhence Possible <code>whence</code> values for TSdlIOStream seeking. TSdlPathKind Types of filesystem entries. Note that there may be other sorts of items on a filesystem: devices, symlinks, named pipes, etc. They are currently reported as Other."},{"location":"Reference/Neslib.Sdl3.IO/#routines","title":"Routines","text":"Name Description SdlLoad(String) Load all the data from a file path. SdlLoad(String, NativeInt) Load all the data from a file path. SdlLoadAsync Load all the data from a file path, asynchronously. SdlSave Save all the data into a file path."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/","title":"TSdlAsyncIO","text":"<p>The asynchronous I/O operation structure.</p> <p>This operates as an opaque handle. One can then request read or write operations on it. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>type TSdlAsyncIO = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#properties","title":"Properties","text":"Name Description Size The size of the data stream."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#constructors","title":"Constructors","text":"Name Description Create Create a new TSdlAsyncIO object for reading from and/or writing to a named file."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#methods","title":"Methods","text":"Name Description Free Close and free any allocated resources for an async I/O object. Read Start an async read. Write Start an async write."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#Size","title":"Size","text":"<p>The size of the data stream.</p> <p>This call is not asynchronous; it assumes that obtaining this info is a non-blocking operation in most reasonable cases. </p> <p><code>property Size: Int64 read GetSize</code></p> <p>Type: <code>Int64</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#remarks","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#Create","title":"<code>Create</code>","text":"<p>Create a new TSdlAsyncIO object for reading from and/or writing to a named file.</p> <p>The <code>AMode</code> string understands the following values:</p> <ul> <li>'r': Open a file for reading. The file must exist.</li> <li>'w': Open a file for writing only. It will create missing files or truncate existing ones.</li> <li>'r+': Open a file for update both reading and writing. The file must exist.</li> <li>'w+': Create an empty file for both reading and writing. If a file with the same name already exists its content is erased and the file is treated as a new empty file.</li> </ul> <p>There is no 'b' mode, as there is only \"binary\" style I/O, and no 'a' mode for appending, since you specify the position when starting a task.</p> <p>This call is not asynchronous; it will open the file before returning, under the assumption that doing so is generally a fast operation. Future reads and writes to the opened file will be async, however. </p> <p><code>constructor Create(const AFilename, AMode: String)</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#parameters","title":"Parameters","text":"<p><code>AFilename</code>: <code>String</code> : The filename to open.</p> <p><code>AMode</code>: <code>String</code> : String representing the mode to be used for opening the file.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#see-also","title":"See Also","text":"<ul> <li>Free</li> <li>Read</li> <li>Write</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#Equal","title":"Equal(TSdlAsyncIO, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlAsyncIO; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#parameters_1","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlAsyncIO</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlAsyncIO; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#parameters_2","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#returns_1","title":"Returns","text":"<p><code>TSdlAsyncIO</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#NotEqual","title":"NotEqual(TSdlAsyncIO, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlAsyncIO; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#parameters_3","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlAsyncIO</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#Free","title":"Free(Boolean, TSdlAsyncIOQueue, Pointer)","text":"<p>Close and free any allocated resources for an async I/O object.</p> <p>Closing a file is also an asynchronous task! If a write failure were to happen during the closing process, for example, the task results will report it as usual.</p> <p>Closing a file that has been written to does not guarantee the data has made it to physical media; it may remain in the operating system's file cache, for later writing to disk. This means that a successfully-closed file can be lost if the system crashes or loses power in this small window. To prevent this, call this method with the <code>AFlush</code> parameter set to True. This will make the operation take longer, and perhaps increase system load in general, but a successful result guarantees that the data has made it to physical storage. Don't use this for temporary files, caches, and unimportant data, and definitely use it for crucial irreplaceable files, like game saves.</p> <p>This method guarantees that the close will happen after any other pending tasks, so it's safe to open a file, start several operations, close the file immediately, then check for all results later. This method will not block until the tasks have completed.</p> <p>Once this method returns, this object is no longer valid, regardless of any future outcomes. Any completed tasks might still contain this pointer in their TSdlAsyncIOOutcome data, in case the app was using this value to track information, but it should not be used again.</p> <p>If this function raises an error, the close wasn't started at all, and it's safe to attempt to close again later.</p> <p>A TSdlAsyncIOQueue must be specified. The newly-created task will be added to it when it completes its work. </p> <p><code>procedure Free(const AFlush: Boolean; const AQueue: TSdlAsyncIOQueue; const AUserData: Pointer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#parameters_4","title":"Parameters","text":"<p><code>AFlush</code>: <code>Boolean</code> : True if data should sync to disk before the task completes.</p> <p><code>AQueue</code>: <code>TSdlAsyncIOQueue</code> : A queue to add the TSdlAsyncIO to.</p> <p><code>AUserData</code>: <code>Pointer</code> : An app-defined pointer that will be provided with the task results.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#remarks_1","title":"Remarks","text":"<p>It is safe to call this method from any thread, but two threads should not attempt to close the same object. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#Read","title":"Read(Pointer, Int64, Int64, TSdlAsyncIOQueue, Pointer)","text":"<p>Start an async read.</p> <p>This method reads up to <code>ASize</code> bytes from <code>AOffset</code> position in the data source to the area pointed at by <code>APtr</code>. This method may read less bytes than requested.</p> <p>This method returns as quickly as possible; it does not wait for the read to complete. On a successful return, this work will continue in the background. If the work begins, even failure is asynchronous: a failing return value from this method only means the work couldn't start at all.</p> <p><code>APtr</code> must remain available until the work is done, and may be accessed by the system at any time until then. Do not allocate it on the stack, as this might take longer than the life of the calling method to complete!</p> <p>A TSdlAsyncIOQueue must be specified. The newly-created task will be added to it when it completes its work. </p> <p><code>procedure Read(const APtr: Pointer; const AOffset, ASize: Int64; const AQueue: TSdlAsyncIOQueue; const AUserData: Pointer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#parameters_5","title":"Parameters","text":"<p><code>APtr</code>: <code>Pointer</code> : A pointer to a buffer to read data into.</p> <p><code>AOffset</code>: <code>Int64</code> : The position to start reading in the data source.</p> <p><code>ASize</code>: <code>Int64</code> : The number of bytes to read from the data source.</p> <p><code>AQueue</code>: <code>TSdlAsyncIOQueue</code> : A queue to add the TSdlAsyncIO to.</p> <p><code>AUserData</code>: <code>Pointer</code> : An app-defined pointer that will be provided with the task results.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#see-also_1","title":"See Also","text":"<ul> <li>Write</li> <li>TSdlAsyncIOQueue</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#remarks_2","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#Write","title":"Write(Pointer, Int64, Int64, TSdlAsyncIOQueue, Pointer)","text":"<p>Start an async write.</p> <p>This method writes <code>ASize</code> bytes from <code>AOffset</code> position in the data source to the area pointed at by <code>APtr</code>.</p> <p>This method returns as quickly as possible; it does not wait for the write to complete. On a successful return, this work will continue in the background. If the work begins, even failure is asynchronous: a failing return value from this method only means the work couldn't start at all.</p> <p><code>APtr</code> must remain available until the work is done, and may be accessed by the system at any time until then. Do not allocate it on the stack, as this might take longer than the life of the calling method to complete!</p> <p>A TSdlAsyncIOQueue must be specified. The newly-created task will be added to it when it completes its work. </p> <p><code>procedure Write(const APtr: Pointer; const AOffset, ASize: Int64; const AQueue: TSdlAsyncIOQueue; const AUserData: Pointer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#parameters_6","title":"Parameters","text":"<p><code>APtr</code>: <code>Pointer</code> : A pointer to a buffer to write data from.</p> <p><code>AOffset</code>: <code>Int64</code> : The position to start writing to the data source.</p> <p><code>ASize</code>: <code>Int64</code> : The number of bytes to write to the data source.</p> <p><code>AQueue</code>: <code>TSdlAsyncIOQueue</code> : A queue to add the TSdlAsyncIO to.</p> <p><code>AUserData</code>: <code>Pointer</code> : An app-defined pointer that will be provided with the task results.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#see-also_2","title":"See Also","text":"<ul> <li>Read</li> <li>TSdlAsyncIOQueue</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIO/#remarks_3","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOOutcome/","title":"TSdlAsyncIOOutcome","text":"<p>Information about a completed asynchronous I/O request. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOOutcome/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>type TSdlAsyncIOOutcome = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOOutcome/#properties","title":"Properties","text":"Name Description AsyncIO What generated this task. This will be invalid if it was closed! Buffer Buffer where data was read/written. BytesRequested Number of bytes the task was to read/write. BytesTransferred actual number of bytes that were read/written. Kind What sort of task was this? Read, write, etc? Offset Offset in the TSdlAsyncIO where data was read/written. Result The result of the work (success, failure, cancellation). UserData pointer provided by the app when starting the task"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOOutcome/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOOutcome/#AsyncIO","title":"AsyncIO","text":"<p>What generated this task. This will be invalid if it was closed! </p> <p><code>property AsyncIO: TSdlAsyncIO read GetAsyncIO</code></p> <p>Type: <code>TSdlAsyncIO</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOOutcome/#Buffer","title":"Buffer","text":"<p>Buffer where data was read/written. </p> <p><code>property Buffer: Pointer read FHandle.buffer</code></p> <p>Type: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOOutcome/#BytesRequested","title":"BytesRequested","text":"<p>Number of bytes the task was to read/write. </p> <p><code>property BytesRequested: Int64 read FHandle.bytes_requested</code></p> <p>Type: <code>Int64</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOOutcome/#BytesTransferred","title":"BytesTransferred","text":"<p>actual number of bytes that were read/written. </p> <p><code>property BytesTransferred: Int64 read FHandle.bytes_transferred</code></p> <p>Type: <code>Int64</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOOutcome/#Kind","title":"Kind","text":"<p>What sort of task was this? Read, write, etc? </p> <p><code>property Kind: TSdlAsyncIOTaskKind read GetKind</code></p> <p>Type: <code>TSdlAsyncIOTaskKind</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOOutcome/#Offset","title":"Offset","text":"<p>Offset in the TSdlAsyncIO where data was read/written. </p> <p><code>property Offset: Int64 read FHandle.offset</code></p> <p>Type: <code>Int64</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOOutcome/#Result","title":"Result","text":"<p>The result of the work (success, failure, cancellation). </p> <p><code>property Result: TSdlAsyncIOResult read GetResult</code></p> <p>Type: <code>TSdlAsyncIOResult</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOOutcome/#UserData","title":"UserData","text":"<p>pointer provided by the app when starting the task </p> <p><code>property UserData: Pointer read FHandle.userdata</code></p> <p>Type: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/","title":"TSdlAsyncIOQueue","text":"<p>A queue of completed asynchronous I/O tasks.</p> <p>When starting an asynchronous operation, you specify a queue for the new task. A queue can be asked later if any tasks in it have completed, allowing an app to manage multiple pending tasks in one place, in whatever order they complete. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>type TSdlAsyncIOQueue = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#methods","title":"Methods","text":"Name Description Create Create a task queue for tracking multiple I/O operations. Free Destroy a previously-created async I/O task queue. GetResult Query the async I/O task queue for completed tasks. Signal Wake up any threads that are blocking in WaitResult. WaitResult Block until an async I/O task queue has a completed task."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#Equal","title":"Equal(TSdlAsyncIOQueue, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlAsyncIOQueue; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlAsyncIOQueue</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlAsyncIOQueue; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#returns_1","title":"Returns","text":"<p><code>TSdlAsyncIOQueue</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#NotEqual","title":"NotEqual(TSdlAsyncIOQueue, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlAsyncIOQueue; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlAsyncIOQueue</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#Create","title":"Create","text":"<p>Create a task queue for tracking multiple I/O operations.</p> <p>Async I/O operations are assigned to a queue when started. The queue can be checked for completed tasks thereafter. </p> <p><code>class function Create: TSdlAsyncIOQueue; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#returns_3","title":"Returns","text":"<p><code>TSdlAsyncIOQueue</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#see-also","title":"See Also","text":"<ul> <li>Free</li> <li>GetResult</li> <li>WaitResult</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#remarks","title":"Remarks","text":"<p>It is safe to call this constructor from any thread </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#Free","title":"Free","text":"<p>Destroy a previously-created async I/O task queue.</p> <p>If there are still tasks pending for this queue, this call will block until those tasks are finished. All those tasks will be deallocated. Their results will be lost to the app.</p> <p>Any pending reads from SdlLoadAsync that are still in this queue will have their buffers deallocated by this function, to prevent a memory leak.</p> <p>Once this function is called, the queue is no longer valid and should not be used, including by other threads that might access it while destruction is blocking on pending tasks.</p> <p>Do not destroy a queue that still has threads waiting on it through WaitResult. You can call Signal first to unblock those threads, and take measures (such as waiting on a thread) to make sure they have finished their wait and won't wait on the queue again. </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#remarks_1","title":"Remarks","text":"<p>It is safe to call this method from any thread, so long as no other thread is waiting on the queue with WaitResult. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#GetResult","title":"GetResult(TSdlAsyncIOOutcome)","text":"<p>Query the async I/O task queue for completed tasks.</p> <p>If a task assigned to this queue has finished, this will return True and fill in <code>AOutcome</code> with the details of the task. If no task in the queue has finished, this function will return False. This function does not block.</p> <p>If a task has completed, this function will free its resources and the task pointer will no longer be valid. The task will be removed from the queue.</p> <p>It is safe for multiple threads to call this function on the same queue at once; a completed task will only go to one of the threads. </p> <p><code>function GetResult(out AOutcome: TSdlAsyncIOOutcome): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#parameters_3","title":"Parameters","text":"<p><code>AOutcome</code>: <code>TSdlAsyncIOOutcome</code> : Details of a finished task will be written here.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#returns_4","title":"Returns","text":"<p><code>Boolean</code>: True if a task has completed, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#see-also_1","title":"See Also","text":"<ul> <li>WaitResult</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#remarks_2","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#Signal","title":"Signal","text":"<p>Wake up any threads that are blocking in WaitResult.</p> <p>This will unblock any threads that are sleeping in a call to WaitResult for the specified queue, and cause them to return from that function.</p> <p>This can be useful when destroying a queue to make sure nothing is touching it indefinitely. In this case, once this call completes, the caller should take measures to make sure any previously-blocked threads have returned from their wait and will not touch the queue again (perhaps by setting a flag to tell the threads to terminate and then waiting for a thread to finish to make sure they've done so). </p> <p><code>procedure Signal; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#see-also_2","title":"See Also","text":"<ul> <li>WaitResult</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#remarks_3","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#WaitResult","title":"WaitResult(TSdlAsyncIOOutcome, Integer)","text":"<p>Block until an async I/O task queue has a completed task.</p> <p>This function puts the calling thread to sleep until there a task assigned to the queue that has finished.</p> <p>If a task assigned to the queue has finished, this will return True and fill in <code>AOutcome</code> with the details of the task. If no task in the queue has finished, this function will return false.</p> <p>If a task has completed, this function will free its resources and the task pointer will no longer be valid. The task will be removed from the queue.</p> <p>It is safe for multiple threads to call this function on the same queue at once; a completed task will only go to one of the threads.</p> <p>Note that by the nature of various platforms, more than one waiting thread may wake to handle a single task, but only one will obtain it, so <code>ATimeoutMS</code> is a maximum wait time, and this function may return False sooner.</p> <p>This function may return False if there was a system error, the OS inadvertently awoke multiple threads, or if Signal was called to wake up all waiting threads without a finished task.</p> <p>A timeout can be used to specify a maximum wait time, but rather than polling, it is possible to have a timeout of -1 to wait forever, and use Signal to wake up the waiting threads later. </p> <p><code>function WaitResult(out AOutcome: TSdlAsyncIOOutcome; const ATimeoutMS: Integer): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#parameters_4","title":"Parameters","text":"<p><code>AOutcome</code>: <code>TSdlAsyncIOOutcome</code> : Details of a finished task will be written here.</p> <p><code>ATimeoutMS</code>: <code>Integer</code> : The maximum time to wait, in milliseconds, or -1 to wait indefinitely.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#returns_5","title":"Returns","text":"<p><code>Boolean</code>: True if task has completed, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#see-also_3","title":"See Also","text":"<ul> <li>Signal</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlAsyncIOQueue/#remarks_4","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlDirectoryEntry/","title":"TSdlDirectoryEntry","text":"<p>An entry in a directory as returned by TSdlStorage.EnumerateDirectory. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlDirectoryEntry/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>type TSdlDirectoryEntry = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlDirectoryEntry/#fields","title":"Fields","text":"Name Description Directory The directory name, ending with a '/'. Filename The filename."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlDirectoryEntry/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlDirectoryEntry/#Directory","title":"Directory","text":"<p>The directory name, ending with a '/'. </p> <p><code>var Directory: String</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlDirectoryEntry/#Filename","title":"Filename","text":"<p>The filename. </p> <p><code>var Filename: String</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/","title":"TSdlIOStream","text":"<p>The read/write operation structure. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>type TSdlIOStream = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#properties","title":"Properties","text":"Name Description Properties The properties associated with this stream. Size The size of the data stream. Status The status of the stream."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#constructors","title":"Constructors","text":"Name Description Create(TSdlIOStreamInterface, Pointer) Create a custom I/O stream. Create(Pointer, NativeInt, Boolean) Create an I/O stream from a read-write memory buffer. Create(String, String) Creates an I/O stream for reading from and/or writing to a named file."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#methods","title":"Methods","text":"Name Description Create Creates an I/O stream that is backed by dynamically allocated memory. Flush Flush any buffered data in the stream. Free Close and free the I/O stream. Load(Boolean) Load all the data from the stream. Load(NativeInt, Boolean) Load all the data from the stream. Read Read from the stream. ReadS16BE Read a signed 16-bit big-endian integer from the stream. ReadS16LE Read a signed 16-bit little-endian integer from the stream. ReadS32BE Read a signed 32-bit big-endian integer from the stream. ReadS32LE Read a signed 32-bit little-endian integer from the stream. ReadS64BE Read a signed 64-bit big-endian integer from the stream. ReadS64LE Read a signed 64-bit little-endian integer from the stream. ReadS8 Read a signed byte from the stream. ReadU16BE Read an unsigned 16-bit big-endian integer from the stream. ReadU16LE Read an unsigned 16-bit little-endian integer from the stream. ReadU32BE Read an unsigned 32-bit big-endian integer from the stream. ReadU32LE Read an unsigned 32-bit little-endian integer from the stream. ReadU64BE Read an unsigned 64-bit big-endian integer from the stream. ReadU64LE Read an unsigned 64-bit little-endian integer from the stream. ReadU8 Read an unsigned byte from the stream. Save Save all the data into the stream. Seek Seek within the data stream. Tell Determine the current read/write offset in the data stream. Write Write to the stream. WriteS16BE Write a signed 16-bit integer to the stream as big-endian data. WriteS16LE Write a signed 16-bit integer to the stream as little-endian data. WriteS32BE Write a signed 32-bit integer to the stream as big-endian data. WriteS32LE Write a signed 32-bit integer to the stream as little-endian data. WriteS64BE Write a signed 64-bit integer to the stream as big-endian data. WriteS64LE Write a signed 64-bit integer to the stream as little-endian data. WriteS8 Write a signed byte to the stream. WriteU16BE Write an unsigned 16-bit integer to the stream as big-endian data. WriteU16LE Write an unsigned 16-bit integer to the stream as little-endian data. WriteU32BE Write an unsigned 32-bit integer to the stream as big-endian data. WriteU32LE Write an unsigned 32-bit integer to the stream as little-endian data. WriteU64BE Write an unsigned 64-bit integer to the stream as big-endian data. WriteU64LE Write an unsigned 64-bit integer to the stream as little-endian data. WriteU8 Write an unsigned byte to the stream."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Properties","title":"Properties","text":"<p>The properties associated with this stream. </p> <p><code>property Properties: TSdlProperties read GetProperties</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks","title":"Remarks","text":"<p>This property is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Size","title":"Size","text":"<p>The size of the data stream. </p> <p><code>property Size: Int64 read GetSize</code></p> <p>Type: <code>Int64</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_1","title":"Remarks","text":"<p>This function is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Status","title":"Status","text":"<p>The status of the stream.</p> <p>This information can be useful to decide if a short read or write was due to an error, an EOF, or a non-blocking operation that isn't yet ready to complete.</p> <p>The status is only expected to change after a Read or Write call; don't expect it to change if you just read this property in a tight loop. </p> <p><code>property Status: TSdlIOStatus read GetStatus</code></p> <p>Type: <code>TSdlIOStatus</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_2","title":"Remarks","text":"<p>This property is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Create_0","title":"<code>Create</code>","text":"<p>Create a custom I/O stream.</p> <p>Applications do not need to use this constructor unless they are providing their own TSdlIOStream implementation. If you just need a TSdlIOStream to read/write a common data source, you should use the built-in implementations in SDL, by using the other constructors. </p> <p><code>constructor Create(const AInterface: TSdlIOStreamInterface; const AUserData: Pointer); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters","title":"Parameters","text":"<p><code>AInterface</code>: <code>TSdlIOStreamInterface</code> : The interface that implements this TSdlIOStream, initialized by calling its Init method.</p> <p><code>AUserData</code>: <code>Pointer</code> : The pointer that will be passed to the interface functions.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#see-also","title":"See Also","text":"<ul> <li>Free</li> <li>TSdlIOStreamInterface.Init</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_3","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Create_1","title":"<code>Create</code>","text":"<p>Create an I/O stream from a read-write memory buffer.</p> <p>This function sets up this record based on a memory area of a certain size, for both read and write access.</p> <p>This memory buffer is not copied by the TSdlIOStream; the pointer you provide must remain valid until you close the stream. Closing the stream will not free the original buffer.</p> <p>If you need to make sure the TSdlIOStream never writes to the memory buffer, you should set AReadOnly to True.</p> <p>The following properties will be set at creation time by SDL:</p> <ul> <li><code>TSdlProperty.IOStreamMemory</code>: this will be the <code>AMem</code> parameter that was passed to this constructor.</li> <li><code>TSdlProperty.IOStreamMemorySize</code>: this will be the <code>ASize</code> parameter that was passed to this constructor. </li> </ul> <p><code>constructor Create(const AMem: Pointer; const ASize: NativeInt; const AReadOnly: Boolean = False); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_1","title":"Parameters","text":"<p><code>AMem</code>: <code>Pointer</code> : A pointer to a buffer to feed an TSdlIOStream stream.</p> <p><code>ASize</code>: <code>NativeInt</code> : The buffer size, in bytes.</p> <p><code>AReadOnly</code>: <code>Boolean = False</code> : (Optional) to disallow writing to this stream. Default to False (that is, you can read and write to this stream).</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#see-also_1","title":"See Also","text":"<ul> <li>Free</li> <li>Flush</li> <li>Read</li> <li>Seek</li> <li>Tell</li> <li>Write</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_4","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Create_2","title":"<code>Create</code>","text":"<p>Creates an I/O stream for reading from and/or writing to a named file.</p> <p>The <code>AMode</code> string is treated roughly the same as in a call to the C library's fopen, even if SDL doesn't happen to use fopen behind the scenes.</p> <p>Available <code>AMode</code> strings:</p> <ul> <li>'r': Open a file for reading. The file must exist.</li> <li>'w': Create an empty file for writing. If a file with the same name already exists its content is erased and the file is treated as a new empty file.</li> <li>'a': Append to a file. Writing operations append data at the end of the file. The file is created if it does not exist.</li> <li>'r+': Open a file for update both reading and writing. The file must exist.</li> <li>'w+': Create an empty file for both reading and writing. If a file with the same name already exists its content is erased and the file is treated as a new empty file.</li> <li>'a+': Open a file for reading and appending. All writing operations are performed at the end of the file, protecting the previous content to be overwritten. You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations will move it back to the end of file. The file is created if it does not exist.</li> </ul> <p>NOTE: In order to open a file as a binary file, a 'b' character has to be included in the <code>AMode</code> string. This additional 'b' character can either be appended at the end of the string (thus making the following compound modes: 'rb', 'wb', 'ab', 'r+b', 'w+b', 'a+b') or be inserted between the letter and the '+' sign for the mixed modes ('rb+', 'wb+', 'ab+'). Additional characters may follow the sequence, although they should have no effect. For example, 't' is sometimes appended to make explicit the file is a text file.</p> <p>In Android, this constructor can be used to open content:// URIs. As a fallback, this constructor will transparently open a matching filename in the app's <code>assets</code>.</p> <p>Freeing the I/O stream will close SDL's internal file handle.</p> <p>The following properties may be set at creation time by SDL:</p> <ul> <li><code>TSdlProperty.IOStreamWindowHandle</code>: a pointer, that can be cast to a THandle, that this TSdlIOStream is using to access the filesystem. If the program isn't running on Windows, or SDL used some other method to access the filesystem, this property will not be set.</li> <li><code>TSdlProperty.IOStreamFileDescriptor</code>: a file descriptor that this TSdlIOStream is using to access the filesystem.</li> <li><code>TSdlProperty.IOStreamAndroidAAsset</code>: a pointer, that can be cast to an Android NDK <code>AAsset</code>, that this TSdlIOStream is using to access the filesystem. If SDL used some other method to access the filesystem, this property will not be set. </li> </ul> <p><code>constructor Create(const AFilename, AMode: String); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_2","title":"Parameters","text":"<p><code>AFilename</code>: <code>String</code> : The filename to open.</p> <p><code>AMode</code>: <code>String</code> : A string representing the mode to be used for opening the file.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#see-also_2","title":"See Also","text":"<ul> <li>Free</li> <li>Flush</li> <li>Read</li> <li>Seek</li> <li>Tell</li> <li>Write</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_5","title":"Remarks","text":"<p>This function is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Equal","title":"Equal(TSdlIOStream, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlIOStream; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_3","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlIOStream</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlIOStream; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_4","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_1","title":"Returns","text":"<p><code>TSdlIOStream</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#NotEqual","title":"NotEqual(TSdlIOStream, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlIOStream; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_5","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlIOStream</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Create","title":"Create","text":"<p>Creates an I/O stream that is backed by dynamically allocated memory.</p> <p>This supports the following properties to provide access to the memory and control over allocations:</p> <ul> <li><code>TSdlProperty.IOStreamDynamicMemory</code>: a pointer to the internal memory of the stream. This can be set to nil to transfer ownership of the memory to the application, which should free the memory with SdlFree. If this is done, the next operation on the stream must be Free.</li> <li><code>TSdlProperty.IOStreamDynamicChunkSize</code>: memory will be allocated in multiples of this size, defaulting to 1024. </li> </ul> <p><code>class function Create: TSdlIOStream; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_3","title":"Returns","text":"<p><code>TSdlIOStream</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#see-also_3","title":"See Also","text":"<ul> <li>Free</li> <li>Flush</li> <li>Read</li> <li>Seek</li> <li>Tell</li> <li>Write</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_6","title":"Remarks","text":"<p>It is safe to call this method from any thread </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Flush","title":"Flush","text":"<p>Flush any buffered data in the stream.</p> <p>This method makes sure that any buffered data is written to the stream. Normally this isn't necessary but if the stream is a pipe or socket it guarantees that any pending data is sent. </p> <p><code>procedure Flush; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_6","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#see-also_4","title":"See Also","text":"<ul> <li>Write</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_7","title":"Remarks","text":"<p>This function is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Free","title":"Free","text":"<p>Close and free the I/O stream.</p> <p>This closes and cleans up the stream. It releases any resources used by the stream and frees the itself.</p> <p>Note that if this fails to flush the stream for any reason, this function raises an error, but the stream is still invalid once this function returns.</p> <p>This call flushes any buffered writes to the operating system, but there are no guarantees that those writes have gone to physical media; they might be in the OS's file cache, waiting to go to disk later. If it's absolutely crucial that writes go to disk immediately, so they are definitely stored even if the power fails before the file cache would have caught up, one should call Flush before closing. Note that flushing takes time and makes the system and your app operate less efficiently, so do so sparingly. </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_7","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure (eg. when the stream failed to flush its output).</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_8","title":"Remarks","text":"<p>This function is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Load_0","title":"Load(Boolean)","text":"<p>Load all the data from the stream.</p> <p>The data is allocated with a zero byte at the end (null terminated) for convenience.</p> <p>The data should be freed with SdlFree. </p> <p><code>function Load(const AClose: Boolean): Pointer; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_8","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_6","title":"Parameters","text":"<p><code>AClose</code>: <code>Boolean</code> : If True, calls Free before returning, even in the case of an error.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_4","title":"Returns","text":"<p><code>Pointer</code>: The data.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#see-also_5","title":"See Also","text":"<ul> <li>SdlLoad</li> <li>Save</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_9","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Load_1","title":"Load(NativeInt, Boolean)","text":"<p>Load all the data from the stream.</p> <p>The data is allocated with a zero byte at the end (null terminated) for convenience. This extra byte is not included in the value reported via <code>ADataSize</code>.</p> <p>The data should be freed with SdlFree. </p> <p><code>function Load(out ADataSize: NativeInt; const AClose: Boolean): Pointer; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_9","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_7","title":"Parameters","text":"<p><code>ADataSize</code>: <code>NativeInt</code> : Will be set to the number of bytes read.</p> <p><code>AClose</code>: <code>Boolean</code> : If True, calls Free before returning, even in the case of an error.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_5","title":"Returns","text":"<p><code>Pointer</code>: The data.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#see-also_6","title":"See Also","text":"<ul> <li>SdlLoad</li> <li>Save</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_10","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Read","title":"Read(Pointer, NativeInt)","text":"<p>Read from the stream.</p> <p>This function reads up <code>ASize</code> bytes from the stream to the area pointed at by <code>APtr</code>. This function may read less bytes than requested.</p> <p>This function will return zero when the data stream is completely read, Status will return TSdlIOStatus.Eof. If zero is returned and the stream is not at EOF, Status will return a different error value and an ESdlError will be raised. </p> <p><code>function Read(const APtr: Pointer; const ASize: NativeInt): NativeInt</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_10","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_8","title":"Parameters","text":"<p><code>APtr</code>: <code>Pointer</code> : A pointer to a buffer to read data into.</p> <p><code>ASize</code>: <code>NativeInt</code> : The number of bytes to read from the stream.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_6","title":"Returns","text":"<p><code>NativeInt</code>: The number of bytes read, or 0 on end of file.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#see-also_7","title":"See Also","text":"<ul> <li>Write</li> <li>Status</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_11","title":"Remarks","text":"<p>This function is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#ReadS16BE","title":"ReadS16BE","text":"<p>Read a signed 16-bit big-endian integer from the stream.</p> <p>SDL byteswaps the data only if necessary, so the data returned will be in the native byte order.</p> <p>This function will return False when the data stream is completely read, Status will return TSdlIOStatus.Eof. </p> <p><code>function ReadS16BE: Int16; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_11","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_7","title":"Returns","text":"<p><code>Int16</code>: The data read.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_12","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#ReadS16LE","title":"ReadS16LE","text":"<p>Read a signed 16-bit little-endian integer from the stream.</p> <p>SDL byteswaps the data only if necessary, so the data returned will be in the native byte order.</p> <p>This function will return False when the data stream is completely read, Status will return TSdlIOStatus.Eof. </p> <p><code>function ReadS16LE: Int16; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_12","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_8","title":"Returns","text":"<p><code>Int16</code>: The data read.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_13","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#ReadS32BE","title":"ReadS32BE","text":"<p>Read a signed 32-bit big-endian integer from the stream.</p> <p>SDL byteswaps the data only if necessary, so the data returned will be in the native byte order.</p> <p>This function will return False when the data stream is completely read, Status will return TSdlIOStatus.Eof. </p> <p><code>function ReadS32BE: Int32; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_13","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_9","title":"Returns","text":"<p><code>Int32</code>: The data read.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_14","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#ReadS32LE","title":"ReadS32LE","text":"<p>Read a signed 32-bit little-endian integer from the stream.</p> <p>SDL byteswaps the data only if necessary, so the data returned will be in the native byte order.</p> <p>This function will return False when the data stream is completely read, Status will return TSdlIOStatus.Eof. </p> <p><code>function ReadS32LE: Int32; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_14","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_10","title":"Returns","text":"<p><code>Int32</code>: The data read.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_15","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#ReadS64BE","title":"ReadS64BE","text":"<p>Read a signed 64-bit big-endian integer from the stream.</p> <p>SDL byteswaps the data only if necessary, so the data returned will be in the native byte order.</p> <p>This function will return False when the data stream is completely read, Status will return TSdlIOStatus.Eof. </p> <p><code>function ReadS64BE: Int64; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_15","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_11","title":"Returns","text":"<p><code>Int64</code>: The data read.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_16","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#ReadS64LE","title":"ReadS64LE","text":"<p>Read a signed 64-bit little-endian integer from the stream.</p> <p>SDL byteswaps the data only if necessary, so the data returned will be in the native byte order.</p> <p>This function will return False when the data stream is completely read, Status will return TSdlIOStatus.Eof. </p> <p><code>function ReadS64LE: Int64; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_16","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_12","title":"Returns","text":"<p><code>Int64</code>: The data read.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_17","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#ReadS8","title":"ReadS8","text":"<p>Read a signed byte from the stream.</p> <p>This function will return False when the data stream is completely read, Status will return TSdlIOStatus.Eof. </p> <p><code>function ReadS8: Int8; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_17","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_13","title":"Returns","text":"<p><code>Int8</code>: The data read.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_18","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#ReadU16BE","title":"ReadU16BE","text":"<p>Read an unsigned 16-bit big-endian integer from the stream.</p> <p>SDL byteswaps the data only if necessary, so the data returned will be in the native byte order.</p> <p>This function will return False when the data stream is completely read, Status will return TSdlIOStatus.Eof. </p> <p><code>function ReadU16BE: UInt16; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_18","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_14","title":"Returns","text":"<p><code>UInt16</code>: The data read.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_19","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#ReadU16LE","title":"ReadU16LE","text":"<p>Read an unsigned 16-bit little-endian integer from the stream.</p> <p>SDL byteswaps the data only if necessary, so the data returned will be in the native byte order.</p> <p>This function will return False when the data stream is completely read, Status will return TSdlIOStatus.Eof. </p> <p><code>function ReadU16LE: UInt16; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_19","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_15","title":"Returns","text":"<p><code>UInt16</code>: The data read.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_20","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#ReadU32BE","title":"ReadU32BE","text":"<p>Read an unsigned 32-bit big-endian integer from the stream.</p> <p>SDL byteswaps the data only if necessary, so the data returned will be in the native byte order.</p> <p>This function will return False when the data stream is completely read, Status will return TSdlIOStatus.Eof. </p> <p><code>function ReadU32BE: UInt32; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_20","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_16","title":"Returns","text":"<p><code>UInt32</code>: The data read.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_21","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#ReadU32LE","title":"ReadU32LE","text":"<p>Read an unsigned 32-bit little-endian integer from the stream.</p> <p>SDL byteswaps the data only if necessary, so the data returned will be in the native byte order.</p> <p>This function will return False when the data stream is completely read, Status will return TSdlIOStatus.Eof. </p> <p><code>function ReadU32LE: UInt32; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_21","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_17","title":"Returns","text":"<p><code>UInt32</code>: The data read.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_22","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#ReadU64BE","title":"ReadU64BE","text":"<p>Read an unsigned 64-bit big-endian integer from the stream.</p> <p>SDL byteswaps the data only if necessary, so the data returned will be in the native byte order.</p> <p>This function will return False when the data stream is completely read, Status will return TSdlIOStatus.Eof. </p> <p><code>function ReadU64BE: UInt64; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_22","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_18","title":"Returns","text":"<p><code>UInt64</code>: The data read.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_23","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#ReadU64LE","title":"ReadU64LE","text":"<p>Read an unsigned 64-bit little-endian integer from the stream.</p> <p>SDL byteswaps the data only if necessary, so the data returned will be in the native byte order.</p> <p>This function will return False when the data stream is completely read, Status will return TSdlIOStatus.Eof. </p> <p><code>function ReadU64LE: UInt64; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_23","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_19","title":"Returns","text":"<p><code>UInt64</code>: The data read.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_24","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#ReadU8","title":"ReadU8","text":"<p>Read an unsigned byte from the stream.</p> <p>This function will return False when the data stream is completely read, Status will return TSdlIOStatus.Eof. </p> <p><code>function ReadU8: UInt8; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_24","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_20","title":"Returns","text":"<p><code>UInt8</code>: The data read.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_25","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Save","title":"Save(Pointer, NativeInt, Boolean)","text":"<p>Save all the data into the stream. </p> <p><code>procedure Save(const AData: Pointer; const ADataSize: NativeInt; const AClose: Boolean); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_25","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_9","title":"Parameters","text":"<p><code>AData</code>: <code>Pointer</code> : The data to be written. If ADataSize is 0, may be nil or a invalid pointer.</p> <p><code>ADataSize</code>: <code>NativeInt</code> : The number of bytes to be written.</p> <p><code>AClose</code>: <code>Boolean</code> : If true, calls Free before returning, even in the case of an error.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#see-also_8","title":"See Also","text":"<ul> <li>SdlSave</li> <li>Load</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_26","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Seek","title":"Seek(Int64, TSdlIOWhence)","text":"<p>Seek within the data stream.</p> <p>This method seeks to byte <code>AOffset</code>, relative to <code>AWhence</code>.</p> <p><code>AWhence</code> may be any of the following values:</p> <ul> <li><code>TSdlIOWhence.Set</code>: seek from the beginning of data</li> <li><code>TSdlIOWhence.Cur</code>: seek relative to current read point</li> <li><code>TSdlIOWhence.End</code>: seek relative to the end of data </li> </ul> <p><code>function Seek(const AOffset: Int64; const AWhence: TSdlIOWhence): Int64; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_10","title":"Parameters","text":"<p><code>AOffset</code>: <code>Int64</code> : An offset in bytes, relative to <code>AWhence</code> location; can be negative.</p> <p><code>AWhence</code>: <code>TSdlIOWhence</code> : Relative seek origin.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_21","title":"Returns","text":"<p><code>Int64</code>: The final offset in the data stream after the seek.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#see-also_9","title":"See Also","text":"<ul> <li>Tell</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_27","title":"Remarks","text":"<p>This function is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Tell","title":"Tell","text":"<p>Determine the current read/write offset in the data stream.</p> <p>This is actually a wrapper function that calls <code>Seek</code> with an offset of 0 bytes from <code>TSdlIOWhence.Cur</code>, to simplify application development. </p> <p><code>function Tell: Int64; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_22","title":"Returns","text":"<p><code>Int64</code>: The current offset in the stream, or -1 if the information can not be determined.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#see-also_10","title":"See Also","text":"<ul> <li>Seek</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_28","title":"Remarks","text":"<p>This function is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#Write","title":"Write(Pointer, NativeInt)","text":"<p>Write to the stream.</p> <p>This function writes exactly <code>ASize</code> bytes from the area pointed at by <code>APtr</code> to the stream. If this fails for any reason, it will return less than <code>ASize</code> to demonstrate how far the write progressed. On success, it returns <code>ASize</code>.</p> <p>On error, this function still attempts to write as much as possible, so it might return a positive value less than the requested write size.</p> <p>The caller can use Status to determine if the problem is recoverable, such as a non-blocking write that can simply be retried later. When there is a fatal error, an ESdlError will be raised. </p> <p><code>function Write(const APtr: Pointer; const ASize: NativeInt): NativeInt</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_26","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_11","title":"Parameters","text":"<p><code>APtr</code>: <code>Pointer</code> : A pointer to a buffer containing data to write.</p> <p><code>ASize</code>: <code>NativeInt</code> : The number of bytes to write.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#returns_23","title":"Returns","text":"<p><code>NativeInt</code>: The number of bytes written, which will be less than <code>ASize</code> on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#see-also_11","title":"See Also","text":"<ul> <li>Read</li> <li>Seek</li> <li>Flush</li> <li>Status</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_29","title":"Remarks","text":"<p>This function is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#WriteS16BE","title":"WriteS16BE(Int16)","text":"<p>Write a signed 16-bit integer to the stream as big-endian data.</p> <p>SDL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in big-endian format. </p> <p><code>procedure WriteS16BE(const AValue: Int16); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_27","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_12","title":"Parameters","text":"<p><code>AValue</code>: <code>Int16</code> : The value to write.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_30","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#WriteS16LE","title":"WriteS16LE(Int16)","text":"<p>Write a signed 16-bit integer to the stream as little-endian data.</p> <p>SDL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in little-endian format. </p> <p><code>procedure WriteS16LE(const AValue: Int16); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_28","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_13","title":"Parameters","text":"<p><code>AValue</code>: <code>Int16</code> : The value to write.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_31","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#WriteS32BE","title":"WriteS32BE(Int32)","text":"<p>Write a signed 32-bit integer to the stream as big-endian data.</p> <p>SDL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in big-endian format. </p> <p><code>procedure WriteS32BE(const AValue: Int32); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_29","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_14","title":"Parameters","text":"<p><code>AValue</code>: <code>Int32</code> : The value to write.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_32","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#WriteS32LE","title":"WriteS32LE(Int32)","text":"<p>Write a signed 32-bit integer to the stream as little-endian data.</p> <p>SDL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in little-endian format. </p> <p><code>procedure WriteS32LE(const AValue: Int32); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_30","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_15","title":"Parameters","text":"<p><code>AValue</code>: <code>Int32</code> : The value to write.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_33","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#WriteS64BE","title":"WriteS64BE(Int64)","text":"<p>Write a signed 64-bit integer to the stream as big-endian data.</p> <p>SDL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in big-endian format. </p> <p><code>procedure WriteS64BE(const AValue: Int64); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_31","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_16","title":"Parameters","text":"<p><code>AValue</code>: <code>Int64</code> : The value to write.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_34","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#WriteS64LE","title":"WriteS64LE(Int64)","text":"<p>Write a signed 64-bit integer to the stream as little-endian data.</p> <p>SDL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in little-endian format. </p> <p><code>procedure WriteS64LE(const AValue: Int64); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_32","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_17","title":"Parameters","text":"<p><code>AValue</code>: <code>Int64</code> : The value to write.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_35","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#WriteS8","title":"WriteS8(Int8)","text":"<p>Write a signed byte to the stream. </p> <p><code>procedure WriteS8(const AValue: Int8); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_33","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_18","title":"Parameters","text":"<p><code>AValue</code>: <code>Int8</code> : The value to write.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_36","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#WriteU16BE","title":"WriteU16BE(UInt16)","text":"<p>Write an unsigned 16-bit integer to the stream as big-endian data.</p> <p>SDL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in big-endian format. </p> <p><code>procedure WriteU16BE(const AValue: UInt16); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_34","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_19","title":"Parameters","text":"<p><code>AValue</code>: <code>UInt16</code> : The value to write.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_37","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#WriteU16LE","title":"WriteU16LE(UInt16)","text":"<p>Write an unsigned 16-bit integer to the stream as little-endian data.</p> <p>SDL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in little-endian format. </p> <p><code>procedure WriteU16LE(const AValue: UInt16); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_35","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_20","title":"Parameters","text":"<p><code>AValue</code>: <code>UInt16</code> : The value to write.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_38","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#WriteU32BE","title":"WriteU32BE(UInt32)","text":"<p>Write an unsigned 32-bit integer to the stream as big-endian data.</p> <p>SDL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in big-endian format. </p> <p><code>procedure WriteU32BE(const AValue: UInt32); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_36","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_21","title":"Parameters","text":"<p><code>AValue</code>: <code>UInt32</code> : The value to write.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_39","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#WriteU32LE","title":"WriteU32LE(UInt32)","text":"<p>Write an unsigned 32-bit integer to the stream as little-endian data.</p> <p>SDL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in little-endian format. </p> <p><code>procedure WriteU32LE(const AValue: UInt32); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_37","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_22","title":"Parameters","text":"<p><code>AValue</code>: <code>UInt32</code> : The value to write.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_40","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#WriteU64BE","title":"WriteU64BE(UInt64)","text":"<p>Write an unsigned 64-bit integer to the stream as big-endian data.</p> <p>SDL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in big-endian format. </p> <p><code>procedure WriteU64BE(const AValue: UInt64); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_38","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_23","title":"Parameters","text":"<p><code>AValue</code>: <code>UInt64</code> : The value to write.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_41","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#WriteU64LE","title":"WriteU64LE(UInt64)","text":"<p>Write an unsigned 64-bit integer to the stream as little-endian data.</p> <p>SDL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in little-endian format. </p> <p><code>procedure WriteU64LE(const AValue: UInt64); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_39","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_24","title":"Parameters","text":"<p><code>AValue</code>: <code>UInt64</code> : The value to write.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_42","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#WriteU8","title":"WriteU8(UInt8)","text":"<p>Write an unsigned byte to the stream. </p> <p><code>procedure WriteU8(const AValue: UInt8); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#exceptions_40","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#parameters_25","title":"Parameters","text":"<p><code>AValue</code>: <code>UInt8</code> : The value to write.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStream/#remarks_43","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStreamInterface/","title":"TSdlIOStreamInterface","text":"<p>The function pointers that drive a TSdlIOStream.</p> <p>Applications can provide this struct to TSdlIOStream.Create to create their own implementation of TSdlIOStream. This is not necessarily required, as SDL already offers several common types of I/O streams, via other constructors of TSdlIOStream.</p> <p>This structure should be initialized calling Init.</p> <p>Note that all function pointers uses the \"cdecl\" calling conventions since these are directly using by the SDL C API. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStreamInterface/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>type TSdlIOStreamInterface = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStreamInterface/#fields","title":"Fields","text":"Name Description Close Close and free any allocated resources. Flush If the stream is buffering, make sure the data is written out. Read Read up to <code>ASize</code> bytes from the data stream to the area pointed at by <code>APtr</code>. Seek Seek to <code>AOffset</code> relative to <code>AWhence</code>. Size Return the number of bytes in this TSdlIOStream Version The version of the interface. Is set by calling Init. Write Write exactly <code>ASize</code> bytes from the area pointed at by <code>APtr</code> to data stream."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStreamInterface/#methods","title":"Methods","text":"Name Description Init Initializes this interface by setting the Version field and clearing all other fields."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStreamInterface/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStreamInterface/#Close","title":"Close","text":"<p>Close and free any allocated resources.</p> <p>This does not guarantee file writes will sync to physical media; they can be in the system's file cache, waiting to go to disk.</p> <p>The TSdlIOStream is still destroyed even if this fails, so clean up anything even if flushing buffers, etc, returns an error. </p> <p><code>var Close: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStreamInterface/#Flush","title":"Flush","text":"<p>If the stream is buffering, make sure the data is written out.</p> <p>On failure, you should set <code>AStatus</code> to a value from the TSdlIOStatus enum. You do not have to explicitly set this on a successful flush. </p> <p><code>var Flush: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStreamInterface/#Read","title":"Read","text":"<p>Read up to <code>ASize</code> bytes from the data stream to the area pointed at by <code>APtr</code>.</p> <p>On an incomplete read, you should set <code>AStatus</code> to a value from the TSdlIOStatus enum. You do not have to explicitly set this on a complete, successful read. </p> <p><code>var Read: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStreamInterface/#Seek","title":"Seek","text":"<p>Seek to <code>AOffset</code> relative to <code>AWhence</code>. </p> <p><code>var Seek: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStreamInterface/#Size","title":"Size","text":"<p>Return the number of bytes in this TSdlIOStream </p> <p><code>var Size: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStreamInterface/#Version","title":"Version","text":"<p>The version of the interface. Is set by calling Init. </p> <p><code>var Version: Cardinal</code></p> <p>Type: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStreamInterface/#Write","title":"Write","text":"<p>Write exactly <code>ASize</code> bytes from the area pointed at by <code>APtr</code> to data stream.</p> <p>On an incomplete write, you should set <code>AStatus</code> to a value from the TSdlIOStatus enum. You do not have to explicitly set this on a complete, successful write. </p> <p><code>var Write: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStreamInterface/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlIOStreamInterface/#Init","title":"Init","text":"<p>Initializes this interface by setting the Version field and clearing all other fields. </p> <p><code>procedure Init</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlPathInfo/","title":"TSdlPathInfo","text":"<p>Information about a path on the filesystem. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlPathInfo/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>type TSdlPathInfo = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlPathInfo/#see-also","title":"See Also","text":"<ul> <li>TSdlStorage.GetPathInfo</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlPathInfo/#properties","title":"Properties","text":"Name Description AccessTime The last time the path was read. CreateTime The time when the path was created. Kind The path type. ModifyTime The last time the path was modified. Size The file size in bytes."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlPathInfo/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlPathInfo/#AccessTime","title":"AccessTime","text":"<p>The last time the path was read. </p> <p><code>property AccessTime: TDateTime read GetAccessTime</code></p> <p>Type: <code>TDateTime</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlPathInfo/#CreateTime","title":"CreateTime","text":"<p>The time when the path was created. </p> <p><code>property CreateTime: TDateTime read GetCreateTime</code></p> <p>Type: <code>TDateTime</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlPathInfo/#Kind","title":"Kind","text":"<p>The path type. </p> <p><code>property Kind: TSdlPathKind read GetKind</code></p> <p>Type: <code>TSdlPathKind</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlPathInfo/#ModifyTime","title":"ModifyTime","text":"<p>The last time the path was modified. </p> <p><code>property ModifyTime: TDateTime read GetModifyTime</code></p> <p>Type: <code>TDateTime</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlPathInfo/#Size","title":"Size","text":"<p>The file size in bytes. </p> <p><code>property Size: Int64 read GetSize</code></p> <p>Type: <code>Int64</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/","title":"TSdlStorage","text":"<p>An abstract interface for filesystem access. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>type TSdlStorage = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#properties","title":"Properties","text":"Name Description IsReady Whether the storage container is ready to use. SpaceRemaining The remaining space in a storage container."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#methods","title":"Methods","text":"Name Description Close Alternative to Free. CopyFile Copy a file in a writable storage container. CreateDirectory Create a directory in a writable storage container. EnumerateDirectory Enumerate a directory in the storage container. Free Closes and frees the storage container. GetFileSize Query the size of a file within a storage container. GetPathInfo Get information about a filesystem path in the storage container. GlobDirectory Enumerate a directory tree, filtered by pattern, and return a list. OpenCustom Opens up a container using a client-provided storage interface. OpenFile Opens up a container for local filesystem storage. OpenTitle(String, TSdlProperties) Opens up a read-only container for the application's filesystem. OpenTitle(String) Opens up a read-only container for the application's filesystem. OpenUser(String, String, TSdlProperties) Opens up a container for a user's unique read/write filesystem. OpenUser(String, String) Opens up a container for a user's unique read/write filesystem. PathExists Checks whether a path in the storage container exists. ReadFile(String, , Int64) Synchronously read a file from a storage container into a client-provided buffer. ReadFile(String) Synchronously read a file from a storage container. RemovePath Remove a file or an empty directory in a writable storage container. RenamePath Rename a file or directory in a writable storage container. WriteFile(String, TBytes) Synchronously write a file. WriteFile(String, , Int64) Synchronously write a file from client memory into a storage container."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#IsReady","title":"IsReady","text":"<p>Whether the storage container is ready to use.</p> <p>This property should be checked at regular intervals until it returns True - however, it is not recommended to spinwait on this call, as the backend may depend on a synchronous message loop. </p> <p><code>property IsReady: Boolean read GetIsReady</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#SpaceRemaining","title":"SpaceRemaining","text":"<p>The remaining space in a storage container. </p> <p><code>property SpaceRemaining: Int64 read GetSpaceRemaining</code></p> <p>Type: <code>Int64</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also","title":"See Also","text":"<ul> <li>IsReady</li> <li>WriteFile</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#Equal","title":"Equal(TSdlStorage, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlStorage; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlStorage</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlStorage; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#returns_1","title":"Returns","text":"<p><code>TSdlStorage</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#NotEqual","title":"NotEqual(TSdlStorage, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlStorage; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlStorage</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#Close","title":"Close","text":"<p>Alternative to Free. </p> <p><code>procedure Close; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#CopyFile","title":"CopyFile(String, String)","text":"<p>Copy a file in a writable storage container. </p> <p><code>procedure CopyFile(const AOldPath, ANewPath: String); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_3","title":"Parameters","text":"<p><code>AOldPath</code>: <code>String</code> : The old path.</p> <p><code>ANewPath</code>: <code>String</code> : The new path.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_1","title":"See Also","text":"<ul> <li>IsReady</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#CreateDirectory","title":"CreateDirectory(String)","text":"<p>Create a directory in a writable storage container. </p> <p><code>procedure CreateDirectory(const APath: String); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_4","title":"Parameters","text":"<p><code>APath</code>: <code>String</code> : The path of the directory to create.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_2","title":"See Also","text":"<ul> <li>IsReady</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#EnumerateDirectory","title":"EnumerateDirectory(String)","text":"<p>Enumerate a directory in the storage container.</p> <p>If <code>APath</code> is empty, this is treated as a request to enumerate the root of the storage container's tree. </p> <p><code>function EnumerateDirectory(const APath: String = ''): TArray&lt;TSdlDirectoryEntry&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_5","title":"Parameters","text":"<p><code>APath</code>: <code>String = ''</code> : (Optional) path of the directory to enumerate, or empty (default) for the root.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#returns_3","title":"Returns","text":"<p><code>TArray&lt;TSdlDirectoryEntry&gt;</code>: An array of all entries in this directory.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_3","title":"See Also","text":"<ul> <li>IsReady</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#Free","title":"Free","text":"<p>Closes and frees the storage container. </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_4","title":"See Also","text":"<ul> <li>OpenFile</li> <li>OpenCustom</li> <li>OpenTitle</li> <li>OpenUser</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#GetFileSize","title":"GetFileSize(String)","text":"<p>Query the size of a file within a storage container. </p> <p><code>function GetFileSize(const APath: String): Int64; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_6","title":"Parameters","text":"<p><code>APath</code>: <code>String</code> : The relative path of the file to query.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#returns_4","title":"Returns","text":"<p><code>Int64</code>: The file's length.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_5","title":"See Also","text":"<ul> <li>ReadFile</li> <li>IsReady</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#GetPathInfo","title":"GetPathInfo(String)","text":"<p>Get information about a filesystem path in the storage container. </p> <p><code>function GetPathInfo(const APath: String): TSdlPathInfo; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure (e.g. when the file does not exist).</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_7","title":"Parameters","text":"<p><code>APath</code>: <code>String</code> : The path to query.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#returns_5","title":"Returns","text":"<p><code>TSdlPathInfo</code>: Information about the path.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_6","title":"See Also","text":"<ul> <li>IsReady</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#GlobDirectory","title":"GlobDirectory(String, String, Boolean)","text":"<p>Enumerate a directory tree, filtered by pattern, and return a list.</p> <p>Files are filtered out if they don't match the string in <code>APattern</code>, which may contain wildcard characters '' (match everything) and '?' (match one character). If APattern is empty, no filtering is done and all results are returned. Subdirectories are permitted, and are specified with a path separator of '/'. Wildcard characters '' and '?' never match a path separator.</p> <p>If <code>APath</code> is empty, this is treated as a request to enumerate the root of the storage container's tree. </p> <p><code>function GlobDirectory(const APath: String = ''; const APattern: String = ''; const ACaseInsensitive: Boolean = False): TArray&lt;String&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_6","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_8","title":"Parameters","text":"<p><code>APath</code>: <code>String = ''</code> : (Optional) path of the directory to enumerate, or empty (default) for the root.</p> <p><code>APattern</code>: <code>String = ''</code> : (Optional) pattern that files in the directory must match, or empty to include all results.</p> <p><code>ACaseInsensitive</code>: <code>Boolean = False</code> : (Optional) flag whether pattern matching is case-insensitive (default False, meaning case-sensitive).</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#returns_6","title":"Returns","text":"<p><code>TArray&lt;String&gt;</code>: An array of strings.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#remarks","title":"Remarks","text":"<p>It is safe to call this method from any thread, assuming the storage object is thread-safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#OpenCustom","title":"OpenCustom(TSdlStorageInterface, Pointer)","text":"<p>Opens up a container using a client-provided storage interface.</p> <p>Applications do not need to use this function unless they are providing their own TSdlStorage implementation. If you just need a TSdlStorage, you should use the built-in implementations in SDL, like OpenTitle or OpenUser. </p> <p><code>class function OpenCustom(const AInterface: TSdlStorageInterface; const AUserData: Pointer): TSdlStorage; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_7","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_9","title":"Parameters","text":"<p><code>AInterface</code>: <code>TSdlStorageInterface</code> : The interface that implements this storage, initialized using Init.</p> <p><code>AUserData</code>: <code>Pointer</code> : The pointer that will be passed to the interface functions.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#returns_7","title":"Returns","text":"<p><code>TSdlStorage</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_7","title":"See Also","text":"<ul> <li>Free</li> <li>GetFileSize</li> <li>SpaceRemaining</li> <li>OpenTitle</li> <li>OpenUser</li> <li>ReadFile</li> <li>WriteFile</li> <li>IsReady</li> <li>TSdlStorageInterface.Init</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#OpenFile","title":"OpenFile(String)","text":"<p>Opens up a container for local filesystem storage.</p> <p>This is provided for development and tools. Portable applications should use OpenTitle for access to game data and OpenUser for access to user data. </p> <p><code>class function OpenFile(const APath: String = ''): TSdlStorage; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_8","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_10","title":"Parameters","text":"<p><code>APath</code>: <code>String = ''</code> : (Optional) base path prepended to all storage paths.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#returns_8","title":"Returns","text":"<p><code>TSdlStorage</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_8","title":"See Also","text":"<ul> <li>Free</li> <li>GetFileSize</li> <li>SpaceRemaining</li> <li>OpenTitle</li> <li>OpenUser</li> <li>ReadFile</li> <li>WriteFile</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#OpenTitle_0","title":"OpenTitle(String, TSdlProperties)","text":"<p>Opens up a read-only container for the application's filesystem. </p> <p><code>class function OpenTitle(const AOverride: String; const AProps: TSdlProperties): TSdlStorage; overload; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_9","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_11","title":"Parameters","text":"<p><code>AOverride</code>: <code>String</code> : A path to override the backend's default title root.</p> <p><code>AProps</code>: <code>TSdlProperties</code> : A property list that may contain backend-specific information.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#returns_9","title":"Returns","text":"<p><code>TSdlStorage</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_9","title":"See Also","text":"<ul> <li>Free</li> <li>GetFileSize</li> <li>OpenUser</li> <li>ReadFile</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#OpenTitle_1","title":"OpenTitle(String)","text":"<p>Opens up a read-only container for the application's filesystem. </p> <p><code>class function OpenTitle(const AOverride: String = ''): TSdlStorage; overload; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_10","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_12","title":"Parameters","text":"<p><code>AOverride</code>: <code>String = ''</code> : (Optional) path to override the backend's default title root.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#returns_10","title":"Returns","text":"<p><code>TSdlStorage</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_10","title":"See Also","text":"<ul> <li>Free</li> <li>GetFileSize</li> <li>OpenUser</li> <li>ReadFile</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#OpenUser_0","title":"OpenUser(String, String, TSdlProperties)","text":"<p>Opens up a container for a user's unique read/write filesystem.</p> <p>While title storage can generally be kept open throughout runtime, user storage should only be opened when the client is ready to read/write files. This allows the backend to properly batch file operations and flush them when the container has been closed; ensuring safe and optimal save I/O. </p> <p><code>class function OpenUser(const AOrg, AApp: String; const AProps: TSdlProperties): TSdlStorage; overload; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_11","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_13","title":"Parameters","text":"<p><code>AOrg</code>: <code>String</code> : The name of your organization.</p> <p><code>AApp</code>: <code>String</code> : The name of your application.</p> <p><code>AProps</code>: <code>TSdlProperties</code> : A property list that may contain backend-specific information.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#returns_11","title":"Returns","text":"<p><code>TSdlStorage</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_11","title":"See Also","text":"<ul> <li>Free</li> <li>GetFileSize</li> <li>OpenTitle</li> <li>ReadFile</li> <li>SpaceRemaining</li> <li>IsReady</li> <li>WriteFile</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#OpenUser_1","title":"OpenUser(String, String)","text":"<p>Opens up a container for a user's unique read/write filesystem.</p> <p>While title storage can generally be kept open throughout runtime, user storage should only be opened when the client is ready to read/write files. This allows the backend to properly batch file operations and flush them when the container has been closed; ensuring safe and optimal save I/O. </p> <p><code>class function OpenUser(const AOrg, AApp: String): TSdlStorage; overload; static</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_12","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_14","title":"Parameters","text":"<p><code>AOrg</code>: <code>String</code> : The name of your organization.</p> <p><code>AApp</code>: <code>String</code> : The name of your application.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#returns_12","title":"Returns","text":"<p><code>TSdlStorage</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_12","title":"See Also","text":"<ul> <li>Free</li> <li>GetFileSize</li> <li>OpenTitle</li> <li>ReadFile</li> <li>SpaceRemaining</li> <li>IsReady</li> <li>WriteFile</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#PathExists","title":"PathExists(String)","text":"<p>Checks whether a path in the storage container exists. </p> <p><code>function PathExists(const APath: String): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_15","title":"Parameters","text":"<p><code>APath</code>: <code>String</code> : The path to query.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#returns_13","title":"Returns","text":"<p><code>Boolean</code>: True if the path exists, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_13","title":"See Also","text":"<ul> <li>IsReady</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#ReadFile_0","title":"ReadFile(String, [untyped], Int64)","text":"<p>Synchronously read a file from a storage container into a client-provided buffer.</p> <p>The value of <code>ALength</code> must match the length of the file exactly; call GetFileSize to get this value. This behavior may be relaxed in a future release. </p> <p><code>procedure ReadFile(const APath: String; var ADestination; const ALength: Int64); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_13","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_16","title":"Parameters","text":"<p><code>APath</code>: <code>String</code> : The relative path of the file to read.</p> <p><code>ADestination</code>:  : A client-provided buffer to read the file into.</p> <p><code>ALength</code>: <code>Int64</code> : The length of the destination buffer.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_14","title":"See Also","text":"<ul> <li>GetFileSize</li> <li>IsReady</li> <li>WriteFile</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#ReadFile_1","title":"ReadFile(String)","text":"<p>Synchronously read a file from a storage container. </p> <p><code>function ReadFile(const APath: String): TBytes; overload</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_14","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_17","title":"Parameters","text":"<p><code>APath</code>: <code>String</code> : The relative path of the file to read.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#returns_14","title":"Returns","text":"<p><code>TBytes</code>: The file's content.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_15","title":"See Also","text":"<ul> <li>GetFileSize</li> <li>IsReady</li> <li>WriteFile</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#RemovePath","title":"RemovePath(String)","text":"<p>Remove a file or an empty directory in a writable storage container. </p> <p><code>procedure RemovePath(const APath: String); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_15","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_18","title":"Parameters","text":"<p><code>APath</code>: <code>String</code> : The path of the file or directory to remove.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_16","title":"See Also","text":"<ul> <li>IsReady</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#RenamePath","title":"RenamePath(String, String)","text":"<p>Rename a file or directory in a writable storage container. </p> <p><code>procedure RenamePath(const AOldPath, ANewPath: String); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_16","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_19","title":"Parameters","text":"<p><code>AOldPath</code>: <code>String</code> : The old path.</p> <p><code>ANewPath</code>: <code>String</code> : The new path.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_17","title":"See Also","text":"<ul> <li>IsReady</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#WriteFile_0","title":"WriteFile(String, TBytes)","text":"<p>Synchronously write a file. </p> <p><code>procedure WriteFile(const APath: String; const ASource: TBytes); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_17","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_20","title":"Parameters","text":"<p><code>APath</code>: <code>String</code> : The relative path of the file to write.</p> <p><code>ASource</code>: <code>TBytes</code> : The buffer to write from.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_18","title":"See Also","text":"<ul> <li>SpaceRemaining</li> <li>ReadFile</li> <li>IsReady</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#WriteFile_1","title":"WriteFile(String, [untyped], Int64)","text":"<p>Synchronously write a file from client memory into a storage container. </p> <p><code>procedure WriteFile(const APath: String; const ASource; const ALength: Int64); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#exceptions_18","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#parameters_21","title":"Parameters","text":"<p><code>APath</code>: <code>String</code> : The relative path of the file to write.</p> <p><code>ASource</code>:  : A client-provided buffer to write from.</p> <p><code>ALength</code>: <code>Int64</code> : The length of the source buffer.</p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorage/#see-also_19","title":"See Also","text":"<ul> <li>SpaceRemaining</li> <li>ReadFile</li> <li>IsReady</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/","title":"TSdlStorageInterface","text":"<p>Function interface for TSdlStorage.</p> <p>Apps that want to supply a custom implementation of TSdlStorage will fill in all the functions in this record, and then pass it to TSdlStorage.Open create a custom TSdlStorage object.</p> <p>It is not usually necessary to do this; SDL provides standard implementations for many things you might expect to do with a TSdlStorage.</p> <p>This structure should be initialized using Init.</p> <p>Note that all function pointers uses the \"cdecl\" calling conventions since these are directly using by the SDL C API. </p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>type TSdlStorageInterface = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#fields","title":"Fields","text":"Name Description Close Copy Enumerate Info MkDir ReadFile Ready Remove Rename SpaceRemaining Version WriteFile"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#methods","title":"Methods","text":"Name Description Init Initializes this interface by setting the Version field and clearing all other fields."},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#Close","title":"Close","text":"<p><code>var Close: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#Copy","title":"Copy","text":"<p><code>var Copy: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#Enumerate","title":"Enumerate","text":"<p><code>var Enumerate: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#Info","title":"Info","text":"<p><code>var Info: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#MkDir","title":"MkDir","text":"<p><code>var MkDir: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#ReadFile","title":"ReadFile","text":"<p><code>var ReadFile: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#Ready","title":"Ready","text":"<p><code>var Ready: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#Remove","title":"Remove","text":"<p><code>var Remove: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#Rename","title":"Rename","text":"<p><code>var Rename: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#SpaceRemaining","title":"SpaceRemaining","text":"<p><code>var SpaceRemaining: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#Version","title":"Version","text":"<p><code>var Version: Cardinal</code></p> <p>Type: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#WriteFile","title":"WriteFile","text":"<p><code>var WriteFile: function</code></p> <p>Type: <code>function</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.IO/classes/TSdlStorageInterface/#Init","title":"Init","text":"<p>Initializes this interface by setting the Version field and clearing all other fields. </p> <p><code>procedure Init</code></p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoadAsync/","title":"SdlLoadAsync","text":"<p>Load all the data from a file path, asynchronously.</p> <p>This routine returns as quickly as possible; it does not wait for the read to complete. On a successful return, this work will continue in the background. If the work begins, even failure is asynchronous: a failing return value from this function only means the work couldn't start at all.</p> <p>The data is allocated with a zero byte at the end (null terminated) for convenience. This extra byte is not included in TSdlAsyncIOOutcome's BytesTransferred value.</p> <p>This routine will allocate the buffer to contain the file. It must be deallocated by calling SdlFree on TSdlAsyncIOOutcome's buffer field after completion.</p> <p>A TSdlAsyncIOQueue must be specified. The newly-created task will be added to it when it completes its work. </p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoadAsync/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>procedure SdlLoadAsync(const AFilename: String; const AQueue: TSdlAsyncIOQueue; \n  const AUserData: Pointer)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoadAsync/#parameters","title":"Parameters","text":"<p><code>AFilename</code>: <code>String</code> : The path to read all available data from.</p> <p><code>AQueue</code>: <code>TSdlAsyncIOQueue</code> : A queue to add the new TSdlAsyncIO to.</p> <p><code>AUserData</code>: <code>Pointer</code> : An app-defined pointer that will be provided with the task results.</p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoadAsync/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoadAsync/#see-also","title":"See Also","text":"<ul> <li>SdlLoad</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoad_0/","title":"SdlLoad","text":"<p>Load all the data from a file path.</p> <p>The data is allocated with a zero byte at the end (null terminated) for convenience.</p> <p>The data should be freed with SdlFree. </p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoad_0/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>function SdlLoad(const AFilename: String): Pointer; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoad_0/#parameters","title":"Parameters","text":"<p><code>AFilename</code>: <code>String</code> : The path to read all available data from.</p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoad_0/#returns","title":"Returns","text":"<p><code>Pointer</code>: The data.</p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoad_0/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoad_0/#see-also","title":"See Also","text":"<ul> <li>TSdlIOStream.Load</li> <li>SdlSave</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoad_0/#remarks","title":"Remarks","text":"<p>This function is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoad_1/","title":"SdlLoad","text":"<p>Load all the data from a file path.</p> <p>The data is allocated with a zero byte at the end (null terminated) for convenience. This extra byte is not included in the value reported via <code>ADataSize</code>.</p> <p>The data should be freed with SdlFree. </p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoad_1/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>function SdlLoad(const AFilename: String; out ADataSize: NativeInt): Pointer; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoad_1/#parameters","title":"Parameters","text":"<p><code>AFilename</code>: <code>String</code> : The path to read all available data from.</p> <p><code>ADataSize</code>: <code>NativeInt</code> : Set to the number of bytes read.</p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoad_1/#returns","title":"Returns","text":"<p><code>Pointer</code>: The data.</p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoad_1/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoad_1/#see-also","title":"See Also","text":"<ul> <li>TSdlIOStream.Load</li> <li>SdlSave</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlLoad_1/#remarks","title":"Remarks","text":"<p>This function is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlSave/","title":"SdlSave","text":"<p>Save all the data into a file path. </p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlSave/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>procedure SdlSave(const AFilename: String; const AData: Pointer; \n  const ADataSize: NativeInt); inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlSave/#parameters","title":"Parameters","text":"<p><code>AFilename</code>: <code>String</code> : The path to write all available data into.</p> <p><code>AData</code>: <code>Pointer</code> : The data to be written. If ADataSize is 0, may be nil or a invalid pointer.</p> <p><code>ADataSize</code>: <code>NativeInt</code> : The number of bytes to be written.</p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlSave/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlSave/#see-also","title":"See Also","text":"<ul> <li>TSdlIOStream.Save</li> <li>SdlLoad</li> </ul>"},{"location":"Reference/Neslib.Sdl3.IO/routines/SdlSave/#remarks","title":"Remarks","text":"<p>This routine is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlAsyncIOResult/","title":"TSdlAsyncIOResult","text":"<p>Possible outcomes of an asynchronous I/O task. </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlAsyncIOResult/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>type TSdlAsyncIOResult = (Complete, Failure, Canceled)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlAsyncIOResult/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlAsyncIOResult/#complete-sdl_asyncio_complete","title":"<code>Complete = SDL_ASYNCIO_COMPLETE</code>","text":"<p>Request was completed without error. </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlAsyncIOResult/#failure-sdl_asyncio_failure","title":"<code>Failure = SDL_ASYNCIO_FAILURE</code>","text":"<p>Request failed for some reason. </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlAsyncIOResult/#canceled-sdl_asyncio_canceled","title":"<code>Canceled = SDL_ASYNCIO_CANCELED</code>","text":"<p>Request was canceled before completing. </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlAsyncIOTaskKind/","title":"TSdlAsyncIOTaskKind","text":"<p>Types of asynchronous I/O tasks. </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlAsyncIOTaskKind/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>type TSdlAsyncIOTaskKind = (Read, Write, Close)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlAsyncIOTaskKind/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlAsyncIOTaskKind/#read-sdl_asyncio_task_read","title":"<code>Read = SDL_ASYNCIO_TASK_READ</code>","text":"<p>A read operation. </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlAsyncIOTaskKind/#write-sdl_asyncio_task_write","title":"<code>Write = SDL_ASYNCIO_TASK_WRITE</code>","text":"<p>A write operation. </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlAsyncIOTaskKind/#close-sdl_asyncio_task_close","title":"<code>Close = SDL_ASYNCIO_TASK_CLOSE</code>","text":"<p>A close operation. </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlIOStatus/","title":"TSdlIOStatus","text":"<p>TSdlIOStream status, set by a read or write operation. </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlIOStatus/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>type TSdlIOStatus = (Ready, Error, Eof, NotReady, ReadOnly, WriteOnly)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlIOStatus/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlIOStatus/#ready-sdl_io_status_ready","title":"<code>Ready = SDL_IO_STATUS_READY</code>","text":"<p>Everything is ready (no errors and not EOF). </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlIOStatus/#error-sdl_io_status_error","title":"<code>Error = SDL_IO_STATUS_ERROR</code>","text":"<p>Read or write I/O error </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlIOStatus/#eof-sdl_io_status_eof","title":"<code>Eof = SDL_IO_STATUS_EOF</code>","text":"<p>End of file </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlIOStatus/#notready-sdl_io_status_not_ready","title":"<code>NotReady = SDL_IO_STATUS_NOT_READY</code>","text":"<p>Non blocking I/O, not ready </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlIOStatus/#readonly-sdl_io_status_readonly","title":"<code>ReadOnly = SDL_IO_STATUS_READONLY</code>","text":"<p>Tried to write a read-only buffer </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlIOStatus/#writeonly-sdl_io_status_writeonly","title":"<code>WriteOnly = SDL_IO_STATUS_WRITEONLY</code>","text":"<p>Tried to read a write-only buffer </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlIOWhence/","title":"TSdlIOWhence","text":"<p>Possible <code>whence</code> values for TSdlIOStream seeking.</p> <p>These map to the same TSeekOrigin used in the Delphi RTL. </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlIOWhence/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>type TSdlIOWhence = (&amp;Set, Cur, &amp;End)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlIOWhence/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlIOWhence/#set-sdl_io_seek_set","title":"<code>&amp;Set = SDL_IO_SEEK_SET</code>","text":"<p>Seek from the beginning of data </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlIOWhence/#cur-sdl_io_seek_cur","title":"<code>Cur = SDL_IO_SEEK_CUR</code>","text":"<p>Seek relative to current read point </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlIOWhence/#end-sdl_io_seek_end","title":"<code>&amp;End = SDL_IO_SEEK_END</code>","text":"<p>Seek relative to the end of data </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlPathKind/","title":"TSdlPathKind","text":"<p>Types of filesystem entries. Note that there may be other sorts of items on a filesystem: devices, symlinks, named pipes, etc. They are currently reported as Other. </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlPathKind/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.IO</p> <pre><code>type TSdlPathKind = (None, &amp;File, Directory, Other)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlPathKind/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlPathKind/#none-sdl_pathtype_none","title":"<code>None = SDL_PATHTYPE_NONE</code>","text":"<p>Path does not exist. </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlPathKind/#file-sdl_pathtype_file","title":"<code>&amp;File = SDL_PATHTYPE_FILE</code>","text":"<p>A normal file. </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlPathKind/#directory-sdl_pathtype_directory","title":"<code>Directory = SDL_PATHTYPE_DIRECTORY</code>","text":"<p>A directory. </p>"},{"location":"Reference/Neslib.Sdl3.IO/types/TSdlPathKind/#other-sdl_pathtype_other","title":"<code>Other = SDL_PATHTYPE_OTHER</code>","text":"<p>Something completely different like a device node (not a symlink, those are always followed) </p>"},{"location":"Reference/Neslib.Sdl3.Input/","title":"Neslib.Sdl3.Input","text":""},{"location":"Reference/Neslib.Sdl3.Input/#classes-records","title":"Classes &amp; Records","text":"Name Description TSdlCursor The structure used to identify an SDL cursor. TSdlFinger Data about a single finger in a multitouch event. TSdlGamepad An SDL gamepad TSdlGamepadBinding A mapping between one joystick input to a gamepad control. TSdlGamepadID This is a unique ID for a gamepad for the time it is connected to the system, and is never reused for the lifetime of the application. TSdlJoystick An SDL joystick TSdlJoystickID This is a unique ID for a joystick for the time it is connected to the system, and is never reused for the lifetime of the application. TSdlKeyboard Represents a keyboard. TSdlKeyboardState The state of a keyboard. TSdlMouse A mouse TSdlSensor An opened SDL sensor. TSdlSensorID This is a unique ID for a sensor for the time it is connected to the system, and is never reused for the lifetime of the application. TSdlTouch A touch device TSdlVirtualJoystickDesc A virtual joystick. TSdlVirtualJoystickSensorDesc A virtual joystick sensor. TSdlVirtualJoystickTouchpadDesc A virtual joystick touchpad."},{"location":"Reference/Neslib.Sdl3.Input/#types","title":"Types","text":"Name Description TSdlBasicGamepadAxis TSdlBasicGamepadButton TSdlFingerID A unique ID for a single finger on a touch device. TSdlGamepadAxes TSdlGamepadAxis The list of axes available on a gamepad TSdlGamepadBindingType Types of gamepad control bindings. TSdlGamepadButton The list of buttons available on a gamepad TSdlGamepadButtonLabel The set of gamepad button labels TSdlGamepadButtons TSdlGamepadConnectionState Possible connection states for a gamepad device. TSdlGamepadKind Standard gamepad types. TSdlHat Joystick Hat positions TSdlJoystickConnectionState Possible connection states for a joystick device. TSdlJoystickKind An enum of some common joystick types. TSdlKeycode The SDL virtual key representation. TSdlKeyMod Valid key modifiers. TSdlKeyMods A set of valid key modifiers. TSdlMouseButton Pressed mouse buttons, as reported by TSdlMouse.GetPressedButtons, etc. TSdlMouseButtons A set of mouse buttons. TSdlMouseWheelDirection Scroll direction types for the Scroll event TSdlPenAxis Pen axis indices. TSdlPenID SDL pen instance IDs. TSdlPenInputFlag Pen input flag, as reported by various pen events' <code>PenState</code> field. TSdlPenInputFlags Set of pen input flags. TSdlScancode The SDL keyboard scancode representation. TSdlSensorKind The different sensors defined by SDL. TSdlSystemCursor Cursor types for TSdlCursor.Create. TSdlTouchDeviceType An enum that describes the type of a touch device. TSdlVirtualJoystickCleanup Callback type for TSdlVirtualJoystickDesc.Cleanup TSdlVirtualJoystickRumble Callback type for TSdlVirtualJoystickDesc.Rumble TSdlVirtualJoystickRumbleTriggers Callback type for TSdlVirtualJoystickDesc.RumbleTriggers TSdlVirtualJoystickSendEffect Callback type for TSdlVirtualJoystickDesc.SendEffect TSdlVirtualJoystickSetLed Callback type for TSdlVirtualJoystickDesc.SetLed TSdlVirtualJoystickSetPlayerIndex Callback type for TSdlVirtualJoystickDesc.SetPlayerIndex TSdlVirtualJoystickSetSensorsEnabled Callback type for TSdlVirtualJoystickDesc.SetSensorsEnabled TSdlVirtualJoystickUpdate Callback type for TSdlVirtualJoystickDesc.Update"},{"location":"Reference/Neslib.Sdl3.Input/#constants","title":"Constants","text":"Name Description SDL_JOYSTICK_AXIS_MAX The largest value an SDL_Joystick's axis can report. SDL_JOYSTICK_AXIS_MIN The smallest value an SDL_Joystick's axis can report. SDL_STANDARD_GRAVITY A constant to represent standard gravity for accelerometer sensors."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/","title":"TSdlCursor","text":"<p>The structure used to identify an SDL cursor.</p> <p>This is opaque data. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlCursor = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#remarks","title":"Remarks","text":"<p>This struct is available since SDL 3.2.0. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#properties","title":"Properties","text":"Name Description Active The active cursor. Default The default cursor. IsVisible Whether the cursor is currently being shown."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#constructors","title":"Constructors","text":"Name Description Create(TSdlSystemCursor) Create a system cursor. Create(TSdlSurface, Integer, Integer) Create a color cursor. Create(Pointer, Pointer, Integer, Integer, Integer, Integer) Create a cursor using the specified bitmap data and mask (in MSB format)."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#methods","title":"Methods","text":"Name Description Free Free a previously-created cursor. Hide Hide the cursor. Show Show the cursor."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#Active","title":"Active","text":"<p>The active cursor.</p> <p>Allows you to set the currently active cursor to the specified one. If the cursor is currently visible, the change will be immediately represented on the display. You can set this properyt to nil to force cursor redraw, if this is desired for any reason. </p> <p><code>class property Active: TSdlCursor read GetActive write SetActive</code></p> <p>Type: <code>TSdlCursor</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#remarks_1","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#Default","title":"Default","text":"<p>The default cursor.</p> <p>You do not have to call Free on this cursor, but it is safe to do so. </p> <p><code>class property Default: TSdlCursor read GetDefault</code></p> <p>Type: <code>TSdlCursor</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#remarks_2","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#IsVisible","title":"IsVisible","text":"<p>Whether the cursor is currently being shown.</p> <p>Setting this property is equivalent to calling Show or Hide. </p> <p><code>class property IsVisible: Boolean read GetIsVisible write SetIsVisible</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#see-also","title":"See Also","text":"<ul> <li>Hide</li> <li>Show</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#remarks_3","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#Create_0","title":"<code>Create</code>","text":"<p>Create a system cursor. </p> <p><code>constructor Create(const ASystemCursor: TSdlSystemCursor); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#parameters","title":"Parameters","text":"<p><code>ASystemCursor</code>: <code>TSdlSystemCursor</code> : The TSdlSystemCursor enum value.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#see-also_1","title":"See Also","text":"<ul> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#remarks_4","title":"Remarks","text":"<p>This constructor should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#Create_1","title":"<code>Create</code>","text":"<p>Create a color cursor.</p> <p>If this constructor is passed a surface with alternate representations, the surface will be interpreted as the content to be used for 100% display scale, and the alternate representations will be used for high DPI situations. For example, if the original surface is 32x32, then on a 2x macOS display or 200% display scale on Windows, a 64x64 version of the image will be used, if available. If a matching version of the image isn't available, the closest larger size image will be downscaled to the appropriate size and be used instead, if available. Otherwise, the closest smaller image will be upscaled and be used instead. </p> <p><code>constructor Create(const ASurface: TSdlSurface; const AHotX, AHotY: Integer); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#parameters_1","title":"Parameters","text":"<p><code>ASurface</code>: <code>TSdlSurface</code> : An SDL surface representing the cursor image.</p> <p><code>AHotX</code>: <code>Integer</code> : The X position of the cursor hot spot.</p> <p><code>AHotY</code>: <code>Integer</code> : The Y position of the cursor hot spot.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#see-also_2","title":"See Also","text":"<ul> <li>Free</li> <li>Active</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#remarks_5","title":"Remarks","text":"<p>This constructor should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#Create_2","title":"<code>Create</code>","text":"<p>Create a cursor using the specified bitmap data and mask (in MSB format).</p> <p><code>AMask</code> has to be in MSB (Most Significant Bit) format.</p> <p>The cursor width (<code>AW</code>) must be a multiple of 8 bits.</p> <p>The cursor is created in black and white according to the following:</p> <ul> <li>AData=0, AMask=1: white</li> <li>AData=1, AMask=1: black</li> <li>AData=0, AMask=0: transparent</li> <li>AData=1, AMask=0: inverted color if possible, black if not.</li> </ul> <p>Cursors created with this function must be freed with Free.</p> <p>If you want to have a color cursor, or create your cursor from an SDL_Surface, you should use another constructor. Alternately, you can hide the cursor and draw your own as part of your game's rendering, but it will be bound to the framerate.</p> <p>There is also a constructor that creates a system cursor, which provides several readily-available system cursors to pick from. </p> <p><code>constructor Create(const AData, AMask: Pointer; const AW, AH, AHotX, AHotY: Integer); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#parameters_2","title":"Parameters","text":"<p><code>AData</code>: <code>Pointer</code> : The color value for each pixel of the cursor.</p> <p><code>AMask</code>: <code>Pointer</code> : The mask value for each pixel of the cursor.</p> <p><code>AW</code>: <code>Integer</code> : The width of the cursor.</p> <p><code>AH</code>: <code>Integer</code> : The height of the cursor.</p> <p><code>AHotX</code>: <code>Integer</code> : The X-axis offset from the left of the cursor image to the mouse X position, in the range of 0 to <code>AW</code> - 1.</p> <p><code>AHotY</code>: <code>Integer</code> : The Y-axis offset from the top of the cursor image to the mouse Y position, in the range of 0 to <code>AH</code> - 1.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#see-also_3","title":"See Also","text":"<ul> <li>Free</li> <li>Active</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#remarks_6","title":"Remarks","text":"<p>This constructor should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#Equal","title":"Equal(TSdlCursor, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlCursor; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#parameters_3","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlCursor</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlCursor; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#parameters_4","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#returns_1","title":"Returns","text":"<p><code>TSdlCursor</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#NotEqual","title":"NotEqual(TSdlCursor, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlCursor; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#parameters_5","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlCursor</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#Free","title":"Free","text":"<p>Free a previously-created cursor. </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#see-also_4","title":"See Also","text":"<ul> <li>Create</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#remarks_7","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#Hide","title":"Hide","text":"<p>Hide the cursor. </p> <p><code>class procedure Hide; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#exceptions_6","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#see-also_5","title":"See Also","text":"<ul> <li>IsVisible</li> <li>Show</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#remarks_8","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#Show","title":"Show","text":"<p>Show the cursor. </p> <p><code>class procedure Show; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#exceptions_7","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#see-also_6","title":"See Also","text":"<ul> <li>IsVisible</li> <li>Hide</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlCursor/#remarks_9","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/","title":"TSdlFinger","text":"<p>Data about a single finger in a multitouch event.</p> <p>Each touch event is a collection of fingers that are simultaneously in contact with the touch device (so a \"touch\" can be a \"multitouch,\" in reality), and this struct reports details of the specific fingers. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlFinger = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#see-also","title":"See Also","text":"<ul> <li>TSdlTouch.Fingers</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#properties","title":"Properties","text":"Name Description ID The finger ID Position The location of the touch event, normalized (0...1, 0...1) Pressure The quantity of pressure applied, normalized (0...1) X The X-axis location of the touch event, normalized (0...1) Y The Y-axis location of the touch event, normalized (0...1)"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#ID","title":"ID","text":"<p>The finger ID </p> <p><code>property ID: TSdlFingerID read GetID</code></p> <p>Type: <code>TSdlFingerID</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#Position","title":"Position","text":"<p>The location of the touch event, normalized (0...1, 0...1) </p> <p><code>property Position: TSdlPointF read GetPosition</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#Pressure","title":"Pressure","text":"<p>The quantity of pressure applied, normalized (0...1) </p> <p><code>property Pressure: Single read GetPressure</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#X","title":"X","text":"<p>The X-axis location of the touch event, normalized (0...1) </p> <p><code>property X: Single read GetX</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#Y","title":"Y","text":"<p>The Y-axis location of the touch event, normalized (0...1) </p> <p><code>property Y: Single read GetY</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#Equal","title":"Equal(TSdlFinger, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlFinger; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlFinger</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlFinger; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#returns_1","title":"Returns","text":"<p><code>TSdlFinger</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#NotEqual","title":"NotEqual(TSdlFinger, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlFinger; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlFinger</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlFinger/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/","title":"TSdlGamepad","text":"<p>An SDL gamepad </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlGamepad = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#properties","title":"Properties","text":"Name Description Axis The current state of an axis control on the gamepad. Bindings Get the SDL joystick layer bindings for a gamepad. Button The current state of a button on the gamepad. ConnectionState The connection state of a gamepad. EventsEnabled Set the state of gamepad event processing. FirmwareVersion The firmware version of this opened gamepad, if available. Gamepads A list of currently connected gamepads. HasGamepad Whether a gamepad is currently connected. ID The instance ID of this opened gamepad. IsConnected Whether the gamepad has been opened and is currently connected. Kind The type of this opened gamepad. Mapping The current mapping of this gamepad. Mappings The current gamepad mappings. Name The implementation-dependent name for this opened gamepad, or an empty string if not available. NumTouchpadFingers The number of supported simultaneous fingers on a touchpad on a game gamepad. NumTouchpads The number of touchpads on the gamepad. Path The implementation-dependent path for this opened gamepad, or an empty string if not available. PlayerIndex The player index of this opened gamepad, or -1 if not available. Product The USB product ID of this opened gamepad, if available. ProductVersion The product version of this opened gamepad, if available. Properties The properties associated with this opened gamepad. RealKind The type of this opened gamepad, ignoring any mapping override. SensorDataRate The data rate (number of events per second) of a gamepad sensor, or 0.0 if not available. SensorEnabled Whether data reporting for a gamepad sensor is enabled. Serial The serial number of this opened gamepad, or an empty string if not available. SteamHandle Get the Steam Input handle of this opened gamepad, or 0 if not available. Vendor The USB vendor ID of this opened gamepad, if available."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#methods","title":"Methods","text":"Name Description AddMapping Add support for gamepads that SDL is unaware of or change the binding of an existing gamepad. AddMappings(String) Load a set of gamepad mappings from a file. AddMappings(TSdlIOStream, Boolean) Load a set of gamepad mappings from a TSdlIOStream. AppleSFSymbolsNameFor(TSdlGamepadAxis) The sfSymbolsName for a given axis on a gamepad on Apple platforms, or an empty string if not found. AppleSFSymbolsNameFor(TSdlGamepadButton) The sfSymbolsName for a given button on a gamepad on Apple platforms, or an empty string if not found. Close Close the gamepad previously opened with Open. FromID Get the gamepad associated with a gamepad instance ID, if it has been opened. FromPlayerIndex Get the gamepad associated with a player index. GetButtonLabel Get the label of a button on the gamepad. GetPowerInfo Get the battery state of the gamepad. GetSensorData Get the current state of the gamepad sensor. GetTouchpadFinger Get the current state of a finger on a touchpad on a gamepad. HasAxis Whether the gamepad has a given axis. HasButton Whether the gamepad has a given button. HasSensor Whether a gamepad has a particular sensor. MappingForGuid Get the gamepad mapping string for a given GUID. Open Open a gamepad for use. ReloadMappings Reinitialize the SDL mapping database to its initial state. Rumble Start a rumble effect on the gamepad. RumbleTriggers Start a rumble effect in the gamepad's triggers. SendEffect Send a gamepad specific effect packet. SetLed Update the gamepad's LED color. Update Manually pump gamepad updates if not using the loop."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Axis","title":"Axis","text":"<p>The current state of an axis control on the gamepad.</p> <p>For thumbsticks, the state is a value ranging from -32768 (up/left) to 32767 (down/right).</p> <p>Triggers range from 0 when released to 32767 when fully pressed, and never return a negative value. Note that this differs from the value reported by the lower-level TSdlJoystick.Axis, which normally uses the full range. </p> <p><code>property Axis[const AAxis: TSdlGamepadAxis]: Smallint read GetAxis</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also","title":"See Also","text":"<ul> <li>HasAxis</li> <li>Button</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Bindings","title":"Bindings","text":"<p>Get the SDL joystick layer bindings for a gamepad. </p> <p><code>property Bindings: TArray&lt;TSdlGamepadBinding&gt; read GetBindings</code></p> <p>Type: <code>TArray&lt;TSdlGamepadBinding&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Button","title":"Button","text":"<p>The current state of a button on the gamepad. True if the button is pressed, False otherwise.</p> <p><code>property Button[const AButton: TSdlGamepadButton]: Boolean read GetButton</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_1","title":"See Also","text":"<ul> <li>HasButton</li> <li>Axis</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#ConnectionState","title":"ConnectionState","text":"<p>The connection state of a gamepad. </p> <p><code>property ConnectionState: TSdlGamepadConnectionState read GetConnectionState</code></p> <p>Type: <code>TSdlGamepadConnectionState</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#EventsEnabled","title":"EventsEnabled","text":"<p>Set the state of gamepad event processing.</p> <p>If gamepad events are disabled, you must call Update yourself and check the state of the gamepad when you want gamepad information. </p> <p><code>class property EventsEnabled: Boolean read GetEventsEnabled write SetEventsEnabled</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_2","title":"See Also","text":"<ul> <li>Update</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#FirmwareVersion","title":"FirmwareVersion","text":"<p>The firmware version of this opened gamepad, if available.</p> <p>If the firmware version isn't available this property returns 0. </p> <p><code>property FirmwareVersion: Word read GetFirmwareVersion</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Gamepads","title":"Gamepads","text":"<p>A list of currently connected gamepads. </p> <p><code>class property Gamepads: TArray&lt;TSdlGamepadID&gt; read GetGamepads</code></p> <p>Type: <code>TArray&lt;TSdlGamepadID&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_3","title":"See Also","text":"<ul> <li>HasGamepad</li> <li>Open</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#HasGamepad","title":"HasGamepad","text":"<p>Whether a gamepad is currently connected. </p> <p><code>class property HasGamepad: Boolean read GetHasGamepad</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_4","title":"See Also","text":"<ul> <li>Gamepads</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#ID","title":"ID","text":"<p>The instance ID of this opened gamepad. </p> <p><code>property ID: TSdlGamepadID read GetID</code></p> <p>Type: <code>TSdlGamepadID</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#IsConnected","title":"IsConnected","text":"<p>Whether the gamepad has been opened and is currently connected. </p> <p><code>property IsConnected: Boolean read GetIsConnected</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Kind","title":"Kind","text":"<p>The type of this opened gamepad. </p> <p><code>property Kind: TSdlGamepadKind read GetKind</code></p> <p>Type: <code>TSdlGamepadKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_5","title":"See Also","text":"<ul> <li>TSdlGamepadID.Kind</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Mapping","title":"Mapping","text":"<p>The current mapping of this gamepad.</p> <p>Details about mappings are discussed with AddMapping. </p> <p><code>property Mapping: String read GetMapping write SetMapping</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_6","title":"See Also","text":"<ul> <li>AddMapping</li> <li>TSdlGamepadID.Mapping</li> <li>MappingForGuid</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Mappings","title":"Mappings","text":"<p>The current gamepad mappings. </p> <p><code>class property Mappings: TArray&lt;String&gt; read GetMappings</code></p> <p>Type: <code>TArray&lt;String&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Name","title":"Name","text":"<p>The implementation-dependent name for this opened gamepad, or an empty string if not available. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_7","title":"See Also","text":"<ul> <li>TSdlGamepadID.Name</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#NumTouchpadFingers","title":"NumTouchpadFingers","text":"<p>The number of supported simultaneous fingers on a touchpad on a game gamepad. </p> <p><code>property NumTouchpadFingers[const ATouchPad: Integer]: Integer read GetNumTouchpadFingers</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_8","title":"See Also","text":"<ul> <li>GetTouchpadFinger</li> <li>NumTouchpads</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#NumTouchpads","title":"NumTouchpads","text":"<p>The number of touchpads on the gamepad. </p> <p><code>property NumTouchpads: Integer read GetNumTouchpads</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Path","title":"Path","text":"<p>The implementation-dependent path for this opened gamepad, or an empty string if not available. </p> <p><code>property Path: String read GetPath</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_9","title":"See Also","text":"<ul> <li>TSdlGamepadID.Path</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#PlayerIndex","title":"PlayerIndex","text":"<p>The player index of this opened gamepad, or -1 if not available.</p> <p>Set this property to -1 to clear the player index and turn off player LEDs.</p> <p>For XInput gamepads this returns the XInput user index. </p> <p><code>property PlayerIndex: Integer read GetPlayerIndex write SetPlayerIndex</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_6","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Product","title":"Product","text":"<p>The USB product ID of this opened gamepad, if available.</p> <p>If the product ID isn't available this property returns 0. </p> <p><code>property Product: Word read GetProduct</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_10","title":"See Also","text":"<ul> <li>TSdlGamepadID.Product</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#ProductVersion","title":"ProductVersion","text":"<p>The product version of this opened gamepad, if available.</p> <p>If the product version isn't available this property returns 0. </p> <p><code>property ProductVersion: Word read GetProductVersion</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_11","title":"See Also","text":"<ul> <li>TSdlGamepadID.ProductVersion</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Properties","title":"Properties","text":"<p>The properties associated with this opened gamepad.</p> <p>These properties are shared with the underlying joystick object.</p> <p>The following read-only properties are provided by SDL:</p> <ul> <li><code>TSdlProperty.GamepadCapMonoLed</code>: True if this gamepad has an LED that has adjustable brightness</li> <li><code>TSdlProperty.GamepadCapRgbLed</code>: True if this gamepad has an LED that has adjustable color</li> <li><code>TSdlProperty.GamepadCapPlayerLed</code>: True if this gamepad has a player LED</li> <li><code>TSdlProperty.GamepadCapRumble</code>: True if this gamepad has left/right rumble</li> <li><code>TSdlProperty.GamepadCapTriggerRumble</code>: True if this gamepad has simple trigger rumble </li> </ul> <p><code>property Properties: TSdlProperties read GetProperties</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_7","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#RealKind","title":"RealKind","text":"<p>The type of this opened gamepad, ignoring any mapping override. </p> <p><code>property RealKind: TSdlGamepadKind read GetRealKind</code></p> <p>Type: <code>TSdlGamepadKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_12","title":"See Also","text":"<ul> <li>TSdlGamepadID.RealKind</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#SensorDataRate","title":"SensorDataRate","text":"<p>The data rate (number of events per second) of a gamepad sensor, or 0.0 if not available. </p> <p><code>property SensorDataRate[const AKind: TSdlSensorKind]: Single read GetSensorDataRate</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#SensorEnabled","title":"SensorEnabled","text":"<p>Whether data reporting for a gamepad sensor is enabled. </p> <p><code>property SensorEnabled[const AKind: TSdlSensorKind]: Boolean read GetSensorEnabled write SetSensorEnabled</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_8","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_13","title":"See Also","text":"<ul> <li>HasSensor</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Serial","title":"Serial","text":"<p>The serial number of this opened gamepad, or an empty string if not available. </p> <p><code>property Serial: String read GetSerial</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#SteamHandle","title":"SteamHandle","text":"<p>Get the Steam Input handle of this opened gamepad, or 0 if not available.</p> <p>Returns a handle for the gamepad that can be used with  Steam Input API. </p> <p><code>property SteamHandle: UInt64 read GetSteamHandle</code></p> <p>Type: <code>UInt64</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Vendor","title":"Vendor","text":"<p>The USB vendor ID of this opened gamepad, if available.</p> <p>If the vendor ID isn't available this property returns 0. </p> <p><code>property Vendor: Word read GetVendor</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_14","title":"See Also","text":"<ul> <li>TSdlGamepadID.Vendor</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Equal","title":"Equal(TSdlGamepad, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGamepad; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGamepad</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlGamepad; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns_1","title":"Returns","text":"<p><code>TSdlGamepad</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#NotEqual","title":"NotEqual(TSdlGamepad, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGamepad; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGamepad</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#AddMapping","title":"AddMapping(String)","text":"<p>Add support for gamepads that SDL is unaware of or change the binding of an existing gamepad.</p> <p>The mapping string has the format 'GUID,Name,Mappings', where:</p> <ul> <li>GUID is the string value from TGuid.ToString, but with curly braces and dashes removed. Under Windows there is a reserved GUID of 'xinput' that covers all XInput devices</li> <li>Name is the human readable string for the device.</li> <li>Mappings are gamepad mappings to joystick ones.</li> </ul> <p>The mapping format for joystick is:</p> <ul> <li><code>bX</code>: a joystick button, index X</li> <li><code>hX.Y</code>: hat X with value Y</li> <li><code>aX</code>: axis X of the joystick</li> </ul> <p>Buttons can be used as a gamepad axes and vice versa.</p> <p>If a device with this GUID is already plugged in, SDL will generate an TSdlEventKind.GamepadAdded event.</p> <p>This string shows an example of a valid mapping for a gamepad:</p> <pre><code>  '341a3608000000000000504944564944,Afterglow PS3 Controller,'+\n  'a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,'+\n  'dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,'+\n  'leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,'+\n  'lefttrigger:b6,righttrigger:b7'\n</code></pre> <p><code>class function AddMapping(const AMapping: String): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_9","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_3","title":"Parameters","text":"<p><code>AMapping</code>: <code>String</code> : The mapping string.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns_3","title":"Returns","text":"<p><code>Boolean</code>: True if a new mapping is added, False if an existing mapping is updated.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_15","title":"See Also","text":"<ul> <li>AddMappings</li> <li>Mappings</li> <li>MappingForGuid</li> <li>TSdlHints.GameControllerConfig</li> <li>TSdlHints.GameControllerConfigFile</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#remarks","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#AddMappings_0","title":"AddMappings(String)","text":"<p>Load a set of gamepad mappings from a file.</p> <p>You can call this method several times, if needed, to load different database files.</p> <p>If a new mapping is loaded for an already known gamepad GUID, the later version will overwrite the one currently loaded.</p> <p>Any new mappings for already plugged in controllers will generate TSdlEventKind.GamepadAdded events.</p> <p>Mappings not belonging to the current platform or with no platform field specified will be ignored (i.e. mappings for Linux will be ignored in Windows, etc). </p> <p><code>class function AddMappings(const AFilename: String): Integer; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_10","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_4","title":"Parameters","text":"<p><code>AFilename</code>: <code>String</code> : The mappings file to load.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns_4","title":"Returns","text":"<p><code>Integer</code>: The number of mappings added.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_16","title":"See Also","text":"<ul> <li>AddMapping</li> <li>Mappings</li> <li>MappingForGuid</li> <li>TSdlHints.GameControllerConfig</li> <li>TSdlHints.GameControllerConfigFile</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#remarks_1","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#AddMappings_1","title":"AddMappings(TSdlIOStream, Boolean)","text":"<p>Load a set of gamepad mappings from a TSdlIOStream.</p> <p>You can call this method several times, if needed, to load different database files.</p> <p>If a new mapping is loaded for an already known gamepad GUID, the later version will overwrite the one currently loaded.</p> <p>Any new mappings for already plugged in controllers will generate TSdlEventKind.GamepadAdded events.</p> <p>Mappings not belonging to the current platform or with no platform field specified will be ignored (i.e. mappings for Linux will be ignored in Windows, etc).</p> <p>This function will load the text database entirely in memory before processing it, so take this into consideration if you are in a memory constrained environment. </p> <p><code>class function AddMappings(const ASrc: TSdlIOStream; const ACloseIO: Boolean): Integer; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_11","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_5","title":"Parameters","text":"<p><code>ASrc</code>: <code>TSdlIOStream</code> : The data stream for the mappings to be added.</p> <p><code>ACloseIO</code>: <code>Boolean</code> : If true, calls TSdlIOStream.Close on <code>ASrc</code> before returning, even in the case of an error.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns_5","title":"Returns","text":"<p><code>Integer</code>: The number of mappings added.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_17","title":"See Also","text":"<ul> <li>AddMapping</li> <li>Mappings</li> <li>MappingForGuid</li> <li>TSdlHints.GameControllerConfig</li> <li>TSdlHints.GameControllerConfigFile</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#remarks_2","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#AppleSFSymbolsNameFor_0","title":"AppleSFSymbolsNameFor(TSdlGamepadAxis)","text":"<p>The sfSymbolsName for a given axis on a gamepad on Apple platforms, or an empty string if not found. </p> <p><code>function AppleSFSymbolsNameFor(const AAxis: TSdlGamepadAxis): String; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_6","title":"Parameters","text":"<p><code>AAxis</code>: <code>TSdlGamepadAxis</code> : A button on the gamepad.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns_6","title":"Returns","text":"<p><code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#AppleSFSymbolsNameFor_1","title":"AppleSFSymbolsNameFor(TSdlGamepadButton)","text":"<p>The sfSymbolsName for a given button on a gamepad on Apple platforms, or an empty string if not found. </p> <p><code>function AppleSFSymbolsNameFor(const AButton: TSdlGamepadButton): String; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_7","title":"Parameters","text":"<p><code>AButton</code>: <code>TSdlGamepadButton</code> : A button on the gamepad.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns_7","title":"Returns","text":"<p><code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Close","title":"Close","text":"<p>Close the gamepad previously opened with Open. </p> <p><code>procedure Close; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_18","title":"See Also","text":"<ul> <li>Open</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#FromID","title":"FromID(TSdlGamepadID)","text":"<p>Get the gamepad associated with a gamepad instance ID, if it has been opened. </p> <p><code>class function FromID(const AInstanceID: TSdlGamepadID): TSdlGamepad; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_12","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure (eg. when the gamepad has not been opened).</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_8","title":"Parameters","text":"<p><code>AInstanceID</code>: <code>TSdlGamepadID</code> : The gamepad instance ID.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns_8","title":"Returns","text":"<p><code>TSdlGamepad</code>: The gamepad.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#FromPlayerIndex","title":"FromPlayerIndex(Integer)","text":"<p>Get the gamepad associated with a player index. </p> <p><code>class function FromPlayerIndex(const APlayerIndex: Integer): TSdlGamepad; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_13","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_9","title":"Parameters","text":"<p><code>APlayerIndex</code>: <code>Integer</code> : The player index.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns_9","title":"Returns","text":"<p><code>TSdlGamepad</code>: The gamepad.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_19","title":"See Also","text":"<ul> <li>PlayerIndex</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#GetButtonLabel","title":"GetButtonLabel(TSdlGamepadButton)","text":"<p>Get the label of a button on the gamepad. </p> <p><code>function GetButtonLabel(const AButton: TSdlGamepadButton): TSdlGamepadButtonLabel; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_10","title":"Parameters","text":"<p><code>AButton</code>: <code>TSdlGamepadButton</code> : The button.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns_10","title":"Returns","text":"<p><code>TSdlGamepadButtonLabel</code>: The TSdlGamepadButtonLabel enum corresponding to the button label.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_20","title":"See Also","text":"<ul> <li>TSdlGamepadKind.GetButtonLabel</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#GetPowerInfo","title":"GetPowerInfo(Integer)","text":"<p>Get the battery state of the gamepad.</p> <p>You should never take a battery status as absolute truth. Batteries (especially failing batteries) are delicate hardware, and the values reported here are best estimates based on what that hardware reports. It's not uncommon for older batteries to lose stored power much faster than it reports, or completely drain when reporting it has 20 percent left, etc. </p> <p><code>function GetPowerInfo(out APercent: Integer): TSdlPowerState; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_14","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_11","title":"Parameters","text":"<p><code>APercent</code>: <code>Integer</code> : Set to the percentage of battery life left, between 0 and 100. Will be set to  -1 if we can't determine a value or there is no battery.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns_11","title":"Returns","text":"<p><code>TSdlPowerState</code>: The current battery state.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#GetSensorData","title":"GetSensorData(TSdlSensorKind, TArray&lt;Single&gt;)","text":"<p>Get the current state of the gamepad sensor.</p> <p>The number of values and interpretation of the data is sensor dependent. The length of the AData array is the maximum number of values that will be written to the array. </p> <p><code>procedure GetSensorData(const AKind: TSdlSensorKind; const AData: TArray&lt;Single&gt;); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_15","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_12","title":"Parameters","text":"<p><code>AKind</code>: <code>TSdlSensorKind</code> : The type of sensor to query.</p> <p><code>AData</code>: <code>TArray&lt;Single&gt;</code> : An array filled with the current sensor state.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#GetTouchpadFinger","title":"GetTouchpadFinger(Integer, Integer, Boolean, Single, Single, Single)","text":"<p>Get the current state of a finger on a touchpad on a gamepad. </p> <p><code>procedure GetTouchpadFinger(const ATouchpad, AFinger: Integer; out AIsDown: Boolean; out AX, AY, APressure: Single); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_16","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_13","title":"Parameters","text":"<p><code>ATouchpad</code>: <code>Integer</code> : The touchpad index.</p> <p><code>AFinger</code>: <code>Integer</code> : The finger index.</p> <p><code>AIsDown</code>: <code>Boolean</code> : Is set to True if the finger is down, False otherwise.</p> <p><code>AX</code>: <code>Single</code> : Is set to the X position, normalized 0 to 1, with the origin in the upper left.</p> <p><code>AY</code>: <code>Single</code> : Is set to the Y position, normalized 0 to 1, with the origin in the upper left.</p> <p><code>APressure</code>: <code>Single</code> : Is set to the pressure value.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_21","title":"See Also","text":"<ul> <li>NumTouchpadFingers</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#HasAxis","title":"HasAxis(TSdlGamepadAxis)","text":"<p>Whether the gamepad has a given axis.</p> <p>This merely reports whether the gamepad's mapping defined this axis, as that is all the information SDL has about the physical device. </p> <p><code>function HasAxis(const AAxis: TSdlGamepadAxis): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_14","title":"Parameters","text":"<p><code>AAxis</code>: <code>TSdlGamepadAxis</code> : The axis enum value.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns_12","title":"Returns","text":"<p><code>Boolean</code>: True if the gamepad has this axis, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_22","title":"See Also","text":"<ul> <li>HasButton</li> <li>Axis</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#HasButton","title":"HasButton(TSdlGamepadButton)","text":"<p>Whether the gamepad has a given button.</p> <p>This merely reports whether the gamepad's mapping defined this button, as that is all the information SDL has about the physical device. </p> <p><code>function HasButton(const AButton: TSdlGamepadButton): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_15","title":"Parameters","text":"<p><code>AButton</code>: <code>TSdlGamepadButton</code> : The button enum value.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns_13","title":"Returns","text":"<p><code>Boolean</code>: True if the gamepad has this button, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_23","title":"See Also","text":"<ul> <li>HasAxis</li> <li>Button</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#HasSensor","title":"HasSensor(TSdlSensorKind)","text":"<p>Whether a gamepad has a particular sensor. </p> <p><code>function HasSensor(const AKind: TSdlSensorKind): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_16","title":"Parameters","text":"<p><code>AKind</code>: <code>TSdlSensorKind</code> : The type of sensor to query.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns_14","title":"Returns","text":"<p><code>Boolean</code>: True if the sensor exists, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_24","title":"See Also","text":"<ul> <li>GetSensorData</li> <li>SensorDataRate</li> <li>SensorEnabled</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#remarks_3","title":"Remarks","text":"<p>This function is available since SDL 3.2.0. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#MappingForGuid","title":"MappingForGuid(TGuid)","text":"<p>Get the gamepad mapping string for a given GUID. </p> <p><code>class function MappingForGuid(const AGuid: TGuid): String; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_17","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_17","title":"Parameters","text":"<p><code>AGuid</code>: <code>TGuid</code> : The GUID for which a mapping is desired.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns_15","title":"Returns","text":"<p><code>String</code>: The mapping string.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_25","title":"See Also","text":"<ul> <li>TSdlJoystickID.Guid</li> <li>TSdlJoystick.Guid</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Open","title":"Open(TSdlGamepadID)","text":"<p>Open a gamepad for use. </p> <p><code>class function Open(const AInstanceID: TSdlGamepadID): TSdlGamepad; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_18","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_18","title":"Parameters","text":"<p><code>AInstanceID</code>: <code>TSdlGamepadID</code> : The gamepad instance ID.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#returns_16","title":"Returns","text":"<p><code>TSdlGamepad</code>: The gamepad.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_26","title":"See Also","text":"<ul> <li>Close</li> <li>TSdlJoystickID.IsGamepad</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#ReloadMappings","title":"ReloadMappings","text":"<p>Reinitialize the SDL mapping database to its initial state.</p> <p>This will generate gamepad events as needed if device mappings change. </p> <p><code>class procedure ReloadMappings; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_19","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Rumble","title":"Rumble(Word, Word, Integer)","text":"<p>Start a rumble effect on the gamepad.</p> <p>Each call to this method cancels any previous rumble effect, and calling it with 0 intensity stops any rumbling.</p> <p>This method requires you to process SDL events or call TSdlJoysticks.Update to update rumble state. </p> <p><code>procedure Rumble(const ALowFrequencyRumble, AHighFrequencyRumble: Word; const ADurationMs: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_20","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_19","title":"Parameters","text":"<p><code>ALowFrequencyRumble</code>: <code>Word</code> : The intensity of the low frequency (left) rumble motor, from 0 to $FFFF.</p> <p><code>AHighFrequencyRumble</code>: <code>Word</code> : The intensity of the high frequency (right) rumble motor, from 0 to $FFFF.</p> <p><code>ADurationMs</code>: <code>Integer</code> : The duration of the rumble effect, in milliseconds.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#RumbleTriggers","title":"RumbleTriggers(Word, Word, Integer)","text":"<p>Start a rumble effect in the gamepad's triggers.</p> <p>Each call to this method cancels any previous trigger rumble effect, and calling it with 0 intensity stops any rumbling.</p> <p>Note that this is rumbling of the triggers and not the gamepad as a whole. This is currently only supported on Xbox One gamepads. If you want the (more common) whole-gamepad rumble, use Rumble instead.</p> <p>This method requires you to process SDL events or call TSdlJoysticks.Update to update rumble state. </p> <p><code>procedure RumbleTriggers(const ALeftRumble, ARightRumble: Word; const ADurationMs: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_21","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_20","title":"Parameters","text":"<p><code>ALeftRumble</code>: <code>Word</code> : The intensity of the left trigger rumble motor, from 0 to $FFFF.</p> <p><code>ARightRumble</code>: <code>Word</code> : The intensity of the right trigger rumble motor, from 0 to $FFFF.</p> <p><code>ADurationMs</code>: <code>Integer</code> : the duration of the rumble effect, in milliseconds.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#see-also_27","title":"See Also","text":"<ul> <li>Rumble</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#SendEffect","title":"SendEffect(TBytes)","text":"<p>Send a gamepad specific effect packet. </p> <p><code>procedure SendEffect(const AData: TBytes); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_22","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_21","title":"Parameters","text":"<p><code>AData</code>: <code>TBytes</code> : The data to send to the gamepad.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#SetLed","title":"SetLed(Byte, Byte, Byte)","text":"<p>Update the gamepad's LED color.</p> <p>An example of a joystick LED is the light on the back of a PlayStation 4's DualShock 4 controller.</p> <p>For gamepads with a single color LED, the maximum of the RGB values will be used as the LED brightness. </p> <p><code>procedure SetLed(const ARed, AGreen, ABlue: Byte); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#exceptions_23","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#parameters_22","title":"Parameters","text":"<p><code>ARed</code>: <code>Byte</code> : The intensity of the red LED.</p> <p><code>AGreen</code>: <code>Byte</code> : The intensity of the green LED.</p> <p><code>ABlue</code>: <code>Byte</code> : The intensity of the blue LED.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepad/#Update","title":"Update","text":"<p>Manually pump gamepad updates if not using the loop.</p> <p>This method is called automatically by the event loop if events are enabled. Under such circumstances, it will not be necessary to call this method. </p> <p><code>class procedure Update; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/","title":"TSdlGamepadBinding","text":"<p>A mapping between one joystick input to a gamepad control.</p> <p>A gamepad has a collection of several bindings, to say, for example, when joystick button number 5 is pressed, that should be treated like the gamepad's \"start\" button.</p> <p>SDL has these bindings built-in for many popular controllers, and can add more with a simple text string. Those strings are parsed into a collection of these structs to make it easier to operate on the data. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlGamepadBinding = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#see-also","title":"See Also","text":"<ul> <li>TSdlGamepad.Bindings</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#properties","title":"Properties","text":"Name Description InputAxisIndex Input axis index (for Axis types) InputAxisMax Input maximum axis value (for Axis types) InputAxisMin Input minimum axis value (for Axis types) InputButtonIndex Input button index (for Button types) InputHatIndex Input hat index (for Hat types) InputHatMask Input hat mask (for Hat types) InputType Input (source) type OutputAxis Output axis (for Axis types) OutputAxisMax Output maximum axis value (for Axis types) OutputAxisMin Output minimum axis value (for Axis types) OutputButton Output button (for Button types) OutputType Output (destination) type"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#InputAxisIndex","title":"InputAxisIndex","text":"<p>Input axis index (for Axis types) </p> <p><code>property InputAxisIndex: Integer read GetInputAxisIndex</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#InputAxisMax","title":"InputAxisMax","text":"<p>Input maximum axis value (for Axis types) </p> <p><code>property InputAxisMax: Integer read GetInputAxisMax</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#InputAxisMin","title":"InputAxisMin","text":"<p>Input minimum axis value (for Axis types) </p> <p><code>property InputAxisMin: Integer read GetInputAxisMin</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#InputButtonIndex","title":"InputButtonIndex","text":"<p>Input button index (for Button types) </p> <p><code>property InputButtonIndex: Integer read GetInputButtonIndex</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#InputHatIndex","title":"InputHatIndex","text":"<p>Input hat index (for Hat types) </p> <p><code>property InputHatIndex: Integer read GetInputHatIndex</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#InputHatMask","title":"InputHatMask","text":"<p>Input hat mask (for Hat types) </p> <p><code>property InputHatMask: Integer read GetInputHatMask</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#InputType","title":"InputType","text":"<p>Input (source) type </p> <p><code>property InputType: TSdlGamepadBindingType read GetInputType</code></p> <p>Type: <code>TSdlGamepadBindingType</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#OutputAxis","title":"OutputAxis","text":"<p>Output axis (for Axis types) </p> <p><code>property OutputAxis: TSdlGamepadAxis read GetOutputAxis</code></p> <p>Type: <code>TSdlGamepadAxis</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#OutputAxisMax","title":"OutputAxisMax","text":"<p>Output maximum axis value (for Axis types) </p> <p><code>property OutputAxisMax: Integer read GetOutputAxisMax</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#OutputAxisMin","title":"OutputAxisMin","text":"<p>Output minimum axis value (for Axis types) </p> <p><code>property OutputAxisMin: Integer read GetOutputAxisMin</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#OutputButton","title":"OutputButton","text":"<p>Output button (for Button types) </p> <p><code>property OutputButton: TSdlGamepadButton read GetOutputButton</code></p> <p>Type: <code>TSdlGamepadButton</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#OutputType","title":"OutputType","text":"<p>Output (destination) type </p> <p><code>property OutputType: TSdlGamepadBindingType read GetOutputType</code></p> <p>Type: <code>TSdlGamepadBindingType</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#Equal","title":"Equal(TSdlGamepadBinding, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGamepadBinding; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGamepadBinding</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlGamepadBinding; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#returns_1","title":"Returns","text":"<p><code>TSdlGamepadBinding</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#NotEqual","title":"NotEqual(TSdlGamepadBinding, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGamepadBinding; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGamepadBinding</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadBinding/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/","title":"TSdlGamepadID","text":"<p>This is a unique ID for a gamepad for the time it is connected to the system, and is never reused for the lifetime of the application.</p> <p>If the gamepad is disconnected and reconnected, it will get a new ID. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlGamepadID = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#properties","title":"Properties","text":"Name Description Guid The implementation-dependent GUID of the gamepad. Kind The type of the gamepad. Mapping The mapping of the gamepad, or an empty string if not available. Name The implementation dependent name of the gamepad, or an empty string if not available. Path The implementation dependent path of the gamepad, or an empty string if not available. This can be used before any gamepads are opened. PlayerIndex The player index of the gamepad, or -1 if not available. Product The USB product ID of the gamepad, if available. ProductVersion The product version of the gamepad, if available. RealKind The type of the gamepad, ignoring any mapping override. Vendor The USB vendor ID of the gamepad, if available."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>0</code>. Implicit Used to set the value to <code>0</code>. NotEqual Used to compare against <code>0</code>."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#Guid","title":"Guid","text":"<p>The implementation-dependent GUID of the gamepad.</p> <p>This can be used before any gamepads are opened. </p> <p><code>property Guid: TGuid read GetGuid</code></p> <p>Type: <code>TGuid</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#see-also","title":"See Also","text":"<ul> <li>TSdlGamepad.Gamepads</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#Kind","title":"Kind","text":"<p>The type of the gamepad.</p> <p>This can be used before any gamepads are opened. </p> <p><code>property Kind: TSdlGamepadKind read GetKind</code></p> <p>Type: <code>TSdlGamepadKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#see-also_1","title":"See Also","text":"<ul> <li>TSdlGamepad.Kind</li> <li>TSdlGamepad.Gamepads</li> <li>RealKind</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#Mapping","title":"Mapping","text":"<p>The mapping of the gamepad, or an empty string if not available.</p> <p>This can be used before any gamepads are opened. </p> <p><code>property Mapping: String read GetMapping</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#see-also_2","title":"See Also","text":"<ul> <li>TSdlGamepad.Gamepads</li> <li>TSdlGamepad.Mapping</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#Name","title":"Name","text":"<p>The implementation dependent name of the gamepad, or an empty string if not available.</p> <p>This can be used before any gamepads are opened. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#see-also_3","title":"See Also","text":"<ul> <li>TSdlGamepad.Name</li> <li>TSdlGamepad.Gamepads</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#Path","title":"Path","text":"<p>The implementation dependent path of the gamepad, or an empty string if not available. This can be used before any gamepads are opened. </p> <p><code>property Path: String read GetPath</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#see-also_4","title":"See Also","text":"<ul> <li>TSdlGamepad.Path</li> <li>TSdlGamepad.Gamepads</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#PlayerIndex","title":"PlayerIndex","text":"<p>The player index of the gamepad, or -1 if not available.</p> <p>This can be used before any gamepads are opened. </p> <p><code>property PlayerIndex: Integer read GetPlayerIndex</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#see-also_5","title":"See Also","text":"<ul> <li>TSdlGamepad.PlayerIndex</li> <li>TSdlGamepad.Gamepads</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#Product","title":"Product","text":"<p>The USB product ID of the gamepad, if available.</p> <p>This can be used before any gamepads are opened. If the product ID isn't available this property returns 0. </p> <p><code>property Product: Word read GetProduct</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#see-also_6","title":"See Also","text":"<ul> <li>TSdlGamepad.Product</li> <li>TSdlGamepad.Gamepads</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#ProductVersion","title":"ProductVersion","text":"<p>The product version of the gamepad, if available.</p> <p>This can be used before any gamepads are opened. If the product version isn't available this property returns 0. </p> <p><code>property ProductVersion: Word read GetProductVersion</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#see-also_7","title":"See Also","text":"<ul> <li>TSdlGamepad.ProductVersion</li> <li>TSdlGamepad.Gamepads</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#RealKind","title":"RealKind","text":"<p>The type of the gamepad, ignoring any mapping override.</p> <p>This can be used before any gamepads are opened. </p> <p><code>property RealKind: TSdlGamepadKind read GetRealKind</code></p> <p>Type: <code>TSdlGamepadKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#see-also_8","title":"See Also","text":"<ul> <li>Kind</li> <li>TSdlGamepad.Gamepads</li> <li>TSdlGamepad.RealKind</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#Vendor","title":"Vendor","text":"<p>The USB vendor ID of the gamepad, if available.</p> <p>This can be used before any gamepads are opened. If the vendor ID isn't available this property returns 0. </p> <p><code>property Vendor: Word read GetVendor</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#see-also_9","title":"See Also","text":"<ul> <li>TSdlGamepad.Vendor</li> <li>TSdlGamepad.Gamepads</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#Equal","title":"Equal(TSdlGamepadID, Cardinal)","text":"<p>Used to compare against <code>0</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGamepadID; const ARight: Cardinal): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGamepadID</code></p> <p><code>ARight</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#Implicit","title":"Implicit(Cardinal)","text":"<p>Used to set the value to <code>0</code>. </p> <p><code>class operator Implicit(const AValue: Cardinal): TSdlGamepadID; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#returns_1","title":"Returns","text":"<p><code>TSdlGamepadID</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#NotEqual","title":"NotEqual(TSdlGamepadID, Cardinal)","text":"<p>Used to compare against <code>0</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGamepadID; const ARight: Cardinal): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGamepadID</code></p> <p><code>ARight</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlGamepadID/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/","title":"TSdlJoystick","text":"<p>An SDL joystick </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlJoystick = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#properties","title":"Properties","text":"Name Description Axis The current state of an axis control on the joystick. Ball The ball axis change since the last poll. Button The current state of a button on the joystick. ConnectionState The connection state of the joystick. EventsEnabled The state of joystick event processing. FirmwareVersion The firmware version of this opened joystick, if available. Guid The implementation-dependent GUID for the joystick. HasJoystick Whether a joystick is currently connected. Hat The current state of a POV hat on the joystick. ID The instance ID of this opened joystick. IsConnected Whether the joystick has been opened and is connected. Joysticks A list of currently connected joysticks. Kind The type of this opened joystick. Name The implementation dependent name of a joystick or an empty string if no name can be found. NumAxes The number of general axis controls on this joystick. NumBalls The number of trackballs on this joystick. NumButtons The number of buttons on this joystick. NumHats The number of POV hats on this joystick. Path The implementation dependent path of a joystick or an empty string if no path can be found. PlayerIndex The player index of this opened joystick or -1 if not available. Product The USB product ID of this opened joystick, if available. ProductVersion The product version of this opened joystick, if available. Properties The properties associated with the joystick. Serial The serial number of this opened joystick, if available. Vendor The USB vendor ID of this opened joystick, if available."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#methods","title":"Methods","text":"Name Description AxisInitialState Get the initial state of an axis control on the joystick. Close Close a joystick previously opened with Open. FromGamepad Get the underlying joystick from a gamepad. FromID Get the joystick associated with an instance ID, if it has been opened. FromPlayerIndex Get the joystick associated with a player index. GetPowerInfo Get the battery state of the joystick. GuidInfo Get the device information encoded in a joystick GUID structure. Lock Locking for atomic access to the joystick API. Open Open a joystick for use. Rumble Start a rumble effect. RumbleTriggers Start a rumble effect in the joystick's triggers. SendEffect Send a joystick specific effect packet. SetLed Update the joystick's LED color. SetVirtualAxis Set the state of an axis on this opened virtual joystick. SetVirtualBall Generate ball motion on this opened virtual joystick. SetVirtualButton Set the state of a button on this opened virtual joystick. SetVirtualHat Set the state of a hat on an opened virtual joystick. SetVirtualSensorData Send a sensor update for an opened virtual joystick. SetVirtualTouchpad Set touchpad finger state on an opened virtual joystick. Unlock Unlocking for atomic access to the joystick API. Update Update the current state of the open joysticks."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Axis","title":"Axis","text":"<p>The current state of an axis control on the joystick.</p> <p>SDL makes no promises about what part of the joystick any given axis refers to. Your game should have some sort of configuration UI to let users specify what each axis should be bound to. Alternately, SDL's higher-level Game Controller API makes a great effort to apply order to this lower-level interface, so you know that a specific axis is the \"left thumb stick,\" etc.</p> <p>The value is a signed 16-bit integer (-32768 to 32767) representing the current position of the axis. It may be necessary to impose certain tolerances on these values to account for jitter. </p> <p><code>property Axis[const AAxis: Integer]: Smallint read GetAxis</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also","title":"See Also","text":"<ul> <li>NumAxes</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Ball","title":"Ball","text":"<p>The ball axis change since the last poll.</p> <p>Trackballs can only return relative motion since the last retrieval if this property. It returns the difference in axis position since the last poll.</p> <p>Most joysticks do not have trackballs. </p> <p><code>property Ball[const ABall: Integer]: TSdlPoint read GetBall</code></p> <p>Type: <code>TSdlPoint</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_1","title":"See Also","text":"<ul> <li>NumBalls</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Button","title":"Button","text":"<p>The current state of a button on the joystick. </p> <p><code>property Button[const AButton: Integer]: Boolean read GetButton</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_2","title":"See Also","text":"<ul> <li>NumButtons</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#ConnectionState","title":"ConnectionState","text":"<p>The connection state of the joystick. </p> <p><code>property ConnectionState: TsdlJoystickConnectionState read GetConnectionState</code></p> <p>Type: <code>TsdlJoystickConnectionState</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#EventsEnabled","title":"EventsEnabled","text":"<p>The state of joystick event processing.</p> <p>If joystick events are disabled, you must call Update yourself and check the state of the joystick when you want joystick information. </p> <p><code>class property EventsEnabled: Boolean read GetEventsEnabled write SetEventsEnabled</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_3","title":"See Also","text":"<ul> <li>Update</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#FirmwareVersion","title":"FirmwareVersion","text":"<p>The firmware version of this opened joystick, if available.</p> <p>If the firmware version isn't available this property returns 0. </p> <p><code>property FirmwareVersion: Word read GetFirmwareVersion</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Guid","title":"Guid","text":"<p>The implementation-dependent GUID for the joystick.</p> <p>This property requires an open joystick. </p> <p><code>property Guid: TGuid read GetGuid</code></p> <p>Type: <code>TGuid</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_4","title":"See Also","text":"<ul> <li>TSdlJoystickID.Guid</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#HasJoystick","title":"HasJoystick","text":"<p>Whether a joystick is currently connected. </p> <p><code>class property HasJoystick: Boolean read GetHasJoystick</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_5","title":"See Also","text":"<ul> <li>Joysticks</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Hat","title":"Hat","text":"<p>The current state of a POV hat on the joystick. </p> <p><code>property Hat[const AHat: Integer]: TSdlHat read GetHat</code></p> <p>Type: <code>TSdlHat</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_6","title":"See Also","text":"<ul> <li>NumHats</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#ID","title":"ID","text":"<p>The instance ID of this opened joystick. </p> <p><code>property ID: TSdlJoystickID read GetID</code></p> <p>Type: <code>TSdlJoystickID</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#IsConnected","title":"IsConnected","text":"<p>Whether the joystick has been opened and is connected. </p> <p><code>property IsConnected: Boolean read GetIsConnected</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Joysticks","title":"Joysticks","text":"<p>A list of currently connected joysticks. </p> <p><code>class property Joysticks: TArray&lt;TSdlJoystickID&gt; read GetJoysticks</code></p> <p>Type: <code>TArray&lt;TSdlJoystickID&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_7","title":"See Also","text":"<ul> <li>HasJoystick</li> <li>Open</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Kind","title":"Kind","text":"<p>The type of this opened joystick. </p> <p><code>property Kind: TSdlJoystickKind read GetKind</code></p> <p>Type: <code>TSdlJoystickKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_8","title":"See Also","text":"<ul> <li>TSdlJoystickID.Kind</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Name","title":"Name","text":"<p>The implementation dependent name of a joystick or an empty string if no name can be found. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_9","title":"See Also","text":"<ul> <li>TSdlJoystickID.Name</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#NumAxes","title":"NumAxes","text":"<p>The number of general axis controls on this joystick.</p> <p>Often, the directional pad on a game controller will either look like 4 separate buttons or a POV hat, and not axes, but all of this is up to the device and platform. </p> <p><code>property NumAxes: Integer read GetNumAxes</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_10","title":"See Also","text":"<ul> <li>Axis</li> <li>NumBalls</li> <li>NumButtons</li> <li>NumHats</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#NumBalls","title":"NumBalls","text":"<p>The number of trackballs on this joystick.</p> <p>Joystick trackballs have only relative motion events associated with them and their state cannot be polled.</p> <p>Most joysticks do not have trackballs. </p> <p><code>property NumBalls: Integer read GetNumBalls</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_11","title":"See Also","text":"<ul> <li>Ball</li> <li>NumAxes</li> <li>NumButtons</li> <li>NumHats</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#NumButtons","title":"NumButtons","text":"<p>The number of buttons on this joystick. </p> <p><code>property NumButtons: Integer read GetNumButtons</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_6","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_12","title":"See Also","text":"<ul> <li>Button</li> <li>NumAxes</li> <li>NumBalls</li> <li>NumHats</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#NumHats","title":"NumHats","text":"<p>The number of POV hats on this joystick. </p> <p><code>property NumHats: Integer read GetNumHats</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_7","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_13","title":"See Also","text":"<ul> <li>Hat</li> <li>NumAxes</li> <li>NumBalls</li> <li>NumButtons</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Path","title":"Path","text":"<p>The implementation dependent path of a joystick or an empty string if no path can be found. </p> <p><code>property Path: String read GetPath</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_14","title":"See Also","text":"<ul> <li>TSdlJoystickID.Path</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#PlayerIndex","title":"PlayerIndex","text":"<p>The player index of this opened joystick or -1 if not available.</p> <p>For XInput controllers this returns the XInput user index. Many joysticks will not be able to supply this information.</p> <p>Set this property to -1 to clear the player index and turn off player LEDs. </p> <p><code>property PlayerIndex: Integer read GetPlayerIndex write SetPlayerIndex</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_8","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_15","title":"See Also","text":"<ul> <li>TSdlJoystickID.PlayerIndex</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Product","title":"Product","text":"<p>The USB product ID of this opened joystick, if available.</p> <p>If the product ID isn't available this property returns 0. </p> <p><code>property Product: Word read GetProduct</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_16","title":"See Also","text":"<ul> <li>TSdlJoystickID.Product</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#ProductVersion","title":"ProductVersion","text":"<p>The product version of this opened joystick, if available.</p> <p>If the product version isn't available this property returns 0. </p> <p><code>property ProductVersion: Word read GetProductVersion</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_17","title":"See Also","text":"<ul> <li>TSdlJoystickID.ProductVersion</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Properties","title":"Properties","text":"<p>The properties associated with the joystick.</p> <p>The following read-only properties are provided by SDL:</p> <ul> <li><code>TSdlProperty.JoystickCapMonoLed</code>: True if this joystick has an LED that has adjustable brightness</li> <li><code>TSdlProperty.JoystickCapRgbLed</code>: True if this joystick has an LED that has adjustable color</li> <li><code>TSdlProperty.JoystickCapPlayerLed</code>: True if this joystick has a player LED</li> <li><code>TSdlProperty.JoystickCapRumble</code>: True if this joystick has left/right rumble</li> <li><code>TSdlProperty.JoystickCapTriggerRumble</code>: True if this joystick has simple trigger rumble </li> </ul> <p><code>property Properties: TSdlProperties read GetProperties</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_9","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Serial","title":"Serial","text":"<p>The serial number of this opened joystick, if available.</p> <p>Returns the serial number of the joystick, or an empty string if it is not available. </p> <p><code>property Serial: String read GetSerial</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Vendor","title":"Vendor","text":"<p>The USB vendor ID of this opened joystick, if available.</p> <p>If the vendor ID isn't available this property returns 0. </p> <p><code>property Vendor: Word read GetVendor</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_18","title":"See Also","text":"<ul> <li>TSdlJoystickID.Vendor</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Equal","title":"Equal(TSdlJoystick, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlJoystick; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlJoystick</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlJoystick; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#returns_1","title":"Returns","text":"<p><code>TSdlJoystick</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#NotEqual","title":"NotEqual(TSdlJoystick, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlJoystick; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlJoystick</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#AxisInitialState","title":"AxisInitialState(Integer, Smallint)","text":"<p>Get the initial state of an axis control on the joystick.</p> <p>The state is a value ranging from -32768 to 32767.</p> <p>The axis indices start at index 0. </p> <p><code>function AxisInitialState(const AAxis: Integer; out AState: Smallint): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_3","title":"Parameters","text":"<p><code>AAxis</code>: <code>Integer</code> : The axis to query; the axis indices start at index 0.</p> <p><code>AState</code>: <code>Smallint</code> : Upon return, the initial value is supplied here.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#returns_3","title":"Returns","text":"<p><code>Boolean</code>: True if this axis has any initial value, or False if not.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Close","title":"Close","text":"<p>Close a joystick previously opened with Open. </p> <p><code>procedure Close; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_19","title":"See Also","text":"<ul> <li>Open</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#FromGamepad","title":"FromGamepad(TSdlGamepad)","text":"<p>Get the underlying joystick from a gamepad.</p> <p>This function will give you a TSdlJoystick object, which allows you to use its properties and methods a TSdlGamepad object. This would be useful for getting a joystick's position at any given time, even if it hasn't moved (moving it would produce an event, which would have the axis' value).</p> <p>The returned joystick is owned by the gamepad. You should not call Close on it, for example, since doing so will likely cause SDL to crash. </p> <p><code>class function FromGamepad(const AGamepad: TSdlGamepad): TSdlJoystick; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_10","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_4","title":"Parameters","text":"<p><code>AGamepad</code>: <code>TSdlGamepad</code> : The gamepad object that you want to get a joystick from.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#returns_4","title":"Returns","text":"<p><code>TSdlJoystick</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#FromID","title":"FromID(TSdlJoystickID)","text":"<p>Get the joystick associated with an instance ID, if it has been opened. </p> <p><code>class function FromID(const AInstanceID: TSdlJoystickID): TSdlJoystick; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_11","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure (eg. when the joystick hasn't been opened).</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_5","title":"Parameters","text":"<p><code>AInstanceID</code>: <code>TSdlJoystickID</code> : The instance ID to get the joystick for.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#returns_5","title":"Returns","text":"<p><code>TSdlJoystick</code>: The opened joystick.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#FromPlayerIndex","title":"FromPlayerIndex(Integer)","text":"<p>Get the joystick associated with a player index. </p> <p><code>class function FromPlayerIndex(const APlayerIndex: Integer): TSdlJoystick; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_12","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_6","title":"Parameters","text":"<p><code>APlayerIndex</code>: <code>Integer</code> : The player index to get the joystick for.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#returns_6","title":"Returns","text":"<p><code>TSdlJoystick</code>: The opened joystick.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_20","title":"See Also","text":"<ul> <li>PlayerIndex</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#GetPowerInfo","title":"GetPowerInfo(Integer)","text":"<p>Get the battery state of the joystick.</p> <p>You should never take a battery status as absolute truth. Batteries (especially failing batteries) are delicate hardware, and the values reported here are best estimates based on what that hardware reports. It's not uncommon for older batteries to lose stored power much faster than it reports, or completely drain when reporting it has 20 percent left, etc. </p> <p><code>function GetPowerInfo(out APercent: Integer): TSdlPowerState; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_13","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_7","title":"Parameters","text":"<p><code>APercent</code>: <code>Integer</code> : Set to the percentage of battery life left, between 0 and 100. Will be set to  -1 if we can't determine a value or there is no battery.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#returns_7","title":"Returns","text":"<p><code>TSdlPowerState</code>: The current battery state.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#GuidInfo","title":"GuidInfo(TGuid, Word, Word, Word, Word)","text":"<p>Get the device information encoded in a joystick GUID structure. </p> <p><code>class procedure GuidInfo(const AGuid: TGuid; out AVendor, AProduct, AVersion, ACrc16: Word); inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_8","title":"Parameters","text":"<p><code>AGuid</code>: <code>TGuid</code> : The GUID you wish to get info about.</p> <p><code>AVendor</code>: <code>Word</code> : Is set to the device VID, or 0 if not available.</p> <p><code>AProduct</code>: <code>Word</code> : Is set to the device PID, or 0 if not available.</p> <p><code>AVersion</code>: <code>Word</code> : Is set to the device version, or 0 if not available.</p> <p><code>ACrc16</code>: <code>Word</code> : Is set to a CRC used to distinguish different products with the same VID/PID, or 0 if not available.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_21","title":"See Also","text":"<ul> <li>Guid</li> <li>TSdlJoystickID.Guid</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Lock","title":"Lock","text":"<p>Locking for atomic access to the joystick API.</p> <p>The SDL joystick functions are thread-safe, however you can lock the joysticks while processing to guarantee that the joystick list won't change and joystick and gamepad events will not be delivered. </p> <p><code>class procedure Lock; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Open","title":"Open(TSdlJoystickID)","text":"<p>Open a joystick for use.</p> <p>The joystick subsystem must be initialized before a joystick can be opened for use. </p> <p><code>class function Open(const AInstanceID: TSdlJoystickID): TSdlJoystick; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_14","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_9","title":"Parameters","text":"<p><code>AInstanceID</code>: <code>TSdlJoystickID</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#returns_8","title":"Returns","text":"<p><code>TSdlJoystick</code>: The opened joystick.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#see-also_22","title":"See Also","text":"<ul> <li>Close</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Rumble","title":"Rumble(Word, Word, Integer)","text":"<p>Start a rumble effect.</p> <p>Each call to this method cancels any previous rumble effect, and calling it with 0 intensity stops any rumbling.</p> <p>This method requires you to process SDL events or call Update to update rumble state. </p> <p><code>function Rumble(const ALowFrequencyRumble, AHighFrequencyRumble: Word; const ADurationMs: Integer): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_10","title":"Parameters","text":"<p><code>ALowFrequencyRumble</code>: <code>Word</code> : The intensity of the low frequency (left) rumble motor, from 0 to $FFFF.</p> <p><code>AHighFrequencyRumble</code>: <code>Word</code> : The intensity of the high frequency (right) rumble motor, from 0 to $FFFF.</p> <p><code>ADurationMs</code>: <code>Integer</code> : The duration of the rumble effect, in milliseconds.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#returns_9","title":"Returns","text":"<p><code>Boolean</code>: True, or False if rumble isn't supported on this joystick.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#RumbleTriggers","title":"RumbleTriggers(Word, Word, Integer)","text":"<p>Start a rumble effect in the joystick's triggers.</p> <p>Each call to this method cancels any previous trigger rumble effect, and calling it with 0 intensity stops any rumbling.</p> <p>Note that this is rumbling of the triggers and not the game controller as a whole. This is currently only supported on Xbox One controllers. If you want the (more common) whole-controller rumble, Rumble instead.</p> <p>This method requires you to process SDL events or call Update to update rumble state. </p> <p><code>function RumbleTriggers(const ALeftRumble, ARightRumble: Word; const ADurationMs: Integer): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_11","title":"Parameters","text":"<p><code>ALeftRumble</code>: <code>Word</code> : The intensity of the left trigger rumble motor, from 0 to $FFFF.</p> <p><code>ARightRumble</code>: <code>Word</code> : The intensity of the right trigger rumble motor, The duration of the rumble effect, in milliseconds.True, or False if rumble isn't supported on this joystick.</p> <p><code>ADurationMs</code>: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#returns_10","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#SendEffect","title":"SendEffect(TBytes)","text":"<p>Send a joystick specific effect packet. </p> <p><code>procedure SendEffect(const AData: TBytes); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_15","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_12","title":"Parameters","text":"<p><code>AData</code>: <code>TBytes</code> : The data to send to the joystick.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#SetLed","title":"SetLed(Byte, Byte, Byte)","text":"<p>Update the joystick's LED color.</p> <p>An example of a joystick LED is the light on the back of a PlayStation 4's DualShock 4 controller.</p> <p>For joysticks with a single color LED, the maximum of the RGB values will be used as the LED brightness. </p> <p><code>procedure SetLed(const ARed, AGreen, ABlue: Byte); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_16","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_13","title":"Parameters","text":"<p><code>ARed</code>: <code>Byte</code> : The intensity of the red LED.</p> <p><code>AGreen</code>: <code>Byte</code> : The intensity of the green LED.</p> <p><code>ABlue</code>: <code>Byte</code> : The intensity of the blue LED.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#SetVirtualAxis","title":"SetVirtualAxis(Integer, Smallint)","text":"<p>Set the state of an axis on this opened virtual joystick.</p> <p>Please note that values set here will not be applied until the next call to Update, which can either be called directly, or can be called indirectly through various other SDL APIs, including, but not limited to the following: TSdlEvents.Poll, TSdlEvents.Pump and TSdlEvents.Wait.</p> <p>Note that when sending trigger axes, you should scale the value to the full range of Int16. For example, a trigger at rest would have the value of <code>SDL_JOYSTICK_AXIS_MIN</code>. </p> <p><code>procedure SetVirtualAxis(const AAxis: Integer; const AValue: Smallint); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_17","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_14","title":"Parameters","text":"<p><code>AAxis</code>: <code>Integer</code> : The index of the axis on the virtual joystick to update.</p> <p><code>AValue</code>: <code>Smallint</code> : The new value for the specified axis.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#SetVirtualBall","title":"SetVirtualBall(Integer, Smallint, Smallint)","text":"<p>Generate ball motion on this opened virtual joystick.</p> <p>Please note that values set here will not be applied until the next call to Update, which can either be called directly, or can be called indirectly through various other SDL APIs, including, but not limited to the following: TSdlEvents.Poll, TSdlEvents.Pump and TSdlEvents.Wait. </p> <p><code>procedure SetVirtualBall(const ABall: Integer; const AXRel, AYRel: Smallint); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_18","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_15","title":"Parameters","text":"<p><code>ABall</code>: <code>Integer</code> : The index of the ball on the virtual joystick to update.</p> <p><code>AXRel</code>: <code>Smallint</code> : The relative motion on the X axis.</p> <p><code>AYRel</code>: <code>Smallint</code> : The relative motion on the Y axis.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#SetVirtualButton","title":"SetVirtualButton(Integer, Boolean)","text":"<p>Set the state of a button on this opened virtual joystick.</p> <p>Please note that values set here will not be applied until the next call to Update, which can either be called directly, or can be called indirectly through various other SDL APIs, including, but not limited to the following: TSdlEvents.Poll, TSdlEvents.Pump and TSdlEvents.Wait. </p> <p><code>procedure SetVirtualButton(const AButton: Integer; const AIsDown: Boolean); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_19","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_16","title":"Parameters","text":"<p><code>AButton</code>: <code>Integer</code> : The index of the button on the virtual joystick to update.</p> <p><code>AIsDown</code>: <code>Boolean</code> : True if the button is pressed, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#SetVirtualHat","title":"SetVirtualHat(Integer, Byte)","text":"<p>Set the state of a hat on an opened virtual joystick.</p> <p>Please note that values set here will not be applied until the next call to Update, which can either be called directly, or can be called indirectly through various other SDL APIs, including, but not limited to the following: TSdlEvents.Poll, TSdlEvents.Pump and TSdlEvents.Wait. </p> <p><code>procedure SetVirtualHat(const AHat: Integer; const AValue: Byte); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_20","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_17","title":"Parameters","text":"<p><code>AHat</code>: <code>Integer</code> : The index of the hat on the virtual joystick to update.</p> <p><code>AValue</code>: <code>Byte</code> : The new value for the specified hat.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#SetVirtualSensorData","title":"SetVirtualSensorData(TSdlSensorKind, Int64, TArray&lt;Single&gt;)","text":"<p>Send a sensor update for an opened virtual joystick.</p> <p>Please note that values set here will not be applied until the next call to Update, which can either be called directly, or can be called indirectly through various other SDL APIs, including, but not limited to the following: TSdlEvents.Poll, TSdlEvents.Pump and TSdlEvents.Wait. </p> <p><code>procedure SetVirtualSensorData(const AKind: TSdlSensorKind; const ATimestamp: Int64; const AData: TArray&lt;Single&gt;); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_21","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_18","title":"Parameters","text":"<p><code>AKind</code>: <code>TSdlSensorKind</code> : The type of the sensor on the virtual joystick to update.</p> <p><code>ATimestamp</code>: <code>Int64</code> : A 64-bit timestamp in nanoseconds associated with the sensor reading.</p> <p><code>AData</code>: <code>TArray&lt;Single&gt;</code> : The data associated with the sensor reading.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#SetVirtualTouchpad","title":"SetVirtualTouchpad(Integer, Integer, Boolean, Single, Single, Single)","text":"<p>Set touchpad finger state on an opened virtual joystick.</p> <p>Please note that values set here will not be applied until the next call to Update, which can either be called directly, or can be called indirectly through various other SDL APIs, including, but not limited to the following: TSdlEvents.Poll, TSdlEvents.Pump and TSdlEvents.Wait. </p> <p><code>procedure SetVirtualTouchpad(const ATouchpad, AFinger: Integer; const AIsDown: Boolean; const AX, AY, APressure: Single); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#exceptions_22","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#parameters_19","title":"Parameters","text":"<p><code>ATouchpad</code>: <code>Integer</code> : The index of the touchpad on the virtual joystick to update.</p> <p><code>AFinger</code>: <code>Integer</code> : The index of the finger on the touchpad to set.</p> <p><code>AIsDown</code>: <code>Boolean</code> : True if the finger is pressed, False if the finger is released.</p> <p><code>AX</code>: <code>Single</code> : The X coordinate of the finger on the touchpad, normalized 0 to 1, with the origin in the upper left.</p> <p><code>AY</code>: <code>Single</code> : The Y coordinate of the finger on the touchpad, normalized 0 to 1, with the origin in the upper left.</p> <p><code>APressure</code>: <code>Single</code> : The pressure of the finger.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Unlock","title":"Unlock","text":"<p>Unlocking for atomic access to the joystick API. </p> <p><code>class procedure Unlock; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystick/#Update","title":"Update","text":"<p>Update the current state of the open joysticks.</p> <p>This is called automatically by the event loop if any joystick events are enabled. </p> <p><code>class procedure Update; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/","title":"TSdlJoystickID","text":"<p>This is a unique ID for a joystick for the time it is connected to the system, and is never reused for the lifetime of the application.</p> <p>If the joystick is disconnected and reconnected, it will get a new ID. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlJoystickID = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#properties","title":"Properties","text":"Name Description Guid The implementation-dependent GUID of the joystick. ID IsGamepad Whether this joystick is supported by the gamepad interface. IsVirtual Whether or not this joystick is virtual. Kind The type of a joystick, if available. Name The implementation dependent name of the joystick or an empty string if not available. Path The implementation dependent path of the joystick or an empty string if not available. PlayerIndex Get the player index of the joystick, or -1 of not available. Product The USB product ID of the joystick, if available. ProductVersion The product version of the joystick, if available. Vendor The USB vendor ID of the joystick, if available."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>0</code>. Implicit Used to set the value to <code>0</code>. NotEqual Used to compare against <code>0</code>."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#Guid","title":"Guid","text":"<p>The implementation-dependent GUID of the joystick.</p> <p>This can be used before any joysticks are opened. </p> <p><code>property Guid: TGuid read GetGuid</code></p> <p>Type: <code>TGuid</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#see-also","title":"See Also","text":"<ul> <li>TSdlJoystick.Guid</li> <li>TSdlJoystick.Joysticks</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#ID","title":"ID","text":"<p><code>property ID: Cardinal read FHandle</code></p> <p>Type: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#IsGamepad","title":"IsGamepad","text":"<p>Whether this joystick is supported by the gamepad interface. </p> <p><code>property IsGamepad: Boolean read GetIsGamepad</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#see-also_1","title":"See Also","text":"<ul> <li>TSdlJoystick.Joysticks</li> <li>TSdlGamepad.Open</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#IsVirtual","title":"IsVirtual","text":"<p>Whether or not this joystick is virtual. </p> <p><code>property IsVirtual: Boolean read GetIsVirtual</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#Kind","title":"Kind","text":"<p>The type of a joystick, if available.</p> <p>This can be used before any joysticks are opened. </p> <p><code>property Kind: TSdlJoystickKind read GetKind</code></p> <p>Type: <code>TSdlJoystickKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#see-also_2","title":"See Also","text":"<ul> <li>TSdlJoystick.Kind</li> <li>TSdlJoystick.Joysticks</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#Name","title":"Name","text":"<p>The implementation dependent name of the joystick or an empty string if not available.</p> <p>This can be used before any joysticks are opened. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#see-also_3","title":"See Also","text":"<ul> <li>TSdlJoystick.Name</li> <li>TSdlJoystick.Joysticks</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#Path","title":"Path","text":"<p>The implementation dependent path of the joystick or an empty string if not available.</p> <p>This can be used before any joysticks are opened. </p> <p><code>property Path: String read GetPath</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#see-also_4","title":"See Also","text":"<ul> <li>TSdlJoystick.Path</li> <li>TSdlJoystick.Joysticks</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#PlayerIndex","title":"PlayerIndex","text":"<p>Get the player index of the joystick, or -1 of not available.</p> <p>This can be used before any joysticks are opened. </p> <p><code>property PlayerIndex: Integer read GetPlayerIndex</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#see-also_5","title":"See Also","text":"<ul> <li>TSdlJoystick.PlayerIndex</li> <li>TSdlJoystick.Joysticks</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#Product","title":"Product","text":"<p>The USB product ID of the joystick, if available.</p> <p>This can be used before any joysticks are opened. If the product ID isn't available this property returns 0. </p> <p><code>property Product: Word read GetProduct</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#see-also_6","title":"See Also","text":"<ul> <li>TSdlJoystick.Product</li> <li>TSdlJoystick.Joysticks</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#ProductVersion","title":"ProductVersion","text":"<p>The product version of the joystick, if available.</p> <p>This can be used before any joysticks are opened. If the product version isn't available this property returns 0. </p> <p><code>property ProductVersion: Word read GetProductVersion</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#see-also_7","title":"See Also","text":"<ul> <li>TSdlJoystick.ProductVersion</li> <li>TSdlJoystick.Joysticks</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#Vendor","title":"Vendor","text":"<p>The USB vendor ID of the joystick, if available.</p> <p>This can be used before any joysticks are opened. If the vendor ID isn't available this property returns 0. </p> <p><code>property Vendor: Word read GetVendor</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#see-also_8","title":"See Also","text":"<ul> <li>TSdlJoystick.Vendor</li> <li>TSdlJoystick.Joysticks</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#Equal","title":"Equal(TSdlJoystickID, Cardinal)","text":"<p>Used to compare against <code>0</code>. </p> <p><code>class operator Equal(const ALeft: TSdlJoystickID; const ARight: Cardinal): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlJoystickID</code></p> <p><code>ARight</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#Implicit","title":"Implicit(Cardinal)","text":"<p>Used to set the value to <code>0</code>. </p> <p><code>class operator Implicit(const AValue: Cardinal): TSdlJoystickID; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#returns_1","title":"Returns","text":"<p><code>TSdlJoystickID</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#NotEqual","title":"NotEqual(TSdlJoystickID, Cardinal)","text":"<p>Used to compare against <code>0</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlJoystickID; const ARight: Cardinal): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlJoystickID</code></p> <p><code>ARight</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlJoystickID/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/","title":"TSdlKeyboard","text":"<p>Represents a keyboard. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlKeyboard = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#properties","title":"Properties","text":"Name Description Focus The window which currently has keyboard focus. HasKeyboard Whether a keyboard is currently connected. HasScreenKeyboardSupport Whether the platform has screen keyboard support. Keyboards A list of currently connected keyboards. ModState The current key modifier state for the keyboard. Name The name of the keyboard. State Get a snapshot of the current state of the keyboard."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#methods","title":"Methods","text":"Name Description Reset Clear the state of the keyboard."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#Focus","title":"Focus","text":"<p>The window which currently has keyboard focus. </p> <p><code>class property Focus: TSdlWindow read GetFocus</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#remarks","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#HasKeyboard","title":"HasKeyboard","text":"<p>Whether a keyboard is currently connected. </p> <p><code>class property HasKeyboard: Boolean read GetHasKeyboard</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#see-also","title":"See Also","text":"<ul> <li>Keyboards</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#remarks_1","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#HasScreenKeyboardSupport","title":"HasScreenKeyboardSupport","text":"<p>Whether the platform has screen keyboard support. </p> <p><code>class property HasScreenKeyboardSupport: Boolean read GetHasScreenKeyboardSupport</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#see-also_1","title":"See Also","text":"<ul> <li>TSdlWindow.StartTextInput</li> <li>TSdlWindow.IsScreenKeyboardShown</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#remarks_2","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#Keyboards","title":"Keyboards","text":"<p>A list of currently connected keyboards.</p> <p>Note that this will include any device or virtual driver that includes keyboard functionality, including some mice, KVM switches, motherboard power buttons, etc. You should wait for input from a device before you consider it actively in use. </p> <p><code>class property Keyboards: TArray&lt;TSdlKeyboard&gt; read GetKeyboards</code></p> <p>Type: <code>TArray&lt;TSdlKeyboard&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#see-also_2","title":"See Also","text":"<ul> <li>Name</li> <li>HasKeyboard</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#remarks_3","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#ModState","title":"ModState","text":"<p>The current key modifier state for the keyboard.</p> <p>You can also set this state. This allows you to impose modifier key states on your application. This does not change the keyboard state, only the key modifier flags that SDL reports. </p> <p><code>class property ModState: TSdlKeyMods read GetModState write SetModState</code></p> <p>Type: <code>TSdlKeyMods</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#see-also_3","title":"See Also","text":"<ul> <li>State</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#remarks_4","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#Name","title":"Name","text":"<p>The name of the keyboard.</p> <p>Returns an empty string if the keyboard doesn't have a name. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#see-also_4","title":"See Also","text":"<ul> <li>Keyboards</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#remarks_5","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#State","title":"State","text":"<p>Get a snapshot of the current state of the keyboard.</p> <p>TSdlEvents.Pump to update the state array.</p> <p>This property gives you the current state after all events have been processed, so if a key or button has been pressed and released before you process events, then the pressed state will never show up in this property.</p> <p>Note: This property doesn't take into account whether shift has been pressed or not. </p> <p><code>class property State: TSdlKeyboardState read GetState</code></p> <p>Type: <code>TSdlKeyboardState</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#see-also_5","title":"See Also","text":"<ul> <li>TSdlEvents.Pump</li> <li>Reset</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#remarks_6","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#Equal","title":"Equal(TSdlKeyboard, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlKeyboard; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlKeyboard</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlKeyboard; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#returns_1","title":"Returns","text":"<p><code>TSdlKeyboard</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#NotEqual","title":"NotEqual(TSdlKeyboard, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlKeyboard; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlKeyboard</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#Reset","title":"Reset","text":"<p>Clear the state of the keyboard.</p> <p>This method will generate key up events for all pressed keys. </p> <p><code>class procedure Reset; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#see-also_6","title":"See Also","text":"<ul> <li>State</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboard/#remarks_7","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboardState/","title":"TSdlKeyboardState","text":"<p>The state of a keyboard. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboardState/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlKeyboardState = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboardState/#methods","title":"Methods","text":"Name Description IsPressed Whether a key with the given scancode is currently pressed."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboardState/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboardState/#IsPressed","title":"IsPressed(TSdlScancode)","text":"<p>Whether a key with the given scancode is currently pressed. </p> <p><code>function IsPressed(const AScancode: TSdlScancode): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboardState/#parameters","title":"Parameters","text":"<p><code>AScancode</code>: <code>TSdlScancode</code> : The scancode to check.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlKeyboardState/#returns","title":"Returns","text":"<p><code>Boolean</code>: True if the key is pressed, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/","title":"TSdlMouse","text":"<p>A mouse </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlMouse = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#properties","title":"Properties","text":"Name Description Focus The window which currently has mouse focus. HasMouse Whether a mouse is currently connected. Mice A list of currently connected mice. Name Get the name of the mouse. Pen A virtual mouse used for mouse events simulated with pen input. Touch A virtual mouse used for mouse events simulated with touch input."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#methods","title":"Methods","text":"Name Description Capture Capture the mouse and to track input outside an SDL window. GetGlobalState(TSdlPointF) Query the platform for the asynchronous mouse button state and the desktop-relative platform-cursor position. GetGlobalState(Single, Single) Query the platform for the asynchronous mouse button state and the desktop-relative platform-cursor position. GetRelativeState(TSdlPointF) Query SDL's cache for the synchronous mouse button state and accumulated mouse delta since last call. GetRelativeState(Single, Single) Query SDL's cache for the synchronous mouse button state and accumulated mouse delta since last call. GetState(TSdlPointF) Query SDL's cache for the synchronous mouse button state and the window-relative SDL-cursor position. GetState(Single, Single) Query SDL's cache for the synchronous mouse button state and the window-relative SDL-cursor position. WarpGlobal(TSdlPointF) Move the mouse to the given position in global screen space. WarpGlobal(Single, Single) Move the mouse to the given position in global screen space."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#Focus","title":"Focus","text":"<p>The window which currently has mouse focus. </p> <p><code>class property Focus: TSdlWindow read GetFocus</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#remarks","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#HasMouse","title":"HasMouse","text":"<p>Whether a mouse is currently connected. </p> <p><code>class property HasMouse: Boolean read GetHasMouse</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#see-also","title":"See Also","text":"<ul> <li>Mice</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#remarks_1","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#Mice","title":"Mice","text":"<p>A list of currently connected mice.</p> <p>Note that this will include any device or virtual driver that includes mouse functionality, including some game controllers, KVM switches, etc. You should wait for input from a device before you consider it actively in use. </p> <p><code>class property Mice: TArray&lt;TSdlMouse&gt; read GetMice</code></p> <p>Type: <code>TArray&lt;TSdlMouse&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#see-also_1","title":"See Also","text":"<ul> <li>Name</li> <li>HasMouse</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#remarks_2","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#Name","title":"Name","text":"<p>Get the name of the mouse.</p> <p>This property returns an empty string if the mouse doesn't have a name. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#see-also_2","title":"See Also","text":"<ul> <li>Mice</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#remarks_3","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#Pen","title":"Pen","text":"<p>A virtual mouse used for mouse events simulated with pen input. </p> <p><code>class property Pen: TSdlMouse read GetPen</code></p> <p>Type: <code>TSdlMouse</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#Touch","title":"Touch","text":"<p>A virtual mouse used for mouse events simulated with touch input. </p> <p><code>class property Touch: TSdlMouse read GetTouch</code></p> <p>Type: <code>TSdlMouse</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#Equal","title":"Equal(TSdlMouse, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlMouse; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlMouse</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlMouse; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#returns_1","title":"Returns","text":"<p><code>TSdlMouse</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#NotEqual","title":"NotEqual(TSdlMouse, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlMouse; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlMouse</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#Capture","title":"Capture(Boolean)","text":"<p>Capture the mouse and to track input outside an SDL window.</p> <p>Capturing enables your app to obtain mouse events globally, instead of just within your window. Not all video targets support this function. When capturing is enabled, the current window will get all mouse events, but unlike relative mode, no change is made to the cursor and it is not restrained to your window.</p> <p>This function may also deny mouse input to other windows--both those in your application and others on the system--so you should use this function sparingly, and in small bursts. For example, you might want to track the mouse while the user is dragging something, until the user releases a mouse button. It is not recommended that you capture the mouse for long periods of time, such as the entire time your app is running. For that, you should probably use TSdlWindow.IsRelativeMouseMode or TSdlWindow.MouseGrab, depending on your goals.</p> <p>While captured, mouse events still report coordinates relative to the current (foreground) window, but those coordinates may be outside the bounds of the window (including negative values). Capturing is only allowed for the foreground window. If the window loses focus while capturing, the capture will be disabled automatically.</p> <p>While capturing is enabled, the current window will have the <code>TSdlWindowFlag.MouseCapture</code> flag set.</p> <p>Please note that SDL will attempt to \"auto capture\" the mouse while the user is pressing a button; this is to try and make mouse behavior more consistent between platforms, and deal with the common case of a user dragging the mouse outside of the window. This means that if you are calling CaptureMouse only to deal with this situation, you do not have to (although it is safe to do so). If this causes problems for your app, you can disable auto capture by setting the <code>TSdlHints.MouseAutoCapture</code> hint to zero. </p> <p><code>class procedure Capture(const AEnabled: Boolean); inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#parameters_3","title":"Parameters","text":"<p><code>AEnabled</code>: <code>Boolean</code> : True to enable capturing, False to disable.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#see-also_3","title":"See Also","text":"<ul> <li>GetGlobalState</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#remarks_4","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#GetGlobalState_0","title":"GetGlobalState(TSdlPointF)","text":"<p>Query the platform for the asynchronous mouse button state and the desktop-relative platform-cursor position.</p> <p>This method immediately queries the platform for the most recent asynchronous state, more costly than retrieving SDL's cached state in GetState.</p> <p>In Relative Mode, the platform-cursor's position usually contradicts the SDL-cursor's position as manually calculated from GetState and TSdlWindow.Position.</p> <p>This method can be useful if you need to track the mouse outside of a specific window and Capture doesn't fit your needs. For example, it could be useful if you need to track the mouse while dragging a window, where coordinates relative to a window might not be in sync at all times. </p> <p><code>function GetGlobalState(out APosition: TSdlPointF): TSdlMouseButtons; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#parameters_4","title":"Parameters","text":"<p><code>APosition</code>: <code>TSdlPointF</code> : Is set to the platform-cursor's position from the desktop's top left corner.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#returns_3","title":"Returns","text":"<p><code>TSdlMouseButtons</code>: The mouse buttons that are pressed.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#see-also_4","title":"See Also","text":"<ul> <li>Capture</li> <li>GetState</li> <li>GetRelativeState</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#remarks_5","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#GetGlobalState_1","title":"GetGlobalState(Single, Single)","text":"<p>Query the platform for the asynchronous mouse button state and the desktop-relative platform-cursor position.</p> <p>This method immediately queries the platform for the most recent asynchronous state, more costly than retrieving SDL's cached state in GetState.</p> <p>In Relative Mode, the platform-cursor's position usually contradicts the SDL-cursor's position as manually calculated from GetState and TSdlWindow.Position.</p> <p>This method can be useful if you need to track the mouse outside of a specific window and Capture doesn't fit your needs. For example, it could be useful if you need to track the mouse while dragging a window, where coordinates relative to a window might not be in sync at all times. </p> <p><code>function GetGlobalState(out AX, AY: Single): TSdlMouseButtons; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#parameters_5","title":"Parameters","text":"<p><code>AX</code>: <code>Single</code> : Is set to the platform-cursor's X-position from the desktop's top left corner.</p> <p><code>AY</code>: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#returns_4","title":"Returns","text":"<p><code>TSdlMouseButtons</code>: The mouse buttons that are pressed.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#see-also_5","title":"See Also","text":"<ul> <li>Capture</li> <li>GetState</li> <li>GetRelativeState</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#remarks_6","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#GetRelativeState_0","title":"GetRelativeState(TSdlPointF)","text":"<p>Query SDL's cache for the synchronous mouse button state and accumulated mouse delta since last call.</p> <p>This method returns the cached synchronous state as SDL understands it from the last pump of the event queue.</p> <p>To query the platform for immediate asynchronous state, use GetGlobalState.</p> <p>This method is useful for reducing overhead by processing relative mouse inputs in one go per-frame instead of individually per-event, at the expense of losing the order between events within the frame (e.g. quickly pressing and releasing a button within the same frame). </p> <p><code>function GetRelativeState(out ADelta: TSdlPointF): TSdlMouseButtons; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#parameters_6","title":"Parameters","text":"<p><code>ADelta</code>: <code>TSdlPointF</code> : Is set to the mouse delta accumulated since last call.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#returns_5","title":"Returns","text":"<p><code>TSdlMouseButtons</code>: The mouse buttons that are pressed.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#see-also_6","title":"See Also","text":"<ul> <li>GetState</li> <li>GetGlobalState</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#remarks_7","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#GetRelativeState_1","title":"GetRelativeState(Single, Single)","text":"<p>Query SDL's cache for the synchronous mouse button state and accumulated mouse delta since last call.</p> <p>This method returns the cached synchronous state as SDL understands it from the last pump of the event queue.</p> <p>To query the platform for immediate asynchronous state, use GetGlobalState.</p> <p>This method is useful for reducing overhead by processing relative mouse inputs in one go per-frame instead of individually per-event, at the expense of losing the order between events within the frame (e.g. quickly pressing and releasing a button within the same frame). </p> <p><code>function GetRelativeState(out AX, AY: Single): TSdlMouseButtons; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#parameters_7","title":"Parameters","text":"<p><code>AX</code>: <code>Single</code> : Is set to the X mouse delta accumulated since last call.</p> <p><code>AY</code>: <code>Single</code> : Is set to the Y mouse delta accumulated since last call.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#returns_6","title":"Returns","text":"<p><code>TSdlMouseButtons</code>: The mouse buttons that are pressed.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#see-also_7","title":"See Also","text":"<ul> <li>GetState</li> <li>GetGlobalState</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#remarks_8","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#GetState_0","title":"GetState(TSdlPointF)","text":"<p>Query SDL's cache for the synchronous mouse button state and the window-relative SDL-cursor position.</p> <p>This method returns the cached synchronous state as SDL understands it from the last pump of the event queue.</p> <p>To query the platform for immediate asynchronous state, use GetGlobalState.</p> <p>In Relative Mode, the SDL-cursor's position usually contradicts the platform-cursor's position as manually calculated from GetGlobalState and TSdlWindow.Position. </p> <p><code>function GetState(out APosition: TSdlPointF): TSdlMouseButtons; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#parameters_8","title":"Parameters","text":"<p><code>APosition</code>: <code>TSdlPointF</code> : Is set to the SDL-cursor's position from the focused window's top left corner.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#returns_7","title":"Returns","text":"<p><code>TSdlMouseButtons</code>: The mouse buttons that are pressed.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#see-also_8","title":"See Also","text":"<ul> <li>GetGlobalState</li> <li>GetRelativeState</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#remarks_9","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#GetState_1","title":"GetState(Single, Single)","text":"<p>Query SDL's cache for the synchronous mouse button state and the window-relative SDL-cursor position.</p> <p>This method returns the cached synchronous state as SDL understands it from the last pump of the event queue.</p> <p>To query the platform for immediate asynchronous state, use GetGlobalState.</p> <p>In Relative Mode, the SDL-cursor's position usually contradicts the platform-cursor's position as manually calculated from GetGlobalState and TSdlWindow.Position. </p> <p><code>function GetState(out AX, AY: Single): TSdlMouseButtons; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#parameters_9","title":"Parameters","text":"<p><code>AX</code>: <code>Single</code> : Is set to the SDL-cursor's X-position from the focused window's top left corner.</p> <p><code>AY</code>: <code>Single</code> : Is set to the SDL-cursor's Y-position from the focused window's top left corner.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#returns_8","title":"Returns","text":"<p><code>TSdlMouseButtons</code>: The mouse buttons that are pressed.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#see-also_9","title":"See Also","text":"<ul> <li>GetGlobalState</li> <li>GetRelativeState</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#remarks_10","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#WarpGlobal_0","title":"WarpGlobal(TSdlPointF)","text":"<p>Move the mouse to the given position in global screen space.</p> <p>This method generates a mouse motion event.</p> <p>A failure of this function usually means that it is unsupported by a platform.</p> <p>Note that this function will appear to succeed, but not actually move the mouse when used over Microsoft Remote Desktop. </p> <p><code>procedure WarpGlobal(const APosition: TSdlPointF); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#parameters_10","title":"Parameters","text":"<p><code>APosition</code>: <code>TSdlPointF</code> : The coordinate.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#see-also_10","title":"See Also","text":"<ul> <li>TSdlWindow.WarpMouse</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#remarks_11","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#WarpGlobal_1","title":"WarpGlobal(Single, Single)","text":"<p>Move the mouse to the given position in global screen space.</p> <p>This method generates a mouse motion event.</p> <p>A failure of this function usually means that it is unsupported by a platform.</p> <p>Note that this function will appear to succeed, but not actually move the mouse when used over Microsoft Remote Desktop. </p> <p><code>procedure WarpGlobal(const AX, AY: Single); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#parameters_11","title":"Parameters","text":"<p><code>AX</code>: <code>Single</code> : The X coordinate.</p> <p><code>AY</code>: <code>Single</code> : The Y coordinate.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#see-also_11","title":"See Also","text":"<ul> <li>TSdlWindow.WarpMouse</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlMouse/#remarks_12","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/","title":"TSdlSensor","text":"<p>An opened SDL sensor. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlSensor = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#properties","title":"Properties","text":"Name Description ID The instance ID of the sensor. Kind The type of the sensor. Name The implementation dependent name of the sensor. NonPortableType The platform dependent type of the sensor. Properties The properties associated with the sensor. Sensors A list of currently connected sensors."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#methods","title":"Methods","text":"Name Description Close Close the sensor previously opened with Open. FromID Return the snsor associated with an opened instance ID. GetSensorData Get the current state of the opened sensor. Open Open a sensor for use. Update Update the current state of the open sensors."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#ID","title":"ID","text":"<p>The instance ID of the sensor. </p> <p><code>property ID: TSdlSensorID read GetID</code></p> <p>Type: <code>TSdlSensorID</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#Kind","title":"Kind","text":"<p>The type of the sensor. </p> <p><code>property Kind: TSdlSensorKind read GetKind</code></p> <p>Type: <code>TSdlSensorKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#Name","title":"Name","text":"<p>The implementation dependent name of the sensor. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#NonPortableType","title":"NonPortableType","text":"<p>The platform dependent type of the sensor. </p> <p><code>property NonPortableType: Integer read GetNonPortableType</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#Properties","title":"Properties","text":"<p>The properties associated with the sensor. </p> <p><code>property Properties: TSdlProperties read GetProperties</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#Sensors","title":"Sensors","text":"<p>A list of currently connected sensors. </p> <p><code>class property Sensors: TArray&lt;TSdlSensorID&gt; read GetSensors</code></p> <p>Type: <code>TArray&lt;TSdlSensorID&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#Equal","title":"Equal(TSdlSensor, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlSensor; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlSensor</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlSensor; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#returns_1","title":"Returns","text":"<p><code>TSdlSensor</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#NotEqual","title":"NotEqual(TSdlSensor, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlSensor; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlSensor</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#Close","title":"Close","text":"<p>Close the sensor previously opened with Open. </p> <p><code>procedure Close; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#FromID","title":"FromID(TSdlSensorID)","text":"<p>Return the snsor associated with an opened instance ID. </p> <p><code>class function FromID(const AInstanceID: TSdlSensorID): TSdlSensor; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#exceptions_6","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#parameters_3","title":"Parameters","text":"<p><code>AInstanceID</code>: <code>TSdlSensorID</code> : The sensor instance ID.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#returns_3","title":"Returns","text":"<p><code>TSdlSensor</code>: The sensor.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#GetSensorData","title":"GetSensorData(TArray&lt;Single&gt;)","text":"<p>Get the current state of the opened sensor.</p> <p>The number of values and interpretation of the data is sensor dependent. The length of the AData array is the maximum number of values that will be written to the array. </p> <p><code>procedure GetSensorData(const AData: TArray&lt;Single&gt;); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#exceptions_7","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#parameters_4","title":"Parameters","text":"<p><code>AData</code>: <code>TArray&lt;Single&gt;</code> : An array filled with the current sensor state.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#Open","title":"Open(TSdlSensorID)","text":"<p>Open a sensor for use. </p> <p><code>class function Open(const AInstanceID: TSdlSensorID): TSdlSensor; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#exceptions_8","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#parameters_5","title":"Parameters","text":"<p><code>AInstanceID</code>: <code>TSdlSensorID</code> : The sensor instance ID.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#returns_4","title":"Returns","text":"<p><code>TSdlSensor</code>: The sensor.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensor/#Update","title":"Update","text":"<p>Update the current state of the open sensors.</p> <p>This is called automatically by the event loop if sensor events are enabled.</p> <p>This needs to be called from the thread that initialized the sensor subsystem. </p> <p><code>class procedure Update; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/","title":"TSdlSensorID","text":"<p>This is a unique ID for a sensor for the time it is connected to the system, and is never reused for the lifetime of the application. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlSensorID = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#properties","title":"Properties","text":"Name Description Kind The type of the sensor. Name The implementation dependent name of the sensor. NonPortableType Get the platform dependent type of a sensor,"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>0</code>. Implicit Used to set the value to <code>0</code>. NotEqual Used to compare against <code>0</code>."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#Kind","title":"Kind","text":"<p>The type of the sensor.</p> <p>This can be used before any sensors are opened. </p> <p><code>property Kind: TSdlSensorKind read GetKind</code></p> <p>Type: <code>TSdlSensorKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#Name","title":"Name","text":"<p>The implementation dependent name of the sensor.</p> <p>This can be used before any sensors are opened. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#NonPortableType","title":"NonPortableType","text":"<p>Get the platform dependent type of a sensor,</p> <p>This can be used before any sensors are opened. </p> <p><code>property NonPortableType: Integer read GetNonPortableType</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#Equal","title":"Equal(TSdlSensorID, Cardinal)","text":"<p>Used to compare against <code>0</code>. </p> <p><code>class operator Equal(const ALeft: TSdlSensorID; const ARight: Cardinal): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlSensorID</code></p> <p><code>ARight</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#Implicit","title":"Implicit(Cardinal)","text":"<p>Used to set the value to <code>0</code>. </p> <p><code>class operator Implicit(const AValue: Cardinal): TSdlSensorID; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#returns_1","title":"Returns","text":"<p><code>TSdlSensorID</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#NotEqual","title":"NotEqual(TSdlSensorID, Cardinal)","text":"<p>Used to compare against <code>0</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlSensorID; const ARight: Cardinal): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlSensorID</code></p> <p><code>ARight</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlSensorID/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/","title":"TSdlTouch","text":"<p>A touch device </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlTouch = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#properties","title":"Properties","text":"Name Description Devices A list of registered touch devices. DeviceType The type of the given touch device. Fingers A list of active fingers for a given touch device. Mouse A virtual touch device used for touch events simulated with mouse input. Name The touch device name as reported from the driver."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#Devices","title":"Devices","text":"<p>A list of registered touch devices.</p> <p>On some platforms SDL first sees the touch device if it was actually used. Therefore the returned list might be empty, although devices are available. After using all devices at least once the number will be correct. </p> <p><code>class property Devices: TArray&lt;TSdlTouch&gt; read GetDevices</code></p> <p>Type: <code>TArray&lt;TSdlTouch&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#DeviceType","title":"DeviceType","text":"<p>The type of the given touch device. </p> <p><code>property DeviceType: TSdlTouchDeviceType read GetDeviceType</code></p> <p>Type: <code>TSdlTouchDeviceType</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#Fingers","title":"Fingers","text":"<p>A list of active fingers for a given touch device. </p> <p><code>property Fingers: TArray&lt;TSdlFinger&gt; read GetFingers</code></p> <p>Type: <code>TArray&lt;TSdlFinger&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#Mouse","title":"Mouse","text":"<p>A virtual touch device used for touch events simulated with mouse input. </p> <p><code>class property Mouse: TSdlTouch read GetMouse</code></p> <p>Type: <code>TSdlTouch</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#Name","title":"Name","text":"<p>The touch device name as reported from the driver. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#Equal","title":"Equal(TSdlTouch, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlTouch; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlTouch</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlTouch; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#returns_1","title":"Returns","text":"<p><code>TSdlTouch</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#NotEqual","title":"NotEqual(TSdlTouch, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlTouch; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlTouch</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlTouch/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/","title":"TSdlVirtualJoystickDesc","text":"<p>A virtual joystick.</p> <p>This record should be initialized using Init. All members of this record are optional. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlVirtualJoystickDesc = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#see-also","title":"See Also","text":"<ul> <li>TSdlVirtualJoystickDesc.Attach</li> <li>TSdlVirtualJoystickDesc.Init</li> <li>TSdlVirtualJoystickSensorDesc</li> <li>TSdlVirtualJoystickTouchpadDesc</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#properties","title":"Properties","text":"Name Description Cleanup Cleans up the userdata when the joystick is detached Kind The joystick type Name The name of the joystick NumAxes The number of axes on this joystick NumBalls The number of balls on this joystick NumButtons The number of buttons on this joystick NumHats The number of hats on this joystick ProductID The USB product ID of this joystick Rumble Implements TSdlJoystick.Rumble RumbleTriggers Implements TSdlJoystick.RumbleTriggers SendEffect Implements TSdlJoystick.SendJEffect Sensors An array of sensor descriptions SetLed Implements TSdlJoystick.SetLed SetPlayerIndex Called when the player index is set SetSensorsEnabled Implements TSdlGamepad.SetSensorEnabled Touchpads An array of touchpad descriptions Update Called when the joystick state should be updated UserData User data pointer passed to callbacks ValidAxes A set of axes that are valid for this controller ValidButtons Set of buttons that are valid for this controller VendorID The USB vendor ID of this joystick"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#methods","title":"Methods","text":"Name Description Attach Attach a new virtual joystick. Detach Detach a virtual joystick. Init Initializes this record. You must call this method before attaching it."},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#Cleanup","title":"Cleanup","text":"<p>Cleans up the userdata when the joystick is detached </p> <p><code>property Cleanup: TSdlVirtualJoystickCleanup read GetCleanup write SetCleanup</code></p> <p>Type: <code>TSdlVirtualJoystickCleanup</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#Kind","title":"Kind","text":"<p>The joystick type </p> <p><code>property Kind: TSdlJoystickKind read GetKind write SetKind</code></p> <p>Type: <code>TSdlJoystickKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#Name","title":"Name","text":"<p>The name of the joystick </p> <p><code>property Name: String read FName write SetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#NumAxes","title":"NumAxes","text":"<p>The number of axes on this joystick </p> <p><code>property NumAxes: Smallint read FHandle.naxes write FHandle.naxes</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#NumBalls","title":"NumBalls","text":"<p>The number of balls on this joystick </p> <p><code>property NumBalls: Smallint read FHandle.nballs write FHandle.nballs</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#NumButtons","title":"NumButtons","text":"<p>The number of buttons on this joystick </p> <p><code>property NumButtons: Smallint read FHandle.nbuttons write FHandle.nbuttons</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#NumHats","title":"NumHats","text":"<p>The number of hats on this joystick </p> <p><code>property NumHats: Smallint read FHandle.nhats write FHandle.nhats</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#ProductID","title":"ProductID","text":"<p>The USB product ID of this joystick </p> <p><code>property ProductID: Word read FHandle.product_id write FHandle.product_id</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#Rumble","title":"Rumble","text":"<p>Implements TSdlJoystick.Rumble </p> <p><code>property Rumble: TSdlVirtualJoystickRumble read GetRumble write SetRumble</code></p> <p>Type: <code>TSdlVirtualJoystickRumble</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#RumbleTriggers","title":"RumbleTriggers","text":"<p>Implements TSdlJoystick.RumbleTriggers </p> <p><code>property RumbleTriggers: TSdlVirtualJoystickRumbleTriggers read GetRumbleTriggers write SetRumbleTriggers</code></p> <p>Type: <code>TSdlVirtualJoystickRumbleTriggers</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#SendEffect","title":"SendEffect","text":"<p>Implements TSdlJoystick.SendJEffect </p> <p><code>property SendEffect: TSdlVirtualJoystickSendEffect read GetSendEffect write SetSendEffect</code></p> <p>Type: <code>TSdlVirtualJoystickSendEffect</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#Sensors","title":"Sensors","text":"<p>An array of sensor descriptions </p> <p><code>property Sensors: TArray&lt;TSdlVirtualJoystickSensorDesc&gt; read FSensors write SetSensors</code></p> <p>Type: <code>TArray&lt;TSdlVirtualJoystickSensorDesc&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#SetLed","title":"SetLed","text":"<p>Implements TSdlJoystick.SetLed </p> <p><code>property SetLed: TSdlVirtualJoystickSetLed read GetSetLed write SetSetLed</code></p> <p>Type: <code>TSdlVirtualJoystickSetLed</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#SetPlayerIndex","title":"SetPlayerIndex","text":"<p>Called when the player index is set </p> <p><code>property SetPlayerIndex: TSdlVirtualJoystickSetPlayerIndex read GetSetPlayerIndex write SetSetPlayerIndex</code></p> <p>Type: <code>TSdlVirtualJoystickSetPlayerIndex</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#SetSensorsEnabled","title":"SetSensorsEnabled","text":"<p>Implements TSdlGamepad.SetSensorEnabled </p> <p><code>property SetSensorsEnabled: TSdlVirtualJoystickSetSensorsEnabled read GetSetSensorsEnabled write SetSetSensorsEnabled</code></p> <p>Type: <code>TSdlVirtualJoystickSetSensorsEnabled</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#Touchpads","title":"Touchpads","text":"<p>An array of touchpad descriptions </p> <p><code>property Touchpads: TArray&lt;TSdlVirtualJoystickTouchpadDesc&gt; read FTouchpads write SetTouchpads</code></p> <p>Type: <code>TArray&lt;TSdlVirtualJoystickTouchpadDesc&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#Update","title":"Update","text":"<p>Called when the joystick state should be updated </p> <p><code>property Update: TSdlVirtualJoystickUpdate read GetUpdate write SetUpdate</code></p> <p>Type: <code>TSdlVirtualJoystickUpdate</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#UserData","title":"UserData","text":"<p>User data pointer passed to callbacks </p> <p><code>property UserData: Pointer read FHandle.userdata write FHandle.userdata</code></p> <p>Type: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#ValidAxes","title":"ValidAxes","text":"<p>A set of axes that are valid for this controller </p> <p><code>property ValidAxes: TSdlGamepadAxes read GetValidAxes write SetValidAxes</code></p> <p>Type: <code>TSdlGamepadAxes</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#ValidButtons","title":"ValidButtons","text":"<p>Set of buttons that are valid for this controller </p> <p><code>property ValidButtons: TSdlGamepadButtons read GetValidButtons write SetValidButtons</code></p> <p>Type: <code>TSdlGamepadButtons</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#VendorID","title":"VendorID","text":"<p>The USB vendor ID of this joystick </p> <p><code>property VendorID: Word read FHandle.vendor_id write FHandle.vendor_id</code></p> <p>Type: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#Attach","title":"Attach","text":"<p>Attach a new virtual joystick. </p> <p><code>function Attach: TSdlJoystickID; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#returns","title":"Returns","text":"<p><code>TSdlJoystickID</code>: The joystick instance ID.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#see-also_1","title":"See Also","text":"<ul> <li>Detach</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#Detach","title":"Detach(TSdlJoystickID)","text":"<p>Detach a virtual joystick. </p> <p><code>class procedure Detach(const AInstanceID: TSdlJoystickID); inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#parameters","title":"Parameters","text":"<p><code>AInstanceID</code>: <code>TSdlJoystickID</code> : The joystick instance ID, previously returned Attach.</p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#see-also_2","title":"See Also","text":"<ul> <li>Attach</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#Init","title":"Init","text":"<p>Initializes this record. You must call this method before attaching it. </p> <p><code>procedure Init; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickDesc/#see-also_3","title":"See Also","text":"<ul> <li>Attach</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickSensorDesc/","title":"TSdlVirtualJoystickSensorDesc","text":"<p>A virtual joystick sensor. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickSensorDesc/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlVirtualJoystickSensorDesc = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickSensorDesc/#see-also","title":"See Also","text":"<ul> <li>TSdlVirtualJoystickDesc</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickSensorDesc/#properties","title":"Properties","text":"Name Description Kind The type of this sensor Rate The update frequency of this sensor, may be 0.0"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickSensorDesc/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickSensorDesc/#Kind","title":"Kind","text":"<p>The type of this sensor </p> <p><code>property Kind: TSdlSensorKind read GetKind write SetKind</code></p> <p>Type: <code>TSdlSensorKind</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickSensorDesc/#Rate","title":"Rate","text":"<p>The update frequency of this sensor, may be 0.0 </p> <p><code>property Rate: Single read FHandle.rate write FHandle.rate</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickTouchpadDesc/","title":"TSdlVirtualJoystickTouchpadDesc","text":"<p>A virtual joystick touchpad. </p>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickTouchpadDesc/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlVirtualJoystickTouchpadDesc = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickTouchpadDesc/#see-also","title":"See Also","text":"<ul> <li>TSdlVirtualJoystickDesc</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickTouchpadDesc/#properties","title":"Properties","text":"Name Description NumFingers The number of simultaneous fingers on this touchpad"},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickTouchpadDesc/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/classes/TSdlVirtualJoystickTouchpadDesc/#NumFingers","title":"NumFingers","text":"<p>The number of simultaneous fingers on this touchpad </p> <p><code>property NumFingers: Smallint read FHandle.nfingers write FHandle.nfingers</code></p> <p>Type: <code>Smallint</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/constants/SDL_JOYSTICK_AXIS_MAX/","title":"SDL_JOYSTICK_AXIS_MAX","text":"<p>The largest value an SDL_Joystick's axis can report. </p>"},{"location":"Reference/Neslib.Sdl3.Input/constants/SDL_JOYSTICK_AXIS_MAX/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>const SDL_JOYSTICK_AXIS_MAX = Neslib.Sdl3.Api.SDL_JOYSTICK_AXIS_MAX\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/constants/SDL_JOYSTICK_AXIS_MAX/#see-also","title":"See Also","text":"<ul> <li>SDL_JOYSTICK_AXIS_MIN</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/constants/SDL_JOYSTICK_AXIS_MIN/","title":"SDL_JOYSTICK_AXIS_MIN","text":"<p>The smallest value an SDL_Joystick's axis can report.</p> <p>This is a negative number! </p>"},{"location":"Reference/Neslib.Sdl3.Input/constants/SDL_JOYSTICK_AXIS_MIN/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>const SDL_JOYSTICK_AXIS_MIN = Neslib.Sdl3.Api.SDL_JOYSTICK_AXIS_MIN\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/constants/SDL_JOYSTICK_AXIS_MIN/#see-also","title":"See Also","text":"<ul> <li>SDL_JOYSTICK_AXIS_MAX</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/constants/SDL_STANDARD_GRAVITY/","title":"SDL_STANDARD_GRAVITY","text":"<p>A constant to represent standard gravity for accelerometer sensors.</p> <p>The accelerometer returns the current acceleration in SI meters per second squared. This measurement includes the force of gravity, so a device at rest will have an value of SDL_STANDARD_GRAVITY away from the center of the earth, which is a positive Y value. </p>"},{"location":"Reference/Neslib.Sdl3.Input/constants/SDL_STANDARD_GRAVITY/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>const SDL_STANDARD_GRAVITY = Neslib.Sdl3.Api.SDL_STANDARD_GRAVITY\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlBasicGamepadAxis/","title":"TSdlBasicGamepadAxis","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlBasicGamepadAxis/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlBasicGamepadAxis = TSdlGamepadAxis..TSdlGamepadAxis.RightTrigger\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlBasicGamepadButton/","title":"TSdlBasicGamepadButton","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlBasicGamepadButton/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlBasicGamepadButton = TSdlGamepadButton..TSdlGamepadButton.Misc6\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlFingerID/","title":"TSdlFingerID","text":"<p>A unique ID for a single finger on a touch device.</p> <p>This ID is valid for the time the finger (stylus, etc) is touching and will be unique for all fingers currently in contact, so this ID tracks the lifetime of a single continuous touch. This value may represent an index, a pointer, or some other unique ID, depending on the platform.</p> <p>The value 0 is an invalid ID. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlFingerID/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlFingerID = SDL_FingerID\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxes/","title":"TSdlGamepadAxes","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxes/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlGamepadAxes = set of TSdlBasicGamepadAxis\n</code></pre> <p>Base type: <code>TSdlBasicGamepadAxis</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/","title":"TSdlGamepadAxis","text":"<p>The list of axes available on a gamepad</p> <p>Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to SDL_JOYSTICK_AXIS_MAX, and are centered within ~8000 of zero, though advanced UI will allow users to set or autodetect the dead zone, which varies between gamepads.</p> <p>Trigger axis values range from 0 (released) to SDL_JOYSTICK_AXIS_MAX (fully pressed) when reported by TSdlGamepad.Axis. Note that this is not the same range that will be reported by the lower-level TSdlJoystick.Axis. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlGamepadAxis = (Invalid, LeftX, LeftY, RightX, RightY, LeftTrigger, RightTrigger)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#invalid-sdl_gamepad_axis_invalid","title":"<code>Invalid = SDL_GAMEPAD_AXIS_INVALID</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#leftx-sdl_gamepad_axis_leftx","title":"<code>LeftX = SDL_GAMEPAD_AXIS_LEFTX</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#lefty-sdl_gamepad_axis_lefty","title":"<code>LeftY = SDL_GAMEPAD_AXIS_LEFTY</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#rightx-sdl_gamepad_axis_rightx","title":"<code>RightX = SDL_GAMEPAD_AXIS_RIGHTX</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#righty-sdl_gamepad_axis_righty","title":"<code>RightY = SDL_GAMEPAD_AXIS_RIGHTY</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#lefttrigger-sdl_gamepad_axis_left_trigger","title":"<code>LeftTrigger = SDL_GAMEPAD_AXIS_LEFT_TRIGGER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#righttrigger-sdl_gamepad_axis_right_trigger","title":"<code>RightTrigger = SDL_GAMEPAD_AXIS_RIGHT_TRIGGER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#methods","title":"Methods","text":"Name Description FromString Convert a string into a TSdlGamepadAxis enum. ToString Convert the enum to a string."},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#FromString","title":"FromString(String)","text":"<p>Convert a string into a TSdlGamepadAxis enum.</p> <p>This method is called internally to translate SDL gamepad mapping strings for the underlying joystick device into the consistent SDL gamepad mapping. You do not normally need to call this method unless you are parsing SDL gamepad mappings in your own code.</p> <p>Note specially that \"righttrigger\" and \"lefttrigger\" map to <code>TSdlGamepadAxis.RightTrigger</code> and <code>TSdlGamepadAxis.LeftTrigger</code>, respectively. </p> <p><code>class function FromString(const AStr: String): TSdlGamepadAxis; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#parameters","title":"Parameters","text":"<p><code>AStr</code>: <code>String</code> : String representing a SDL gamepad axis.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#returns","title":"Returns","text":"<p><code>TSdlGamepadAxis</code>: The TSdlGamepadAxis enum corresponding to the input string, or <code>Invalid</code> if no match was found.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#see-also","title":"See Also","text":"<ul> <li>ToString</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#ToString","title":"ToString","text":"<p>Convert the enum to a string. </p> <p><code>function ToString: String; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#returns_1","title":"Returns","text":"<p><code>String</code>: A string for the axis, or an empty string if an invalid axis is specified. The string returned is of the format used by SDL gamepad mapping strings.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadAxis/#see-also_1","title":"See Also","text":"<ul> <li>FromString</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadBindingType/","title":"TSdlGamepadBindingType","text":"<p>Types of gamepad control bindings.</p> <p>A gamepad is a collection of bindings that map arbitrary joystick buttons, axes and hat switches to specific positions on a generic console-style gamepad. This enum is used as part of TSdlGamepadBinding to specify those mappings. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadBindingType/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlGamepadBindingType = (None, Button, Axis, Hat)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadBindingType/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadBindingType/#none-sdl_gamepad_bindtype_none","title":"<code>None = SDL_GAMEPAD_BINDTYPE_NONE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadBindingType/#button-sdl_gamepad_bindtype_button","title":"<code>Button = SDL_GAMEPAD_BINDTYPE_BUTTON</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadBindingType/#axis-sdl_gamepad_bindtype_axis","title":"<code>Axis = SDL_GAMEPAD_BINDTYPE_AXIS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadBindingType/#hat-sdl_gamepad_bindtype_hat","title":"<code>Hat = SDL_GAMEPAD_BINDTYPE_HAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/","title":"TSdlGamepadButton","text":"<p>The list of buttons available on a gamepad</p> <p>For controllers that use a diamond pattern for the face buttons, the south/east/west/north buttons below correspond to the locations in the diamond pattern. For Xbox controllers, this would be A/B/X/Y, for Nintendo Switch controllers, this would be B/A/Y/X, for PlayStation controllers this would be Cross/Circle/Square/Triangle.</p> <p>For controllers that don't use a diamond pattern for the face buttons, the south/east/west/north buttons indicate the buttons labeled A, B, C, D, or 1, 2, 3, 4, or for controllers that aren't labeled, they are the primary, secondary, etc. buttons.</p> <p>The activate action is often the south button and the cancel action is often the east button, but in some regions this is reversed, so your game should allow remapping actions based on user preferences.</p> <p>You can query the labels for the face buttons using TSdlGamepad.ButtonLabel. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlGamepadButton = (Invalid, South, East, West, North, Back, Guide, Start, LeftStick, RightStick, LeftShoulder, RightSoulder, DPadUp, DPadDown, DPadLeft...)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#invalid-sdl_gamepad_button_invalid","title":"<code>Invalid = SDL_GAMEPAD_BUTTON_INVALID</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#south-sdl_gamepad_button_south","title":"<code>South = SDL_GAMEPAD_BUTTON_SOUTH</code>","text":"<p>Bottom face button (e.g. Xbox A button)</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#east-sdl_gamepad_button_east","title":"<code>East = SDL_GAMEPAD_BUTTON_EAST</code>","text":"<p>Right face button (e.g. Xbox B button)</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#west-sdl_gamepad_button_west","title":"<code>West = SDL_GAMEPAD_BUTTON_WEST</code>","text":"<p>Left face button (e.g. Xbox X button)</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#north-sdl_gamepad_button_north","title":"<code>North = SDL_GAMEPAD_BUTTON_NORTH</code>","text":"<p>Top face button (e.g. Xbox Y button)</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#back-sdl_gamepad_button_back","title":"<code>Back = SDL_GAMEPAD_BUTTON_BACK</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#guide-sdl_gamepad_button_guide","title":"<code>Guide = SDL_GAMEPAD_BUTTON_GUIDE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#start-sdl_gamepad_button_start","title":"<code>Start = SDL_GAMEPAD_BUTTON_START</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#leftstick-sdl_gamepad_button_left_stick","title":"<code>LeftStick = SDL_GAMEPAD_BUTTON_LEFT_STICK</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#rightstick-sdl_gamepad_button_right_stick","title":"<code>RightStick = SDL_GAMEPAD_BUTTON_RIGHT_STICK</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#leftshoulder-sdl_gamepad_button_left_shoulder","title":"<code>LeftShoulder = SDL_GAMEPAD_BUTTON_LEFT_SHOULDER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#rightsoulder-sdl_gamepad_button_right_shoulder","title":"<code>RightSoulder = SDL_GAMEPAD_BUTTON_RIGHT_SHOULDER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#dpadup-sdl_gamepad_button_dpad_up","title":"<code>DPadUp = SDL_GAMEPAD_BUTTON_DPAD_UP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#dpaddown-sdl_gamepad_button_dpad_down","title":"<code>DPadDown = SDL_GAMEPAD_BUTTON_DPAD_DOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#dpadleft-sdl_gamepad_button_dpad_left","title":"<code>DPadLeft = SDL_GAMEPAD_BUTTON_DPAD_LEFT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#dpadright-sdl_gamepad_button_dpad_right","title":"<code>DPadRight = SDL_GAMEPAD_BUTTON_DPAD_RIGHT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#misc1-sdl_gamepad_button_misc1","title":"<code>Misc1 = SDL_GAMEPAD_BUTTON_MISC1</code>","text":"<p>Additional button (e.g. Xbox Series X share button, PS5 microphone button, Nintendo Switch Pro capture button, Amazon Luna microphone button, Google Stadia capture button)</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#rightpaddle1-sdl_gamepad_button_right_paddle1","title":"<code>RightPaddle1 = SDL_GAMEPAD_BUTTON_RIGHT_PADDLE1</code>","text":"<p>Upper or primary paddle, under your right hand (e.g. Xbox Elite paddle P1)</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#leftpaddle1-sdl_gamepad_button_left_paddle1","title":"<code>LeftPaddle1 = SDL_GAMEPAD_BUTTON_LEFT_PADDLE1</code>","text":"<p>Upper or primary paddle, under your left hand (e.g. Xbox Elite paddle P3)</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#rightpaddle2-sdl_gamepad_button_right_paddle2","title":"<code>RightPaddle2 = SDL_GAMEPAD_BUTTON_RIGHT_PADDLE2</code>","text":"<p>Lower or secondary paddle, under your right hand (e.g. Xbox Elite paddle P2)</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#leftpaddle2-sdl_gamepad_button_left_paddle2","title":"<code>LeftPaddle2 = SDL_GAMEPAD_BUTTON_LEFT_PADDLE2</code>","text":"<p>Lower or secondary paddle, under your left hand (e.g. Xbox Elite paddle P4)</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#touchpad-sdl_gamepad_button_touchpad","title":"<code>Touchpad = SDL_GAMEPAD_BUTTON_TOUCHPAD</code>","text":"<p>PS4/PS5 touchpad button</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#misc2-sdl_gamepad_button_misc2","title":"<code>Misc2 = SDL_GAMEPAD_BUTTON_MISC2</code>","text":"<p>Additional button</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#misc3-sdl_gamepad_button_misc3","title":"<code>Misc3 = SDL_GAMEPAD_BUTTON_MISC3</code>","text":"<p>Additional button</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#misc4-sdl_gamepad_button_misc4","title":"<code>Misc4 = SDL_GAMEPAD_BUTTON_MISC4</code>","text":"<p>Additional button</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#misc5-sdl_gamepad_button_misc5","title":"<code>Misc5 = SDL_GAMEPAD_BUTTON_MISC5</code>","text":"<p>Additional button</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#misc6-sdl_gamepad_button_misc6","title":"<code>Misc6 = SDL_GAMEPAD_BUTTON_MISC6</code>","text":"<p>Additional button</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#methods","title":"Methods","text":"Name Description FromString Convert a string into a TSdlGamepadButton enum. ToString Convert the enum to a string."},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#FromString","title":"FromString(String)","text":"<p>Convert a string into a TSdlGamepadButton enum.</p> <p>This method is called internally to translate SDL gamepad mapping strings for the underlying joystick device into the consistent SDL gamepad mapping. You do not normally need to call this method unless you are parsing SDL gamepad mappings in your own code. </p> <p><code>class function FromString(const AStr: String): TSdlGamepadButton; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#parameters","title":"Parameters","text":"<p><code>AStr</code>: <code>String</code> : String representing a SDL gamepad button.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#returns","title":"Returns","text":"<p><code>TSdlGamepadButton</code>: The TSdlGamepadButton enum corresponding to the input string, or <code>Invalid</code> if no match was found.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#see-also","title":"See Also","text":"<ul> <li>ToString</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#ToString","title":"ToString","text":"<p>Convert the enum to a string. </p> <p><code>function ToString: String; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#returns_1","title":"Returns","text":"<p><code>String</code>: A string for the given button, or an empty string if an invalid button is specified. The string returned is of the format used by SDL gamepad mapping strings.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButton/#see-also_1","title":"See Also","text":"<ul> <li>FromString</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButtonLabel/","title":"TSdlGamepadButtonLabel","text":"<p>The set of gamepad button labels</p> <p>This isn't a complete set, just the face buttons to make it easy to show button prompts.</p> <p>For a complete set, you should look at the button and gamepad type and have a set of symbols that work well with your art style. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButtonLabel/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlGamepadButtonLabel = (Unknown, A, B, X, Y, Cross, Circle, Square, Triangle)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButtonLabel/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButtonLabel/#unknown-sdl_gamepad_button_label_unknown","title":"<code>Unknown = SDL_GAMEPAD_BUTTON_LABEL_UNKNOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButtonLabel/#a-sdl_gamepad_button_label_a","title":"<code>A = SDL_GAMEPAD_BUTTON_LABEL_A</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButtonLabel/#b-sdl_gamepad_button_label_b","title":"<code>B = SDL_GAMEPAD_BUTTON_LABEL_B</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButtonLabel/#x-sdl_gamepad_button_label_x","title":"<code>X = SDL_GAMEPAD_BUTTON_LABEL_X</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButtonLabel/#y-sdl_gamepad_button_label_y","title":"<code>Y = SDL_GAMEPAD_BUTTON_LABEL_Y</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButtonLabel/#cross-sdl_gamepad_button_label_cross","title":"<code>Cross = SDL_GAMEPAD_BUTTON_LABEL_CROSS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButtonLabel/#circle-sdl_gamepad_button_label_circle","title":"<code>Circle = SDL_GAMEPAD_BUTTON_LABEL_CIRCLE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButtonLabel/#square-sdl_gamepad_button_label_square","title":"<code>Square = SDL_GAMEPAD_BUTTON_LABEL_SQUARE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButtonLabel/#triangle-sdl_gamepad_button_label_triangle","title":"<code>Triangle = SDL_GAMEPAD_BUTTON_LABEL_TRIANGLE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButtons/","title":"TSdlGamepadButtons","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadButtons/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlGamepadButtons = set of TSdlBasicGamepadButton\n</code></pre> <p>Base type: <code>TSdlBasicGamepadButton</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadConnectionState/","title":"TSdlGamepadConnectionState","text":"<p>Possible connection states for a gamepad device.</p> <p>This is used by TSdlGamepad.ConnectionState to report how a device is connected to the system. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadConnectionState/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlGamepadConnectionState = (Invalid, Unknown, Wired, Wireless)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadConnectionState/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadConnectionState/#invalid-sdl_joystick_connection_invalid","title":"<code>Invalid = SDL_JOYSTICK_CONNECTION_INVALID</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadConnectionState/#unknown-sdl_joystick_connection_unknown","title":"<code>Unknown = SDL_JOYSTICK_CONNECTION_UNKNOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadConnectionState/#wired-sdl_joystick_connection_wired","title":"<code>Wired = SDL_JOYSTICK_CONNECTION_WIRED</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadConnectionState/#wireless-sdl_joystick_connection_wireless","title":"<code>Wireless = SDL_JOYSTICK_CONNECTION_WIRELESS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/","title":"TSdlGamepadKind","text":"<p>Standard gamepad types.</p> <p>This type does not necessarily map to first-party controllers from Microsoft/Sony/Nintendo; in many cases, third-party controllers can report as these, either because they were designed for a specific console, or they simply most closely match that console's controllers (does it have A/B/X/Y buttons or X/O/Square/Triangle? Does it have a touchpad? etc). </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlGamepadKind = (Unknown, Standard, XBox360, XBoxOne, PS3, PS4, PS5, SwitchPro, SwitchJoyConLeft, SwitchJoyConRight, SwitchJoyConPair)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#unknown-sdl_gamepad_type_unknown","title":"<code>Unknown = SDL_GAMEPAD_TYPE_UNKNOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#standard-sdl_gamepad_type_standard","title":"<code>Standard = SDL_GAMEPAD_TYPE_STANDARD</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#xbox360-sdl_gamepad_type_xbox360","title":"<code>XBox360 = SDL_GAMEPAD_TYPE_XBOX360</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#xboxone-sdl_gamepad_type_xboxone","title":"<code>XBoxOne = SDL_GAMEPAD_TYPE_XBOXONE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#ps3-sdl_gamepad_type_ps3","title":"<code>PS3 = SDL_GAMEPAD_TYPE_PS3</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#ps4-sdl_gamepad_type_ps4","title":"<code>PS4 = SDL_GAMEPAD_TYPE_PS4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#ps5-sdl_gamepad_type_ps5","title":"<code>PS5 = SDL_GAMEPAD_TYPE_PS5</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#switchpro-sdl_gamepad_type_nintendo_switch_pro","title":"<code>SwitchPro = SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_PRO</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#switchjoyconleft-sdl_gamepad_type_nintendo_switch_joycon_left","title":"<code>SwitchJoyConLeft = SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_LEFT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#switchjoyconright-sdl_gamepad_type_nintendo_switch_joycon_right","title":"<code>SwitchJoyConRight = SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_RIGHT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#switchjoyconpair-sdl_gamepad_type_nintendo_switch_joycon_pair","title":"<code>SwitchJoyConPair = SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_PAIR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#methods","title":"Methods","text":"Name Description FromString Convert a string into a TSdlGamepadKind enum. GetButtonLabel The label of a button on a gamepad. ToString Convert this enum to a string."},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#FromString","title":"FromString(String)","text":"<p>Convert a string into a TSdlGamepadKind enum.</p> <p>This mehtod is called internally to translate SDL gamepad mapping strings for the underlying joystick device into the consistent SDL gamepad mapping. You do not normally need to call this mehtod unless you are parsing SDL gamepad mappings in your own code. </p> <p><code>class function FromString(const AStr: String): TSdlGamepadKind; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#parameters","title":"Parameters","text":"<p><code>AStr</code>: <code>String</code> : String representing a TSdlGamepadKind type.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#returns","title":"Returns","text":"<p><code>TSdlGamepadKind</code>: The TSdlGamepadKind enum corresponding to the input string, or <code>Unknown</code> if no match was found.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#see-also","title":"See Also","text":"<ul> <li>ToString</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#GetButtonLabel","title":"GetButtonLabel(TSdlGamepadButton)","text":"<p>The label of a button on a gamepad. </p> <p><code>function GetButtonLabel(const AButton: TSdlGamepadButton): TSdlGamepadButtonLabel; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#parameters_1","title":"Parameters","text":"<p><code>AButton</code>: <code>TSdlGamepadButton</code> : The button.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#returns_1","title":"Returns","text":"<p><code>TSdlGamepadButtonLabel</code>: The TSdlGamepadButtonLabel enum corresponding to the button label.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#see-also_1","title":"See Also","text":"<ul> <li>TSdlGamepad.GetButtonLabel</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#ToString","title":"ToString","text":"<p>Convert this enum to a string. </p> <p><code>function ToString: String; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#returns_2","title":"Returns","text":"<p><code>String</code>: A string for the given type, or an empty string an invalid type is specified. The string returned is of the format used by SDL gamepad mapping strings.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlGamepadKind/#see-also_2","title":"See Also","text":"<ul> <li>FromString</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlHat/","title":"TSdlHat","text":"<p>Joystick Hat positions </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlHat/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlHat = (Centered, Up, Right, Down, Left, RightUp, RightDown, LeftUp, LeftDown)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlHat/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlHat/#centered-sdl_hat_centered","title":"<code>Centered = SDL_HAT_CENTERED</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlHat/#up-sdl_hat_up","title":"<code>Up = SDL_HAT_UP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlHat/#right-sdl_hat_right","title":"<code>Right = SDL_HAT_RIGHT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlHat/#down-sdl_hat_down","title":"<code>Down = SDL_HAT_DOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlHat/#left-sdl_hat_left","title":"<code>Left = SDL_HAT_LEFT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlHat/#rightup-sdl_hat_rightup","title":"<code>RightUp = SDL_HAT_RIGHTUP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlHat/#rightdown-sdl_hat_rightdown","title":"<code>RightDown = SDL_HAT_RIGHTDOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlHat/#leftup-sdl_hat_leftup","title":"<code>LeftUp = SDL_HAT_LEFTUP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlHat/#leftdown-sdl_hat_leftdown","title":"<code>LeftDown = SDL_HAT_LEFTDOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickConnectionState/","title":"TSdlJoystickConnectionState","text":"<p>Possible connection states for a joystick device.</p> <p>This is used by TSdlJoystick.ConnectionState to report how a device is connected to the system. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickConnectionState/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlJoystickConnectionState = (Invalid, Unknown, Wired, Wireless)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickConnectionState/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickConnectionState/#invalid-sdl_joystick_connection_invalid","title":"<code>Invalid = SDL_JOYSTICK_CONNECTION_INVALID</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickConnectionState/#unknown-sdl_joystick_connection_unknown","title":"<code>Unknown = SDL_JOYSTICK_CONNECTION_UNKNOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickConnectionState/#wired-sdl_joystick_connection_wired","title":"<code>Wired = SDL_JOYSTICK_CONNECTION_WIRED</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickConnectionState/#wireless-sdl_joystick_connection_wireless","title":"<code>Wireless = SDL_JOYSTICK_CONNECTION_WIRELESS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickKind/","title":"TSdlJoystickKind","text":"<p>An enum of some common joystick types.</p> <p>In some cases, SDL can identify a low-level joystick as being a certain type of device, and will report it through TSdlJoystick.Kind.</p> <p>This is by no means a complete list of everything that can be plugged into a computer. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickKind/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlJoystickKind = (Unknown, Gamepad, Wheel, ArcadeStick, FlightStick, DancePad, Guitar, DrumKit, ArcadePad, Throttle)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickKind/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickKind/#unknown-sdl_joystick_type_unknown","title":"<code>Unknown = SDL_JOYSTICK_TYPE_UNKNOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickKind/#gamepad-sdl_joystick_type_gamepad","title":"<code>Gamepad = SDL_JOYSTICK_TYPE_GAMEPAD</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickKind/#wheel-sdl_joystick_type_wheel","title":"<code>Wheel = SDL_JOYSTICK_TYPE_WHEEL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickKind/#arcadestick-sdl_joystick_type_arcade_stick","title":"<code>ArcadeStick = SDL_JOYSTICK_TYPE_ARCADE_STICK</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickKind/#flightstick-sdl_joystick_type_flight_stick","title":"<code>FlightStick = SDL_JOYSTICK_TYPE_FLIGHT_STICK</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickKind/#dancepad-sdl_joystick_type_dance_pad","title":"<code>DancePad = SDL_JOYSTICK_TYPE_DANCE_PAD</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickKind/#guitar-sdl_joystick_type_guitar","title":"<code>Guitar = SDL_JOYSTICK_TYPE_GUITAR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickKind/#drumkit-sdl_joystick_type_drum_kit","title":"<code>DrumKit = SDL_JOYSTICK_TYPE_DRUM_KIT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickKind/#arcadepad-sdl_joystick_type_arcade_pad","title":"<code>ArcadePad = SDL_JOYSTICK_TYPE_ARCADE_PAD</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlJoystickKind/#throttle-sdl_joystick_type_throttle","title":"<code>Throttle = SDL_JOYSTICK_TYPE_THROTTLE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMod/","title":"TSdlKeyMod","text":"<p>Valid key modifiers. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMod/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlKeyMod = (LShift, RShift, Level5, LCtrl, RCtrl, LAtl, RAlt, LGui, RGui, Num, Caps, Mode, Scroll)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMod/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMod/#lshift-0","title":"<code>LShift = 0</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMod/#rshift-1","title":"<code>RShift = 1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMod/#level5-2","title":"<code>Level5 = 2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMod/#lctrl-6","title":"<code>LCtrl = 6</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMod/#rctrl-7","title":"<code>RCtrl = 7</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMod/#latl-8","title":"<code>LAtl = 8</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMod/#ralt-9","title":"<code>RAlt = 9</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMod/#lgui-10","title":"<code>LGui = 10</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMod/#rgui-11","title":"<code>RGui = 11</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMod/#num-12","title":"<code>Num = 12</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMod/#caps-13","title":"<code>Caps = 13</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMod/#mode-14","title":"<code>Mode = 14</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMod/#scroll-15","title":"<code>Scroll = 15</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMods/","title":"TSdlKeyMods","text":"<p>A set of valid key modifiers. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeyMods/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlKeyMods = set of TSdlKeyMod\n</code></pre> <p>Base type: <code>TSdlKeyMod</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/","title":"TSdlKeycode","text":"<p>The SDL virtual key representation.</p> <p>Values of this type are used to represent keyboard keys using the current layout of the keyboard. These values include Unicode values representing the unmodified character that would be generated by pressing the key, or an TSdlKeycode.* value for those keys that do not generate characters.</p> <p>A special exception is the number keys at the top of the keyboard which map to TSdlKeycode._0...TSdlKeycode._9 on AZERTY layouts. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlKeycode = (Unknown, Return, Escape, Backspace, Tab, Space, Exclaim, DblApostrophe, Hash, Dollar, Percent, Ampersand, Apostrophe, LeftParen, RightParen...)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#unknown-sdlk_unknown","title":"<code>Unknown = SDLK_UNKNOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#return-sdlk_return","title":"<code>Return = SDLK_RETURN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#escape-sdlk_escape","title":"<code>Escape = SDLK_ESCAPE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#backspace-sdlk_backspace","title":"<code>Backspace = SDLK_BACKSPACE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#tab-sdlk_tab","title":"<code>Tab = SDLK_TAB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#space-sdlk_space","title":"<code>Space = SDLK_SPACE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#exclaim-sdlk_exclaim","title":"<code>Exclaim = SDLK_EXCLAIM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#dblapostrophe-sdlk_dblapostrophe","title":"<code>DblApostrophe = SDLK_DBLAPOSTROPHE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#hash-sdlk_hash","title":"<code>Hash = SDLK_HASH</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#dollar-sdlk_dollar","title":"<code>Dollar = SDLK_DOLLAR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#percent-sdlk_percent","title":"<code>Percent = SDLK_PERCENT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#ampersand-sdlk_ampersand","title":"<code>Ampersand = SDLK_AMPERSAND</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#apostrophe-sdlk_apostrophe","title":"<code>Apostrophe = SDLK_APOSTROPHE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#leftparen-sdlk_leftparen","title":"<code>LeftParen = SDLK_LEFTPAREN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#rightparen-sdlk_rightparen","title":"<code>RightParen = SDLK_RIGHTPAREN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#asterisk-sdlk_asterisk","title":"<code>Asterisk = SDLK_ASTERISK</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#plus-sdlk_plus","title":"<code>Plus = SDLK_PLUS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#comma-sdlk_comma","title":"<code>Comma = SDLK_COMMA</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#minus-sdlk_minus","title":"<code>Minus = SDLK_MINUS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#period-sdlk_period","title":"<code>Period = SDLK_PERIOD</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#slash-sdlk_slash","title":"<code>Slash = SDLK_SLASH</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#_0-sdlk_0","title":"<code>_0 = SDLK_0</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#_1-sdlk_1","title":"<code>_1 = SDLK_1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#_2-sdlk_2","title":"<code>_2 = SDLK_2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#_3-sdlk_3","title":"<code>_3 = SDLK_3</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#_4-sdlk_4","title":"<code>_4 = SDLK_4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#_5-sdlk_5","title":"<code>_5 = SDLK_5</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#_6-sdlk_6","title":"<code>_6 = SDLK_6</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#_7-sdlk_7","title":"<code>_7 = SDLK_7</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#_8-sdlk_8","title":"<code>_8 = SDLK_8</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#_9-sdlk_9","title":"<code>_9 = SDLK_9</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#colon-sdlk_colon","title":"<code>Colon = SDLK_COLON</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#semicolon-sdlk_semicolon","title":"<code>SemiColon = SDLK_SEMICOLON</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#less-sdlk_less","title":"<code>Less = SDLK_LESS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#equals-sdlk_equals","title":"<code>Equals = SDLK_EQUALS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#greater-sdlk_greater","title":"<code>Greater = SDLK_GREATER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#question-sdlk_question","title":"<code>Question = SDLK_QUESTION</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#at-sdlk_at","title":"<code>At = SDLK_AT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#leftbracket-sdlk_leftbracket","title":"<code>LeftBracket = SDLK_LEFTBRACKET</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#backslash-sdlk_backslash","title":"<code>Backslash = SDLK_BACKSLASH</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#rightbracket-sdlk_rightbracket","title":"<code>RightBracket = SDLK_RIGHTBRACKET</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#caret-sdlk_caret","title":"<code>Caret = SDLK_CARET</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#underscore-sdlk_underscore","title":"<code>Underscore = SDLK_UNDERSCORE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#grave-sdlk_grave","title":"<code>Grave = SDLK_GRAVE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#a-sdlk_a","title":"<code>A = SDLK_A</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#b-sdlk_b","title":"<code>B = SDLK_B</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#c-sdlk_c","title":"<code>C = SDLK_C</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#d-sdlk_d","title":"<code>D = SDLK_D</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#e-sdlk_e","title":"<code>E = SDLK_E</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f-sdlk_f","title":"<code>F = SDLK_F</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#g-sdlk_g","title":"<code>G = SDLK_G</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#h-sdlk_h","title":"<code>H = SDLK_H</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#i-sdlk_i","title":"<code>I = SDLK_I</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#j-sdlk_j","title":"<code>J = SDLK_J</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#k-sdlk_k","title":"<code>K = SDLK_K</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#l-sdlk_l","title":"<code>L = SDLK_L</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#m-sdlk_m","title":"<code>M = SDLK_M</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#n-sdlk_n","title":"<code>N = SDLK_N</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#o-sdlk_o","title":"<code>O = SDLK_O</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#p-sdlk_p","title":"<code>P = SDLK_P</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#q-sdlk_q","title":"<code>Q = SDLK_Q</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#r-sdlk_r","title":"<code>R = SDLK_R</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#s-sdlk_s","title":"<code>S = SDLK_S</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#t-sdlk_t","title":"<code>T = SDLK_T</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#u-sdlk_u","title":"<code>U = SDLK_U</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#v-sdlk_v","title":"<code>V = SDLK_V</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#w-sdlk_w","title":"<code>W = SDLK_W</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#x-sdlk_x","title":"<code>X = SDLK_X</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#y-sdlk_y","title":"<code>Y = SDLK_Y</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#z-sdlk_z","title":"<code>Z = SDLK_Z</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#leftbrace-sdlk_leftbrace","title":"<code>LeftBrace = SDLK_LEFTBRACE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#pipe-sdlk_pipe","title":"<code>Pipe = SDLK_PIPE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#rightbrace-sdlk_rightbrace","title":"<code>RightBrace = SDLK_RIGHTBRACE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#tilde-sdlk_tilde","title":"<code>Tilde = SDLK_TILDE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#delete-sdlk_delete","title":"<code>Delete = SDLK_DELETE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#plusminus-sdlk_plusminus","title":"<code>PlusMinus = SDLK_PLUSMINUS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#capslock-sdlk_capslock","title":"<code>CapsLock = SDLK_CAPSLOCK</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f1-sdlk_f1","title":"<code>F1 = SDLK_F1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f2-sdlk_f2","title":"<code>F2 = SDLK_F2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f3-sdlk_f3","title":"<code>F3 = SDLK_F3</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f4-sdlk_f4","title":"<code>F4 = SDLK_F4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f5-sdlk_f5","title":"<code>F5 = SDLK_F5</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f6-sdlk_f6","title":"<code>F6 = SDLK_F6</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f7-sdlk_f7","title":"<code>F7 = SDLK_F7</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f8-sdlk_f8","title":"<code>F8 = SDLK_F8</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f9-sdlk_f9","title":"<code>F9 = SDLK_F9</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f10-sdlk_f10","title":"<code>F10 = SDLK_F10</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f11-sdlk_f11","title":"<code>F11 = SDLK_F11</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f12-sdlk_f12","title":"<code>F12 = SDLK_F12</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#printscreen-sdlk_printscreen","title":"<code>PrintScreen = SDLK_PRINTSCREEN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#scrolllock-sdlk_scrolllock","title":"<code>ScrollLock = SDLK_SCROLLLOCK</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#pause-sdlk_pause","title":"<code>Pause = SDLK_PAUSE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#insert-sdlk_insert","title":"<code>Insert = SDLK_INSERT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#home-sdlk_home","title":"<code>Home = SDLK_HOME</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#pageup-sdlk_pageup","title":"<code>PageUp = SDLK_PAGEUP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#end-sdlk_end","title":"<code>&amp;End = SDLK_END</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#pagedown-sdlk_pagedown","title":"<code>PageDown = SDLK_PAGEDOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#right-sdlk_right","title":"<code>Right = SDLK_RIGHT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#left-sdlk_left","title":"<code>Left = SDLK_LEFT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#down-sdlk_down","title":"<code>Down = SDLK_DOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#up-sdlk_up","title":"<code>Up = SDLK_UP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#numlockclear-sdlk_numlockclear","title":"<code>NumLockClear = SDLK_NUMLOCKCLEAR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpdivide-sdlk_kp_divide","title":"<code>KPDivide = SDLK_KP_DIVIDE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpmultiply-sdlk_kp_multiply","title":"<code>KPMultiply = SDLK_KP_MULTIPLY</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpminus-sdlk_kp_minus","title":"<code>KPMinus = SDLK_KP_MINUS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpplus-sdlk_kp_plus","title":"<code>KPPlus = SDLK_KP_PLUS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpenter-sdlk_kp_enter","title":"<code>KPEnter = SDLK_KP_ENTER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kp1-sdlk_kp_1","title":"<code>KP1 = SDLK_KP_1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kp2-sdlk_kp_2","title":"<code>KP2 = SDLK_KP_2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kp3-sdlk_kp_3","title":"<code>KP3 = SDLK_KP_3</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kp4-sdlk_kp_4","title":"<code>KP4 = SDLK_KP_4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kp5-sdlk_kp_5","title":"<code>KP5 = SDLK_KP_5</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kp6-sdlk_kp_6","title":"<code>KP6 = SDLK_KP_6</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kp7-sdlk_kp_7","title":"<code>KP7 = SDLK_KP_7</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kp8-sdlk_kp_8","title":"<code>KP8 = SDLK_KP_8</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kp9-sdlk_kp_9","title":"<code>KP9 = SDLK_KP_9</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kp0-sdlk_kp_0","title":"<code>KP0 = SDLK_KP_0</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpperiod-sdlk_kp_period","title":"<code>KPPeriod = SDLK_KP_PERIOD</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#application-sdlk_application","title":"<code>Application = SDLK_APPLICATION</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#power-sdlk_power","title":"<code>Power = SDLK_POWER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpequals-sdlk_kp_equals","title":"<code>KPEquals = SDLK_KP_EQUALS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f13-sdlk_f13","title":"<code>F13 = SDLK_F13</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f14-sdlk_f14","title":"<code>F14 = SDLK_F14</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f15-sdlk_f15","title":"<code>F15 = SDLK_F15</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f16-sdlk_f16","title":"<code>F16 = SDLK_F16</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f17-sdlk_f17","title":"<code>F17 = SDLK_F17</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f18-sdlk_f18","title":"<code>F18 = SDLK_F18</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f19-sdlk_f19","title":"<code>F19 = SDLK_F19</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f20-sdlk_f20","title":"<code>F20 = SDLK_F20</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f21-sdlk_f21","title":"<code>F21 = SDLK_F21</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f22-sdlk_f22","title":"<code>F22 = SDLK_F22</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f23-sdlk_f23","title":"<code>F23 = SDLK_F23</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#f24-sdlk_f24","title":"<code>F24 = SDLK_F24</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#execute-sdlk_execute","title":"<code>Execute = SDLK_EXECUTE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#help-sdlk_help","title":"<code>Help = SDLK_HELP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#menu-sdlk_menu","title":"<code>Menu = SDLK_MENU</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#select-sdlk_select","title":"<code>Select = SDLK_SELECT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#stop-sdlk_stop","title":"<code>Stop = SDLK_STOP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#again-sdlk_again","title":"<code>Again = SDLK_AGAIN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#undo-sdlk_undo","title":"<code>Undo = SDLK_UNDO</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#cut-sdlk_cut","title":"<code>Cut = SDLK_CUT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#copy-sdlk_copy","title":"<code>Copy = SDLK_COPY</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#paste-sdlk_paste","title":"<code>Paste = SDLK_PASTE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#find-sdlk_find","title":"<code>Find = SDLK_FIND</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#mute-sdlk_mute","title":"<code>Mute = SDLK_MUTE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#volumeup-sdlk_volumeup","title":"<code>VolumeUp = SDLK_VOLUMEUP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#volumedown-sdlk_volumedown","title":"<code>VolumeDown = SDLK_VOLUMEDOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpcomma-sdlk_kp_comma","title":"<code>KPComma = SDLK_KP_COMMA</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpequalsas400-sdlk_kp_equalsas400","title":"<code>KPEqualsAS400 = SDLK_KP_EQUALSAS400</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#alterase-sdlk_alterase","title":"<code>AltErase = SDLK_ALTERASE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#sysreq-sdlk_sysreq","title":"<code>SysReq = SDLK_SYSREQ</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#cancel-sdlk_cancel","title":"<code>Cancel = SDLK_CANCEL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#clear-sdlk_clear","title":"<code>Clear = SDLK_CLEAR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#prior-sdlk_prior","title":"<code>Prior = SDLK_PRIOR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#return2-sdlk_return2","title":"<code>Return2 = SDLK_RETURN2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#separator-sdlk_separator","title":"<code>Separator = SDLK_SEPARATOR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#out-sdlk_out","title":"<code>&amp;Out = SDLK_OUT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#oper-sdlk_oper","title":"<code>Oper = SDLK_OPER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#clearagain-sdlk_clearagain","title":"<code>ClearAgain = SDLK_CLEARAGAIN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#crsel-sdlk_crsel","title":"<code>CRSel = SDLK_CRSEL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#exsel-sdlk_exsel","title":"<code>EXSel = SDLK_EXSEL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kp00-sdlk_kp_00","title":"<code>KP00 = SDLK_KP_00</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kp000-sdlk_kp_000","title":"<code>KP000 = SDLK_KP_000</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#thousandsseparator-sdlk_thousandsseparator","title":"<code>ThousandsSeparator = SDLK_THOUSANDSSEPARATOR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#decimalseparator-sdlk_decimalseparator","title":"<code>DecimalSeparator = SDLK_DECIMALSEPARATOR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#currencyunit-sdlk_currencyunit","title":"<code>CurrencyUnit = SDLK_CURRENCYUNIT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#currencysubunit-sdlk_currencysubunit","title":"<code>CurrencySubUnit = SDLK_CURRENCYSUBUNIT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpleftparen-sdlk_kp_leftparen","title":"<code>KPLeftParen = SDLK_KP_LEFTPAREN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kprightparen-sdlk_kp_rightparen","title":"<code>KPRightParen = SDLK_KP_RIGHTPAREN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpleftbrace-sdlk_kp_leftbrace","title":"<code>KPLeftBrace = SDLK_KP_LEFTBRACE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kprightbrace-sdlk_kp_rightbrace","title":"<code>KPRightBrace = SDLK_KP_RIGHTBRACE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kptab-sdlk_kp_tab","title":"<code>KPTab = SDLK_KP_TAB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpbackspace-sdlk_kp_backspace","title":"<code>KPBackspace = SDLK_KP_BACKSPACE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpa-sdlk_kp_a","title":"<code>KPA = SDLK_KP_A</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpb-sdlk_kp_b","title":"<code>KPB = SDLK_KP_B</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpc-sdlk_kp_c","title":"<code>KPC = SDLK_KP_C</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpd-sdlk_kp_d","title":"<code>KPD = SDLK_KP_D</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpe-sdlk_kp_e","title":"<code>KPE = SDLK_KP_E</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpf-sdlk_kp_f","title":"<code>KPF = SDLK_KP_F</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpxor-sdlk_kp_xor","title":"<code>KPXor = SDLK_KP_XOR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kppower-sdlk_kp_power","title":"<code>KPPower = SDLK_KP_POWER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kppercent-sdlk_kp_percent","title":"<code>KPPercent = SDLK_KP_PERCENT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpless-sdlk_kp_less","title":"<code>KPLess = SDLK_KP_LESS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpgreater-sdlk_kp_greater","title":"<code>KPGreater = SDLK_KP_GREATER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpampersand-sdlk_kp_ampersand","title":"<code>KPAmpersand = SDLK_KP_AMPERSAND</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpdblampersand-sdlk_kp_dblampersand","title":"<code>KPDblAmpersand = SDLK_KP_DBLAMPERSAND</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpverticalbar-sdlk_kp_verticalbar","title":"<code>KPVerticalBar = SDLK_KP_VERTICALBAR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpdblverticalbar-sdlk_kp_dblverticalbar","title":"<code>KPDblVerticalBar = SDLK_KP_DBLVERTICALBAR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpcolon-sdlk_kp_colon","title":"<code>KPColon = SDLK_KP_COLON</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kphash-sdlk_kp_hash","title":"<code>KPHash = SDLK_KP_HASH</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpspace-sdlk_kp_space","title":"<code>KPSpace = SDLK_KP_SPACE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpat-sdlk_kp_at","title":"<code>KPAt = SDLK_KP_AT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpexclam-sdlk_kp_exclam","title":"<code>KPExclam = SDLK_KP_EXCLAM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpmemstore-sdlk_kp_memstore","title":"<code>KPMemStore = SDLK_KP_MEMSTORE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpmemrecall-sdlk_kp_memrecall","title":"<code>KPMemRecall = SDLK_KP_MEMRECALL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpmemclear-sdlk_kp_memclear","title":"<code>KPMemClear = SDLK_KP_MEMCLEAR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpmemadd-sdlk_kp_memadd","title":"<code>KPMemAdd = SDLK_KP_MEMADD</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpmemsubtract-sdlk_kp_memsubtract","title":"<code>KPMemSubtract = SDLK_KP_MEMSUBTRACT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpmemmultiply-sdlk_kp_memmultiply","title":"<code>KPMemMultiply = SDLK_KP_MEMMULTIPLY</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpmemdivide-sdlk_kp_memdivide","title":"<code>KPMemDivide = SDLK_KP_MEMDIVIDE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpplusminus-sdlk_kp_plusminus","title":"<code>KPPlusMinus = SDLK_KP_PLUSMINUS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpclear-sdlk_kp_clear","title":"<code>KPClear = SDLK_KP_CLEAR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpclearentry-sdlk_kp_clearentry","title":"<code>KPClearEntry = SDLK_KP_CLEARENTRY</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kpbinary-sdlk_kp_binary","title":"<code>KPBinary = SDLK_KP_BINARY</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kp_octal-sdlk_kp_octal","title":"<code>KP_OCTAL = SDLK_KP_OCTAL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kp_decimal-sdlk_kp_decimal","title":"<code>KP_DECIMAL = SDLK_KP_DECIMAL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#kp_hexadecimal-sdlk_kp_hexadecimal","title":"<code>KP_HEXADECIMAL = SDLK_KP_HEXADECIMAL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#lctrl-sdlk_lctrl","title":"<code>LCtrl = SDLK_LCTRL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#lshift-sdlk_lshift","title":"<code>LShift = SDLK_LSHIFT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#lalt-sdlk_lalt","title":"<code>LAlt = SDLK_LALT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#lgui-sdlk_lgui","title":"<code>LGui = SDLK_LGUI</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#rctrl-sdlk_rctrl","title":"<code>RCtrl = SDLK_RCTRL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#rshift-sdlk_rshift","title":"<code>RShift = SDLK_RSHIFT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#ralt-sdlk_ralt","title":"<code>RAlt = SDLK_RALT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#rgui-sdlk_rgui","title":"<code>RGui = SDLK_RGUI</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#mode-sdlk_mode","title":"<code>Mode = SDLK_MODE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#sleep-sdlk_sleep","title":"<code>Sleep = SDLK_SLEEP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#wake-sdlk_wake","title":"<code>Wake = SDLK_WAKE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#channelincremenet-sdlk_channel_increment","title":"<code>ChannelIncremenet = SDLK_CHANNEL_INCREMENT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#channeldecremenet-sdlk_channel_decrement","title":"<code>ChannelDecremenet = SDLK_CHANNEL_DECREMENT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#mediaplay-sdlk_media_play","title":"<code>MediaPlay = SDLK_MEDIA_PLAY</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#mediapause-sdlk_media_pause","title":"<code>MediaPause = SDLK_MEDIA_PAUSE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#mediarecord-sdlk_media_record","title":"<code>MediaRecord = SDLK_MEDIA_RECORD</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#mediafastforward-sdlk_media_fast_forward","title":"<code>MediaFastForward = SDLK_MEDIA_FAST_FORWARD</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#mediarewind-sdlk_media_rewind","title":"<code>MediaRewind = SDLK_MEDIA_REWIND</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#medianexttrack-sdlk_media_next_track","title":"<code>MediaNextTrack = SDLK_MEDIA_NEXT_TRACK</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#mediaprevioustrack-sdlk_media_previous_track","title":"<code>MediaPreviousTrack = SDLK_MEDIA_PREVIOUS_TRACK</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#mediastop-sdlk_media_stop","title":"<code>MediaStop = SDLK_MEDIA_STOP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#mediaeject-sdlk_media_eject","title":"<code>MediaEject = SDLK_MEDIA_EJECT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#mediaplaypause-sdlk_media_play_pause","title":"<code>MediaPlayPause = SDLK_MEDIA_PLAY_PAUSE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#mediaselect-sdlk_media_select","title":"<code>MediaSelect = SDLK_MEDIA_SELECT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#acnew-sdlk_ac_new","title":"<code>ACNew = SDLK_AC_NEW</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#acopen-sdlk_ac_open","title":"<code>ACOpen = SDLK_AC_OPEN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#acclose-sdlk_ac_close","title":"<code>ACClose = SDLK_AC_CLOSE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#acexit-sdlk_ac_exit","title":"<code>ACExit = SDLK_AC_EXIT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#acsave-sdlk_ac_save","title":"<code>ACSave = SDLK_AC_SAVE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#acprint-sdlk_ac_print","title":"<code>ACPrint = SDLK_AC_PRINT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#acproperties-sdlk_ac_properties","title":"<code>ACProperties = SDLK_AC_PROPERTIES</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#acsearch-sdlk_ac_search","title":"<code>ACSearch = SDLK_AC_SEARCH</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#achome-sdlk_ac_home","title":"<code>ACHome = SDLK_AC_HOME</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#acback-sdlk_ac_back","title":"<code>ACBack = SDLK_AC_BACK</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#acforward-sdlk_ac_forward","title":"<code>ACForward = SDLK_AC_FORWARD</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#acstop-sdlk_ac_stop","title":"<code>ACStop = SDLK_AC_STOP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#acrefresh-sdlk_ac_refresh","title":"<code>ACRefresh = SDLK_AC_REFRESH</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#acbookmarks-sdlk_ac_bookmarks","title":"<code>ACBookmarks = SDLK_AC_BOOKMARKS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#softleft-sdlk_softleft","title":"<code>SoftLeft = SDLK_SOFTLEFT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#softright-sdlk_softright","title":"<code>SoftRight = SDLK_SOFTRIGHT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#call-sdlk_call","title":"<code>Call = SDLK_CALL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#endcall-sdlk_endcall","title":"<code>EndCall = SDLK_ENDCALL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#lefttab-sdlk_left_tab","title":"<code>LeftTab = SDLK_LEFT_TAB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#level5shift-sdlk_level5_shift","title":"<code>Level5Shift = SDLK_LEVEL5_SHIFT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#multikeycompose-sdlk_multi_key_compose","title":"<code>MultiKeyCompose = SDLK_MULTI_KEY_COMPOSE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#lmeta-sdlk_lmeta","title":"<code>LMeta = SDLK_LMETA</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#rmeta-sdlk_rmeta","title":"<code>RMeta = SDLK_RMETA</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#lhyper-sdlk_lhyper","title":"<code>LHyper = SDLK_LHYPER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#rhyper-sdlk_rhyper","title":"<code>RHyper = SDLK_RHYPER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#properties","title":"Properties","text":"Name Description Name A human-readable name for the key."},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#methods","title":"Methods","text":"Name Description FromName Get a keycode from a human-readable name. FromScancode(TSdlScancode) Creates a TSdlKeycode from a TSdlScancode. FromScancode(TSdlScancode, TSdlKeymods, Boolean) Get the key code corresponding to the given scancode according to the current keyboard layout. ToScancode Get the scancode corresponding to this key code according to the current keyboard layout. ToScancode(TSdlKeyMods) Get the scancode corresponding to this key code according to the current keyboard layout."},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#Name","title":"Name","text":"<p>A human-readable name for the key.</p> <p>If the key doesn't have a name, this property returns an empty string.</p> <p>Letters will be presented in their uppercase form, if applicable. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#see-also","title":"See Also","text":"<ul> <li>FromName</li> <li>FromScancode</li> <li>TSdlScancode.FromKeycode</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#remarks","title":"Remarks","text":"<p>This property is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#FromName","title":"FromName(String)","text":"<p>Get a keycode from a human-readable name. </p> <p><code>class function FromName(const AName: String): TSdlKeycode; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#parameters","title":"Parameters","text":"<p><code>AName</code>: <code>String</code> : The human-readable key name.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#returns","title":"Returns","text":"<p><code>TSdlKeycode</code>: The keycode, or <code>TSdlKeycode.Unknown</code> if the name wasn't recognized.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#see-also_1","title":"See Also","text":"<ul> <li>FromScancode</li> <li>Name</li> <li>TSdlScancode.FromName</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#remarks_1","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#FromScancode_0","title":"FromScancode(TSdlScancode)","text":"<p>Creates a TSdlKeycode from a TSdlScancode. </p> <p><code>class function FromScancode(const AScancode: TSdlScancode): TSdlKeycode; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#parameters_1","title":"Parameters","text":"<p><code>AScancode</code>: <code>TSdlScancode</code> : The scan code to convert.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#returns_1","title":"Returns","text":"<p><code>TSdlKeycode</code>: The keycode for this scancode.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#FromScancode_1","title":"FromScancode(TSdlScancode, TSdlKeymods, Boolean)","text":"<p>Get the key code corresponding to the given scancode according to the current keyboard layout.</p> <p>If you want to get the keycode as it would be delivered in key events, including options specified in TSdlHints.KeycodeOptions, then you should pass <code>AKeyEvent</code> as True. Otherwise this function simply translates the scancode based on the given modifier state. </p> <p><code>class function FromScancode(const AScancode: TSdlScancode; const AModState: TSdlKeymods; const AKeyEvent: Boolean): TSdlKeycode; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#parameters_2","title":"Parameters","text":"<p><code>AScancode</code>: <code>TSdlScancode</code> : The desired scancode to query.</p> <p><code>AModState</code>: <code>TSdlKeymods</code> : The modifier state to use when translating the scancode to a keycode.</p> <p><code>AKeyEvent</code>: <code>Boolean</code> : True if the keycode will be used in key events.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#returns_2","title":"Returns","text":"<p><code>TSdlKeycode</code>: The keycode that corresponds to the given scancode.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#see-also_2","title":"See Also","text":"<ul> <li>Name</li> <li>TSdlScancode.FromKeycode</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#remarks_2","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#ToScancode_0","title":"ToScancode","text":"<p>Get the scancode corresponding to this key code according to the current keyboard layout. </p> <p><code>function ToScancode: TSdlScancode; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#returns_3","title":"Returns","text":"<p><code>TSdlScancode</code>: The scancode that corresponds to the given keycode.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#see-also_3","title":"See Also","text":"<ul> <li>FromScancode</li> <li>TSdlScancode.Name</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#remarks_3","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#ToScancode_1","title":"ToScancode(TSdlKeyMods)","text":"<p>Get the scancode corresponding to this key code according to the current keyboard layout.</p> <p>Note that there may be multiple scancode+modifier states that can generate this keycode, this will just return the first one found. </p> <p><code>function ToScancode(const AModState: TSdlKeyMods): TSdlScancode; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#parameters_3","title":"Parameters","text":"<p><code>AModState</code>: <code>TSdlKeyMods</code> : The modifier state that would be used when the scancode generates this key.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#returns_4","title":"Returns","text":"<p><code>TSdlScancode</code>: The scancode that corresponds to the given keycode.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#see-also_4","title":"See Also","text":"<ul> <li>FromScancode</li> <li>TSdlScancode.Name</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlKeycode/#remarks_4","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlMouseButton/","title":"TSdlMouseButton","text":"<p>Pressed mouse buttons, as reported by TSdlMouse.GetPressedButtons, etc.</p> <ul> <li>Button 0: Left mouse button</li> <li>Button 1: Middle mouse button</li> <li>Button 2: Right mouse button</li> <li>Button 3: Side mouse button 1</li> <li>Button 4: Side mouse button 2 </li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlMouseButton/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlMouseButton = (Left, Middle, Right, X1, X2)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlMouseButton/#see-also","title":"See Also","text":"<ul> <li>TSdlMouse.GetState</li> <li>TSdlMouse.GetGlobalState</li> <li>TSdlMouse.GetRelativeState</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlMouseButton/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlMouseButton/#left-sdl_button_left-1","title":"<code>Left = SDL_BUTTON_LEFT - 1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlMouseButton/#middle-sdl_button_middle-1","title":"<code>Middle = SDL_BUTTON_MIDDLE - 1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlMouseButton/#right-sdl_button_right-1","title":"<code>Right = SDL_BUTTON_RIGHT - 1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlMouseButton/#x1-sdl_button_x1-1","title":"<code>X1 = SDL_BUTTON_X1 - 1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlMouseButton/#x2-sdl_button_x2-1","title":"<code>X2 = SDL_BUTTON_X2 - 1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlMouseButtons/","title":"TSdlMouseButtons","text":"<p>A set of mouse buttons. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlMouseButtons/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlMouseButtons = set of TSdlMouseButton\n</code></pre> <p>Base type: <code>TSdlMouseButton</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlMouseWheelDirection/","title":"TSdlMouseWheelDirection","text":"<p>Scroll direction types for the Scroll event </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlMouseWheelDirection/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlMouseWheelDirection = (Normal, Flipped)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlMouseWheelDirection/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlMouseWheelDirection/#normal-sdl_mousewheel_normal","title":"<code>Normal = SDL_MOUSEWHEEL_NORMAL</code>","text":"<p>The scroll direction is normal</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlMouseWheelDirection/#flipped-sdl_mousewheel_flipped","title":"<code>Flipped = SDL_MOUSEWHEEL_FLIPPED</code>","text":"<p>The scroll direction is flipped / natural</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenAxis/","title":"TSdlPenAxis","text":"<p>Pen axis indices.</p> <p>These are the valid values for the <code>Axis</code> field in TSdlPenAxisEvent. All axes are either normalised to 0..1 or report a (positive or negative) angle in degrees, with 0.0 representing the centre. Not all pens/backends support all axes: unsupported axes are always zero.</p> <p>To convert angles for tilt and rotation into vector representation, use Sin on the XTilt, YTilt, or Rotation component, for example:</p> <p><code>Sin(XTilt * PI / 180)</code>. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenAxis/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlPenAxis = (Presssure, XTilt, YTilt, Distance, Rotation, Slider, TangentialPressure)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenAxis/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenAxis/#presssure-sdl_pen_axis_pressure","title":"<code>Presssure = SDL_PEN_AXIS_PRESSURE</code>","text":"<p>Pen pressure. Unidirectional: 0 to 1.0</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenAxis/#xtilt-sdl_pen_axis_xtilt","title":"<code>XTilt = SDL_PEN_AXIS_XTILT</code>","text":"<p>Pen horizontal tilt angle. Bidirectional: -90.0 to 90.0 (left-to-right).</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenAxis/#ytilt-sdl_pen_axis_ytilt","title":"<code>YTilt = SDL_PEN_AXIS_YTILT</code>","text":"<p>Pen vertical tilt angle. Bidirectional: -90.0 to 90.0 (top-to-down).</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenAxis/#distance-sdl_pen_axis_distance","title":"<code>Distance = SDL_PEN_AXIS_DISTANCE</code>","text":"<p>Pen distance to drawing surface. Unidirectional: 0.0 to 1.0</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenAxis/#rotation-sdl_pen_axis_rotation","title":"<code>Rotation = SDL_PEN_AXIS_ROTATION</code>","text":"<p>Pen barrel rotation. Bidirectional: -180 to 179.9 (clockwise, 0 is facing up, -180.0 is facing down).</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenAxis/#slider-sdl_pen_axis_slider","title":"<code>Slider = SDL_PEN_AXIS_SLIDER</code>","text":"<p>Pen finger wheel or slider (e.g., Airbrush Pen). Unidirectional: 0 to 1.0</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenAxis/#tangentialpressure-sdl_pen_axis_tangential_pressure","title":"<code>TangentialPressure = SDL_PEN_AXIS_TANGENTIAL_PRESSURE</code>","text":"<p>Pressure from squeezing the pen (\"barrel pressure\").</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenID/","title":"TSdlPenID","text":"<p>SDL pen instance IDs.</p> <p>Zero is used to signify an invalid/null device.</p> <p>These show up in pen events when SDL sees input from them. They remain consistent as long as SDL can recognize a tool to be the same pen; but if a pen physically leaves the area and returns, it might get a new ID. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenID/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlPenID = SDL_PenID\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenInputFlag/","title":"TSdlPenInputFlag","text":"<p>Pen input flag, as reported by various pen events' <code>PenState</code> field. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenInputFlag/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlPenInputFlag = (Down, Button1, Button2, Button3, Button4, Button5, EraserTip)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenInputFlag/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenInputFlag/#down-0","title":"<code>Down = 0</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenInputFlag/#button1-1","title":"<code>Button1 = 1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenInputFlag/#button2-2","title":"<code>Button2 = 2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenInputFlag/#button3-3","title":"<code>Button3 = 3</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenInputFlag/#button4-4","title":"<code>Button4 = 4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenInputFlag/#button5-5","title":"<code>Button5 = 5</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenInputFlag/#erasertip-30","title":"<code>EraserTip = 30</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenInputFlags/","title":"TSdlPenInputFlags","text":"<p>Set of pen input flags. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlPenInputFlags/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlPenInputFlags = set of TSdlPenInputFlag\n</code></pre> <p>Base type: <code>TSdlPenInputFlag</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/","title":"TSdlScancode","text":"<p>The SDL keyboard scancode representation.</p> <p>An SDL scancode is the physical representation of a key on the keyboard, independent of language and keyboard mapping.</p> <p>Values of this type are used to represent keyboard keys, among other places in the <code>Scancode</code> property of TSdlKeyboardEvent.</p> <p>The values in this enumeration are based on the  USB usage page standard. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlScancode = (Unknown, A, B, C, D, E, F, G, H, I, J, K, L, M, N...)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#unknown-sdl_scancode_unknown","title":"<code>Unknown = SDL_SCANCODE_UNKNOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#a-sdl_scancode_a","title":"<code>A = SDL_SCANCODE_A</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#b-sdl_scancode_b","title":"<code>B = SDL_SCANCODE_B</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#c-sdl_scancode_c","title":"<code>C = SDL_SCANCODE_C</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#d-sdl_scancode_d","title":"<code>D = SDL_SCANCODE_D</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#e-sdl_scancode_e","title":"<code>E = SDL_SCANCODE_E</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f-sdl_scancode_f","title":"<code>F = SDL_SCANCODE_F</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#g-sdl_scancode_g","title":"<code>G = SDL_SCANCODE_G</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#h-sdl_scancode_h","title":"<code>H = SDL_SCANCODE_H</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#i-sdl_scancode_i","title":"<code>I = SDL_SCANCODE_I</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#j-sdl_scancode_j","title":"<code>J = SDL_SCANCODE_J</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#k-sdl_scancode_k","title":"<code>K = SDL_SCANCODE_K</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#l-sdl_scancode_l","title":"<code>L = SDL_SCANCODE_L</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#m-sdl_scancode_m","title":"<code>M = SDL_SCANCODE_M</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#n-sdl_scancode_n","title":"<code>N = SDL_SCANCODE_N</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#o-sdl_scancode_o","title":"<code>O = SDL_SCANCODE_O</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#p-sdl_scancode_p","title":"<code>P = SDL_SCANCODE_P</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#q-sdl_scancode_q","title":"<code>Q = SDL_SCANCODE_Q</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#r-sdl_scancode_r","title":"<code>R = SDL_SCANCODE_R</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#s-sdl_scancode_s","title":"<code>S = SDL_SCANCODE_S</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#t-sdl_scancode_t","title":"<code>T = SDL_SCANCODE_T</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#u-sdl_scancode_u","title":"<code>U = SDL_SCANCODE_U</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#v-sdl_scancode_v","title":"<code>V = SDL_SCANCODE_V</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#w-sdl_scancode_w","title":"<code>W = SDL_SCANCODE_W</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#x-sdl_scancode_x","title":"<code>X = SDL_SCANCODE_X</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#y-sdl_scancode_y","title":"<code>Y = SDL_SCANCODE_Y</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#z-sdl_scancode_z","title":"<code>Z = SDL_SCANCODE_Z</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#_1-sdl_scancode_1","title":"<code>_1 = SDL_SCANCODE_1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#_2-sdl_scancode_2","title":"<code>_2 = SDL_SCANCODE_2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#_3-sdl_scancode_3","title":"<code>_3 = SDL_SCANCODE_3</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#_4-sdl_scancode_4","title":"<code>_4 = SDL_SCANCODE_4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#_5-sdl_scancode_5","title":"<code>_5 = SDL_SCANCODE_5</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#_6-sdl_scancode_6","title":"<code>_6 = SDL_SCANCODE_6</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#_7-sdl_scancode_7","title":"<code>_7 = SDL_SCANCODE_7</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#_8-sdl_scancode_8","title":"<code>_8 = SDL_SCANCODE_8</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#_9-sdl_scancode_9","title":"<code>_9 = SDL_SCANCODE_9</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#_0-sdl_scancode_0","title":"<code>_0 = SDL_SCANCODE_0</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#return-sdl_scancode_return","title":"<code>Return = SDL_SCANCODE_RETURN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#escape-sdl_scancode_escape","title":"<code>Escape = SDL_SCANCODE_ESCAPE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#backspace-sdl_scancode_backspace","title":"<code>Backspace = SDL_SCANCODE_BACKSPACE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#tab-sdl_scancode_tab","title":"<code>Tab = SDL_SCANCODE_TAB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#space-sdl_scancode_space","title":"<code>Space = SDL_SCANCODE_SPACE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#minus-sdl_scancode_minus","title":"<code>Minus = SDL_SCANCODE_MINUS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#equals-sdl_scancode_equals","title":"<code>Equals = SDL_SCANCODE_EQUALS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#leftbracket-sdl_scancode_leftbracket","title":"<code>LeftBracket = SDL_SCANCODE_LEFTBRACKET</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#rightbracket-sdl_scancode_rightbracket","title":"<code>RightBracket = SDL_SCANCODE_RIGHTBRACKET</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#backslash-sdl_scancode_backslash","title":"<code>Backslash = SDL_SCANCODE_BACKSLASH</code>","text":"<p>Located at the lower left of the return key on ISO keyboards and at the right end of the QWERTY row on ANSI keyboards. Produces REVERSE SOLIDUS (backslash) and VERTICAL LINE in a US layout, REVERSE SOLIDUS and VERTICAL LINE in a UK Mac layout, NUMBER SIGN and TILDE in a UK Windows layout, DOLLAR SIGN and POUND SIGN in a Swiss German layout, NUMBER SIGN and APOSTROPHE in a German layout, GRAVE ACCENT and POUND SIGN in a French Mac layout, and ASTERISK and MICRO SIGN in a French Windows layout. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#nonushash-sdl_scancode_nonushash","title":"<code>NonUSHash = SDL_SCANCODE_NONUSHASH</code>","text":"<p>ISO USB keyboards actually use this code instead of 49 for the same key, but all OSes I've seen treat the two codes identically. So, as an implementor, unless your keyboard generates both of those codes and your OS treats them differently, you should generate SDL_SCANCODE_BACKSLASH instead of this code. As a user, you should not rely on this code because SDL will never generate it with most (all?) keyboards. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#semicolon-sdl_scancode_semicolon","title":"<code>SemiColon = SDL_SCANCODE_SEMICOLON</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#apostrophe-sdl_scancode_apostrophe","title":"<code>Apostrophe = SDL_SCANCODE_APOSTROPHE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#grave-sdl_scancode_grave","title":"<code>Grave = SDL_SCANCODE_GRAVE</code>","text":"<p>Located in the top left corner (on both ANSI and ISO keyboards). Produces GRAVE ACCENT and TILDE in a US Windows layout and in US and UK Mac layouts on ANSI keyboards, GRAVE ACCENT and NOT SIGN in a UK Windows layout, SECTION SIGN and PLUS-MINUS SIGN in US and UK Mac layouts on ISO keyboards, SECTION SIGN and DEGREE SIGN in a Swiss German layout (Mac: only on ISO keyboards), CIRCUMFLEX ACCENT and DEGREE SIGN in a German layout (Mac: only on ISO keyboards), SUPERSCRIPT TWO and TILDE in a French Windows layout, COMMERCIAL AT and NUMBER SIGN in a French Mac layout on ISO keyboards, and LESS-THAN SIGN and GREATER-THAN SIGN in a Swiss German, German, or French Mac layout on ANSI keyboards. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#comma-sdl_scancode_comma","title":"<code>Comma = SDL_SCANCODE_COMMA</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#period-sdl_scancode_period","title":"<code>Period = SDL_SCANCODE_PERIOD</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#slash-sdl_scancode_slash","title":"<code>Slash = SDL_SCANCODE_SLASH</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#capslock-sdl_scancode_capslock","title":"<code>CapsLock = SDL_SCANCODE_CAPSLOCK</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f1-sdl_scancode_f1","title":"<code>F1 = SDL_SCANCODE_F1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f2-sdl_scancode_f2","title":"<code>F2 = SDL_SCANCODE_F2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f3-sdl_scancode_f3","title":"<code>F3 = SDL_SCANCODE_F3</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f4-sdl_scancode_f4","title":"<code>F4 = SDL_SCANCODE_F4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f5-sdl_scancode_f5","title":"<code>F5 = SDL_SCANCODE_F5</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f6-sdl_scancode_f6","title":"<code>F6 = SDL_SCANCODE_F6</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f7-sdl_scancode_f7","title":"<code>F7 = SDL_SCANCODE_F7</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f8-sdl_scancode_f8","title":"<code>F8 = SDL_SCANCODE_F8</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f9-sdl_scancode_f9","title":"<code>F9 = SDL_SCANCODE_F9</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f10-sdl_scancode_f10","title":"<code>F10 = SDL_SCANCODE_F10</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f11-sdl_scancode_f11","title":"<code>F11 = SDL_SCANCODE_F11</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f12-sdl_scancode_f12","title":"<code>F12 = SDL_SCANCODE_F12</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#printscreen-sdl_scancode_printscreen","title":"<code>PrintScreen = SDL_SCANCODE_PRINTSCREEN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#scrolllock-sdl_scancode_scrolllock","title":"<code>ScrollLock = SDL_SCANCODE_SCROLLLOCK</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#pause-sdl_scancode_pause","title":"<code>Pause = SDL_SCANCODE_PAUSE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#insert-sdl_scancode_insert","title":"<code>Insert = SDL_SCANCODE_INSERT</code>","text":"<p>Insert on PC, help on some Mac keyboards (but does send code 73, not 117)</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#home-sdl_scancode_home","title":"<code>Home = SDL_SCANCODE_HOME</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#pageup-sdl_scancode_pageup","title":"<code>PageUp = SDL_SCANCODE_PAGEUP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#delete-sdl_scancode_delete","title":"<code>Delete = SDL_SCANCODE_DELETE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#end-sdl_scancode_end","title":"<code>&amp;End = SDL_SCANCODE_END</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#pagedown-sdl_scancode_pagedown","title":"<code>PageDown = SDL_SCANCODE_PAGEDOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#right-sdl_scancode_right","title":"<code>Right = SDL_SCANCODE_RIGHT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#left-sdl_scancode_left","title":"<code>Left = SDL_SCANCODE_LEFT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#down-sdl_scancode_down","title":"<code>Down = SDL_SCANCODE_DOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#up-sdl_scancode_up","title":"<code>Up = SDL_SCANCODE_UP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#numlockclear-sdl_scancode_numlockclear","title":"<code>NumLockClear = SDL_SCANCODE_NUMLOCKCLEAR</code>","text":"<p>Num lock on PC, clear on Mac keyboards</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpdivide-sdl_scancode_kp_divide","title":"<code>KPDivide = SDL_SCANCODE_KP_DIVIDE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpmultiply-sdl_scancode_kp_multiply","title":"<code>KPMultiply = SDL_SCANCODE_KP_MULTIPLY</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpminus-sdl_scancode_kp_minus","title":"<code>KPMinus = SDL_SCANCODE_KP_MINUS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpplus-sdl_scancode_kp_plus","title":"<code>KPPlus = SDL_SCANCODE_KP_PLUS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpenter-sdl_scancode_kp_enter","title":"<code>KPEnter = SDL_SCANCODE_KP_ENTER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kp1-sdl_scancode_kp_1","title":"<code>KP1 = SDL_SCANCODE_KP_1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kp2-sdl_scancode_kp_2","title":"<code>KP2 = SDL_SCANCODE_KP_2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kp3-sdl_scancode_kp_3","title":"<code>KP3 = SDL_SCANCODE_KP_3</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kp4-sdl_scancode_kp_4","title":"<code>KP4 = SDL_SCANCODE_KP_4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kp5-sdl_scancode_kp_5","title":"<code>KP5 = SDL_SCANCODE_KP_5</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kp6-sdl_scancode_kp_6","title":"<code>KP6 = SDL_SCANCODE_KP_6</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kp7-sdl_scancode_kp_7","title":"<code>KP7 = SDL_SCANCODE_KP_7</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kp8-sdl_scancode_kp_8","title":"<code>KP8 = SDL_SCANCODE_KP_8</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kp9-sdl_scancode_kp_9","title":"<code>KP9 = SDL_SCANCODE_KP_9</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kp0-sdl_scancode_kp_0","title":"<code>KP0 = SDL_SCANCODE_KP_0</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpperiod-sdl_scancode_kp_period","title":"<code>KPPeriod = SDL_SCANCODE_KP_PERIOD</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#nonusbackslash-sdl_scancode_nonusbackslash","title":"<code>NonUSBackslash = SDL_SCANCODE_NONUSBACKSLASH</code>","text":"<p>This is the additional key that ISO keyboards have over ANSI ones, located between left shift and Y. Produces GRAVE ACCENT and TILDE in a US or UK Mac layout, REVERSE SOLIDUS (backslash) and VERTICAL LINE in a US or UK Windows layout, and LESS-THAN SIGN and GREATER-THAN SIGN in a Swiss German, German, or French layout.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#application-sdl_scancode_application","title":"<code>Application = SDL_SCANCODE_APPLICATION</code>","text":"<p>windows contextual menu, compose</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#power-sdl_scancode_power","title":"<code>Power = SDL_SCANCODE_POWER</code>","text":"<p>The USB document says this is a status flag, not a physical key - but some Mac keyboards do have a power key.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpequals-sdl_scancode_kp_equals","title":"<code>KPEquals = SDL_SCANCODE_KP_EQUALS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f13-sdl_scancode_f13","title":"<code>F13 = SDL_SCANCODE_F13</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f14-sdl_scancode_f14","title":"<code>F14 = SDL_SCANCODE_F14</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f15-sdl_scancode_f15","title":"<code>F15 = SDL_SCANCODE_F15</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f16-sdl_scancode_f16","title":"<code>F16 = SDL_SCANCODE_F16</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f17-sdl_scancode_f17","title":"<code>F17 = SDL_SCANCODE_F17</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f18-sdl_scancode_f18","title":"<code>F18 = SDL_SCANCODE_F18</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f19-sdl_scancode_f19","title":"<code>F19 = SDL_SCANCODE_F19</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f20-sdl_scancode_f20","title":"<code>F20 = SDL_SCANCODE_F20</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f21-sdl_scancode_f21","title":"<code>F21 = SDL_SCANCODE_F21</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f22-sdl_scancode_f22","title":"<code>F22 = SDL_SCANCODE_F22</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f23-sdl_scancode_f23","title":"<code>F23 = SDL_SCANCODE_F23</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#f24-sdl_scancode_f24","title":"<code>F24 = SDL_SCANCODE_F24</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#execute-sdl_scancode_execute","title":"<code>EXECUTE = SDL_SCANCODE_EXECUTE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#help-sdl_scancode_help","title":"<code>Help = SDL_SCANCODE_HELP</code>","text":"<p>AL Integrated Help Center</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#menu-sdl_scancode_menu","title":"<code>Menu = SDL_SCANCODE_MENU</code>","text":"<p>Menu (show menu)</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#select-sdl_scancode_select","title":"<code>Select = SDL_SCANCODE_SELECT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#stop-sdl_scancode_stop","title":"<code>Stop = SDL_SCANCODE_STOP</code>","text":"<p>AC Stop</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#again-sdl_scancode_again","title":"<code>Again = SDL_SCANCODE_AGAIN</code>","text":"<p>AC Redo/Repeat</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#undo-sdl_scancode_undo","title":"<code>Undo = SDL_SCANCODE_UNDO</code>","text":"<p>AC Undo</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#cut-sdl_scancode_cut","title":"<code>Cut = SDL_SCANCODE_CUT</code>","text":"<p>AC Cut</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#copy-sdl_scancode_copy","title":"<code>Copy = SDL_SCANCODE_COPY</code>","text":"<p>AC Copy</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#paste-sdl_scancode_paste","title":"<code>Paste = SDL_SCANCODE_PASTE</code>","text":"<p>AC Paste</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#find-sdl_scancode_find","title":"<code>Find = SDL_SCANCODE_FIND</code>","text":"<p>AC Find</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#mute-sdl_scancode_mute","title":"<code>Mute = SDL_SCANCODE_MUTE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#volumeup-sdl_scancode_volumeup","title":"<code>VolumeUp = SDL_SCANCODE_VOLUMEUP</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#volumedown-sdl_scancode_volumedown","title":"<code>VolumeDown = SDL_SCANCODE_VOLUMEDOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpcomma-sdl_scancode_kp_comma","title":"<code>KPComma = SDL_SCANCODE_KP_COMMA</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpequalsas400-sdl_scancode_kp_equalsas400","title":"<code>KPEqualsAS400 = SDL_SCANCODE_KP_EQUALSAS400</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#international1-sdl_scancode_international1","title":"<code>International1 = SDL_SCANCODE_INTERNATIONAL1</code>","text":"<p>used on Asian keyboards, see footnotes in USB doc</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#international2-sdl_scancode_international2","title":"<code>International2 = SDL_SCANCODE_INTERNATIONAL2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#international3-sdl_scancode_international3","title":"<code>International3 = SDL_SCANCODE_INTERNATIONAL3</code>","text":"<p>Yen</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#international4-sdl_scancode_international4","title":"<code>International4 = SDL_SCANCODE_INTERNATIONAL4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#international5-sdl_scancode_international5","title":"<code>International5 = SDL_SCANCODE_INTERNATIONAL5</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#international6-sdl_scancode_international6","title":"<code>International6 = SDL_SCANCODE_INTERNATIONAL6</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#international7-sdl_scancode_international7","title":"<code>International7 = SDL_SCANCODE_INTERNATIONAL7</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#international8-sdl_scancode_international8","title":"<code>International8 = SDL_SCANCODE_INTERNATIONAL8</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#international9-sdl_scancode_international9","title":"<code>International9 = SDL_SCANCODE_INTERNATIONAL9</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#lang1-sdl_scancode_lang1","title":"<code>Lang1 = SDL_SCANCODE_LANG1</code>","text":"<p>Hangul/English toggle</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#lang2-sdl_scancode_lang2","title":"<code>Lang2 = SDL_SCANCODE_LANG2</code>","text":"<p>Hanja conversion</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#lang3-sdl_scancode_lang3","title":"<code>Lang3 = SDL_SCANCODE_LANG3</code>","text":"<p>Katakana</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#lang4-sdl_scancode_lang4","title":"<code>Lang4 = SDL_SCANCODE_LANG4</code>","text":"<p>Hiragana</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#lang5-sdl_scancode_lang5","title":"<code>Lang5 = SDL_SCANCODE_LANG5</code>","text":"<p>Zenkaku/Hankaku</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#lang6-sdl_scancode_lang6","title":"<code>Lang6 = SDL_SCANCODE_LANG6</code>","text":"<p>reserved</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#lang7-sdl_scancode_lang7","title":"<code>Lang7 = SDL_SCANCODE_LANG7</code>","text":"<p>reserved</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#lang8-sdl_scancode_lang8","title":"<code>Lang8 = SDL_SCANCODE_LANG8</code>","text":"<p>reserved</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#lang9-sdl_scancode_lang9","title":"<code>Lang9 = SDL_SCANCODE_LANG9</code>","text":"<p>reserved</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#alterase-sdl_scancode_alterase","title":"<code>AltErase = SDL_SCANCODE_ALTERASE</code>","text":"<p>Erase-Eaze</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#sysreq-sdl_scancode_sysreq","title":"<code>SysReq = SDL_SCANCODE_SYSREQ</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#cancel-sdl_scancode_cancel","title":"<code>Cancel = SDL_SCANCODE_CANCEL</code>","text":"<p>AC Cancel</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#clear-sdl_scancode_clear","title":"<code>Clear = SDL_SCANCODE_CLEAR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#prior-sdl_scancode_prior","title":"<code>Prior = SDL_SCANCODE_PRIOR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#return2-sdl_scancode_return2","title":"<code>Return2 = SDL_SCANCODE_RETURN2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#separator-sdl_scancode_separator","title":"<code>Separator = SDL_SCANCODE_SEPARATOR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#out-sdl_scancode_out","title":"<code>&amp;Out = SDL_SCANCODE_OUT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#oper-sdl_scancode_oper","title":"<code>Oper = SDL_SCANCODE_OPER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#clearagain-sdl_scancode_clearagain","title":"<code>ClearAgain = SDL_SCANCODE_CLEARAGAIN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#crsel-sdl_scancode_crsel","title":"<code>CRSel = SDL_SCANCODE_CRSEL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#exsel-sdl_scancode_exsel","title":"<code>EXSel = SDL_SCANCODE_EXSEL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kp00-sdl_scancode_kp_00","title":"<code>KP00 = SDL_SCANCODE_KP_00</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kp000-sdl_scancode_kp_000","title":"<code>KP000 = SDL_SCANCODE_KP_000</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#thousandsseparator-sdl_scancode_thousandsseparator","title":"<code>ThousandsSeparator = SDL_SCANCODE_THOUSANDSSEPARATOR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#decimalseparator-sdl_scancode_decimalseparator","title":"<code>DecimalSeparator = SDL_SCANCODE_DECIMALSEPARATOR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#currencyunit-sdl_scancode_currencyunit","title":"<code>CurrencyUnit = SDL_SCANCODE_CURRENCYUNIT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#currencysubunit-sdl_scancode_currencysubunit","title":"<code>CurrencySubUnit = SDL_SCANCODE_CURRENCYSUBUNIT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpleftparen-sdl_scancode_kp_leftparen","title":"<code>KPLeftParen = SDL_SCANCODE_KP_LEFTPAREN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kprightparen-sdl_scancode_kp_rightparen","title":"<code>KPRightParen = SDL_SCANCODE_KP_RIGHTPAREN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpleftbrace-sdl_scancode_kp_leftbrace","title":"<code>KPLeftBrace = SDL_SCANCODE_KP_LEFTBRACE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kprightbrace-sdl_scancode_kp_rightbrace","title":"<code>KPRightBrace = SDL_SCANCODE_KP_RIGHTBRACE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kptab-sdl_scancode_kp_tab","title":"<code>KPTab = SDL_SCANCODE_KP_TAB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpbackspace-sdl_scancode_kp_backspace","title":"<code>KPBackspace = SDL_SCANCODE_KP_BACKSPACE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpa-sdl_scancode_kp_a","title":"<code>KPA = SDL_SCANCODE_KP_A</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpb-sdl_scancode_kp_b","title":"<code>KPB = SDL_SCANCODE_KP_B</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpc-sdl_scancode_kp_c","title":"<code>KPC = SDL_SCANCODE_KP_C</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpd-sdl_scancode_kp_d","title":"<code>KPD = SDL_SCANCODE_KP_D</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpe-sdl_scancode_kp_e","title":"<code>KPE = SDL_SCANCODE_KP_E</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpf-sdl_scancode_kp_f","title":"<code>KPF = SDL_SCANCODE_KP_F</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpxor-sdl_scancode_kp_xor","title":"<code>KPXor = SDL_SCANCODE_KP_XOR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kppower-sdl_scancode_kp_power","title":"<code>KPPower = SDL_SCANCODE_KP_POWER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kppercent-sdl_scancode_kp_percent","title":"<code>KPPercent = SDL_SCANCODE_KP_PERCENT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpless-sdl_scancode_kp_less","title":"<code>KPLess = SDL_SCANCODE_KP_LESS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpgreater-sdl_scancode_kp_greater","title":"<code>KPGreater = SDL_SCANCODE_KP_GREATER</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpampersand-sdl_scancode_kp_ampersand","title":"<code>KPAmpersand = SDL_SCANCODE_KP_AMPERSAND</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpdblampersand-sdl_scancode_kp_dblampersand","title":"<code>KPDblAmpersand = SDL_SCANCODE_KP_DBLAMPERSAND</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpverticalbar-sdl_scancode_kp_verticalbar","title":"<code>KPVerticalBar = SDL_SCANCODE_KP_VERTICALBAR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpdblverticalbar-sdl_scancode_kp_dblverticalbar","title":"<code>KPDblVerticalBar = SDL_SCANCODE_KP_DBLVERTICALBAR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpcolon-sdl_scancode_kp_colon","title":"<code>KPColon = SDL_SCANCODE_KP_COLON</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kphash-sdl_scancode_kp_hash","title":"<code>KPHash = SDL_SCANCODE_KP_HASH</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpspace-sdl_scancode_kp_space","title":"<code>KPSpace = SDL_SCANCODE_KP_SPACE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpat-sdl_scancode_kp_at","title":"<code>KPAt = SDL_SCANCODE_KP_AT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpexclam-sdl_scancode_kp_exclam","title":"<code>KPExclam = SDL_SCANCODE_KP_EXCLAM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpmemstore-sdl_scancode_kp_memstore","title":"<code>KPMemStore = SDL_SCANCODE_KP_MEMSTORE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpmemrecall-sdl_scancode_kp_memrecall","title":"<code>KPMemRecall = SDL_SCANCODE_KP_MEMRECALL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpmemclear-sdl_scancode_kp_memclear","title":"<code>KPMemClear = SDL_SCANCODE_KP_MEMCLEAR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpmemadd-sdl_scancode_kp_memadd","title":"<code>KPMemAdd = SDL_SCANCODE_KP_MEMADD</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpmemsubtract-sdl_scancode_kp_memsubtract","title":"<code>KPMemSubtract = SDL_SCANCODE_KP_MEMSUBTRACT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpmemmultiply-sdl_scancode_kp_memmultiply","title":"<code>KPMemMultiply = SDL_SCANCODE_KP_MEMMULTIPLY</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpmemdivide-sdl_scancode_kp_memdivide","title":"<code>KPMemDivide = SDL_SCANCODE_KP_MEMDIVIDE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpplusminus-sdl_scancode_kp_plusminus","title":"<code>KPPlusMinus = SDL_SCANCODE_KP_PLUSMINUS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpclear-sdl_scancode_kp_clear","title":"<code>KPClear = SDL_SCANCODE_KP_CLEAR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpclearentry-sdl_scancode_kp_clearentry","title":"<code>KPClearEntry = SDL_SCANCODE_KP_CLEARENTRY</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpbinary-sdl_scancode_kp_binary","title":"<code>KPBinary = SDL_SCANCODE_KP_BINARY</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpoctal-sdl_scancode_kp_octal","title":"<code>KPOctal = SDL_SCANCODE_KP_OCTAL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kpdecimal-sdl_scancode_kp_decimal","title":"<code>KPDecimal = SDL_SCANCODE_KP_DECIMAL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#kphexadecimal-sdl_scancode_kp_hexadecimal","title":"<code>KPHexadecimal = SDL_SCANCODE_KP_HEXADECIMAL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#lctrl-sdl_scancode_lctrl","title":"<code>LCtrl = SDL_SCANCODE_LCTRL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#lshift-sdl_scancode_lshift","title":"<code>LShift = SDL_SCANCODE_LSHIFT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#lalt-sdl_scancode_lalt","title":"<code>LAlt = SDL_SCANCODE_LALT</code>","text":"<p>Alt, option</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#lgui-sdl_scancode_lgui","title":"<code>LGui = SDL_SCANCODE_LGUI</code>","text":"<p>Windows, command (apple), meta</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#rctrl-sdl_scancode_rctrl","title":"<code>RCtrl = SDL_SCANCODE_RCTRL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#rshift-sdl_scancode_rshift","title":"<code>RShift = SDL_SCANCODE_RSHIFT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#ralt-sdl_scancode_ralt","title":"<code>RAlt = SDL_SCANCODE_RALT</code>","text":"<p>Alt gr, option</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#rgui-sdl_scancode_rgui","title":"<code>RGui = SDL_SCANCODE_RGUI</code>","text":"<p>Windows, command (apple), meta</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#mode-sdl_scancode_mode","title":"<code>Mode = SDL_SCANCODE_MODE</code>","text":"<p>I'm not sure if this is really not covered by any of the above, but since there's a special SDL_KMOD_MODE for it I'm adding it here </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#sleep-sdl_scancode_sleep","title":"<code>Sleep = SDL_SCANCODE_SLEEP</code>","text":"<p>Sleep</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#wake-sdl_scancode_wake","title":"<code>Wake = SDL_SCANCODE_WAKE</code>","text":"<p>Wake</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#channelincrement-sdl_scancode_channel_increment","title":"<code>ChannelIncrement = SDL_SCANCODE_CHANNEL_INCREMENT</code>","text":"<p>Channel Increment</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#channeldecrement-sdl_scancode_channel_decrement","title":"<code>ChannelDecrement = SDL_SCANCODE_CHANNEL_DECREMENT</code>","text":"<p>Channel Decrement</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#mediaplay-sdl_scancode_media_play","title":"<code>MediaPlay = SDL_SCANCODE_MEDIA_PLAY</code>","text":"<p>Play</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#mediapause-sdl_scancode_media_pause","title":"<code>MediaPause = SDL_SCANCODE_MEDIA_PAUSE</code>","text":"<p>Pause</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#mediarecord-sdl_scancode_media_record","title":"<code>MediaRecord = SDL_SCANCODE_MEDIA_RECORD</code>","text":"<p>Record</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#mediafastforward-sdl_scancode_media_fast_forward","title":"<code>MediaFastForward = SDL_SCANCODE_MEDIA_FAST_FORWARD</code>","text":"<p>Fast Forward</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#mediarewind-sdl_scancode_media_rewind","title":"<code>MediaRewind = SDL_SCANCODE_MEDIA_REWIND</code>","text":"<p>Rewind</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#medianexttrack-sdl_scancode_media_next_track","title":"<code>MediaNextTrack = SDL_SCANCODE_MEDIA_NEXT_TRACK</code>","text":"<p>Next Track</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#mediaprevioustrack-sdl_scancode_media_previous_track","title":"<code>MediaPreviousTrack = SDL_SCANCODE_MEDIA_PREVIOUS_TRACK</code>","text":"<p>Previous Track</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#mediastop-sdl_scancode_media_stop","title":"<code>MediaStop = SDL_SCANCODE_MEDIA_STOP</code>","text":"<p>Stop</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#mediaeject-sdl_scancode_media_eject","title":"<code>MediaEject = SDL_SCANCODE_MEDIA_EJECT</code>","text":"<p>Eject</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#mediaplaypause-sdl_scancode_media_play_pause","title":"<code>MediaPlayPause = SDL_SCANCODE_MEDIA_PLAY_PAUSE</code>","text":"<p>Play / Pause</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#mediaselect-sdl_scancode_media_select","title":"<code>MediaSelect = SDL_SCANCODE_MEDIA_SELECT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#acnew-sdl_scancode_ac_new","title":"<code>ACNew = SDL_SCANCODE_AC_NEW</code>","text":"<p>AC New</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#acopen-sdl_scancode_ac_open","title":"<code>ACOpen = SDL_SCANCODE_AC_OPEN</code>","text":"<p>AC Open</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#acclose-sdl_scancode_ac_close","title":"<code>ACClose = SDL_SCANCODE_AC_CLOSE</code>","text":"<p>AC Close</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#acexit-sdl_scancode_ac_exit","title":"<code>ACExit = SDL_SCANCODE_AC_EXIT</code>","text":"<p>AC Exit</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#acsave-sdl_scancode_ac_save","title":"<code>ACSave = SDL_SCANCODE_AC_SAVE</code>","text":"<p>AC Save</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#acprint-sdl_scancode_ac_print","title":"<code>ACPrint = SDL_SCANCODE_AC_PRINT</code>","text":"<p>AC Print</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#acproperties-sdl_scancode_ac_properties","title":"<code>ACProperties = SDL_SCANCODE_AC_PROPERTIES</code>","text":"<p>AC Properties</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#acsearch-sdl_scancode_ac_search","title":"<code>ACSearch = SDL_SCANCODE_AC_SEARCH</code>","text":"<p>AC Search</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#achome-sdl_scancode_ac_home","title":"<code>ACHome = SDL_SCANCODE_AC_HOME</code>","text":"<p>AC Home</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#acback-sdl_scancode_ac_back","title":"<code>ACBack = SDL_SCANCODE_AC_BACK</code>","text":"<p>AC Back</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#acforward-sdl_scancode_ac_forward","title":"<code>ACForward = SDL_SCANCODE_AC_FORWARD</code>","text":"<p>AC Forward</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#acstop-sdl_scancode_ac_stop","title":"<code>ACStop = SDL_SCANCODE_AC_STOP</code>","text":"<p>AC Stop</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#acrefresh-sdl_scancode_ac_refresh","title":"<code>ACRefresh = SDL_SCANCODE_AC_REFRESH</code>","text":"<p>AC Refresh</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#acbookmarks-sdl_scancode_ac_bookmarks","title":"<code>ACBookmarks = SDL_SCANCODE_AC_BOOKMARKS</code>","text":"<p>AC Bookmarks</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#softleft-sdl_scancode_softleft","title":"<code>SoftLeft = SDL_SCANCODE_SOFTLEFT</code>","text":"<p>Usually situated below the display on phones and used as a multi-function feature key for selecting a software defined function shown on the bottom left of the display.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#softright-sdl_scancode_softright","title":"<code>SoftRight = SDL_SCANCODE_SOFTRIGHT</code>","text":"<p>Usually situated below the display on phones and used as a multi-function feature key for selecting a software defined function shown on the bottom right of the display.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#call-sdl_scancode_call","title":"<code>Call = SDL_SCANCODE_CALL</code>","text":"<p>Used for accepting phone calls.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#endcall-sdl_scancode_endcall","title":"<code>EndCall = SDL_SCANCODE_ENDCALL</code>","text":"<p>Used for rejecting phone calls.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#properties","title":"Properties","text":"Name Description Name A human-readable name for the scancode."},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#methods","title":"Methods","text":"Name Description FromKeycode(TSdlKeycode) Get the scancode corresponding to the given key code according to the current keyboard layout. FromKeycode(TSdlKeycode, TSdlKeyMods) Get the scancode corresponding to the given key code according to the current keyboard layout. FromName Get a scancode from a human-readable name. ToKeycode Converts the scancode to a TSdlKeycode. ToKeycode(TSdlKeymods, Boolean) Get the key code corresponding to this scancode according to the current keyboard layout."},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#Name","title":"Name","text":"<p>A human-readable name for the scancode.</p> <p>Warning: The returned name is by design not stable across platforms, e.g. the name for <code>TSdlScancode.LGui</code> is 'Left GUI' under Linux but 'Left Windows' under Microsoft Windows, and some scancodes like <code>TSdlScancode.NonUSBackslash</code> don't have any name at all. There are even scancodes that share names, e.g. <code>TSdlScancode.Return</code> and <code>TSdlScancode.Return2</code> (both called 'Return'). This property is therefore unsuitable for creating a stable cross-platform two-way mapping between strings and scancodes.</p> <p>You can also set this property to a different name. </p> <p><code>property Name: String read GetName write SetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#see-also","title":"See Also","text":"<ul> <li>FromKeycode</li> <li>FromName</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#remarks","title":"Remarks","text":"<p>This property is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#FromKeycode_0","title":"FromKeycode(TSdlKeycode)","text":"<p>Get the scancode corresponding to the given key code according to the current keyboard layout. </p> <p><code>class function FromKeycode(const AKey: TSdlKeycode): TSdlScancode; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#parameters","title":"Parameters","text":"<p><code>AKey</code>: <code>TSdlKeycode</code> : The desired keycode to query.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#returns","title":"Returns","text":"<p><code>TSdlScancode</code>: The scancode that corresponds to the given keycode.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#see-also_1","title":"See Also","text":"<ul> <li>TSdlKeycode.FromScancode</li> <li>Name</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#remarks_1","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#FromKeycode_1","title":"FromKeycode(TSdlKeycode, TSdlKeyMods)","text":"<p>Get the scancode corresponding to the given key code according to the current keyboard layout.</p> <p>Note that there may be multiple scancode+modifier states that can generate this keycode, this will just return the first one found. </p> <p><code>class function FromKeycode(const AKey: TSdlKeycode; const AModState: TSdlKeyMods): TSdlScancode; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#parameters_1","title":"Parameters","text":"<p><code>AKey</code>: <code>TSdlKeycode</code> : The desired keycode to query.</p> <p><code>AModState</code>: <code>TSdlKeyMods</code> : The modifier state that would be used when the scancode generates this key.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#returns_1","title":"Returns","text":"<p><code>TSdlScancode</code>: The scancode that corresponds to the given keycode.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#see-also_2","title":"See Also","text":"<ul> <li>TSdlKeycode.FromScancode</li> <li>Name</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#remarks_2","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#FromName","title":"FromName(String)","text":"<p>Get a scancode from a human-readable name. </p> <p><code>class function FromName(const AName: String): TSdlScancode; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#parameters_2","title":"Parameters","text":"<p><code>AName</code>: <code>String</code> : The human-readable scancode name.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#returns_2","title":"Returns","text":"<p><code>TSdlScancode</code>: The scancode, or <code>TSdlScancode.Unknown</code> if the name wasn't recognized.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#see-also_3","title":"See Also","text":"<ul> <li>TSdlKeycode.FromName</li> <li>FromKeycode</li> <li>Name</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#remarks_3","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#ToKeycode_0","title":"ToKeycode","text":"<p>Converts the scancode to a TSdlKeycode. </p> <p><code>function ToKeycode: TSdlKeycode; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#returns_3","title":"Returns","text":"<p><code>TSdlKeycode</code>: The keycode for this scancode.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#ToKeycode_1","title":"ToKeycode(TSdlKeymods, Boolean)","text":"<p>Get the key code corresponding to this scancode according to the current keyboard layout.</p> <p>If you want to get the keycode as it would be delivered in key events, including options specified in TSdlHints.KeycodeOptions, then you should pass <code>AKeyEvent</code> as True. Otherwise this function simply translates the scancode based on the given modifier state. </p> <p><code>function ToKeycode(const AModState: TSdlKeymods; const AKeyEvent: Boolean): TSdlKeycode; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#parameters_3","title":"Parameters","text":"<p><code>AModState</code>: <code>TSdlKeymods</code> : The modifier state to use when translating the scancode to a keycode.</p> <p><code>AKeyEvent</code>: <code>Boolean</code> : True if the keycode will be used in key events.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#returns_4","title":"Returns","text":"<p><code>TSdlKeycode</code>: The keycode that corresponds to the given scancode.</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#see-also_4","title":"See Also","text":"<ul> <li>TSdlKeycode.Name</li> <li>TSdlScancode.FromKeycode</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlScancode/#remarks_4","title":"Remarks","text":"<p>This method is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSensorKind/","title":"TSdlSensorKind","text":"<p>The different sensors defined by SDL.</p> <p>Additional sensors may be available, using platform dependent semantics.</p> <p>Here are the additional  Android sensors.</p> <p>Accelerometer sensor notes:</p> <p>The accelerometer returns the current acceleration in SI meters per second squared. This measurement includes the force of gravity, so a device at rest will have an value of SDL_STANDARD_GRAVITY away from the center of the earth, which is a positive Y value.</p> <ul> <li><code>Values[0]</code>: Acceleration on the x axis</li> <li><code>Values[1]</code>: Acceleration on the y axis</li> <li><code>Values[2]</code>: Acceleration on the z axis</li> </ul> <p>For phones and tablets held in natural orientation and game controllers held in front of you, the axes are defined as follows:</p> <ul> <li>-X ... +X : left ... right</li> <li>-Y ... +Y : bottom ... top</li> <li>-Z ... +Z : farther ... closer</li> </ul> <p>The accelerometer axis data is not changed when the device is rotated.</p> <p>Gyroscope sensor notes:</p> <p>The gyroscope returns the current rate of rotation in radians per second. The rotation is positive in the counter-clockwise direction. That is, an observer looking from a positive location on one of the axes would see positive rotation on that axis when it appeared to be rotating counter-clockwise.</p> <ul> <li><code>Values[0]</code>: Angular speed around the x axis (pitch)</li> <li><code>Values[1]</code>: Angular speed around the y axis (yaw)</li> <li><code>Values[2]</code>: Angular speed around the z axis (roll)</li> </ul> <p>For phones and tablets held in natural orientation and game controllers held in front of you, the axes are defined as follows:</p> <ul> <li>-X ... +X : left ... right</li> <li>-Y ... +Y : bottom ... top</li> <li>-Z ... +Z : farther ... closer</li> </ul> <p>The gyroscope axis data is not changed when the device is rotated. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSensorKind/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlSensorKind = (Invalid, Unknown, Accel, Gyro, AccelLeft, GyroLeft, AccelRight, GyroRight)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSensorKind/#see-also","title":"See Also","text":"<ul> <li>TSdlDisplay.CurrentOrientation</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSensorKind/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSensorKind/#invalid-sdl_sensor_invalid","title":"<code>Invalid = SDL_SENSOR_INVALID</code>","text":"<p>Returned for an invalid sensor</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSensorKind/#unknown-sdl_sensor_unknown","title":"<code>Unknown = SDL_SENSOR_UNKNOWN</code>","text":"<p>Unknown sensor type</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSensorKind/#accel-sdl_sensor_accel","title":"<code>Accel = SDL_SENSOR_ACCEL</code>","text":"<p>Accelerometer</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSensorKind/#gyro-sdl_sensor_gyro","title":"<code>Gyro = SDL_SENSOR_GYRO</code>","text":"<p>Gyroscope</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSensorKind/#accelleft-sdl_sensor_accel_l","title":"<code>AccelLeft = SDL_SENSOR_ACCEL_L</code>","text":"<p>Accelerometer for left Joy-Con controller and Wii nunchuk</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSensorKind/#gyroleft-sdl_sensor_gyro_l","title":"<code>GyroLeft = SDL_SENSOR_GYRO_L</code>","text":"<p>Gyroscope for left Joy-Con controller</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSensorKind/#accelright-sdl_sensor_accel_r","title":"<code>AccelRight = SDL_SENSOR_ACCEL_R</code>","text":"<p>Accelerometer for right Joy-Con controller</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSensorKind/#gyroright-sdl_sensor_gyro_r","title":"<code>GyroRight = SDL_SENSOR_GYRO_R</code>","text":"<p>Gyroscope for right Joy-Con controller</p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/","title":"TSdlSystemCursor","text":"<p>Cursor types for TSdlCursor.Create. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlSystemCursor = (Default, Text, Wait, Crosshair, Progress, NwseResize, NeswResize, EWResize, NSResize, Move, NotAllowed, Pointer, NWResize, NResize, NEResize...)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#default-sdl_system_cursor_default","title":"<code>Default = SDL_SYSTEM_CURSOR_DEFAULT</code>","text":"<p>Default cursor. Usually an arrow. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#text-sdl_system_cursor_text","title":"<code>Text = SDL_SYSTEM_CURSOR_TEXT</code>","text":"<p>Text selection. Usually an I-beam. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#wait-sdl_system_cursor_wait","title":"<code>Wait = SDL_SYSTEM_CURSOR_WAIT</code>","text":"<p>Wait. Usually an hourglass or watch or spinning ball. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#crosshair-sdl_system_cursor_crosshair","title":"<code>Crosshair = SDL_SYSTEM_CURSOR_CROSSHAIR</code>","text":"<p>Crosshair. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#progress-sdl_system_cursor_progress","title":"<code>Progress = SDL_SYSTEM_CURSOR_PROGRESS</code>","text":"<p>Program is busy but still interactive. Usually it's WAIT with an arrow. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#nwseresize-sdl_system_cursor_nwse_resize","title":"<code>NwseResize = SDL_SYSTEM_CURSOR_NWSE_RESIZE</code>","text":"<p>Double arrow pointing northwest and southeast. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#neswresize-sdl_system_cursor_nesw_resize","title":"<code>NeswResize = SDL_SYSTEM_CURSOR_NESW_RESIZE</code>","text":"<p>Double arrow pointing northeast and southwest. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#ewresize-sdl_system_cursor_ew_resize","title":"<code>EWResize = SDL_SYSTEM_CURSOR_EW_RESIZE</code>","text":"<p>Double arrow pointing west and east. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#nsresize-sdl_system_cursor_ns_resize","title":"<code>NSResize = SDL_SYSTEM_CURSOR_NS_RESIZE</code>","text":"<p>Double arrow pointing north and south. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#move-sdl_system_cursor_move","title":"<code>Move = SDL_SYSTEM_CURSOR_MOVE</code>","text":"<p>Four pointed arrow pointing north, south, east, and west. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#notallowed-sdl_system_cursor_not_allowed","title":"<code>NotAllowed = SDL_SYSTEM_CURSOR_NOT_ALLOWED</code>","text":"<p>Not permitted. Usually a slashed circle or crossbones. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#pointer-sdl_system_cursor_pointer","title":"<code>Pointer = SDL_SYSTEM_CURSOR_POINTER</code>","text":"<p>Pointer that indicates a link. Usually a pointing hand. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#nwresize-sdl_system_cursor_nw_resize","title":"<code>NWResize = SDL_SYSTEM_CURSOR_NW_RESIZE</code>","text":"<p>Window resize top-left. This may be a single arrow or a double arrow like NwseResize. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#nresize-sdl_system_cursor_n_resize","title":"<code>NResize = SDL_SYSTEM_CURSOR_N_RESIZE</code>","text":"<p>Window resize top. May be NSResize </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#neresize-sdl_system_cursor_ne_resize","title":"<code>NEResize = SDL_SYSTEM_CURSOR_NE_RESIZE</code>","text":"<p>Window resize top-right. May be NeswResize. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#eresize-sdl_system_cursor_e_resize","title":"<code>EResize = SDL_SYSTEM_CURSOR_E_RESIZE</code>","text":"<p>Window resize right. May be EWResize. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#serezize-sdl_system_cursor_se_resize","title":"<code>SERezize = SDL_SYSTEM_CURSOR_SE_RESIZE</code>","text":"<p>Window resize bottom-right. May be NwseResize. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#sresize-sdl_system_cursor_s_resize","title":"<code>SResize = SDL_SYSTEM_CURSOR_S_RESIZE</code>","text":"<p>Window resize bottom. May be NSResize. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#swresize-sdl_system_cursor_sw_resize","title":"<code>SWResize = SDL_SYSTEM_CURSOR_SW_RESIZE</code>","text":"<p>Window resize bottom-left. May be NeswResize. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlSystemCursor/#wresize-sdl_system_cursor_w_resize","title":"<code>WResize = SDL_SYSTEM_CURSOR_W_RESIZE</code>","text":"<p>Window resize left. May be EWResize. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlTouchDeviceType/","title":"TSdlTouchDeviceType","text":"<p>An enum that describes the type of a touch device. </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlTouchDeviceType/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlTouchDeviceType = (Invalid, Direct, IndirectAbsolute, IndirectRelative)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlTouchDeviceType/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlTouchDeviceType/#invalid-sdl_touch_device_invalid","title":"<code>Invalid = SDL_TOUCH_DEVICE_INVALID</code>","text":"<p>Invalid </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlTouchDeviceType/#direct-sdl_touch_device_direct","title":"<code>Direct = SDL_TOUCH_DEVICE_DIRECT</code>","text":"<p>Touch screen with window-relative coordinates </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlTouchDeviceType/#indirectabsolute-sdl_touch_device_indirect_absolute","title":"<code>IndirectAbsolute = SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE</code>","text":"<p>Trackpad with absolute device coordinates </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlTouchDeviceType/#indirectrelative-sdl_touch_device_indirect_relative","title":"<code>IndirectRelative = SDL_TOUCH_DEVICE_INDIRECT_RELATIVE</code>","text":"<p>Trackpad with screen cursor-relative coordinates </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickCleanup/","title":"TSdlVirtualJoystickCleanup","text":"<p>Callback type for TSdlVirtualJoystickDesc.Cleanup </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickCleanup/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlVirtualJoystickCleanup = procedure(AUserData: Pointer); cdecl\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickCleanup/#parameters","title":"Parameters","text":"<p><code>AUserData</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickRumble/","title":"TSdlVirtualJoystickRumble","text":"<p>Callback type for TSdlVirtualJoystickDesc.Rumble </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickRumble/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlVirtualJoystickRumble = function(AUserData: Pointer; \n  ALowFrequencyRumble, AHighFrequencyRumble: Word): Boolean; cdecl\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickRumble/#parameters","title":"Parameters","text":"<p><code>AUserData</code>: <code>Pointer</code></p> <p><code>ALowFrequencyRumble</code>: <code>Word</code></p> <p><code>AHighFrequencyRumble</code>: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickRumble/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickRumbleTriggers/","title":"TSdlVirtualJoystickRumbleTriggers","text":"<p>Callback type for TSdlVirtualJoystickDesc.RumbleTriggers </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickRumbleTriggers/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlVirtualJoystickRumbleTriggers = function(AUserData: Pointer; \n  ALeftR, ARightRumble: Word): Boolean; cdecl\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickRumbleTriggers/#parameters","title":"Parameters","text":"<p><code>AUserData</code>: <code>Pointer</code></p> <p><code>ALeftR</code>: <code>Word</code></p> <p><code>ARightRumble</code>: <code>Word</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickRumbleTriggers/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickSendEffect/","title":"TSdlVirtualJoystickSendEffect","text":"<p>Callback type for TSdlVirtualJoystickDesc.SendEffect </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickSendEffect/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlVirtualJoystickSendEffect = function(AUserData: Pointer; \n  const AData: Pointer; ASize: Integer): Boolean; cdecl\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickSendEffect/#parameters","title":"Parameters","text":"<p><code>AUserData</code>: <code>Pointer</code></p> <p><code>AData</code>: <code>Pointer</code></p> <p><code>ASize</code>: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickSendEffect/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickSetLed/","title":"TSdlVirtualJoystickSetLed","text":"<p>Callback type for TSdlVirtualJoystickDesc.SetLed </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickSetLed/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlVirtualJoystickSetLed = function(AUserData: Pointer; \n  ARed, AGreen, ABlue: Byte): Boolean; cdecl\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickSetLed/#parameters","title":"Parameters","text":"<p><code>AUserData</code>: <code>Pointer</code></p> <p><code>ARed</code>: <code>Byte</code></p> <p><code>AGreen</code>: <code>Byte</code></p> <p><code>ABlue</code>: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickSetLed/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickSetPlayerIndex/","title":"TSdlVirtualJoystickSetPlayerIndex","text":"<p>Callback type for TSdlVirtualJoystickDesc.SetPlayerIndex </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickSetPlayerIndex/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlVirtualJoystickSetPlayerIndex = procedure(AUserData: Pointer; \n  APlayerIndex: Integer); cdecl\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickSetPlayerIndex/#parameters","title":"Parameters","text":"<p><code>AUserData</code>: <code>Pointer</code></p> <p><code>APlayerIndex</code>: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickSetSensorsEnabled/","title":"TSdlVirtualJoystickSetSensorsEnabled","text":"<p>Callback type for TSdlVirtualJoystickDesc.SetSensorsEnabled </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickSetSensorsEnabled/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlVirtualJoystickSetSensorsEnabled = function(AUserData: Pointer; \n  AEnabled: Boolean): Boolean; cdecl\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickSetSensorsEnabled/#parameters","title":"Parameters","text":"<p><code>AUserData</code>: <code>Pointer</code></p> <p><code>AEnabled</code>: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickSetSensorsEnabled/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickUpdate/","title":"TSdlVirtualJoystickUpdate","text":"<p>Callback type for TSdlVirtualJoystickDesc.Update </p>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickUpdate/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Input</p> <pre><code>type TSdlVirtualJoystickUpdate = procedure(AUserData: Pointer); cdecl\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Input/types/TSdlVirtualJoystickUpdate/#parameters","title":"Parameters","text":"<p><code>AUserData</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Time/","title":"Neslib.Sdl3.Time","text":""},{"location":"Reference/Neslib.Sdl3.Time/#types","title":"Types","text":"Name Description TSdlTimerCallback Function prototype for the millisecond timer callback function. TSdlTimerID A timer ID. TSdlTimerNSCallback Function prototype for the nanosecond timer callback function."},{"location":"Reference/Neslib.Sdl3.Time/#routines","title":"Routines","text":"Name Description SdlAddTimer Call a callback function at a future time. SdlAddTimerNS Call a callback function at a future time. SdlDelay Wait a specified number of milliseconds before returning. SdlDelayNS Wait a specified number of nanoseconds before returning. SdlDelayPrecise Wait a specified number of nanoseconds before returning. SdlGetPerformanceCounter Get the current value of the high resolution counter. SdlGetPerformanceFrequency Get the count per second of the high resolution counter. SdlGetTicks Get the number of milliseconds since SDL library initialization. SdlMSToNS Convert milliseconds to nanoseconds. SdlNSToMS Convert nanoseconds to milliseconds. SdlNSToSeconds Convert nanoseconds to seconds. SdlNSToUS Convert nanoseconds to microseconds. SdlRemoveTimer Remove a timer created with SdlAddTimer or SdlAddTimerNS. SdlSecondsToNS Convert seconds to nanoseconds. SdlUSToNS Convert microseconds to nanoseconds."},{"location":"Reference/Neslib.Sdl3.Time/#constants","title":"Constants","text":"Name Description SDL_MS_PER_SECOND Number of milliseconds in a second. SDL_NS_PER_MS Number of nanoseconds in a millisecond. SDL_NS_PER_SECOND Number of nanoseconds in a second. SDL_NS_PER_US Number of nanoseconds in a microsecond. SDL_US_PER_SECOND Number of microseconds in a second."},{"location":"Reference/Neslib.Sdl3.Time/constants/SDL_MS_PER_SECOND/","title":"SDL_MS_PER_SECOND","text":"<p>Number of milliseconds in a second.</p> <p>This is always 1,000. </p>"},{"location":"Reference/Neslib.Sdl3.Time/constants/SDL_MS_PER_SECOND/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>const SDL_MS_PER_SECOND = 1000\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/constants/SDL_NS_PER_MS/","title":"SDL_NS_PER_MS","text":"<p>Number of nanoseconds in a millisecond.</p> <p>This is always 1,000,000. </p>"},{"location":"Reference/Neslib.Sdl3.Time/constants/SDL_NS_PER_MS/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>const SDL_NS_PER_MS = 1000000\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/constants/SDL_NS_PER_SECOND/","title":"SDL_NS_PER_SECOND","text":"<p>Number of nanoseconds in a second.</p> <p>This is always 1,000,000,000. </p>"},{"location":"Reference/Neslib.Sdl3.Time/constants/SDL_NS_PER_SECOND/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>const SDL_NS_PER_SECOND = 1000000000\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/constants/SDL_NS_PER_US/","title":"SDL_NS_PER_US","text":"<p>Number of nanoseconds in a microsecond.</p> <p>This is always 1,000. </p>"},{"location":"Reference/Neslib.Sdl3.Time/constants/SDL_NS_PER_US/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>const SDL_NS_PER_US = 1000\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/constants/SDL_US_PER_SECOND/","title":"SDL_US_PER_SECOND","text":"<p>Number of microseconds in a second.</p> <p>This is always 1,000,000. </p>"},{"location":"Reference/Neslib.Sdl3.Time/constants/SDL_US_PER_SECOND/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>const SDL_US_PER_SECOND = 1000000\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlAddTimer/","title":"SdlAddTimer","text":"<p>Call a callback function at a future time.</p> <p>The callback function is passed the current timer interval and should return the next timer interval. If the value returned from the callback is 0, the timer is canceled and will be removed.</p> <p>The callback is run on a separate thread, and for short timeouts can potentially be called before this function returns.</p> <p>Timers take into account the amount of time it took to execute the callback. For example, if the callback took 250 ms to execute and returned 1000 (ms), the timer would only wait another 750 ms before its next iteration.</p> <p>Timing may be inexact due to OS scheduling. Be sure to note the current time with SdlGetTicksNS or SdlGetPerformanceCounter in case your callback needs to adjust for variances. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlAddTimer/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>function SdlAddTimer(const AInterval: Integer; const ACallback: TSdlTimerCallback): TSdlTimerID\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlAddTimer/#parameters","title":"Parameters","text":"<p><code>AInterval</code>: <code>Integer</code> : The timer delay, in milliseconds, passed to <code>ACallback</code>.</p> <p><code>ACallback</code>: <code>TSdlTimerCallback</code> : The SdlTimerCallback function to call when the specified <code>AInterval</code> elapses.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlAddTimer/#returns","title":"Returns","text":"<p><code>TSdlTimerID</code>: A timer ID.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlAddTimer/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlAddTimer/#see-also","title":"See Also","text":"<ul> <li>SdlAddTimerNS</li> <li>SdlRemoveTimer</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlAddTimer/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlAddTimerNS/","title":"SdlAddTimerNS","text":"<p>Call a callback function at a future time.</p> <p>The callback function is passed the current timer interval and should return the next timer interval. If the value returned from the callback is 0, the timer is canceled and will be removed.</p> <p>The callback is run on a separate thread, and for short timeouts can potentially be called before this function returns.</p> <p>Timers take into account the amount of time it took to execute the callback. For example, if the callback took 250 ns to execute and returned 1000 (ns), the timer would only wait another 750 ns before its next iteration.</p> <p>Timing may be inexact due to OS scheduling. Be sure to note the current time with SdlGetTicksNS or SdlGetPerformanceCounter in case your callback needs to adjust for variances. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlAddTimerNS/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>function SdlAddTimerNS(const AInterval: Int64; const ACallback: TSdlTimerNSCallback): TSdlTimerID\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlAddTimerNS/#parameters","title":"Parameters","text":"<p><code>AInterval</code>: <code>Int64</code> : The timer delay, in nanoseconds, passed to <code>Aallback</code>.</p> <p><code>ACallback</code>: <code>TSdlTimerNSCallback</code> : The TSdlTimerNSCallback function to call when the specified <code>AInterval</code> elapses.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlAddTimerNS/#returns","title":"Returns","text":"<p><code>TSdlTimerID</code>: A timer ID.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlAddTimerNS/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlAddTimerNS/#see-also","title":"See Also","text":"<ul> <li>SdlAddTimer</li> <li>SdlRemoveTimer</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlAddTimerNS/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlDelay/","title":"SdlDelay","text":"<p>Wait a specified number of milliseconds before returning.</p> <p>This function waits a specified number of milliseconds before returning. It waits at least the specified time, but possibly longer due to OS scheduling. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlDelay/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>procedure SdlDelay(const AMilliSeconds: Integer); inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlDelay/#parameters","title":"Parameters","text":"<p><code>AMilliSeconds</code>: <code>Integer</code> : The number of milliseconds to delay.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlDelay/#see-also","title":"See Also","text":"<ul> <li>SdlDelayNS</li> <li>SdlDelayPrecise</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlDelay/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlDelayNS/","title":"SdlDelayNS","text":"<p>Wait a specified number of nanoseconds before returning.</p> <p>This function waits a specified number of nanoseconds before returning. It waits at least the specified time, but possibly longer due to OS scheduling. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlDelayNS/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>procedure SdlDelayNS(const ANanoSeconds: Int64); inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlDelayNS/#parameters","title":"Parameters","text":"<p><code>ANanoSeconds</code>: <code>Int64</code> : The number of nanoseconds to delay.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlDelayNS/#see-also","title":"See Also","text":"<ul> <li>SdlDelay</li> <li>SdlDelayPrecise</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlDelayNS/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlDelayPrecise/","title":"SdlDelayPrecise","text":"<p>Wait a specified number of nanoseconds before returning.</p> <p>This function waits a specified number of nanoseconds before returning. It will attempt to wait as close to the requested time as possible, busy waiting if necessary, but could return later due to OS scheduling. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlDelayPrecise/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>procedure SdlDelayPrecise(const ANanoSeconds: Int64); inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlDelayPrecise/#parameters","title":"Parameters","text":"<p><code>ANanoSeconds</code>: <code>Int64</code> : the number of nanoseconds to delay.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlDelayPrecise/#see-also","title":"See Also","text":"<ul> <li>SdlDelay</li> <li>SdlDelayNS</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlDelayPrecise/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlGetPerformanceCounter/","title":"SdlGetPerformanceCounter","text":"<p>Get the current value of the high resolution counter.</p> <p>This function is typically used for profiling.</p> <p>The counter values are only meaningful relative to each other. Differences between values can be converted to times by using SdlGetPerformanceFrequency. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlGetPerformanceCounter/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>function SdlGetPerformanceCounter: Int64; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlGetPerformanceCounter/#returns","title":"Returns","text":"<p><code>Int64</code>: The current counter value.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlGetPerformanceCounter/#see-also","title":"See Also","text":"<ul> <li>SdlGetPerformanceFrequency</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlGetPerformanceCounter/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlGetPerformanceFrequency/","title":"SdlGetPerformanceFrequency","text":"<p>Get the count per second of the high resolution counter. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlGetPerformanceFrequency/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>function SdlGetPerformanceFrequency: Int64; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlGetPerformanceFrequency/#returns","title":"Returns","text":"<p><code>Int64</code>: A platform-specific count per second.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlGetPerformanceFrequency/#see-also","title":"See Also","text":"<ul> <li>SdlGetPerformanceCounter</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlGetPerformanceFrequency/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlGetTicks/","title":"SdlGetTicks","text":"<p>Get the number of milliseconds since SDL library initialization. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlGetTicks/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>function SdlGetTicks: Int64; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlGetTicks/#returns","title":"Returns","text":"<p><code>Int64</code>: A signed 64-bit value representing the number of milliseconds since the SDL library initialized.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlGetTicks/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlMSToNS/","title":"SdlMSToNS","text":"<p>Convert milliseconds to nanoseconds. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlMSToNS/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>function SdlMSToNS(const AMilliSeconds: Integer): Int64; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlMSToNS/#parameters","title":"Parameters","text":"<p><code>AMilliSeconds</code>: <code>Integer</code> : The number of milliseconds to convert.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlMSToNS/#returns","title":"Returns","text":"<p><code>Int64</code>: AMilliSeconds, expressed in nanoseconds.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlMSToNS/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlNSToMS/","title":"SdlNSToMS","text":"<p>Convert nanoseconds to milliseconds. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlNSToMS/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>function SdlNSToMS(const ANanoSeconds: Int64): Integer; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlNSToMS/#parameters","title":"Parameters","text":"<p><code>ANanoSeconds</code>: <code>Int64</code> : the number of nanoseconds to convert.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlNSToMS/#returns","title":"Returns","text":"<p><code>Integer</code>: ANanoSeconds, expressed in milliseconds.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlNSToMS/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlNSToSeconds/","title":"SdlNSToSeconds","text":"<p>Convert nanoseconds to seconds. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlNSToSeconds/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>function SdlNSToSeconds(const ANanoSeconds: Int64): Double; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlNSToSeconds/#parameters","title":"Parameters","text":"<p><code>ANanoSeconds</code>: <code>Int64</code> : The number of nanoseconds to convert.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlNSToSeconds/#returns","title":"Returns","text":"<p><code>Double</code>: ANanoSeconds, expressed in seconds.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlNSToSeconds/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlNSToUS/","title":"SdlNSToUS","text":"<p>Convert nanoseconds to microseconds. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlNSToUS/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>function SdlNSToUS(const ANanoSeconds: Int64): Int64; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlNSToUS/#parameters","title":"Parameters","text":"<p><code>ANanoSeconds</code>: <code>Int64</code> : the number of nanoseconds to convert.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlNSToUS/#returns","title":"Returns","text":"<p><code>Int64</code>: ANanoSeconds, expressed in microseconds.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlNSToUS/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlRemoveTimer/","title":"SdlRemoveTimer","text":"<p>Remove a timer created with SdlAddTimer or SdlAddTimerNS. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlRemoveTimer/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>procedure SdlRemoveTimer(const AID: TSdlTimerID)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlRemoveTimer/#parameters","title":"Parameters","text":"<p><code>AID</code>: <code>TSdlTimerID</code> : The ID of the timer to remove.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlRemoveTimer/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlRemoveTimer/#see-also","title":"See Also","text":"<ul> <li>SdlAddTimer</li> <li>SdlAddTimerNS</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlRemoveTimer/#remarks","title":"Remarks","text":"<p>It is safe to call this routine from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlSecondsToNS/","title":"SdlSecondsToNS","text":"<p>Convert seconds to nanoseconds. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlSecondsToNS/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>function SdlSecondsToNS(const ASeconds: Double): Int64; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlSecondsToNS/#parameters","title":"Parameters","text":"<p><code>ASeconds</code>: <code>Double</code> : the number of seconds to convert.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlSecondsToNS/#returns","title":"Returns","text":"<p><code>Int64</code>: ASeconds, expressed in nanoseconds.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlSecondsToNS/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlUSToNS/","title":"SdlUSToNS","text":"<p>Convert microseconds to nanoseconds. </p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlUSToNS/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>function SdlUSToNS(const AMicroSeconds: Int64): Int64; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlUSToNS/#parameters","title":"Parameters","text":"<p><code>AMicroSeconds</code>: <code>Int64</code> : the number of microseconds to convert.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlUSToNS/#returns","title":"Returns","text":"<p><code>Int64</code>: AMicroSeconds, expressed in nanoseconds.</p>"},{"location":"Reference/Neslib.Sdl3.Time/routines/SdlUSToNS/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Time/types/TSdlTimerCallback/","title":"TSdlTimerCallback","text":"<p>Function prototype for the millisecond timer callback function.</p> <p>The callback function is passed the current timer interval and returns the next timer interval, in milliseconds. If the returned value is the same as the one passed in, the periodic alarm continues, otherwise a new alarm is scheduled. If the callback returns 0, the periodic alarm is canceled and will be removed. </p>"},{"location":"Reference/Neslib.Sdl3.Time/types/TSdlTimerCallback/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>type TSdlTimerCallback = function(const ATimerID: TSdlTimerID; \n  const AInterval: Integer): Integer of object\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/types/TSdlTimerCallback/#parameters","title":"Parameters","text":"<p><code>ATimerID</code>: <code>TSdlTimerID</code> : The current timer being processed.</p> <p><code>AInterval</code>: <code>Integer</code> : The current callback time interval.</p>"},{"location":"Reference/Neslib.Sdl3.Time/types/TSdlTimerCallback/#returns","title":"Returns","text":"<p><code>Integer</code>: The new callback time interval, or 0 to disable further runs of the callback.</p>"},{"location":"Reference/Neslib.Sdl3.Time/types/TSdlTimerCallback/#see-also","title":"See Also","text":"<ul> <li>SdlAddTimer</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Time/types/TSdlTimerCallback/#remarks","title":"Remarks","text":"<p>SDL may call this callback at any time from a background thread; the application is responsible for locking resources the callback touches that need to be protected. </p>"},{"location":"Reference/Neslib.Sdl3.Time/types/TSdlTimerID/","title":"TSdlTimerID","text":"<p>A timer ID. </p>"},{"location":"Reference/Neslib.Sdl3.Time/types/TSdlTimerID/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>type TSdlTimerID = SDL_TimerID\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/types/TSdlTimerNSCallback/","title":"TSdlTimerNSCallback","text":"<p>Function prototype for the nanosecond timer callback function.</p> <p>The callback function is passed the current timer interval and returns the next timer interval, in nanoseconds. If the returned value is the same as the one passed in, the periodic alarm continues, otherwise a new alarm is scheduled. If the callback returns 0, the periodic alarm is canceled and will be removed. </p>"},{"location":"Reference/Neslib.Sdl3.Time/types/TSdlTimerNSCallback/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Time</p> <pre><code>type TSdlTimerNSCallback = function(const ATimerID: TSdlTimerID; \n  const AInterval: Int64): Int64 of object\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Time/types/TSdlTimerNSCallback/#parameters","title":"Parameters","text":"<p><code>ATimerID</code>: <code>TSdlTimerID</code> : The current timer being processed.</p> <p><code>AInterval</code>: <code>Int64</code> : The current callback time interval.</p>"},{"location":"Reference/Neslib.Sdl3.Time/types/TSdlTimerNSCallback/#returns","title":"Returns","text":"<p><code>Int64</code>: The new callback time interval, or 0 to disable further runs of the callback.</p>"},{"location":"Reference/Neslib.Sdl3.Time/types/TSdlTimerNSCallback/#see-also","title":"See Also","text":"<ul> <li>SdlAddTimerNS</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Time/types/TSdlTimerNSCallback/#remarks","title":"Remarks","text":"<p>SDL may call this callback at any time from a background thread; the application is responsible for locking resources the callback touches that need to be protected. </p>"},{"location":"Reference/Neslib.Sdl3.Video/","title":"Neslib.Sdl3.Video","text":""},{"location":"Reference/Neslib.Sdl3.Video/#classes-records","title":"Classes &amp; Records","text":"Name Description TSdlCamera SDL Camera. TSdlCameraDriver Camera driver. TSdlCameraID This is a unique ID for a camera device for the time it is connected to the system, and is never reused for the lifetime of the application. TSdlCameraSpec The details of an output format for a camera device. TSdlColor A structure that represents a color as 8-bit RGBA components. TSdlColorF A structure that represents a color as floating-point RGBA components. TSdlDisplay A display. TSdlDisplayMode The record that defines a display mode. TSdlEgl For working with OpenGL in SDL. TSdlEglConfig An EGL config. TSdlEglDisplay An EGL display. TSdlEglSurface An EGL surface. TSdlGL For working with OpenGL in SDL. TSdlGLContext An OpenGL context. TSdlMetalView A a CAMetalLayer-backed NSView (macOS) or UIView (iOS/tvOS). TSdlPalette A set of indexed colors representing a palette. TSdlPixelFormatDetails Details about the format of a pixel. TSdlPoint The structure that defines a point (using integers). TSdlPointF The structure that defines a point (using floating-point values). TSdlRect A rectangle, with the origin at the upper left (using integers). TSdlRectF A rectangle, with the origin at the upper left (using floating-point values). TSdlRenderer Rendering state TSdlScreenSaver Screen saver functionality TSdlSize The structure that defines a size (using integers). TSdlSizeF The structure that defines a size (using floating-point values). TSdlSurface A collection of pixels used in software blitting. TSdlTexture An efficient driver-specific representation of pixel data. To create a texture, use TSdlRenderer.CreateTexture. TSdlVertex Vertex structure. TSdlVideoDriver A video driver. TSdlWindow A window."},{"location":"Reference/Neslib.Sdl3.Video/#types","title":"Types","text":"Name Description PSdlColor PSdlColorF PSdlDisplayMode PSdlPoint PSdlPointF PSdlRect PSdlRectF PSdlSize PSdlSizeF PSdlVertex PVkAllocationCallbacks TSdlArrayOrder Array component order, low byte -&gt; high byte. TSdlBitmapOrder Bitmap pixel order, high bit -&gt; low bit. TSdlBlendFactor The normalized factor used to multiply pixel components. TSdlBlendMode A set of blend modes used in drawing operations. TSdlBlendOperation The blend operation used when combining source and destination pixel components. TSdlCameraPermissionState Permission state of a camera. TSdlCameraPosition The position of camera in relation to system device. TSdlCapitalization Auto capitalization type. TSdlChromaLocation Colorspace chroma sample location. TSdlColorPrimaries Colorspace color primaries, as described by TSdlColorRange Colorspace color range, as described by TSdlColorspace Colorspace definitions. TSdlColorType Colorspace color type. TSdlDisplayID This is a unique ID for a display for the time it is connected to the system, and is never reused for the lifetime of the application. TSdlDisplayOrientation Display orientation values; the way a display is rotated. TSdlEglAttrib An EGL attribute, used when creating an EGL context. TSdlEglAttribArrayCallback EGL platform attribute initialization callback. TSdlEglInt An EGL integer attribute, used when creating an EGL surface. TSdlEglIntArrayCallback EGL surface/context attribute initialization callback. TSdlFlashOperation Window flash operation. TSdlFlipMode Flip mode. TSdlFlipModes Flip modes. TSdlGLAttr An enumeration of OpenGL configuration attributes. TSdlGLContextFlag Possible context flags. TSdlGLContextFlags Set of context flags to be set for the TSdlGLAttr.ContextFlags attribute. TSdlGLContextReleaseFlag Possible context release flags. TSdlGLContextReleaseFlags Possible values to be set for the TSdlGLAttr.ContextReleaseBehavior attribute. TSdlGLContextResetNotification Possible values to be set TSdlGLAttr.ContextReleaseNotification attribute. TSdlGLProfile Possible values to be set for the TSdlGLAttr.ContextProfileMask attribute. TSdlHitTestCallback Callback used for hit-testing. TSdlHitTestResult Possible return values from the TSdlWindow.SetHitTestCallback. TSdlIndexType The type of indices in an index array TSdlMatrixCoefficients Colorspace matrix coefficients. TSdlPackedLayout Packed component layout. TSdlPackedOrder Packed component order, high bit -&gt; low bit. TSdlPixelFormat Pixel format. TSdlPixelType Pixel type. TSdlRendererLogicalPresentation How the logical size is mapped to the output. TSdlRendererVsync Renderer vsync values. TSdlScaleMode Scaling mode. TSdlSurfaceFlag The flags on a TSdlSurface. TSdlSurfaceFlags A set of surface flags. TSdlSystemTheme System theme. TSdlTextInputType Text input type. TSdlTextureAccess The access pattern allowed for a texture. TSdlTransferCharacteristics Colorspace transfer characteristics. TSdlWindowFlag The flags on a window. TSdlWindowFlags A set of window flags. TSdlWindowID This is a unique ID for a window. TSdlWindowPos Horizontal or vertical position of a window. TSdlWindowSurfaceVsync Window surface vsync values. VkInstance VkPhysicalDevice VkSurfaceKHR"},{"location":"Reference/Neslib.Sdl3.Video/#routines","title":"Routines","text":"Name Description PremultiplyAlpha Premultiply the alpha on a block of pixels. SdlColor Create a color. SdlColorF Create a color. SdlConvert(Integer, Integer, TSdlPixelFormat, TSdlColorspace, TSdlProperties, Pointer, Integer, TSdlPixelFormat, TSdlColorspace, TSdlProperties, Pointer, Integer) Copy a block of pixels of one format and colorspace to another format and colorspace. SdlConvert(Integer, Integer, TSdlPixelFormat, TSdlColorspace, Pointer, Integer, TSdlPixelFormat, TSdlColorspace, Pointer, Integer) Copy a block of pixels of one format and colorspace to another format and colorspace. SdlConvert(Integer, Integer, TSdlPixelFormat, Pointer, Integer, TSdlPixelFormat, Pointer, Integer) Copy a block of pixels of one format to another format. SdlPoint(Integer, Integer) Create a TSdlPoint from X and Y values. SdlPoint(TPoint) Create a TSdlPoint from a TPoint. SdlPointF(Single, Single) Create a TSdlPointF from X and Y values. SdlPointF(TSdlPoint) Create a TSdlPointF from a TSdlPoint. SdlPointF(TPoint) Create a TSdlPointF from a TPoint. SdlPointF(TPointF) Create a TSdlPointF from a TPointF. SdlRect(TRect) Create a TSdlRect from a TRect. SdlRect(Integer, Integer, Integer, Integer) Create a TSdlRect from X, Y, W and H values. SdlRectF(TRectF) Create a TSdlRectF from a TRectF. SdlRectF(Single, Single, Single, Single) Create a TSdlRectF from X, Y, W and H values. SdlRectF(TSdlRect) Create a TSdlRectF from a TSdlRect. SdlRectF(TRect) Create a TSdlRectF from a TRect. SdlSize Create a TSdlSize from W and H values. SdlSizeF(TSdlSize) Create a TSdlSizeF from a TSdlSize. SdlSizeF(Single, Single) Create a TSdlSizeF from W and H values. SdlVulkanCreateSurface Create a Vulkan rendering surface for a window. SdlVulkanDestroySurface Destroy the Vulkan rendering surface of a window. SdlVulkanGetInstanceExtensions Get the Vulkan instance extensions needed for vkCreateInstance. SdlVulkanGetPresentationSupport Query support for presentation via a given physical device and queue family. SdlVulkanGetVkGetInstanceProcAddr Get the address of the <code>vkGetInstanceProcAddr</code> function. SdlVulkanLoadLibrary Dynamically load the Vulkan loader library. SdlVulkanUnloadLibrary Unload the Vulkan library previously loaded by SdlVulkanLoadLibrary."},{"location":"Reference/Neslib.Sdl3.Video/#constants","title":"Constants","text":"Name Description SDL_ALPHA_OPAQUE A fully opaque 8-bit alpha value. SDL_ALPHA_OPAQUE_FLOAT A fully opaque floating point alpha value. SDL_ALPHA_TRANSPARENT A fully transparent 8-bit alpha value. SDL_ALPHA_TRANSPARENT_FLOAT A fully transparent floating point alpha value. SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE The size, in pixels, of a single TSdlRenderer.DrawDebugText character. SDL_NO_COLOR_KEY Uses with TSdlSurface.ColorKey to disable the color key. SDL_SOFTWARE_RENDERER The name of the software renderer."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/","title":"TSdlCamera","text":"<p>SDL Camera. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlCamera = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#properties","title":"Properties","text":"Name Description Format The spec that a camera is using when generating images. ID The instance ID of this opened camera. PermissionState Whether camera access has been approved by the user. Properties The properties associated with the opened camera."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#methods","title":"Methods","text":"Name Description AcquireFrame Acquire a frame. Close Shut down camera processing and close the camera device. Open(TSdlCameraID, TSdlCameraSpec) Open a video recording device (a \"camera\"). Open(TSdlCameraID) Open a video recording device (a \"camera\") using its preferred format. ReleaseFrame Release a frame of video acquired from the camera."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#Format","title":"Format","text":"<p>The spec that a camera is using when generating images.</p> <p>Note that this might not be the native format of the hardware, as SDL might be converting to this format behind the scenes.</p> <p>If the system is waiting for the user to approve access to the camera, as some platforms require, this will raise an error, but this isn't necessarily a fatal error; you should either wait for an TSdlEventKind.CameraDeviceApproved (or TSdlEventKind.CameraDeviceDenied) event, or poll PermissionState occasionally. </p> <p><code>property Format: TSdlCameraSpec read GetFormat</code></p> <p>Type: <code>TSdlCameraSpec</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#see-also","title":"See Also","text":"<ul> <li>Open</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#remarks","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#ID","title":"ID","text":"<p>The instance ID of this opened camera. </p> <p><code>property ID: TSdlCameraID read GetID</code></p> <p>Type: <code>TSdlCameraID</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#see-also_1","title":"See Also","text":"<ul> <li>Open</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#remarks_1","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#PermissionState","title":"PermissionState","text":"<p>Whether camera access has been approved by the user.</p> <p>Cameras will not function between when the device is opened by the app and when the user permits access to the hardware. On some platforms, this presents as a popup dialog where the user has to explicitly approve access; on others the approval might be implicit and not alert the user at all.</p> <p>This property can be used to check the status of that approval. It will return <code>Waiting</code> if still waiting for user response, <code>Approved</code> if the camera is approved for use, and <code>Denied</code> if the user denied access.</p> <p>Instead of polling with this property, you can wait for a TSdlEventKind.CameraDeviceApproved (or TSdlEventKind.CameraDeviceDenied) event in the standard SDL event loop, which is guaranteed to be sent once when permission to use the camera is decided.</p> <p>If a camera is declined, there's nothing to be done but call Close to dispose of it. </p> <p><code>property PermissionState: TSdlCameraPermissionState read GetPermissionState</code></p> <p>Type: <code>TSdlCameraPermissionState</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#see-also_2","title":"See Also","text":"<ul> <li>Open</li> <li>Close</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#remarks_2","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#Properties","title":"Properties","text":"<p>The properties associated with the opened camera. </p> <p><code>property Properties: TSdlProperties read GetProperties</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#remarks_3","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#Equal","title":"Equal(TSdlCamera, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlCamera; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlCamera</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlCamera; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#returns_1","title":"Returns","text":"<p><code>TSdlCamera</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#NotEqual","title":"NotEqual(TSdlCamera, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlCamera; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlCamera</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#AcquireFrame","title":"AcquireFrame(UInt64)","text":"<p>Acquire a frame.</p> <p>The frame is a memory pointer to the image data, whose size and format are given by the spec requested when opening the device.</p> <p>This is a non blocking API. If there is a frame available, a non-nil surface is returned, and ATimestampNS will be filled with a non-zero value.</p> <p>Note that an error case can also return nil, but a nil by itself is normal and just signifies that a new frame is not yet available. Note that even if a camera device fails outright (a USB camera is unplugged while in use, etc), SDL will send an event separately to notify the app, but continue to provide blank frames at ongoing intervals until Close is called, so real failure here is almost always an out of memory condition.</p> <p>After use, the frame should be released with ReleaseFrame. If you don't do this, the system may stop providing more video!</p> <p>Do not call Free on the returned surface! It must be given back to the camera subsystem with ReleaseFrame!</p> <p>If the system is waiting for the user to approve access to the camera, as some platforms require, this will return nil (no frames available); you should either wait for an TSdlEventKind.CameraDeviceApproved (or TSdlEventKind.CameraDeviceDenied) event, or poll PermissionState occasionally. </p> <p><code>function AcquireFrame(out ATimestampNS: UInt64): TSdlSurface; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#parameters_3","title":"Parameters","text":"<p><code>ATimestampNS</code>: <code>UInt64</code> : Is set to the frame's timestamp.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#returns_3","title":"Returns","text":"<p><code>TSdlSurface</code>: A new frame of video on success, nil if none is currently available.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#see-also_3","title":"See Also","text":"<ul> <li>ReleaseFrame</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#remarks_4","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#Close","title":"Close","text":"<p>Shut down camera processing and close the camera device. </p> <p><code>procedure Close; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#see-also_4","title":"See Also","text":"<ul> <li>Open</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#remarks_5","title":"Remarks","text":"<p>It is safe to call this method from any thread, but no thread may reference the device once this method is called. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#Open_0","title":"Open(TSdlCameraID, TSdlCameraSpec)","text":"<p>Open a video recording device (a \"camera\").</p> <p>You can open the device with any reasonable spec, and if the hardware can't directly support it, it will convert data seamlessly to the requested format. This might incur overhead, including scaling of image data.</p> <p>You can see the exact specs a device can support without conversion with TSdlCameraID.SupportedFormats.</p> <p>SDL will not attempt to emulate framerate; it will try to set the hardware to the rate closest to the requested speed, but it won't attempt to limit or duplicate frames artificially; use Format to see the actual framerate of the opened the device, and check your timestamps if this is crucial to your app!</p> <p>Note that the camera is not usable until the user approves its use! On some platforms, the operating system will prompt the user to permit access to the camera, and they can choose Yes or No at that point. Until they do, the camera will not be usable. The app should either wait for an TSdlEventKind.CameraDeviceApproved (or TSdlEventKind.CameraDeviceDenied) event, or poll PermissionState occasionally until it returns <code>Approved</code> or <code>Denied</code>. On platforms that don't require explicit user approval (and perhaps in places where the user previously permitted access), the approval event might come immediately, but it might come seconds, minutes, or hours later! </p> <p><code>class function Open(const AInstanceID: TSdlCameraID; const ASpec: TSdlCameraSpec): TSdlCamera; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#parameters_4","title":"Parameters","text":"<p><code>AInstanceID</code>: <code>TSdlCameraID</code> : The camera device instance ID.</p> <p><code>ASpec</code>: <code>TSdlCameraSpec</code> : The desired format for data the device will provide.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#returns_4","title":"Returns","text":"<p><code>TSdlCamera</code>: The opened camera.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#see-also_5","title":"See Also","text":"<ul> <li>TSdlCameraID.Cameras</li> <li>Format</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#remarks_6","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#Open_1","title":"Open(TSdlCameraID)","text":"<p>Open a video recording device (a \"camera\") using its preferred format.</p> <p>This version will choose a format for you (and you can use TSdlSurface's conversion/scaling functions directly if necessary).</p> <p>You can use Format to get the actual data format. You can see the exact specs a device can support without conversion with TSdlCameraID.SupportedFormats.</p> <p>SDL will not attempt to emulate framerate; it will try to set the hardware to the rate closest to the requested speed, but it won't attempt to limit or duplicate frames artificially; use Format to see the actual framerate of the opened the device, and check your timestamps if this is crucial to your app!</p> <p>Note that the camera is not usable until the user approves its use! On some platforms, the operating system will prompt the user to permit access to the camera, and they can choose Yes or No at that point. Until they do, the camera will not be usable. The app should either wait for an TSdlEventKind.CameraDeviceApproved (or TSdlEventKind.CameraDeviceDenied) event, or poll PermissionState occasionally until it returns <code>Approved</code> or <code>Denied</code>. On platforms that don't require explicit user approval (and perhaps in places where the user previously permitted access), the approval event might come immediately, but it might come seconds, minutes, or hours later! </p> <p><code>class function Open(const AInstanceID: TSdlCameraID): TSdlCamera; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#parameters_5","title":"Parameters","text":"<p><code>AInstanceID</code>: <code>TSdlCameraID</code> : The camera device instance ID.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#returns_5","title":"Returns","text":"<p><code>TSdlCamera</code>: The opened camera.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#see-also_6","title":"See Also","text":"<ul> <li>TSdlCameraID.Cameras</li> <li>Format</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#remarks_7","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#ReleaseFrame","title":"ReleaseFrame(TSdlSurface)","text":"<p>Release a frame of video acquired from the camera.</p> <p>Let the back-end re-use the internal buffer for camera.</p> <p>This method must be called only on surface objects returned by AcquireFrame. This method should be called as quickly as possible after acquisition, as SDL keeps a small FIFO queue of surfaces for video frames; if surfaces aren't released in a timely manner, SDL may drop upcoming video frames from the camera.</p> <p>If the app needs to keep the surface for a significant time, they should make a copy of it and release the original.</p> <p>The app should not use the surface again after calling this function; assume the surface is freed and the pointer is invalid. </p> <p><code>procedure ReleaseFrame(const AFrame: TSdlSurface); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#parameters_6","title":"Parameters","text":"<p><code>AFrame</code>: <code>TSdlSurface</code> : The video frame surface to release.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#see-also_7","title":"See Also","text":"<ul> <li>AcquireFrame</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCamera/#remarks_8","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/","title":"TSdlCameraDriver","text":"<p>Camera driver. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlCameraDriver = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#properties","title":"Properties","text":"Name Description Current The current camera driver, or nil if no driver has been initialized.. DriverCount The number of built-in camera drivers. Drivers The built in camera drivers. Name The name of a built in camera driver."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#Current","title":"Current","text":"<p>The current camera driver, or nil if no driver has been initialized.. </p> <p><code>class property Current: TSdlCameraDriver read GetCurrent</code></p> <p>Type: <code>TSdlCameraDriver</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#remarks","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#DriverCount","title":"DriverCount","text":"<p>The number of built-in camera drivers.</p> <p>This property returns a hardcoded number. This never returns a negative value; if there are no drivers compiled into this build of SDL, this function returns zero. The presence of a driver in this list does not mean it will function, it just means SDL is capable of interacting with that interface. For example, a build of SDL might have v4l2 support, but if there's no kernel support available, SDL's v4l2 driver would fail if used.</p> <p>By default, SDL tries all drivers, in its preferred order, until one is found to be usable. </p> <p><code>class property DriverCount: Integer read GetDriverCount</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#see-also","title":"See Also","text":"<ul> <li>Drivers</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#remarks_1","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#Drivers","title":"Drivers","text":"<p>The built in camera drivers.</p> <p>The list of camera drivers is given in the order that they are normally initialized by default; the drivers that seem more reasonable to choose first (as far as the SDL developers believe) are earlier in the list. </p> <p><code>class property Drivers[const AIndex: Integer]: TSdlCameraDriver read GetDriver</code></p> <p>Type: <code>TSdlCameraDriver</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#see-also_1","title":"See Also","text":"<ul> <li>DriverCount</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#remarks_2","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#Name","title":"Name","text":"<p>The name of a built in camera driver.</p> <p>The list of camera drivers is given in the order that they are normally initialized by default; the drivers that seem more reasonable to choose first (as far as the SDL developers believe) are earlier in the list.</p> <p>The names of drivers are all simple, low-ASCII identifiers, like \"v4l2\", \"coremedia\" or \"android\". These never have Unicode characters, and are not meant to be proper names. </p> <p><code>property Name: String read FName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#Equal","title":"Equal(TSdlCameraDriver, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlCameraDriver; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlCameraDriver</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlCameraDriver; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#returns_1","title":"Returns","text":"<p><code>TSdlCameraDriver</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#NotEqual","title":"NotEqual(TSdlCameraDriver, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlCameraDriver; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlCameraDriver</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraDriver/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/","title":"TSdlCameraID","text":"<p>This is a unique ID for a camera device for the time it is connected to the system, and is never reused for the lifetime of the application.</p> <p>If the device is disconnected and reconnected, it will get a new ID.</p> <p>The value 0 is an invalid ID. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlCameraID = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#see-also","title":"See Also","text":"<ul> <li>TSdlCameraID.Cameras</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#properties","title":"Properties","text":"Name Description Cameras A list of currently connected camera devices. Name The human-readable device name for the camera. Position The position of the camera in relation to the system. SupportedFormats The list of native formats/sizes the camera supports."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>0</code>. Implicit Used to set the value to <code>0</code>. NotEqual Used to compare against <code>0</code>."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#Cameras","title":"Cameras","text":"<p>A list of currently connected camera devices. </p> <p><code>class property Cameras: TArray&lt;TSdlCameraID&gt; read GetCameras</code></p> <p>Type: <code>TArray&lt;TSdlCameraID&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#see-also_1","title":"See Also","text":"<ul> <li>TSdlCamera.Open</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#remarks","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#Name","title":"Name","text":"<p>The human-readable device name for the camera. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#see-also_2","title":"See Also","text":"<ul> <li>Cameras</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#remarks_1","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#Position","title":"Position","text":"<p>The position of the camera in relation to the system.</p> <p>Most platforms will report Unknown, but mobile devices, like phones, can often make a distinction between cameras on the front of the device (that points towards the user, for taking \"selfies\") and cameras on the back (for filming in the direction the user is facing). </p> <p><code>property Position: TSdlCameraPosition read GetPosition</code></p> <p>Type: <code>TSdlCameraPosition</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#see-also_3","title":"See Also","text":"<ul> <li>Cameras</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#remarks_2","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#SupportedFormats","title":"SupportedFormats","text":"<p>The list of native formats/sizes the camera supports.</p> <p>This returns a list of all formats and frame sizes that a specific camera can offer. This is useful if your app can accept a variety of image formats and sizes and so want to find the optimal spec that doesn't require conversion.</p> <p>This property isn't strictly required; if you call TSdlCamera.Open with a nil spec, SDL will choose a native format for you, and if you instead specify a desired format, it will transparently convert to the requested format on your behalf.</p> <p>Note that it's legal for a camera to supply an empty list. </p> <p><code>property SupportedFormats: TArray&lt;TSdlCameraSpec&gt; read GetSupportedFormats</code></p> <p>Type: <code>TArray&lt;TSdlCameraSpec&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#see-also_4","title":"See Also","text":"<ul> <li>Cameras</li> <li>TSdlCamera.Open</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#remarks_3","title":"Remarks","text":"<p>It is safe to use this property from any thread </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#Equal","title":"Equal(TSdlCameraID, Cardinal)","text":"<p>Used to compare against <code>0</code>. </p> <p><code>class operator Equal(const ALeft: TSdlCameraID; const ARight: Cardinal): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlCameraID</code></p> <p><code>ARight</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#Implicit","title":"Implicit(Cardinal)","text":"<p>Used to set the value to <code>0</code>. </p> <p><code>class operator Implicit(const AValue: Cardinal): TSdlCameraID; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#returns_1","title":"Returns","text":"<p><code>TSdlCameraID</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#NotEqual","title":"NotEqual(TSdlCameraID, Cardinal)","text":"<p>Used to compare against <code>0</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlCameraID; const ARight: Cardinal): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlCameraID</code></p> <p><code>ARight</code>: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraID/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraSpec/","title":"TSdlCameraSpec","text":"<p>The details of an output format for a camera device.</p> <p>Cameras often support multiple formats; each one will be encapsulated in this struct. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraSpec/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlCameraSpec = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraSpec/#see-also","title":"See Also","text":"<ul> <li>TSdlCameraID.SupportedFormats</li> <li>TSdlCamera.Format</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraSpec/#properties","title":"Properties","text":"Name Description Colorspace Frame colorspace Format Frame format FrameDurationMs Frame duration in Ms FrameRate Frame rate (frames per second) FrameRateDenominator Frame rate demoninator. ((Num / Denom) = FPS, (Denom / Num) = duration in seconds) FrameRateNumerator Frame rate numerator. ((Num / Denom) = FPS, (Denom / Num) = duration in seconds) Height Frame height Width Frame width"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraSpec/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraSpec/#Colorspace","title":"Colorspace","text":"<p>Frame colorspace </p> <p><code>property Colorspace: TSdlColorspace read GetColorspace</code></p> <p>Type: <code>TSdlColorspace</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraSpec/#Format","title":"Format","text":"<p>Frame format </p> <p><code>property Format: TSdlPixelFormat read GetFormat</code></p> <p>Type: <code>TSdlPixelFormat</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraSpec/#FrameDurationMs","title":"FrameDurationMs","text":"<p>Frame duration in Ms </p> <p><code>property FrameDurationMs: Double read GetFrameDurationMs</code></p> <p>Type: <code>Double</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraSpec/#FrameRate","title":"FrameRate","text":"<p>Frame rate (frames per second) </p> <p><code>property FrameRate: Double read GetFrameRate</code></p> <p>Type: <code>Double</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraSpec/#FrameRateDenominator","title":"FrameRateDenominator","text":"<p>Frame rate demoninator. ((Num / Denom) = FPS, (Denom / Num) = duration in seconds) </p> <p><code>property FrameRateDenominator: Integer read GetFrameRateDenominator</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraSpec/#FrameRateNumerator","title":"FrameRateNumerator","text":"<p>Frame rate numerator. ((Num / Denom) = FPS, (Denom / Num) = duration in seconds) </p> <p><code>property FrameRateNumerator: Integer read GetFrameRateNumerator</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraSpec/#Height","title":"Height","text":"<p>Frame height </p> <p><code>property Height: Integer read GetHeight</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlCameraSpec/#Width","title":"Width","text":"<p>Frame width </p> <p><code>property Width: Integer read GetWidth</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/","title":"TSdlColor","text":"<p>A structure that represents a color as 8-bit RGBA components.</p> <p>The bits of this structure can be directly reinterpreted as an integer-packed color which uses the TSdlPixelFormat.Rgba32 format (TSdlPixelFormat.Abgr8888 on little-endian systems and TSdlPixelFormat.Rgba8888 on big-endian systems). </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlColor = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#fields","title":"Fields","text":"Name Description A B G R"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#constructors","title":"Constructors","text":"Name Description Create Create a color."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#methods","title":"Methods","text":"Name Description Init Initializes the a color."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#A","title":"A","text":"<p><code>var A: Byte</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#B","title":"B","text":"<p><code>var B: Byte</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#G","title":"G","text":"<p><code>var G: Byte</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#R","title":"R","text":"<p><code>var R: Byte</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#Create","title":"<code>Create</code>","text":"<p>Create a color. </p> <p><code>constructor Create(const AR, AG, AB: Byte; const AA: Byte = 255)</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#parameters","title":"Parameters","text":"<p><code>AR</code>: <code>Byte</code> : The red value.</p> <p><code>AG</code>: <code>Byte</code> : The green value.</p> <p><code>AB</code>: <code>Byte</code> : The blue value.</p> <p><code>AA</code>: <code>Byte = 255</code> : (Optional) alpha value. Defaults to 255</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#remarks","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#Init","title":"Init(Byte, Byte, Byte, Byte)","text":"<p>Initializes the a color. </p> <p><code>procedure Init(const AR, AG, AB: Byte; const AA: Byte = 255); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#parameters_1","title":"Parameters","text":"<p><code>AR</code>: <code>Byte</code> : The red value.</p> <p><code>AG</code>: <code>Byte</code> : The green value.</p> <p><code>AB</code>: <code>Byte</code> : The blue value.</p> <p><code>AA</code>: <code>Byte = 255</code> : (Optional) alpha value. Defaults to 255</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColor/#remarks_1","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/","title":"TSdlColorF","text":"<p>A structure that represents a color as floating-point RGBA components.</p> <p>The bits of this structure can be directly reinterpreted as a float-packed color which uses the TSdlPixelFormat.Rgba128Float format. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlColorF = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#fields","title":"Fields","text":"Name Description A B G R"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#constructors","title":"Constructors","text":"Name Description Create Create a color."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#methods","title":"Methods","text":"Name Description Init Initializes the a color."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#A","title":"A","text":"<p><code>var A: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#B","title":"B","text":"<p><code>var B: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#G","title":"G","text":"<p><code>var G: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#R","title":"R","text":"<p><code>var R: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#Create","title":"<code>Create</code>","text":"<p>Create a color. </p> <p><code>constructor Create(const AR, AG, AB: Single; const AA: Single = 1)</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#parameters","title":"Parameters","text":"<p><code>AR</code>: <code>Single</code> : The red value.</p> <p><code>AG</code>: <code>Single</code> : The green value.</p> <p><code>AB</code>: <code>Single</code> : The blue value.</p> <p><code>AA</code>: <code>Single = 1</code> : (Optional) alpha value. Defaults to 1.0</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#remarks","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#Init","title":"Init(Single, Single, Single, Single)","text":"<p>Initializes the a color. </p> <p><code>procedure Init(const AR, AG, AB: Single; const AA: Single = 1); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#parameters_1","title":"Parameters","text":"<p><code>AR</code>: <code>Single</code> : The red value.</p> <p><code>AG</code>: <code>Single</code> : The green value.</p> <p><code>AB</code>: <code>Single</code> : The blue value.</p> <p><code>AA</code>: <code>Single = 1</code> : (Optional) alpha value. Defaults to 1.0</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlColorF/#remarks_1","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/","title":"TSdlDisplay","text":"<p>A display. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlDisplay = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#properties","title":"Properties","text":"Name Description Bounds The desktop area represented by the display. ContentScale The content scale of a display. Count The number of currently connected displays. CurrentMode Information about the current display mode. CurrentOrientation The orientation of a display or TSdlDisplayOrientation.Unknown if it isn't available. DesktopMode Information about the desktop's display mode. Displays The currently connected displays. FullScreenModes An array of fullscreen display modes available on the display. HdrEnabled True if the display has HDR headroom above the SDR white point. This is for informational and diagnostic purposes only, as not all platforms provide this information at the display level. Name The name of a display. NaturalOrientation The orientation of a display when it is unrotated or TSdlDisplayOrientation.Unknown if it isn't available. Primary The primary display. UsableBounds The usable desktop area represented by the display, in screen coordinates."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#methods","title":"Methods","text":"Name Description ForPoint Get the display containing a point. ForRect Get the display primarily containing a rect. GetClosestFullscreenMode Get the closest match to the requested display mode."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#Bounds","title":"Bounds","text":"<p>The desktop area represented by the display.</p> <p>The primary display is often located at (0,0), but may be placed at a different location depending on monitor layout. </p> <p><code>property Bounds: TSdlRect read GetBounds</code></p> <p>Type: <code>TSdlRect</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#see-also","title":"See Also","text":"<ul> <li>UsableBounds</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#remarks","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#ContentScale","title":"ContentScale","text":"<p>The content scale of a display.</p> <p>The content scale is the expected scale for content based on the DPI settings of the display. For example, a 4K display might have a 2.0 (200%) display scale, which means that the user expects UI elements to be twice as big on this display, to aid in readability.</p> <p>After window creation, TSdlWindow.DisplayScale should be used to query the content scale factor for individual windows instead of querying the display for a window and using this property, as the per-window content scale factor may differ from the base value of the display it is on, particularly on high-DPI and/or multi-monitor desktop configurations. </p> <p><code>property ContentScale: Single read GetContentScale</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#see-also_1","title":"See Also","text":"<ul> <li>TSdlWindow.DisplayScale</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#remarks_1","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#Count","title":"Count","text":"<p>The number of currently connected displays. </p> <p><code>class property Count: Integer read GetCount</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#remarks_2","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#CurrentMode","title":"CurrentMode","text":"<p>Information about the current display mode.</p> <p>There's a difference between this function and DesktopMode when SDL runs fullscreen and has changed the resolution. In that case this function will return the current display mode, and not the previous native display mode. </p> <p><code>property CurrentMode: TSdlDisplayMode read GetCurrentMode</code></p> <p>Type: <code>TSdlDisplayMode</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#see-also_2","title":"See Also","text":"<ul> <li>DesktopMode</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#remarks_3","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#CurrentOrientation","title":"CurrentOrientation","text":"<p>The orientation of a display or TSdlDisplayOrientation.Unknown if it isn't available. </p> <p><code>property CurrentOrientation: TSdlDisplayOrientation read GetCurrentOrientation</code></p> <p>Type: <code>TSdlDisplayOrientation</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#remarks_4","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#DesktopMode","title":"DesktopMode","text":"<p>Information about the desktop's display mode.</p> <p>There's a difference between this property and CurrentMode when SDL runs fullscreen and has changed the resolution. In that case this property will return the previous native display mode, and not the current display mode. </p> <p><code>property DesktopMode: TSdlDisplayMode read GetDesktopMode</code></p> <p>Type: <code>TSdlDisplayMode</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#see-also_3","title":"See Also","text":"<ul> <li>CurrentMode</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#remarks_5","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#Displays","title":"Displays","text":"<p>The currently connected displays. </p> <p><code>class property Displays[const AIndex: Integer]: TSdlDisplay read GetDisplay; default</code></p> <p>Type: <code>TSdlDisplay</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#remarks_6","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#FullScreenModes","title":"FullScreenModes","text":"<p>An array of fullscreen display modes available on the display.</p> <p>The display modes are sorted in this priority:</p> <ul> <li>W -&gt; largest to smallest</li> <li>H -&gt; largest to smallest</li> <li>Bits per pixel -&gt; more colors to fewer colors</li> <li>Packed pixel layout -&gt; largest to smallest</li> <li>Refresh rate -&gt; highest to lowest</li> <li>Pixel density -&gt; lowest to highest </li> </ul> <p><code>property FullScreenModes: TArray&lt;TSdlDisplayMode&gt; read GetFullScreenModes</code></p> <p>Type: <code>TArray&lt;TSdlDisplayMode&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#exceptions_6","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#remarks_7","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#HdrEnabled","title":"HdrEnabled","text":"<p>True if the display has HDR headroom above the SDR white point. This is for informational and diagnostic purposes only, as not all platforms provide this information at the display level. </p> <p><code>property HdrEnabled: Boolean read GetHdrEnabled</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#exceptions_7","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#remarks_8","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#Name","title":"Name","text":"<p>The name of a display. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#exceptions_8","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#remarks_9","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#NaturalOrientation","title":"NaturalOrientation","text":"<p>The orientation of a display when it is unrotated or TSdlDisplayOrientation.Unknown if it isn't available. </p> <p><code>property NaturalOrientation: TSdlDisplayOrientation read GetNaturalOrientation</code></p> <p>Type: <code>TSdlDisplayOrientation</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#remarks_10","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#Primary","title":"Primary","text":"<p>The primary display. </p> <p><code>class property Primary: TSdlDisplay read GetPrimary</code></p> <p>Type: <code>TSdlDisplay</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#exceptions_9","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#remarks_11","title":"Remarks","text":"<p>This function should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#UsableBounds","title":"UsableBounds","text":"<p>The usable desktop area represented by the display, in screen coordinates.</p> <p>This is the same area as Bounds, but with portions reserved by the system removed. For example, on Apple's macOS, this subtracts the area occupied by the menu bar and dock.</p> <p>Setting a window to be fullscreen generally bypasses these unusable areas, so these are good guidelines for the maximum space available to a non-fullscreen window. </p> <p><code>property UsableBounds: TSdlRect read GetUsableBounds</code></p> <p>Type: <code>TSdlRect</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#exceptions_10","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#see-also_4","title":"See Also","text":"<ul> <li>Bounds</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#remarks_12","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#ForPoint","title":"ForPoint(TSdlPoint)","text":"<p>Get the display containing a point. </p> <p><code>class function ForPoint(const APoint: TSdlPoint): TSdlDisplay; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#exceptions_11","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#parameters","title":"Parameters","text":"<p><code>APoint</code>: <code>TSdlPoint</code> : the point to query.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#returns","title":"Returns","text":"<p><code>TSdlDisplay</code>: The display containing the point.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#see-also_5","title":"See Also","text":"<ul> <li>Bounds</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#remarks_13","title":"Remarks","text":"<p>This function should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#ForRect","title":"ForRect(TSdlRect)","text":"<p>Get the display primarily containing a rect. </p> <p><code>class function ForRect(const ARect: TSdlRect): TSdlDisplay; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#exceptions_12","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#parameters_1","title":"Parameters","text":"<p><code>ARect</code>: <code>TSdlRect</code> : the rect to query.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#returns_1","title":"Returns","text":"<p><code>TSdlDisplay</code>: The display entirely containing the rect or closest to the center of the rect on success.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#see-also_6","title":"See Also","text":"<ul> <li>Bounds</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#remarks_14","title":"Remarks","text":"<p>This function should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#GetClosestFullscreenMode","title":"GetClosestFullscreenMode(Integer, Integer, Single, Boolean)","text":"<p>Get the closest match to the requested display mode.</p> <p>The available display modes are scanned and the closest mode matching the requested mode is returned. The mode format and refresh rate default to the desktop mode if they are set to 0. The modes are scanned with size being first priority, format being second priority, and / finally checking the refresh rate. If all the available modes are too small, then false is returned. </p> <p><code>function GetClosestFullscreenMode(const AW, AH: Integer; const ARefreshRate: Single = 0; const AIncludeHighDensityModes: Boolean = False): TSdlDisplayMode; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#exceptions_13","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#parameters_2","title":"Parameters","text":"<p><code>AW</code>: <code>Integer</code> : The width in pixels of the desired display mode.</p> <p><code>AH</code>: <code>Integer</code> : The height in pixels of the desired display mode.</p> <p><code>ARefreshRate</code>: <code>Single = 0</code> : (optional) Refresh rate of the desired display mode, or 0.0 (default) for the desktop refresh rate.</p> <p><code>AIncludeHighDensityModes</code>: <code>Boolean = False</code> : (optional) Whether to include high density modes in the search (default False).</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#returns_2","title":"Returns","text":"<p><code>TSdlDisplayMode</code>: The closest display mode equal to or larger than the desired mode.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#see-also_7","title":"See Also","text":"<ul> <li>FullscreenModes</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplay/#remarks_15","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplayMode/","title":"TSdlDisplayMode","text":"<p>The record that defines a display mode. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplayMode/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlDisplayMode = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplayMode/#see-also","title":"See Also","text":"<ul> <li>TSdlDisplay.FullscreenModes</li> <li>TSdlDisplay.DesktopMode</li> <li>TSdlDisplay.CurrentMode</li> <li>TSdlWindow.FullscreenMode</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplayMode/#remarks","title":"Remarks","text":"<p>This struct is available since SDL 3.2.0. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplayMode/#properties","title":"Properties","text":"Name Description DisplayID The display this mode is associated with Format Pixel format H Height PixelDdensity Scale converting size to pixels (e.g. a 1920x1080 mode with 2.0 scale would have 3840x2160 pixels) RefreshRate Refresh rate (or 0.0f for unspecified) RefreshRateDenominator Precise refresh rate denominator RefreshRateNumerator Precise refresh rate numerator (or 0 for unspecified) W Width"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplayMode/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplayMode/#DisplayID","title":"DisplayID","text":"<p>The display this mode is associated with</p> <p><code>property DisplayID: TSdlDisplayID read FHandle.displayID</code></p> <p>Type: <code>TSdlDisplayID</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplayMode/#Format","title":"Format","text":"<p>Pixel format</p> <p><code>property Format: TSdlPixelFormat read GetFormat</code></p> <p>Type: <code>TSdlPixelFormat</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplayMode/#H","title":"H","text":"<p>Height</p> <p><code>property H: Integer read FHandle.h</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplayMode/#PixelDdensity","title":"PixelDdensity","text":"<p>Scale converting size to pixels (e.g. a 1920x1080 mode with 2.0 scale would have 3840x2160 pixels)</p> <p><code>property PixelDdensity: Single read FHandle.pixel_density</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplayMode/#RefreshRate","title":"RefreshRate","text":"<p>Refresh rate (or 0.0f for unspecified)</p> <p><code>property RefreshRate: Single read FHandle.refresh_rate</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplayMode/#RefreshRateDenominator","title":"RefreshRateDenominator","text":"<p>Precise refresh rate denominator</p> <p><code>property RefreshRateDenominator: Integer read FHandle.refresh_rate_denominator</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplayMode/#RefreshRateNumerator","title":"RefreshRateNumerator","text":"<p>Precise refresh rate numerator (or 0 for unspecified)</p> <p><code>property RefreshRateNumerator: Integer read FHandle.refresh_rate_numerator</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlDisplayMode/#W","title":"W","text":"<p>Width</p> <p><code>property W: Integer read FHandle.w</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEgl/","title":"TSdlEgl","text":"<p>For working with OpenGL in SDL. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEgl/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlEgl = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEgl/#methods","title":"Methods","text":"Name Description GetProcAddress Get an EGL library function by name. SetAttributeCallbacks Sets the callbacks for defining custom EGLAttrib arrays for EGL initialization."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEgl/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEgl/#GetProcAddress","title":"GetProcAddress(String)","text":"<p>Get an EGL library function by name.</p> <p>If an EGL library is loaded, this function allows applications to get entry points for EGL functions. This is useful to provide to an EGL API and extension loader. </p> <p><code>class function GetProcAddress(const AProc: String): Pointer; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEgl/#parameters","title":"Parameters","text":"<p><code>AProc</code>: <code>String</code> : The name of an EGL function.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEgl/#returns","title":"Returns","text":"<p><code>Pointer</code>: A pointer to the named EGL function. The returned pointer should be cast to the appropriate function signature.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEgl/#see-also","title":"See Also","text":"<ul> <li>TSdlEglDisplay.Current</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEgl/#remarks","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEgl/#SetAttributeCallbacks","title":"SetAttributeCallbacks(TSdlEglAttribArrayCallback, TSdlEglIntArrayCallback, TSdlEglIntArrayCallback)","text":"<p>Sets the callbacks for defining custom EGLAttrib arrays for EGL initialization.</p> <p>Callbacks that aren't needed can be set to <code>nil</code>.</p> <p>NOTE: These callback pointers will be reset after TSdlGL.ResetAttributes. </p> <p><code>class procedure SetAttributeCallbacks(const APlatformAttribCallback: TSdlEglAttribArrayCallback; const ASurfaceAttribCallback, AContextAttribCallback: TSdlEglIntArrayCallback); static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEgl/#parameters_1","title":"Parameters","text":"<p><code>APlatformAttribCallback</code>: <code>TSdlEglAttribArrayCallback</code> : Callback for attributes to pass to eglGetPlatformDisplay. May be nil.</p> <p><code>ASurfaceAttribCallback</code>: <code>TSdlEglIntArrayCallback</code> : Callback for attributes to pass to eglCreateSurface. May be nil.</p> <p><code>AContextAttribCallback</code>: <code>TSdlEglIntArrayCallback</code> : Callback for attributes to pass to eglCreateContext. May be nil.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEgl/#remarks_1","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/","title":"TSdlEglConfig","text":"<p>An EGL config. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlEglConfig = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#properties","title":"Properties","text":"Name Description Current The currently active EGL config."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#Current","title":"Current","text":"<p>The currently active EGL config. </p> <p><code>class property Current: TSdlEglConfig read GetCurrent</code></p> <p>Type: <code>TSdlEglConfig</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#remarks","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#Equal","title":"Equal(TSdlEglConfig, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlEglConfig; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlEglConfig</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlEglConfig; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#returns_1","title":"Returns","text":"<p><code>TSdlEglConfig</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#NotEqual","title":"NotEqual(TSdlEglConfig, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlEglConfig; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlEglConfig</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglConfig/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/","title":"TSdlEglDisplay","text":"<p>An EGL display. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlEglDisplay = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#properties","title":"Properties","text":"Name Description Current The currently active EGL display."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#Current","title":"Current","text":"<p>The currently active EGL display. </p> <p><code>class property Current: TSdlEglDisplay read GetCurrent</code></p> <p>Type: <code>TSdlEglDisplay</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#remarks","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#Equal","title":"Equal(TSdlEglDisplay, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlEglDisplay; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlEglDisplay</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlEglDisplay; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#returns_1","title":"Returns","text":"<p><code>TSdlEglDisplay</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#NotEqual","title":"NotEqual(TSdlEglDisplay, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlEglDisplay; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlEglDisplay</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglDisplay/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/","title":"TSdlEglSurface","text":"<p>An EGL surface. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlEglSurface = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#methods","title":"Methods","text":"Name Description ForWindow Get the EGL surface associated with the window."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#Equal","title":"Equal(TSdlEglSurface, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlEglSurface; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlEglSurface</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlEglSurface; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#returns_1","title":"Returns","text":"<p><code>TSdlEglSurface</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#NotEqual","title":"NotEqual(TSdlEglSurface, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlEglSurface; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlEglSurface</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#ForWindow","title":"ForWindow(TSdlWindow)","text":"<p>Get the EGL surface associated with the window. </p> <p><code>class function ForWindow(const AWindow: TSdlWindow): TSdlEglSurface; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#parameters_3","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : The window to query.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#returns_3","title":"Returns","text":"<p><code>TSdlEglSurface</code>: The EGL surface associated with the window.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlEglSurface/#remarks","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/","title":"TSdlGL","text":"<p>For working with OpenGL in SDL. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlGL = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#properties","title":"Properties","text":"Name Description Attributes OpenGL window attributes. CurrentWindow The currently active OpenGL window. SwapInterval The swap interval for the current OpenGL context."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#methods","title":"Methods","text":"Name Description GetProcAddress Get an OpenGL function by name. IsExtensionSupported Check if an OpenGL extension is supported for the current context. LoadLibrary Dynamically load an OpenGL library. ResetAttributes Reset all previously set OpenGL context attributes to their default values. SwapWindow Update a window with OpenGL rendering. UnloadLibrary Unload the OpenGL library previously loaded by LoadLibrary."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#Attributes","title":"Attributes","text":"<p>OpenGL window attributes.</p> <p>You should set these before window creation.</p> <p>You shouls get these after creating the OpenGL context, since the values obtained can differ from the requested ones. </p> <p><code>class property Attributes[const AAttr: TSdlGLAttr]: Integer read GetAttribute write SetAttribute</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#see-also","title":"See Also","text":"<ul> <li>ResetAttributes</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#remarks","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#CurrentWindow","title":"CurrentWindow","text":"<p>The currently active OpenGL window. </p> <p><code>class property CurrentWindow: TSdlWindow read GetCurrentWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#remarks_1","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#SwapInterval","title":"SwapInterval","text":"<p>The swap interval for the current OpenGL context.</p> <p>Some systems allow specifying -1 for the interval, to enable adaptive vsync. Adaptive vsync works the same as vsync, but if you've already missed the vertical retrace for a given frame, it swaps buffers immediately, which might be less jarring for the user during occasional framerate drops. If an application requests adaptive vsync and the system does not support it, this function will fail and return false. In such a case, you should probably retry the call with 1 for the interval.</p> <p>Adaptive vsync is implemented for some glX drivers with GLX_EXT_swap_control_tear, and for some Windows drivers with WGL_EXT_swap_control_tear.</p> <p>If the system can't determine the swap interval, or there isn't a valid current context, this property will return 0 as a safe default.</p> <p>Read more on the  Khronos wiki. </p> <p><code>class property SwapInterval: Integer read GetSwapInterval write SetSwapInterval</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#remarks_2","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#GetProcAddress","title":"GetProcAddress(String)","text":"<p>Get an OpenGL function by name.</p> <p>If the GL library is loaded at runtime with LoadLibrary, then all GL functions must be retrieved this way. Usually this is used to retrieve function pointers to OpenGL extensions.</p> <p>There are some quirks to looking up OpenGL functions that require some extra care from the application. If you code carefully, you can handle these quirks without any platform-specific code, though:</p> <ul> <li>On Windows, function pointers are specific to the current GL context; this means you need to have created a GL context and made it current before calling GetProcAddress. If you recreate your context or create a second context, you should assume that any existing function pointers aren't valid to use with it. This is (currently) a Windows-specific limitation, and in practice lots of drivers don't suffer this limitation, but it is still the way the wgl API is documented to work and you should expect crashes if you don't respect it. Store a copy of the function pointers that comes and goes with context lifespan.</li> <li>Some OpenGL drivers, on all platforms, will return <code>nil</code> if a function isn't supported, but you can't count on this behavior. Check for extensions you use, and if you get a <code>nil</code> anyway, act as if that extension wasn't available. This is probably a bug in the driver, but you can code defensively for this scenario anyhow.</li> <li>OpenGL function pointers must be declared <code>stdcall</code>, even when not running on Windows. This will ensure the proper calling convention is followed on platforms where this matters (Win32) thereby avoiding stack corruption. </li> </ul> <p><code>class function GetProcAddress(const AProc: String): Pointer; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#parameters","title":"Parameters","text":"<p><code>AProc</code>: <code>String</code> : The name of an OpenGL function.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#returns","title":"Returns","text":"<p><code>Pointer</code>: A pointer to the named OpenGL function. The returned pointer should be cast to the appropriate function signature.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#see-also_1","title":"See Also","text":"<ul> <li>IsExtensionSupported</li> <li>LoadLibrary</li> <li>UnloadLibrary</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#remarks_3","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#IsExtensionSupported","title":"IsExtensionSupported(String)","text":"<p>Check if an OpenGL extension is supported for the current context.</p> <p>This function operates on the current GL context; you must have created a context and it must be current before calling this function. Do not assume that all contexts you create will have the same set of extensions available, or that recreating an existing context will offer the same extensions again.</p> <p>While it's probably not a massive overhead, this function is not an O(1) operation. Check the extensions you care about after creating the GL context and save that information somewhere instead of calling the function every time you need to know. </p> <p><code>class function IsExtensionSupported(const AExtension: String): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#parameters_1","title":"Parameters","text":"<p><code>AExtension</code>: <code>String</code> : The name of the extension to check.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#returns_1","title":"Returns","text":"<p><code>Boolean</code>: True if the extension is supported, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#remarks_4","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#LoadLibrary","title":"LoadLibrary(String)","text":"<p>Dynamically load an OpenGL library.</p> <p>This should be done after initializing the video driver, but before creating any OpenGL windows. If no OpenGL library is loaded, the default library will be loaded upon creation of the first OpenGL window.</p> <p>If you do this, you need to retrieve all of the GL functions used in your program from the dynamic library using GetProcAddress. </p> <p><code>class procedure LoadLibrary(const APath: String); static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#parameters_2","title":"Parameters","text":"<p><code>APath</code>: <code>String</code> : The platform dependent OpenGL library name, or an empty string to open the default OpenGL library.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#see-also_2","title":"See Also","text":"<ul> <li>GetProcAddress</li> <li>UnloadLibrary</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#remarks_5","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#ResetAttributes","title":"ResetAttributes","text":"<p>Reset all previously set OpenGL context attributes to their default values. </p> <p><code>class procedure ResetAttributes; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#see-also_3","title":"See Also","text":"<ul> <li>Attributes</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#remarks_6","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#SwapWindow","title":"SwapWindow(TSdlWindow)","text":"<p>Update a window with OpenGL rendering.</p> <p>This is used with double-buffered OpenGL contexts, which are the default.</p> <p>On macOS, make sure you bind 0 to the draw framebuffer before swapping the window, otherwise nothing will happen. If you aren't using glBindFramebuffer, this is the default and you won't have to do anything extra. </p> <p><code>class procedure SwapWindow(const AWindow: TSdlWindow); inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#parameters_3","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : The window to change.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#remarks_7","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#UnloadLibrary","title":"UnloadLibrary","text":"<p>Unload the OpenGL library previously loaded by LoadLibrary. </p> <p><code>class procedure UnloadLibrary; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#see-also_4","title":"See Also","text":"<ul> <li>LoadLibrary</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGL/#remarks_8","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/","title":"TSdlGLContext","text":"<p>An OpenGL context. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlGLContext = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#properties","title":"Properties","text":"Name Description Current The currently active OpenGL context."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#constructors","title":"Constructors","text":"Name Description Create Create an OpenGL context for an OpenGL window, and make it current."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#methods","title":"Methods","text":"Name Description Free Free an OpenGL context. MakeCurrent Set up this OpenGL context for rendering into an OpenGL window."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#Current","title":"Current","text":"<p>The currently active OpenGL context. </p> <p><code>class property Current: TSdlGLContext read GetCurrent</code></p> <p>Type: <code>TSdlGLContext</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#see-also","title":"See Also","text":"<ul> <li>MakeCurrent</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#remarks","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#Create","title":"<code>Create</code>","text":"<p>Create an OpenGL context for an OpenGL window, and make it current.</p> <p>Windows users new to OpenGL should note that, for historical reasons, GL functions added after OpenGL version 1.1 are not available by default. Those functions must be loaded at run-time, either with an OpenGL extension-handling library or with TSdlGL.GetProcAddress and its related functions.</p> <p><code>constructor Create(const AWindow: TSdlWindow)</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#parameters","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : The window to associate with the context.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#see-also_1","title":"See Also","text":"<ul> <li>Free</li> <li>MakeCurrent</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#remarks_1","title":"Remarks","text":"<p>This constructor should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#Equal","title":"Equal(TSdlGLContext, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlGLContext; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#parameters_1","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGLContext</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlGLContext; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#parameters_2","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#returns_1","title":"Returns","text":"<p><code>TSdlGLContext</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#NotEqual","title":"NotEqual(TSdlGLContext, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlGLContext; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#parameters_3","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlGLContext</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#Free","title":"Free","text":"<p>Free an OpenGL context. </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#see-also_2","title":"See Also","text":"<ul> <li>Create</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#remarks_2","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#MakeCurrent","title":"MakeCurrent(TSdlWindow)","text":"<p>Set up this OpenGL context for rendering into an OpenGL window.</p> <p>This context must have been created with a compatible window. </p> <p><code>procedure MakeCurrent(const AWindow: TSdlWindow); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#parameters_4","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : The window to associate with the context.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlGLContext/#remarks_3","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/","title":"TSdlMetalView","text":"<p>A a CAMetalLayer-backed NSView (macOS) or UIView (iOS/tvOS). </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlMetalView = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#properties","title":"Properties","text":"Name Description Layer The (Objective-C) ID of the backing CAMetalLayer for this viuew. You can use TCAMetalLayer.Wrap to access this layer. View The (Objective-C) ID of this metal view. You can use TNSView.Wrap (on macOS) or TUIView.Wrap (on IOS) to get the underlying NSView or UIView."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#constructors","title":"Constructors","text":"Name Description Create Create a CAMetalLayer-backed NSView/UIView and attach it to the specified window."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#methods","title":"Methods","text":"Name Description Free Destroy this TSdlMetalView object."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#Layer","title":"Layer","text":"<p>The (Objective-C) ID of the backing CAMetalLayer for this viuew. You can use TCAMetalLayer.Wrap to access this layer. </p> <p><code>property Layer: Pointer read GetLayer</code></p> <p>Type: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#View","title":"View","text":"<p>The (Objective-C) ID of this metal view. You can use TNSView.Wrap (on macOS) or TUIView.Wrap (on IOS) to get the underlying NSView or UIView. </p> <p><code>property View: Pointer read GetView</code></p> <p>Type: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#Create","title":"<code>Create</code>","text":"<p>Create a CAMetalLayer-backed NSView/UIView and attach it to the specified window.</p> <p>On macOS, this does not associate a MTLDevice with the CAMetalLayer on its own. It is up to user code to do that.</p> <p>The View property can by cast to a NSView (macOS) or UIView (iOS) using TNSView.Wrap() or TUIView.Wrap(). To access the backing CAMetalLayer, use the Layer property and wrap it using TCAMetalLayer.Wrap(). </p> <p><code>constructor Create(const AWindow: TSdlWindow)</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#parameters","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : The window.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#see-also","title":"See Also","text":"<ul> <li>Free</li> <li>Layer</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#Equal","title":"Equal(TSdlMetalView, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlMetalView; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#parameters_1","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlMetalView</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlMetalView; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#parameters_2","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#returns_1","title":"Returns","text":"<p><code>TSdlMetalView</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#NotEqual","title":"NotEqual(TSdlMetalView, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlMetalView; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#parameters_3","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlMetalView</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlMetalView/#Free","title":"Free","text":"<p>Destroy this TSdlMetalView object.</p> <p>This should be called destroying the window, if it was created after the window was created.. </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/","title":"TSdlPalette","text":"<p>A set of indexed colors representing a palette. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlPalette = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#properties","title":"Properties","text":"Name Description Colors Poitner to an array of colors, <code>NumColors</code> long. NumColors Number of elements in <code>Colors</code>."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#constructors","title":"Constructors","text":"Name Description Create Create a palette with the specified number of color entries."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#methods","title":"Methods","text":"Name Description Free Free the palette. SetColors(TSdlColor[], Integer, Integer) Set a range of colors in a palette. SetColors(TArray&lt;TSdlColor&gt;, Integer, Integer) Set a range of colors in a palette."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#Colors","title":"Colors","text":"<p>Poitner to an array of colors, <code>NumColors</code> long.</p> <p><code>property Colors: PSdlColor read GetColors</code></p> <p>Type: <code>PSdlColor</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#NumColors","title":"NumColors","text":"<p>Number of elements in <code>Colors</code>.</p> <p><code>property NumColors: Integer read GetNumColors</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#Create","title":"<code>Create</code>","text":"<p>Create a palette with the specified number of color entries.</p> <p>The palette entries are initialized to white. </p> <p><code>constructor Create(const ANumColors: Integer)</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#parameters","title":"Parameters","text":"<p><code>ANumColors</code>: <code>Integer</code> : The number of color entries in the color palette.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#see-also","title":"See Also","text":"<ul> <li>Free</li> <li>SetColors</li> <li>TSdlSurface.Palette</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#remarks","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#Equal","title":"Equal(TSdlPalette, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlPalette; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#parameters_1","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlPalette</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlPalette; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#parameters_2","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#returns_1","title":"Returns","text":"<p><code>TSdlPalette</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#NotEqual","title":"NotEqual(TSdlPalette, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlPalette; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#parameters_3","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlPalette</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#Free","title":"Free","text":"<p>Free the palette. </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#remarks_1","title":"Remarks","text":"<p>It is safe to call this method from any thread, as long as the palette is not modified or destroyed in another thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#SetColors_0","title":"SetColors(TSdlColor[], Integer, Integer)","text":"<p>Set a range of colors in a palette. </p> <p><code>procedure SetColors(const AColors: array of TSdlColor; const AFirstColor: Integer = 0; const ANumColors: Integer = 0); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#parameters_4","title":"Parameters","text":"<p><code>AColors</code>: <code>array of TSdlColor</code> : A array of TSdlColor record to copy into the palette.</p> <p><code>AFirstColor</code>: <code>Integer = 0</code> : (Optional) index of the first palette entry to modify.</p> <p><code>ANumColors</code>: <code>Integer = 0</code> : (Optional) number of entries to modify. Use 0 (default) to se the length of AColors.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#remarks_2","title":"Remarks","text":"<p>It is safe to call this method from any thread, as long as the palette is not modified or destroyed in another thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#SetColors_1","title":"SetColors(TArray&lt;TSdlColor&gt;, Integer, Integer)","text":"<p>Set a range of colors in a palette. </p> <p><code>procedure SetColors(const AColors: TArray&lt;TSdlColor&gt;; const AFirstColor: Integer = 0; const ANumColors: Integer = 0); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#parameters_5","title":"Parameters","text":"<p><code>AColors</code>: <code>TArray&lt;TSdlColor&gt;</code> : A array of TSdlColor record to copy into the palette.</p> <p><code>AFirstColor</code>: <code>Integer = 0</code> : (Optional) index of the first palette entry to modify.</p> <p><code>ANumColors</code>: <code>Integer = 0</code> : (Optional) number of entries to modify. Use 0 (default) to se the length of AColors.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPalette/#remarks_3","title":"Remarks","text":"<p>It is safe to call this method from any thread, as long as the palette is not modified or destroyed in another thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/","title":"TSdlPixelFormatDetails","text":"<p>Details about the format of a pixel. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlPixelFormatDetails = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#properties","title":"Properties","text":"Name Description ABits AMask AShift BBits BitsPerPixel BMask BShift BytesPerPixel Format GBits GMask GShift RBits RMask RShift"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#methods","title":"Methods","text":"Name Description GetRgb(Cardinal, TSdlPalette, Byte, Byte, Byte) GetRgb(Cardinal, Byte, Byte, Byte) Get RGB values from a pixel in this format. GetRgba(Cardinal, TSdlPalette, Byte, Byte, Byte, Byte) GetRgba(Cardinal, Byte, Byte, Byte, Byte) Get RGBA values from a pixel in the specified format. MapRgb(TSdlPalette, Byte, Byte, Byte) MapRgb(Byte, Byte, Byte) Map an RGB triple to an opaque pixel value for this given pixel format. MapRgba(TSdlPalette, Byte, Byte, Byte, Byte) MapRgba(Byte, Byte, Byte, Byte) Map an RGBA quadruple to a pixel value for this pixel format."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#ABits","title":"ABits","text":"<p><code>property ABits: Byte read FHandle.Abits</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#AMask","title":"AMask","text":"<p><code>property AMask: Cardinal read FHandle.Amask</code></p> <p>Type: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#AShift","title":"AShift","text":"<p><code>property AShift: Byte read FHandle.Ashift</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#BBits","title":"BBits","text":"<p><code>property BBits: Byte read FHandle.Bbits</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#BitsPerPixel","title":"BitsPerPixel","text":"<p><code>property BitsPerPixel: Byte read FHandle.bits_per_pixel</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#BMask","title":"BMask","text":"<p><code>property BMask: Cardinal read FHandle.Bmask</code></p> <p>Type: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#BShift","title":"BShift","text":"<p><code>property BShift: Byte read FHandle.Bshift</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#BytesPerPixel","title":"BytesPerPixel","text":"<p><code>property BytesPerPixel: Byte read FHandle.bytes_per_pixel</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#Format","title":"Format","text":"<p><code>property Format: TSdlPixelFormat read GetFormat</code></p> <p>Type: <code>TSdlPixelFormat</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#GBits","title":"GBits","text":"<p><code>property GBits: Byte read FHandle.Gbits</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#GMask","title":"GMask","text":"<p><code>property GMask: Cardinal read FHandle.Gmask</code></p> <p>Type: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#GShift","title":"GShift","text":"<p><code>property GShift: Byte read FHandle.Gshift</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#RBits","title":"RBits","text":"<p><code>property RBits: Byte read FHandle.Rbits</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#RMask","title":"RMask","text":"<p><code>property RMask: Cardinal read FHandle.Rmask</code></p> <p>Type: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#RShift","title":"RShift","text":"<p><code>property RShift: Byte read FHandle.Rshift</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#GetRgb_0","title":"GetRgb(Cardinal, TSdlPalette, Byte, Byte, Byte)","text":"<p><code>procedure GetRgb(const APixel: Cardinal; const APalette: TSdlPalette; out AR, AG, AB: Byte); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#parameters","title":"Parameters","text":"<p><code>APixel</code>: <code>Cardinal</code></p> <p><code>APalette</code>: <code>TSdlPalette</code></p> <p><code>AR</code>: <code>Byte</code></p> <p><code>AG</code>: <code>Byte</code></p> <p><code>AB</code>: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#GetRgb_1","title":"GetRgb(Cardinal, Byte, Byte, Byte)","text":"<p>Get RGB values from a pixel in this format.</p> <p>This function uses the entire 8-bit [0..255] range when converting color components from pixel formats with less than 8-bits per RGB component (e.g., a completely white pixel in 16-bit RGB565 format would return [$ff, $ff, $ff] not [$f8, $fc, $f8]). </p> <p><code>procedure GetRgb(const APixel: Cardinal; out AR, AG, AB: Byte); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#parameters_1","title":"Parameters","text":"<p><code>APixel</code>: <code>Cardinal</code> : A pixel value.</p> <p><code>AR</code>: <code>Byte</code> : Is set to the red component.</p> <p><code>AG</code>: <code>Byte</code> : Is set to the green component.</p> <p><code>AB</code>: <code>Byte</code> : Is set to the blue component.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#see-also","title":"See Also","text":"<ul> <li>TSdlPixelFormat.Details</li> <li>GetRgba</li> <li>MapRgb</li> <li>MapRgba</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#remarks","title":"Remarks","text":"<p>It is safe to call this method from any thread, as long as the palette is not modified. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#GetRgba_0","title":"GetRgba(Cardinal, TSdlPalette, Byte, Byte, Byte, Byte)","text":"<p><code>procedure GetRgba(const APixel: Cardinal; const APalette: TSdlPalette; out AR, AG, AB, AA: Byte); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#parameters_2","title":"Parameters","text":"<p><code>APixel</code>: <code>Cardinal</code></p> <p><code>APalette</code>: <code>TSdlPalette</code></p> <p><code>AR</code>: <code>Byte</code></p> <p><code>AG</code>: <code>Byte</code></p> <p><code>AB</code>: <code>Byte</code></p> <p><code>AA</code>: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#GetRgba_1","title":"GetRgba(Cardinal, Byte, Byte, Byte, Byte)","text":"<p>Get RGBA values from a pixel in the specified format.</p> <p>This function uses the entire 8-bit [0..255] range when converting color components from pixel formats with less than 8-bits per RGB component (e.g., a completely white pixel in 16-bit RGB565 format would return [$ff, $ff, $ff] not [$f8, $fc, $f8]).</p> <p>If the surface has no alpha component, the alpha will be returned as $ff (100% opaque). </p> <p><code>procedure GetRgba(const APixel: Cardinal; out AR, AG, AB, AA: Byte); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#parameters_3","title":"Parameters","text":"<p><code>APixel</code>: <code>Cardinal</code> : A pixel value.</p> <p><code>AR</code>: <code>Byte</code> : Is set to the red component.</p> <p><code>AG</code>: <code>Byte</code> : Is set to the green component.</p> <p><code>AB</code>: <code>Byte</code> : Is set to the blue component.</p> <p><code>AA</code>: <code>Byte</code> : Is set to the alpha component.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#see-also_1","title":"See Also","text":"<ul> <li>TSdlPixelFormat.Details</li> <li>GetRgb</li> <li>MapRgb</li> <li>MapRgba</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#remarks_1","title":"Remarks","text":"<p>It is safe to call this method from any thread, as long as the palette is not modified. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#MapRgb_0","title":"MapRgb(TSdlPalette, Byte, Byte, Byte)","text":"<p><code>function MapRgb(const APalette: TSdlPalette; const AR, AG, AB: Byte): Cardinal; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#parameters_4","title":"Parameters","text":"<p><code>APalette</code>: <code>TSdlPalette</code></p> <p><code>AR</code>: <code>Byte</code></p> <p><code>AG</code>: <code>Byte</code></p> <p><code>AB</code>: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#returns","title":"Returns","text":"<p><code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#MapRgb_1","title":"MapRgb(Byte, Byte, Byte)","text":"<p>Map an RGB triple to an opaque pixel value for this given pixel format.</p> <p>This function maps the RGB color value to the specified pixel format and returns the pixel value best approximating the given RGB color value for the given pixel format.</p> <p>If the format has a palette (8-bit) the index of the closest matching color in the palette will be returned.</p> <p>If the specified pixel format has an alpha component it will be returned as all 1 bits (fully opaque).</p> <p>If the pixel format bpp (color depth) is less than 32-bpp then the unused upper bits of the return value can safely be ignored (e.g., with a 16-bpp format the return value can be assigned to a UInt16, and similarly a UInt8 for an 8-bpp format). </p> <p><code>function MapRgb(const AR, AG, AB: Byte): Cardinal; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#parameters_5","title":"Parameters","text":"<p><code>AR</code>: <code>Byte</code> : The red component of the pixel in the range 0-255.</p> <p><code>AG</code>: <code>Byte</code> : The green component of the pixel in the range 0-255.</p> <p><code>AB</code>: <code>Byte</code> : The blue component of the pixel in the range 0-255.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#returns_1","title":"Returns","text":"<p><code>Cardinal</code>: A pixel value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#see-also_2","title":"See Also","text":"<ul> <li>TSdlPixelFormat.Details</li> <li>GetRgb</li> <li>MapRgba</li> <li>TSdlSurface.MapRgb</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#remarks_2","title":"Remarks","text":"<p>It is safe to call this method from any thread, as long as the palette is not modified. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#MapRgba_0","title":"MapRgba(TSdlPalette, Byte, Byte, Byte, Byte)","text":"<p><code>function MapRgba(const APalette: TSdlPalette; const AR, AG, AB, AA: Byte): Cardinal; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#parameters_6","title":"Parameters","text":"<p><code>APalette</code>: <code>TSdlPalette</code></p> <p><code>AR</code>: <code>Byte</code></p> <p><code>AG</code>: <code>Byte</code></p> <p><code>AB</code>: <code>Byte</code></p> <p><code>AA</code>: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#returns_2","title":"Returns","text":"<p><code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#MapRgba_1","title":"MapRgba(Byte, Byte, Byte, Byte)","text":"<p>Map an RGBA quadruple to a pixel value for this pixel format.</p> <p>This function maps the RGBA color value to the specified pixel format and returns the pixel value best approximating the given RGBA color value for the given pixel format.</p> <p>If the specified pixel format has no alpha component the alpha value will be ignored (as it will be in formats with a palette).</p> <p>If the format has a palette (8-bit) the index of the closest matching color in the palette will be returned.</p> <p>If the pixel format bpp (color depth) is less than 32-bpp then the unused upper bits of the return value can safely be ignored (e.g., with a 16-bpp format the return value can be assigned to a UInt16, and similarly a UInt8 for an 8-bpp format). </p> <p><code>function MapRgba(const AR, AG, AB, AA: Byte): Cardinal; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#parameters_7","title":"Parameters","text":"<p><code>AR</code>: <code>Byte</code> : The red component of the pixel in the range 0-255.</p> <p><code>AG</code>: <code>Byte</code> : The green component of the pixel in the range 0-255.</p> <p><code>AB</code>: <code>Byte</code> : The blue component of the pixel in the range 0-255.</p> <p><code>AA</code>: <code>Byte</code> : The alpha component of the pixel in the range 0-255.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#returns_3","title":"Returns","text":"<p><code>Cardinal</code>: A pixel value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#see-also_3","title":"See Also","text":"<ul> <li>TSdlPixelFormat.Details</li> <li>GetRgba</li> <li>MapRgb</li> <li>TSdlSurface.MapRgba</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPixelFormatDetails/#remarks_3","title":"Remarks","text":"<p>It is safe to call this method from any thread, as long as the palette is not modified. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/","title":"TSdlPoint","text":"<p>The structure that defines a point (using integers). </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlPoint = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#fields","title":"Fields","text":"Name Description X Y"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#constructors","title":"Constructors","text":"Name Description Create(TPoint) Create from a TPoint. Create(Integer, Integer) Create from X and Y values."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#methods","title":"Methods","text":"Name Description Init(TPoint) Initialize from a TPoint. Init(Integer, Integer) Initialize from X and Y values."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#X","title":"X","text":"<p><code>var X: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#Y","title":"Y","text":"<p><code>var Y: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#Create_0","title":"<code>Create</code>","text":"<p>Create from a TPoint. </p> <p><code>constructor Create(const APoint: TPoint); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#parameters","title":"Parameters","text":"<p><code>APoint</code>: <code>TPoint</code> : The TPoint.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#remarks","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#Create_1","title":"<code>Create</code>","text":"<p>Create from X and Y values. </p> <p><code>constructor Create(const AX, AY: Integer); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#parameters_1","title":"Parameters","text":"<p><code>AX</code>: <code>Integer</code> : The X value.</p> <p><code>AY</code>: <code>Integer</code> : The Y value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#remarks_1","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#Init_0","title":"Init(TPoint)","text":"<p>Initialize from a TPoint. </p> <p><code>procedure Init(const APoint: TPoint); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#parameters_2","title":"Parameters","text":"<p><code>APoint</code>: <code>TPoint</code> : The TPoint.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#remarks_2","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#Init_1","title":"Init(Integer, Integer)","text":"<p>Initialize from X and Y values. </p> <p><code>procedure Init(const AX, AY: Integer); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#parameters_3","title":"Parameters","text":"<p><code>AX</code>: <code>Integer</code> : The X value.</p> <p><code>AY</code>: <code>Integer</code> : The Y value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPoint/#remarks_3","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/","title":"TSdlPointF","text":"<p>The structure that defines a point (using floating-point values). </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlPointF = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#fields","title":"Fields","text":"Name Description X Y"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#constructors","title":"Constructors","text":"Name Description Create(TPointF) Create from a TPointF. Create(TPoint) Create from a TPoint. Create(TSdlPoint) Create from a TSdlPoint. Create(Single, Single) Create from X and Y values."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#methods","title":"Methods","text":"Name Description Init(TPointF) Initialize from a TPointF. Init(TPoint) Initialize from a TPoint. Init(TSdlPoint) Initialize from a TSdlPoint. Init(Single, Single) Initialize from X and Y values."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#X","title":"X","text":"<p><code>var X: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#Y","title":"Y","text":"<p><code>var Y: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#Create_0","title":"<code>Create</code>","text":"<p>Create from a TPointF. </p> <p><code>constructor Create(const APoint: TPointF); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#parameters","title":"Parameters","text":"<p><code>APoint</code>: <code>TPointF</code> : The TPointF.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#remarks","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#Create_1","title":"<code>Create</code>","text":"<p>Create from a TPoint. </p> <p><code>constructor Create(const APoint: TPoint); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#parameters_1","title":"Parameters","text":"<p><code>APoint</code>: <code>TPoint</code> : The TPoint.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#remarks_1","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#Create_2","title":"<code>Create</code>","text":"<p>Create from a TSdlPoint. </p> <p><code>constructor Create(const APoint: TSdlPoint); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#parameters_2","title":"Parameters","text":"<p><code>APoint</code>: <code>TSdlPoint</code> : The TSdlPoint.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#remarks_2","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#Create_3","title":"<code>Create</code>","text":"<p>Create from X and Y values. </p> <p><code>constructor Create(const AX, AY: Single); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#parameters_3","title":"Parameters","text":"<p><code>AX</code>: <code>Single</code> : The X value.</p> <p><code>AY</code>: <code>Single</code> : The Y value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#remarks_3","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#Init_0","title":"Init(TPointF)","text":"<p>Initialize from a TPointF. </p> <p><code>procedure Init(const APoint: TPointF); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#parameters_4","title":"Parameters","text":"<p><code>APoint</code>: <code>TPointF</code> : The TPointF.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#remarks_4","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#Init_1","title":"Init(TPoint)","text":"<p>Initialize from a TPoint. </p> <p><code>procedure Init(const APoint: TPoint); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#parameters_5","title":"Parameters","text":"<p><code>APoint</code>: <code>TPoint</code> : The TPoint.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#remarks_5","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#Init_2","title":"Init(TSdlPoint)","text":"<p>Initialize from a TSdlPoint. </p> <p><code>procedure Init(const APoint: TSdlPoint); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#parameters_6","title":"Parameters","text":"<p><code>APoint</code>: <code>TSdlPoint</code> : The TSdlPoint.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#remarks_6","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#Init_3","title":"Init(Single, Single)","text":"<p>Initialize from X and Y values. </p> <p><code>procedure Init(const AX, AY: Single); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#parameters_7","title":"Parameters","text":"<p><code>AX</code>: <code>Single</code> : The X value.</p> <p><code>AY</code>: <code>Single</code> : The Y value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlPointF/#remarks_7","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/","title":"TSdlRect","text":"<p>A rectangle, with the origin at the upper left (using integers). </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlRect = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#fields","title":"Fields","text":"Name Description H W X Y"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#properties","title":"Properties","text":"Name Description IsEmpty Whether the rectangle has no area."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#constructors","title":"Constructors","text":"Name Description Create(TRect) Create from a TRect. Create(Integer, Integer, Integer, Integer) Create from X, Y, W and H values."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#operators","title":"Operators","text":"Name Description Equal Determine whether two rectangles are equal. NotEqual Determine whether two rectangles are not equal."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#methods","title":"Methods","text":"Name Description ContainsPoint Determine whether a point resides inside the rectangle. Init(TRect) Initialize from a TRect. Init(Integer, Integer, Integer, Integer) Initialize from X, Y, W and H values. InitFromEnclosingPoints(TSdlPoint[], PSdlRect) Calculate a minimal rectangle enclosing a set of points. InitFromEnclosingPoints(TArray&lt;TSdlPoint&gt;, PSdlRect) Calculate a minimal rectangle enclosing a set of points. Intersection Calculate the intersection of two rectangles. Intersects Determine whether two rectangles intersect. LineIntersection(TSdlPoint, TSdlPoint) Calculate the intersection of this rectangle and line segment. LineIntersection(Integer, Integer, Integer, Integer) Calculate the intersection of this rectangle and line segment. Union Calculate the union of two rectangles."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#H","title":"H","text":"<p><code>var H: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#W","title":"W","text":"<p><code>var W: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#X","title":"X","text":"<p><code>var X: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#Y","title":"Y","text":"<p><code>var Y: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#IsEmpty","title":"IsEmpty","text":"<p>Whether the rectangle has no area.</p> <p>A rectangle is considered \"empty\" for this function if it's width and/or height are &lt;whether the rectangle has no area.</p> <p>a rectangle is considered \"empty\" for this function if it's width and/or height are /&gt;True if the rectangle is \"empty\", False otherwise.It is safe to use this property from any thread. </p> <p><code>property IsEmpty: Boolean read GetIsEmpty</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#Create_0","title":"<code>Create</code>","text":"<p>Create from a TRect. </p> <p><code>constructor Create(const ARect: TRect); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#parameters","title":"Parameters","text":"<p><code>ARect</code>: <code>TRect</code> : The TRect.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#remarks","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#Create_1","title":"<code>Create</code>","text":"<p>Create from X, Y, W and H values. </p> <p><code>constructor Create(const AX, AY, AW, AH: Integer); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#parameters_1","title":"Parameters","text":"<p><code>AX</code>: <code>Integer</code> : The X value.</p> <p><code>AY</code>: <code>Integer</code> : The Y value.</p> <p><code>AW</code>: <code>Integer</code> : The width.</p> <p><code>AH</code>: <code>Integer</code> : The height.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#remarks_1","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#Equal","title":"Equal(TSdlRect, TSdlRect)","text":"<p>Determine whether two rectangles are equal. </p> <p><code>class operator Equal(const ALeft, ARight: TSdlRect): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlRect</code></p> <p><code>ARight</code>: <code>TSdlRect</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#remarks_2","title":"Remarks","text":"<p>It is safe to call this operator from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#NotEqual","title":"NotEqual(TSdlRect, TSdlRect)","text":"<p>Determine whether two rectangles are not equal. </p> <p><code>class operator NotEqual(const ALeft, ARight: TSdlRect): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#parameters_3","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlRect</code></p> <p><code>ARight</code>: <code>TSdlRect</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#returns_1","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#remarks_3","title":"Remarks","text":"<p>It is safe to call this operator from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#ContainsPoint","title":"ContainsPoint(TSdlPoint)","text":"<p>Determine whether a point resides inside the rectangle.</p> <p>A point is considered part of a rectangle if <code>APP</code>'s x and y coordinates are &gt;= to the rectangle's top left corner, and &lt;determine whether a point resides inside the rectangle.</p> <p>a point is considered part of a rectangle if <code>app</code>'s x and y coordinates are &gt;= to the rectangle's top left corner, and &gt;rectangle's X+W and Y+H. So a 1x1 rectangle considers point (0, 0) as \"inside\" and (0, 1) as not. &lt;/determine whether a point resides inside the rectangle.</p> <p>a point is considered part of a rectangle if <code>app</code>'s x and y coordinates are &gt;= to the rectangle's top left corner, and &gt;The point to test.True if <code>AP</code> is contained by this rectangle, False otherwise.It is safe to call this method from any thread. </p> <p><code>function ContainsPoint(const AP: TSdlPoint): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#parameters_4","title":"Parameters","text":"<p><code>AP</code>: <code>TSdlPoint</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#Init_0","title":"Init(TRect)","text":"<p>Initialize from a TRect. </p> <p><code>procedure Init(const ARect: TRect); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#parameters_5","title":"Parameters","text":"<p><code>ARect</code>: <code>TRect</code> : The TRect.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#remarks_4","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#Init_1","title":"Init(Integer, Integer, Integer, Integer)","text":"<p>Initialize from X, Y, W and H values. </p> <p><code>procedure Init(const AX, AY, AW, AH: Integer); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#parameters_6","title":"Parameters","text":"<p><code>AX</code>: <code>Integer</code> : The X value.</p> <p><code>AY</code>: <code>Integer</code> : The Y value.</p> <p><code>AW</code>: <code>Integer</code> : The width.</p> <p><code>AH</code>: <code>Integer</code> : The height.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#remarks_5","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#InitFromEnclosingPoints_0","title":"InitFromEnclosingPoints(TSdlPoint[], PSdlRect)","text":"<p>Calculate a minimal rectangle enclosing a set of points.</p> <p>If <code>AClip</code> is not nil then only points inside of the clipping rectangle are considered. </p> <p><code>function InitFromEnclosingPoints(const APoints: array of TSdlPoint; const AClip: PSdlRect = nil): Boolean; overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#parameters_7","title":"Parameters","text":"<p><code>APoints</code>: <code>array of TSdlPoint</code> : An array of points to be enclosed.</p> <p><code>AClip</code>: <code>PSdlRect = nil</code> : (Optional) rect used for clipping or nil to enclose all points.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#returns_3","title":"Returns","text":"<p><code>Boolean</code>: True if any points were enclosed or False if all the points were outside of the clipping rectangle.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#InitFromEnclosingPoints_1","title":"InitFromEnclosingPoints(TArray&lt;TSdlPoint&gt;, PSdlRect)","text":"<p>Calculate a minimal rectangle enclosing a set of points.</p> <p>If <code>AClip</code> is not nil then only points inside of the clipping rectangle are considered. </p> <p><code>function InitFromEnclosingPoints(const APoints: TArray&lt;TSdlPoint&gt;; const AClip: PSdlRect = nil): Boolean; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#parameters_8","title":"Parameters","text":"<p><code>APoints</code>: <code>TArray&lt;TSdlPoint&gt;</code> : An array of points to be enclosed.</p> <p><code>AClip</code>: <code>PSdlRect = nil</code> : (Optional) rect used for clipping or nil to enclose all points.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#returns_4","title":"Returns","text":"<p><code>Boolean</code>: True if any points were enclosed or False if all the points were outside of the clipping rectangle.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#Intersection","title":"Intersection(TSdlRect, TSdlRect)","text":"<p>Calculate the intersection of two rectangles. </p> <p><code>function Intersection(const AOther: TSdlRect; out AIntersection: TSdlRect): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#parameters_9","title":"Parameters","text":"<p><code>AOther</code>: <code>TSdlRect</code> : The other rectangle.</p> <p><code>AIntersection</code>: <code>TSdlRect</code> : Is set to the intersection of this rectangle and AOther.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#returns_5","title":"Returns","text":"<p><code>Boolean</code>: True if there is an intersection, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#see-also","title":"See Also","text":"<ul> <li>Intersects</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#Intersects","title":"Intersects(TSdlRect)","text":"<p>Determine whether two rectangles intersect. </p> <p><code>function Intersects(const AOther: TSdlRect): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#parameters_10","title":"Parameters","text":"<p><code>AOther</code>: <code>TSdlRect</code> : The other rectangle.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#returns_6","title":"Returns","text":"<p><code>Boolean</code>: True if there is an intersection, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#see-also_1","title":"See Also","text":"<ul> <li>Intersection</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#remarks_6","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#LineIntersection_0","title":"LineIntersection(TSdlPoint, TSdlPoint)","text":"<p>Calculate the intersection of this rectangle and line segment.</p> <p>This function is used to clip a line segment to a rectangle. A line segment contained entirely within the rectangle or that does not intersect will remain unchanged. A line segment that crosses the rectangle at either or both ends will be clipped to the boundary of the rectangle and the new coordinates saved in <code>AP1</code> and/or <code>AP2</code> as necessary. </p> <p><code>function LineIntersection(var AP1, AP2: TSdlPoint): Boolean; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#parameters_11","title":"Parameters","text":"<p><code>AP1</code>: <code>TSdlPoint</code> : The starting point of the line.</p> <p><code>AP2</code>: <code>TSdlPoint</code> : The ending point of the line.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#returns_7","title":"Returns","text":"<p><code>Boolean</code>: True if there is an intersection, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#LineIntersection_1","title":"LineIntersection(Integer, Integer, Integer, Integer)","text":"<p>Calculate the intersection of this rectangle and line segment.</p> <p>This function is used to clip a line segment to a rectangle. A line segment contained entirely within the rectangle or that does not intersect will remain unchanged. A line segment that crosses the rectangle at either or both ends will be clipped to the boundary of the rectangle and the new coordinates saved in <code>AX1</code>, <code>AY1</code>, <code>AX2</code>, and/or <code>AY2</code> as necessary. </p> <p><code>function LineIntersection(var AX1, AY1, AX2, AY2: Integer): Boolean; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#parameters_12","title":"Parameters","text":"<p><code>AX1</code>: <code>Integer</code> : The starting X-coordinate of the line.</p> <p><code>AY1</code>: <code>Integer</code> : The starting Y-coordinate of the line.</p> <p><code>AX2</code>: <code>Integer</code> : The ending X-coordinate of the line.</p> <p><code>AY2</code>: <code>Integer</code> : The ending Y-coordinate of the line.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#returns_8","title":"Returns","text":"<p><code>Boolean</code>: True if there is an intersection, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#Union","title":"Union(TSdlRect, TSdlRect)","text":"<p>Calculate the union of two rectangles. </p> <p><code>procedure Union(const AOther: TSdlRect; out AUnion: TSdlRect); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRect/#parameters_13","title":"Parameters","text":"<p><code>AOther</code>: <code>TSdlRect</code> : The other rectangle.</p> <p><code>AUnion</code>: <code>TSdlRect</code> : Is set to the union this rectangle and AOther.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/","title":"TSdlRectF","text":"<p>A rectangle, with the origin at the upper left (using floating-point values). </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlRectF = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#fields","title":"Fields","text":"Name Description H W X Y"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#properties","title":"Properties","text":"Name Description IsEmpty Whether the rectangle has no area."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#constructors","title":"Constructors","text":"Name Description Create(TRectF) Create from a TRectF. Create(TRect) Create from a TRect. Create(TSdlRect) Create from a TSdlRect. Create(Single, Single, Single, Single) Create from X, Y, W and H values."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#operators","title":"Operators","text":"Name Description Equal Determine whether two rectangles are equal. NotEqual Determine whether two rectangles are not equal."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#methods","title":"Methods","text":"Name Description ContainsPoint Determine whether a point resides inside the rectangle. Equals Determine whether two floating point rectangles are equal, within some given epsilon. Init(TRectF) Initialize from a TRectF. Init(TRect) Initialize from a TRect. Init(TSdlRect) Initialize from a TSdlRect. Init(Single, Single, Single, Single) Initialize from X, Y, W and H values. InitFromEnclosingPoints(TSdlPointF[], PSdlRectF) Calculate a minimal rectangle enclosing a set of points. InitFromEnclosingPoints(TArray&lt;TSdlPointF&gt;, PSdlRectF) Calculate a minimal rectangle enclosing a set of points. Intersection Calculate the intersection of two rectangles. Intersects Determine whether two rectangles intersect. LineIntersection(TSdlPointF, TSdlPointF) Calculate the intersection of this rectangle and line segment. LineIntersection(Single, Single, Single, Single) Calculate the intersection of this rectangle and line segment. Union Calculate the union of two rectangles."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#H","title":"H","text":"<p><code>var H: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#W","title":"W","text":"<p><code>var W: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#X","title":"X","text":"<p><code>var X: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#Y","title":"Y","text":"<p><code>var Y: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#IsEmpty","title":"IsEmpty","text":"<p>Whether the rectangle has no area.</p> <p>A rectangle is considered \"empty\" for this function if it's width and/or height are &lt;whether the rectangle has no area.</p> <p>a rectangle is considered \"empty\" for this function if it's width and/or height are /&gt;True if the rectangle is \"empty\", False otherwise.It is safe to use this property from any thread. </p> <p><code>property IsEmpty: Boolean read GetIsEmpty</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#Create_0","title":"<code>Create</code>","text":"<p>Create from a TRectF. </p> <p><code>constructor Create(const ARect: TRectF); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters","title":"Parameters","text":"<p><code>ARect</code>: <code>TRectF</code> : The TRectF.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#remarks","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#Create_1","title":"<code>Create</code>","text":"<p>Create from a TRect. </p> <p><code>constructor Create(const ARect: TRect); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_1","title":"Parameters","text":"<p><code>ARect</code>: <code>TRect</code> : The TRect.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#remarks_1","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#Create_2","title":"<code>Create</code>","text":"<p>Create from a TSdlRect. </p> <p><code>constructor Create(const ARect: TSdlRect); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_2","title":"Parameters","text":"<p><code>ARect</code>: <code>TSdlRect</code> : The TSdlRect.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#remarks_2","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#Create_3","title":"<code>Create</code>","text":"<p>Create from X, Y, W and H values. </p> <p><code>constructor Create(const AX, AY, AW, AH: Single); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_3","title":"Parameters","text":"<p><code>AX</code>: <code>Single</code> : The X value.</p> <p><code>AY</code>: <code>Single</code> : The Y value.</p> <p><code>AW</code>: <code>Single</code> : The width.</p> <p><code>AH</code>: <code>Single</code> : The height.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#remarks_3","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#Equal","title":"Equal(TSdlRectF, TSdlRectF)","text":"<p>Determine whether two rectangles are equal.</p> <p>Rectangles are considered equal if each of their X, Y, W and Ht are within SDL_SINGLE_EPSILON of each other. This is often a reasonable way to compare two floating point rectangles and deal with the slight precision variations in floating point calculations that tend to pop up. </p> <p><code>class operator Equal(const ALeft, ARight: TSdlRectF): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_4","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlRectF</code></p> <p><code>ARight</code>: <code>TSdlRectF</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#remarks_4","title":"Remarks","text":"<p>It is safe to call this operator from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#NotEqual","title":"NotEqual(TSdlRectF, TSdlRectF)","text":"<p>Determine whether two rectangles are not equal.</p> <p>Rectangles are considered equal if each of their X, Y, W and Ht are within SDL_SINGLE_EPSILON of each other. This is often a reasonable way to compare two floating point rectangles and deal with the slight precision variations in floating point calculations that tend to pop up. </p> <p><code>class operator NotEqual(const ALeft, ARight: TSdlRectF): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_5","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlRectF</code></p> <p><code>ARight</code>: <code>TSdlRectF</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#returns_1","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#remarks_5","title":"Remarks","text":"<p>It is safe to call this operator from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#ContainsPoint","title":"ContainsPoint(TSdlPointF)","text":"<p>Determine whether a point resides inside the rectangle.</p> <p>A point is considered part of a rectangle if <code>APP</code>'s x and y coordinates are &gt;= to the rectangle's top left corner, and &lt;determine whether a point resides inside the rectangle.</p> <p>a point is considered part of a rectangle if <code>app</code>'s x and y coordinates are &gt;= to the rectangle's top left corner, and &gt;rectangle's X+W and Y+H. So a 1x1 rectangle considers point (0, 0) as \"inside\" and (0, 1) as not. &lt;/determine whether a point resides inside the rectangle.</p> <p>a point is considered part of a rectangle if <code>app</code>'s x and y coordinates are &gt;= to the rectangle's top left corner, and &gt;The point to test.True if <code>AP</code> is contained by this rectangle, False otherwise.It is safe to call this method from any thread. </p> <p><code>function ContainsPoint(const AP: TSdlPointF): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_6","title":"Parameters","text":"<p><code>AP</code>: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#Equals","title":"Equals(TSdlRectF, Single)","text":"<p>Determine whether two floating point rectangles are equal, within some given epsilon.</p> <p>Rectangles are considered equal if each of their X, Y, W and H are within <code>AEpsilon</code> of each other. If you don't know what value to use for <code>AEpsilon</code>, you should call use the '=' operator. </p> <p><code>function Equals(const AOther: TSdlRectF; const AEpsilon: Single): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_7","title":"Parameters","text":"<p><code>AOther</code>: <code>TSdlRectF</code> : The other rectangle to test.</p> <p><code>AEpsilon</code>: <code>Single</code> : The epsilon value for comparison.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#returns_3","title":"Returns","text":"<p><code>Boolean</code>: True if the rectangles are equal, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#remarks_6","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#Init_0","title":"Init(TRectF)","text":"<p>Initialize from a TRectF. </p> <p><code>procedure Init(const ARect: TRectF); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_8","title":"Parameters","text":"<p><code>ARect</code>: <code>TRectF</code> : The TRectF.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#remarks_7","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#Init_1","title":"Init(TRect)","text":"<p>Initialize from a TRect. </p> <p><code>procedure Init(const ARect: TRect); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_9","title":"Parameters","text":"<p><code>ARect</code>: <code>TRect</code> : The TRect.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#remarks_8","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#Init_2","title":"Init(TSdlRect)","text":"<p>Initialize from a TSdlRect. </p> <p><code>procedure Init(const ARect: TSdlRect); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_10","title":"Parameters","text":"<p><code>ARect</code>: <code>TSdlRect</code> : The TSdlRect.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#remarks_9","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#Init_3","title":"Init(Single, Single, Single, Single)","text":"<p>Initialize from X, Y, W and H values. </p> <p><code>procedure Init(const AX, AY, AW, AH: Single); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_11","title":"Parameters","text":"<p><code>AX</code>: <code>Single</code> : The X value.</p> <p><code>AY</code>: <code>Single</code> : The Y value.</p> <p><code>AW</code>: <code>Single</code> : The width.</p> <p><code>AH</code>: <code>Single</code> : The height.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#remarks_10","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#InitFromEnclosingPoints_0","title":"InitFromEnclosingPoints(TSdlPointF[], PSdlRectF)","text":"<p>Calculate a minimal rectangle enclosing a set of points.</p> <p>If <code>AClip</code> is not nil then only points inside of the clipping rectangle are considered. </p> <p><code>function InitFromEnclosingPoints(const APoints: array of TSdlPointF; const AClip: PSdlRectF = nil): Boolean; overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_12","title":"Parameters","text":"<p><code>APoints</code>: <code>array of TSdlPointF</code> : An array of points to be enclosed.</p> <p><code>AClip</code>: <code>PSdlRectF = nil</code> : (Optional) rect used for clipping or nil to enclose all points.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#returns_4","title":"Returns","text":"<p><code>Boolean</code>: True if any points were enclosed or False if all the points were outside of the clipping rectangle.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#InitFromEnclosingPoints_1","title":"InitFromEnclosingPoints(TArray&lt;TSdlPointF&gt;, PSdlRectF)","text":"<p>Calculate a minimal rectangle enclosing a set of points.</p> <p>If <code>AClip</code> is not nil then only points inside of the clipping rectangle are considered. </p> <p><code>function InitFromEnclosingPoints(const APoints: TArray&lt;TSdlPointF&gt;; const AClip: PSdlRectF = nil): Boolean; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_13","title":"Parameters","text":"<p><code>APoints</code>: <code>TArray&lt;TSdlPointF&gt;</code> : An array of points to be enclosed.</p> <p><code>AClip</code>: <code>PSdlRectF = nil</code> : (Optional) rect used for clipping or nil to enclose all points.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#returns_5","title":"Returns","text":"<p><code>Boolean</code>: True if any points were enclosed or False if all the points were outside of the clipping rectangle.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#Intersection","title":"Intersection(TSdlRectF, TSdlRectF)","text":"<p>Calculate the intersection of two rectangles. </p> <p><code>function Intersection(const AOther: TSdlRectF; out AIntersection: TSdlRectF): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_14","title":"Parameters","text":"<p><code>AOther</code>: <code>TSdlRectF</code> : The other rectangle.</p> <p><code>AIntersection</code>: <code>TSdlRectF</code> : Is set to the intersection of this rectangle and AOther.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#returns_6","title":"Returns","text":"<p><code>Boolean</code>: True if there is an intersection, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#see-also","title":"See Also","text":"<ul> <li>Intersects</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#Intersects","title":"Intersects(TSdlRectF)","text":"<p>Determine whether two rectangles intersect. </p> <p><code>function Intersects(const AOther: TSdlRectF): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_15","title":"Parameters","text":"<p><code>AOther</code>: <code>TSdlRectF</code> : The other rectangle.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#returns_7","title":"Returns","text":"<p><code>Boolean</code>: True if there is an intersection, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#see-also_1","title":"See Also","text":"<ul> <li>Intersection</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#remarks_11","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#LineIntersection_0","title":"LineIntersection(TSdlPointF, TSdlPointF)","text":"<p>Calculate the intersection of this rectangle and line segment.</p> <p>This function is used to clip a line segment to a rectangle. A line segment contained entirely within the rectangle or that does not intersect will remain unchanged. A line segment that crosses the rectangle at either or both ends will be clipped to the boundary of the rectangle and the new coordinates saved in <code>AP1</code> and/or <code>AP2</code> as necessary. </p> <p><code>function LineIntersection(var AP1, AP2: TSdlPointF): Boolean; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_16","title":"Parameters","text":"<p><code>AP1</code>: <code>TSdlPointF</code> : The starting point of the line.</p> <p><code>AP2</code>: <code>TSdlPointF</code> : The ending point of the line.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#returns_8","title":"Returns","text":"<p><code>Boolean</code>: True if there is an intersection, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#LineIntersection_1","title":"LineIntersection(Single, Single, Single, Single)","text":"<p>Calculate the intersection of this rectangle and line segment.</p> <p>This function is used to clip a line segment to a rectangle. A line segment contained entirely within the rectangle or that does not intersect will remain unchanged. A line segment that crosses the rectangle at either or both ends will be clipped to the boundary of the rectangle and the new coordinates saved in <code>AX1</code>, <code>AY1</code>, <code>AX2</code>, and/or <code>AY2</code> as necessary. </p> <p><code>function LineIntersection(var AX1, AY1, AX2, AY2: Single): Boolean; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_17","title":"Parameters","text":"<p><code>AX1</code>: <code>Single</code> : The starting X-coordinate of the line.</p> <p><code>AY1</code>: <code>Single</code> : The starting Y-coordinate of the line.</p> <p><code>AX2</code>: <code>Single</code> : The ending X-coordinate of the line.</p> <p><code>AY2</code>: <code>Single</code> : The ending Y-coordinate of the line.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#returns_9","title":"Returns","text":"<p><code>Boolean</code>: True if there is an intersection, False otherwise.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#Union","title":"Union(TSdlRectF, TSdlRectF)","text":"<p>Calculate the union of two rectangles. </p> <p><code>procedure Union(const AOther: TSdlRectF; out AUnion: TSdlRectF); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRectF/#parameters_18","title":"Parameters","text":"<p><code>AOther</code>: <code>TSdlRectF</code> : The other rectangle.</p> <p><code>AUnion</code>: <code>TSdlRectF</code> : Is set to the union this rectangle and AOther.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/","title":"TSdlRenderer","text":"<p>Rendering state </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlRenderer = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#properties","title":"Properties","text":"Name Description ClipRect The clip rectangle for rendering on the specified target, relative to the viewport (or an empty rectangle if clipping is disabled). ColorScale Set the color scale used for render operations. CurrentOutputSize The current output size in pixels of a rendering context. DrawBlendMode Set the blend mode used for drawing operations (Fill and Line). DrawColor The (integer) color used for drawing operations (for drawing or filling rectangles, lines, and points, and for Clear). DrawColorFloat The (floating-point) color used for drawing operations (for drawing or filling rectangles, lines, and points, and for Clear). DriverCount The number of 2D rendering drivers available for the current display. Drivers The names of the built in 2D rendering driver (or an empty string if an invalid index is given). IsClipEnabled Whether clipping is enabled on the given renderer. IsViewportSet Whether an explicit rectangle was set as the viewport. LogicalPresentationRect Get the final presentation rectangle for rendering. MetalCommandEncoder Get the Metal command encoder for the current frame. MetalLayer The CAMetalLayer associated with the given Metal renderer. Name The name of the renderer. OutputSize The output size in pixels of a rendering context. Properties The properties associated with the renderer. SafeArea The safe area for rendering within the current viewport. Scale The drawing scale for rendering on the current target. Target The current rendering target. Viewport The drawing area for rendering on the current target. VSync The VSync of the renderer. Window The window associated with the renderer."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#constructors","title":"Constructors","text":"Name Description Create(TSdlSurface) Create a 2D software rendering context for a surface. Create(TSdlProperties) Create a 2D rendering context for a window, with the specified properties. Create(TSdlWindow, String) Create a 2D rendering context for a window. Create(String, Integer, Integer, TSdlWindowFlags, TSdlWindow) Create a default renderer and window."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#methods","title":"Methods","text":"Name Description AddVulkanSemaphores Add a set of synchronization semaphores for the current frame when using Vulkan. Clear Clear the current rendering target with the drawing color. CreateTexture(TSdlProperties) Create a texture for this rendering context with the specified properties. CreateTexture(TSdlSurface) Create a texture for this rendering context from an existing surface. CreateTexture(TSdlPixelFormat, TSdlTextureAccess, Integer, Integer) Create a texture for this rendering context. DrawDebugText(TSdlPointF, String) Draw debug text. DrawDebugText(Single, Single, String) Draw debug text. DrawGeometry(TSdlTexture, TArray&lt;TSdlPointF&gt;, Integer, TArray&lt;TSdlColorF&gt;, Integer, TArray&lt;TSdlPointF&gt;, Integer, Pointer, Integer, TSdlIndexType) Render a list of triangles, optionally using a texture and indices into the vertex array. Color and alpha modulation is done per vertex (TSdlTexture.ColorMod and TSdlTexture.AlphaMod are ignored). DrawGeometry(TArray&lt;TSdlPointF&gt;, Integer, TArray&lt;TSdlColorF&gt;, Integer, TArray&lt;TSdlPointF&gt;, Integer, Pointer, Integer, TSdlIndexType) Render a list of triangles, optionally using indices into the vertex array. Color and alpha modulation is done per vertex (TSdlTexture.ColorMod and TSdlTexture.AlphaMod are ignored). DrawGeometry(TSdlTexture, TArray&lt;TSdlVertex&gt;, TArray&lt;Integer&gt;) Render a list of triangles, optionally using a texture and indices into the vertex array. Color and alpha modulation is done per vertex (TSdlTexture.ColorMod and TSdlTexture.AlphaMod are ignored). DrawGeometry(TArray&lt;TSdlVertex&gt;, TArray&lt;Integer&gt;) Render a list of triangles, optionally using indices into the vertex array. Color and alpha modulation is done per vertex. DrawLine(TSdlPointF, TSdlPointF) Draw a line on the current rendering target at subpixel precision. DrawLine(Single, Single, Single, Single) Draw a line on the current rendering target at subpixel precision. DrawLines(TSdlPointF[]) Draw a series of connected lines on the current rendering target at subpixel precision. DrawLines(TArray&lt;TSdlPointF&gt;) Draw a series of connected lines on the current rendering target at subpixel precision. DrawPoint(TSdlPointF) Draw a point on the current rendering target at subpixel precision. DrawPoint(Single, Single) Draw a point on the current rendering target at subpixel precision. DrawPoints(TSdlPointF[]) Draw multiple points on the current rendering target at subpixel precision. DrawPoints(TArray&lt;TSdlPointF&gt;) Draw multiple points on the current rendering target at subpixel precision. DrawRect Draw a rectangle on the current rendering target at subpixel precision. DrawRects(TSdlRectF[]) Draw some number of rectangles on the current rendering target at subpixel precision. DrawRects(TArray&lt;TSdlRectF&gt;) Draw some number of rectangles on the current rendering target at subpixel precision. DrawTexture(TSdlTexture, TSdlRectF, TSdlRectF) Copy a portion of the texture to the current rendering target at subpixel precision. DrawTexture(TSdlTexture, TSdlRectF) Copy the texture to the current rendering target at subpixel precision. DrawTexture9Grid(TSdlTexture, TSdlRectF, Single, Single, Single, Single, Single, TSdlRectF) Perform a scaled copy using the 9-grid algorithm to the current rendering target at subpixel precision. DrawTexture9Grid(TSdlTexture, Single, Single, Single, Single, Single, TSdlRectF) Perform a scaled copy using the 9-grid algorithm to the current rendering target at subpixel precision. DrawTextureAffine(TSdlTexture, TSdlRectF, TSdlPointF, TSdlPointF, TSdlPointF) Copy a portion of the source texture to the current rendering target, with affine transform, at subpixel precision. DrawTextureAffine(TSdlTexture, TSdlPointF, TSdlPointF, TSdlPointF) Copy the source texture to the current rendering target, with affine transform, at subpixel precision. DrawTextureRotated(TSdlTexture, TSdlRectF, TSdlRectF, Double, TSdlPointF, TSdlFlipModes) Copy a portion of the source texture to the current rendering target, with rotation and flipping, at subpixel precision. DrawTextureRotated(TSdlTexture, TSdlRectF, TSdlRectF, Double, TSdlFlipModes) Copy a portion of the source texture to the current rendering target, with rotation and flipping, at subpixel precision. DrawTextureRotated(TSdlTexture, TSdlRectF, Double, TSdlPointF, TSdlFlipModes) Copy the source texture to the current rendering target, with rotation and flipping, at subpixel precision. DrawTextureRotated(TSdlTexture, TSdlRectF, Double, TSdlFlipModes) Copy the source texture to the current rendering target, with rotation and flipping, at subpixel precision. DrawTextureTiled(TSdlTexture, TSdlRectF, Single, TSdlRectF) Tile a portion of the texture to the current rendering target at subpixel precision. DrawTextureTiled(TSdlTexture, Single, TSdlRectF) Tile the texture to the current rendering target at subpixel precision. FillRect Fill a rectangle on the current rendering target with the drawing color at subpixel precision. FillRects(TSdlRectF[]) Fill some number of rectangles on the current rendering target with the drawing color at subpixel precision. FillRects(TArray&lt;TSdlRectF&gt;) Fill some number of rectangles on the current rendering target with the drawing color at subpixel precision. Flush Force the rendering context to flush any pending commands and state. ForWindow Get the renderer associated with a window. Free Destroy the rendering context for a window and free all associated textures. GetLogicalPresentation Get device independent resolution and presentation mode for rendering. Present Update the screen with any rendering performed since the previous call. ReadPixels(TSdlRect) Read pixels from the current rendering target. ReadPixels Read pixels from the entire viewport of the current rendering target. RenderCoordinatesFromWindow Get a point in render coordinates when given a point in window coordinates. RenderCoordinatesToWindow Get a point in window coordinates when given a point in render coordinates. ResetViewport Set the viewport to the entire target. SetDrawColor Set the (integer) color used for drawing operations. SetDrawColorFloat Set the (floating-point) color used for drawing operations. SetLogicalPresentation Set a device independent resolution and presentation mode for rendering."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#ClipRect","title":"ClipRect","text":"<p>The clip rectangle for rendering on the specified target, relative to the viewport (or an empty rectangle if clipping is disabled).</p> <p>To disable clipping, set IsClipEnabled to False. </p> <p><code>property ClipRect: TSdlRect read GetClipRect write SetClipRect</code></p> <p>Type: <code>TSdlRect</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also","title":"See Also","text":"<ul> <li>IsClipEnabled</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#ColorScale","title":"ColorScale","text":"<p>Set the color scale used for render operations.</p> <p>The color scale is an additional scale multiplied into the pixel color value while rendering. This can be used to adjust the brightness of colors during HDR rendering, or changing HDR video brightness when playing on an SDR display.</p> <p>The color scale does not affect the alpha channel, only the color brightness. </p> <p><code>property ColorScale: Single read GetColorScale write SetColorScale</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_1","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#CurrentOutputSize","title":"CurrentOutputSize","text":"<p>The current output size in pixels of a rendering context.</p> <p>If a rendering target is active, this will return the size of the rendering target in pixels, otherwise if a logical size is set, it will return the logical size, otherwise it will return the value of OutputSize. </p> <p><code>property CurrentOutputSize: TSdlSize read GetCurrentOutputSize</code></p> <p>Type: <code>TSdlSize</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_1","title":"See Also","text":"<ul> <li>OutputSize</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_2","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawBlendMode","title":"DrawBlendMode","text":"<p>Set the blend mode used for drawing operations (Fill and Line).</p> <p>If the blend mode is not supported, the closest supported mode is chosen. </p> <p><code>property DrawBlendMode: TSdlBlendMode read GetDrawBlendMode write SetDrawBlendMode</code></p> <p>Type: <code>TSdlBlendMode</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_3","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawColor","title":"DrawColor","text":"<p>The (integer) color used for drawing operations (for drawing or filling rectangles, lines, and points, and for Clear). </p> <p><code>property DrawColor: TSdlColor read GetDrawColor write SetDrawColor</code></p> <p>Type: <code>TSdlColor</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_2","title":"See Also","text":"<ul> <li>SetDrawColor</li> <li>DrawColorFloat</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_4","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawColorFloat","title":"DrawColorFloat","text":"<p>The (floating-point) color used for drawing operations (for drawing or filling rectangles, lines, and points, and for Clear). </p> <p><code>property DrawColorFloat: TSdlColorF read GetDrawColorFloat write SetDrawColorFloat</code></p> <p>Type: <code>TSdlColorF</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_3","title":"See Also","text":"<ul> <li>SetDrawColor</li> <li>DrawColor</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_5","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DriverCount","title":"DriverCount","text":"<p>The number of 2D rendering drivers available for the current display.</p> <p>A render driver is a set of code that handles rendering and texture management on a particular display. Normally there is only one, but some drivers may have several available with different capabilities.</p> <p>There may be none if SDL was compiled without render support. </p> <p><code>class property DriverCount: Integer read GetDriverCount</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_4","title":"See Also","text":"<ul> <li>Drivers</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_6","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Drivers","title":"Drivers","text":"<p>The names of the built in 2D rendering driver (or an empty string if an invalid index is given).</p> <p>The list of rendering drivers is given in the order that they are normally initialized by default; the drivers that seem more reasonable to choose first (as far as the SDL developers believe) are earlier in the list.</p> <p>The names of drivers are all simple, low-ASCII identifiers, like 'opengl', 'direct3d12' or 'metal'. These never have Unicode characters, and are not meant to be proper names. </p> <p><code>class property Drivers[const AIndex: Integer]: String read GetDriver</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_5","title":"See Also","text":"<ul> <li>DriverCount</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_7","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#IsClipEnabled","title":"IsClipEnabled","text":"<p>Whether clipping is enabled on the given renderer.</p> <p>Set this property to False to disable clipping. To enable clipping, set the ClipRect property. </p> <p><code>property IsClipEnabled: Boolean read GetIsClipEnabled write SetIsClipEnabled</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_6","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_6","title":"See Also","text":"<ul> <li>ClipRect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_8","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#IsViewportSet","title":"IsViewportSet","text":"<p>Whether an explicit rectangle was set as the viewport.</p> <p>This is useful if you're saving and restoring the viewport and want to know whether you should restore a specific rectangle or reset the viewport. Note that the viewport is always reset when changing rendering targets. </p> <p><code>property IsViewportSet: Boolean read GetIsViewportSet</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_7","title":"See Also","text":"<ul> <li>Viewport</li> <li>ResetViewport</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_9","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#LogicalPresentationRect","title":"LogicalPresentationRect","text":"<p>Get the final presentation rectangle for rendering.</p> <p>This property returns the calculated rectangle used for logical presentation, based on the presentation mode and output size. If logical presentation is disabled, it will fill the rectangle with the output size, in pixels. </p> <p><code>property LogicalPresentationRect: TSdlRect read GetLogicalPresentationRect</code></p> <p>Type: <code>TSdlRect</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_7","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_8","title":"See Also","text":"<ul> <li>SetLogicalPresentation</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_10","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#MetalCommandEncoder","title":"MetalCommandEncoder","text":"<p>Get the Metal command encoder for the current frame.</p> <p>This property returns a pointer, so SDL doesn't have to link to Metal.</p> <p>Returns nil if the renderer isn't a Metal renderer, or if Metal refuses to give SDL a drawable to render to, which might happen if the window is hidden/minimized/offscreen. This doesn't apply to command encoders for render targets, just the window's backbuffer. Check your return values! </p> <p><code>property MetalCommandEncoder: Pointer read GetMetalCommandEncoder</code></p> <p>Type: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_9","title":"See Also","text":"<ul> <li>MetalLayer</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_11","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#MetalLayer","title":"MetalLayer","text":"<p>The CAMetalLayer associated with the given Metal renderer.</p> <p>This property returns a pointer, so SDL doesn't have to link to Metal, but it can be safely cast to a <code>CAMetalLayer</code> using <code>TCAMetalLayer.Wrap()</code>.</p> <p>Returns nil if the renderer isn't a Metal renderer. </p> <p><code>property MetalLayer: Pointer read GetMetalLayer</code></p> <p>Type: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_10","title":"See Also","text":"<ul> <li>MetalCommandEncoder</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_12","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Name","title":"Name","text":"<p>The name of the renderer. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_8","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_13","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#OutputSize","title":"OutputSize","text":"<p>The output size in pixels of a rendering context.</p> <p>This returns the true output size in pixels, ignoring any render targets or logical size and presentation. </p> <p><code>property OutputSize: TSdlSize read GetOutputSize</code></p> <p>Type: <code>TSdlSize</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_9","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_11","title":"See Also","text":"<ul> <li>CurrentOutputSize</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_14","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Properties","title":"Properties","text":"<p>The properties associated with the renderer.</p> <p>The following read-only properties are provided by SDL:</p> <ul> <li><code>TSdlProperty.RendererName</code>: the name of the rendering driver</li> <li><code>TSdlProperty.RendererWindow</code>: the window where rendering is displayed, if any</li> <li><code>TSdlProperty.RendererSurface</code>: the surface where rendering is displayed, if this is a software renderer without a window</li> <li><code>TSdlProperty.RendererVSync</code>: the current vsync setting</li> <li><code>TSdlProperty.RendererMaxTextureSize</code>: the maximum texture width and height</li> <li><code>TSdlProperty.RendererTextureFormats</code>: a PSdlPixelFormat array of pixel formats, terminated with TSdlPixelFormat.Unknown, representing the available texture formats for this renderer.</li> <li><code>TSdlProperty.RendererOutputColorspace</code>: a TSdlColorspace value describing the colorspace for output to the display, defaults to TSdlColorspace.Srgb.</li> <li><code>TSdlProperty.RendererHdrEnabled</code>: True if the output colorspace is TSdlColorspace.SrgbLinear and the renderer is showing on a display with HDR enabled. This property can change dynamically when TSdlEventKind.WindowHdrStateChanged is sent.</li> <li><code>TSdlProperty.RendererSdrWhitePoint</code>: the value of SDR white in the TSdlColorspace.SrgbLinear colorspace. When HDR is enabled, this value is automatically multiplied into the color scale. This property can change dynamically when TSdlEventKind.HdrStateChanged is sent.</li> <li><code>TSdlProperty.RendererHdrHeadroom</code>: the additional high dynamic range that can be displayed, in terms of the SDR white point. When HDR is not enabled, this will be 1.0. This property can change dynamically when TSdlEventKind.HdrStateChanged is sent.</li> </ul> <p>With the Direct3D renderer:</p> <ul> <li><code>TSdlProperty.RendererD3D9Device</code>: the IDirect3DDevice9 associated with the renderer</li> </ul> <p>With the Direct3D11 renderer:</p> <ul> <li><code>TSdlProperty.RendererD3D11Device</code>: the ID3D11Device associated with the renderer</li> <li><code>TSdlProperty.RendererD3D11SwapChain</code>: the IDXGISwapChain1 associated with the renderer. This may change when the window is resized.</li> </ul> <p>With the Direct3D12 renderer:</p> <ul> <li><code>TSdlProperty.RendererD3D12Device</code>: the ID3D12Device associated with the renderer</li> <li><code>TSdlProperty.RendererD3D12SwapChain</code>: the IDXGISwapChain4 associated with the renderer.</li> <li><code>TSdlProperty.RendererD3D12CommandQueue</code>: the ID3D12CommandQueue associated with the renderer</li> </ul> <p>With the vulkan renderer:</p> <ul> <li><code>TSdlProperty.RendererVulkanInstance</code>: the VkInstance associated with the renderer</li> <li><code>TSdlProperty.RendererVulkanSurface</code>: the VkSurfaceKHR associated with the renderer</li> <li><code>TSdlProperty.RendererVulkanPhysicalDevice</code>: the VkPhysicalDevice associated with the renderer</li> <li><code>TSdlProperty.RendererVulkanDevice</code>: the VkDevice associated with the renderer</li> <li><code>TSdlProperty.RendererVulkanGraphicsQueueFamilyIndex</code>: the queue family index used for rendering</li> <li><code>TSdlProperty.RendererVulkanPresentQueueFamilyIndex</code>: the queue family index used for presentation</li> <li><code>TSdlProperty.RendererVulkanSwapChainImageCount</code>: the number of swapchain images, or potential frames in flight, used by the Vulkan renderer</li> </ul> <p>With the GPU renderer:</p> <ul> <li><code>TSdlProperty.RendererGpuDevice</code>: the TSdlGpuDevice associated with the renderer </li> </ul> <p><code>property Properties: TSdlProperties read GetProperties</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_10","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_15","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#SafeArea","title":"SafeArea","text":"<p>The safe area for rendering within the current viewport.</p> <p>Some devices have portions of the screen which are partially obscured or not interactive, possibly due to on-screen controls, curved edges, camera notches, TV overscan, etc. This function provides the area of the current viewport which is safe to have interactible content. You should continue rendering into the rest of the render target, but it should not contain visually important or interactible content. </p> <p><code>property SafeArea: TSdlRect read GetSafeArea</code></p> <p>Type: <code>TSdlRect</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_11","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_16","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Scale","title":"Scale","text":"<p>The drawing scale for rendering on the current target.</p> <p>The drawing coordinates are scaled by the X/Y scaling factors before they are used by the renderer. This allows resolution independent drawing with a single coordinate system.</p> <p>If this results in scaling or subpixel drawing by the rendering backend, it will be handled using the appropriate quality hints. For best results use integer scaling factors. </p> <p><code>property Scale: TSdlPointF read GetScale write SetScale</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_12","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_17","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Target","title":"Target","text":"<p>The current rendering target.</p> <p>The default render target is the window for which the renderer was created. To stop rendering to a texture and render to the window again, set this property to a nil <code>texture</code>. </p> <p><code>property Target: TSdlTexture read GetTarget write SetTarget</code></p> <p>Type: <code>TSdlTexture</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_13","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_18","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Viewport","title":"Viewport","text":"<p>The drawing area for rendering on the current target.</p> <p>Drawing will clip to this area (separately from any clipping done with ClipRect), and the top left of the area will become coordinate (0, 0) for future drawing commands.</p> <p>The area's width and height must be &gt;= 0.</p> <p>Call ResetViewport to set the viewport to the entire target. </p> <p><code>property Viewport: TSdlRect read GetViewport write SetViewport</code></p> <p>Type: <code>TSdlRect</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_14","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_12","title":"See Also","text":"<ul> <li>IsViewportSet</li> <li>ResetViewport</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_19","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#VSync","title":"VSync","text":"<p>The VSync of the renderer.</p> <p>When a renderer is created, vsync defaults to TSdlRendererVSync.Disabled.</p> <p>Can be 1 to synchronize present with every vertical refresh, 2 to synchronize present with every second vertical refresh, etc., TSdlRendererVSync.Adaptive for late swap tearing (adaptive vsync), or TSdlRendererVSync.Disabled to disable. Not every value is supported by every driver, so you should check the return value to see whether the requested setting is supported. </p> <p><code>property VSync: TSdlRendererVsync read GetVSync write SetVSync</code></p> <p>Type: <code>TSdlRendererVsync</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_15","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_20","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Window","title":"Window","text":"<p>The window associated with the renderer. </p> <p><code>property Window: TSdlWindow read GetWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_16","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_21","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Create_0","title":"<code>Create</code>","text":"<p>Create a 2D software rendering context for a surface.</p> <p>The other constructors can also create a software renderer, but they are intended to be used with a TSdlWindow as the final destination and not a TSdlSurface. </p> <p><code>constructor Create(const ASurface: TSdlSurface); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters","title":"Parameters","text":"<p><code>ASurface</code>: <code>TSdlSurface</code> : The srface where rendering is done.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_17","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_13","title":"See Also","text":"<ul> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_22","title":"Remarks","text":"<p>This constructor should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Create_1","title":"<code>Create</code>","text":"<p>Create a 2D rendering context for a window, with the specified properties.</p> <p>These are the supported properties:</p> <ul> <li><code>TSdlProperty.RendererCreateName</code>: the name of the rendering driver to use, if a specific one is desired</li> <li><code>TSdlProperty.RendererCreateWindow</code>: the window where rendering is displayed, required if this isn't a software renderer using a surface</li> <li><code>TSdlProperty.RendererCreateSurface</code>: the surface where rendering is displayed, if you want a software renderer without a window</li> <li><code>TSdlProperty.RendererCreateOutputColorspace</code>: a TSdlColorspace value describing the colorspace for output to the display, defaults to TSdlColorspace.Srgb. The Direct3D11, Direct3D12, and Metal renderers support TSdlColorspace.SrgbLinear, which is a linear color space and supports HDR output. If you select TSdlColorspace.SrgbLinear, drawing still uses the sRGB colorspace, but values can go beyond 1.0 and float (linear) format textures can be used for HDR content.</li> <li><code>TSdlProperty.RendererCreatePresentVSync</code>: non-zero if you want present synchronized with the refresh rate. This property can take any value that is supported by the VSync property for the renderer.</li> </ul> <p>With the vulkan renderer:</p> <ul> <li><code>TSdlProperty.RendererCreateVulkanInstance</code>: the VkInstance to use with the renderer, optional.</li> <li><code>TSdlProperty.RendererCreateVulkanSurface</code>: the VkSurfaceKHR to use with the renderer, optional.</li> <li><code>TSdlProperty.RendererCreateVulkanPhysicalDevice</code>: the VkPhysicalDevice to use with the renderer, optional.</li> <li><code>TSdlProperty.RendererCreateVulkanDevice</code>: the VkDevice to use with the renderer, optional.</li> <li><code>TSdlProperty.RendererCreateVulkanGraphicsQueueFamilyIndex</code>: the queue family index used for rendering.</li> <li><code>TSdlProperty.RendererCreateVulkanPresentQueueFamilyIndex</code>: the queue family index used for presentation. </li> </ul> <p><code>constructor Create(const AProperties: TSdlProperties); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_1","title":"Parameters","text":"<p><code>AProperties</code>: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_18","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_14","title":"See Also","text":"<ul> <li>TSdlProperties</li> <li>Free</li> <li>Name</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_23","title":"Remarks","text":"<p>This constructor should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Create_2","title":"<code>Create</code>","text":"<p>Create a 2D rendering context for a window.</p> <p>If you want a specific renderer, you can specify its name here. A list of available renderers can be obtained through the RenderDriverCount and RenderDrivers properties. If you don't need a specific renderer, don't specify a name (or an empty string) and SDL will attempt to choose the best option for you, based on what is available on the user's system.</p> <p>If <code>AName</code> is a comma-separated list, SDL will try each name, in the order listed, until one succeeds or all of them fail.</p> <p>By default the rendering size matches the window size in pixels, but you can set LogicalPresentation to change the content size and scaling options. </p> <p><code>constructor Create(const AWindow: TSdlWindow; const AName: String = ''); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_2","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : The window where rendering is displayed.</p> <p><code>AName</code>: <code>String = ''</code> : (Optional) name of the rendering driver to initialize, or an empty string to let SDL choose one.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_19","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_15","title":"See Also","text":"<ul> <li>Free</li> <li>DriverCount</li> <li>Drivers</li> <li>Name</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_24","title":"Remarks","text":"<p>This constructor should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Create_3","title":"<code>Create</code>","text":"<p>Create a default renderer and window. </p> <p><code>constructor Create(const ATitle: String; const AWidth, AHeight: Integer; const AWindowFlags: TSdlWindowFlags; out AWindow: TSdlWindow); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_3","title":"Parameters","text":"<p><code>ATitle</code>: <code>String</code> : The title of the window.</p> <p><code>AWidth</code>: <code>Integer</code> : The width of the window.</p> <p><code>AHeight</code>: <code>Integer</code> : The height of the window.</p> <p><code>AWindowFlags</code>: <code>TSdlWindowFlags</code> : The flags used to create the window (see TSdlWindow.Create).</p> <p><code>AWindow</code>: <code>TSdlWindow</code> : Is set to the newly created window.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_20","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_16","title":"See Also","text":"<ul> <li>TSdlWindow.Create</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_25","title":"Remarks","text":"<p>This constructor should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Equal","title":"Equal(TSdlRenderer, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlRenderer; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_4","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlRenderer</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlRenderer; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_5","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#returns_1","title":"Returns","text":"<p><code>TSdlRenderer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#NotEqual","title":"NotEqual(TSdlRenderer, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlRenderer; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_6","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlRenderer</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#AddVulkanSemaphores","title":"AddVulkanSemaphores(UInt32, Int64, Int64)","text":"<p>Add a set of synchronization semaphores for the current frame when using Vulkan.</p> <p>The Vulkan renderer will wait for <code>AWaitSemaphore</code> before submitting rendering commands and signal <code>ASignalSemaphore</code> after rendering commands are complete for this frame.</p> <p>This should be called each frame that you want semaphore synchronization. The Vulkan renderer may have multiple frames in flight on the GPU, so you should have multiple semaphores that are used for synchronization. Querying TSdlProperty.RendererVulkanSwapChainImageCount will give you the maximum number of semaphores you'll need. </p> <p><code>procedure AddVulkanSemaphores(const AWaitStageMask: UInt32; const AWaitSemaphore, ASignalSemaphore: Int64); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_21","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_7","title":"Parameters","text":"<p><code>AWaitStageMask</code>: <code>UInt32</code> : The VkPipelineStageFlags for the wait.</p> <p><code>AWaitSemaphore</code>: <code>Int64</code> : A VkSempahore to wait on before rendering the current frame, or 0 if not needed.</p> <p><code>ASignalSemaphore</code>: <code>Int64</code> : A VkSempahore that SDL will signal when rendering for the current frame is complete, or 0 if not needed.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_26","title":"Remarks","text":"<p>It is NOT safe to call this method from two threads at once. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Clear","title":"Clear","text":"<p>Clear the current rendering target with the drawing color.</p> <p>This function clears the entire rendering target, ignoring the viewport and the clip rectangle. Note, that clearing will also set/fill all pixels of the rendering target to current renderer draw color, so make sure to invoke SetDrawColor when needed. </p> <p><code>procedure Clear; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_22","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_17","title":"See Also","text":"<ul> <li>SetDrawColor</li> <li>DrawColor</li> <li>DrawColorFloat</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_27","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#CreateTexture_0","title":"CreateTexture(TSdlProperties)","text":"<p>Create a texture for this rendering context with the specified properties.</p> <p>These are the supported properties:</p> <ul> <li><code>TSdlProperty.TextureCreateColorspace</code>: a TSdlColorspace value describing the texture colorspace, defaults to TSdlColorspace.SrgbLinear for floating point textures, TSdlColorspace.Hdr10 for 10-bit textures, TSdlColorspace.Srgb for other RGB textures and TSdlColorspace.Jpeg for YUV textures.</li> <li><code>TSdlProperty.TextureCreateFormat</code>: one of the enumerated values in TSdlPixelFormat, defaults to the best RGBA format for the renderer.</li> <li><code>TSdlProperty.TextureCreateAccess</code>: one of the enumerated values in TSdlTextureAccess, defaults to TSdlTextureAccess.Static.</li> <li><code>TSdlProperty.TextureCreateWidth</code>: the width of the texture in pixels, required</li> <li><code>TSdlProperty.TextureCreateHeight</code>: the height of the texture in pixels, required</li> <li><code>TSdlProperty.TextureCreateSdrWhitePoint</code>: for HDR10 and floating point textures, this defines the value of 100% diffuse white, with higher values being displayed in the High Dynamic Range headroom. This defaults to 100 for HDR10 textures and 1.0 for floating point textures.</li> <li><code>TSdlProperty.TextureCreateHdrHeadroom</code>: for HDR10 and floating point textures, this defines the maximum dynamic range used by the content, in terms of the SDR white point. This would be equivalent to maxCLL / TSdlProperty.TextureCreateSdrWhitePoint for HDR10 content. If this is defined, any values outside the range supported by the display will be scaled into the available HDR headroom, otherwise they are clipped.</li> </ul> <p>With the Direct3D11 renderer:</p> <ul> <li><code>TSdlProperty.TextureCreateD3D11Texture</code>: the ID3D11Texture2D associated with the texture, if you want to wrap an existing texture.</li> <li><code>TSdlProperty.TextureCreateD3D11TextureU</code>: the ID3D11Texture2D associated with the U plane of a YUV texture, if you want to wrap an existing texture.</li> <li><code>TSdlProperty.TextureCreateD3D11TextureV</code>: the ID3D11Texture2D associated with the V plane of a YUV texture, if you want to wrap an existing texture.</li> </ul> <p>With the Direct3D12 renderer:</p> <ul> <li><code>TSdlProperty.TextureCreateD3D12Texture</code>: the ID3D12Resource associated with the texture, if you want to wrap an existing texture.</li> <li><code>TSdlProperty.TextureCreateD3D12TextureU</code>: the ID3D12Resource associated with the U plane of a YUV texture, if you want to wrap an existing texture.</li> <li><code>TSdlProperty.TextureCreateD3D12TextureV</code>: the ID3D12Resource associated with the V plane of a YUV texture, if you want to wrap an existing texture.</li> </ul> <p>With the Metal renderer:</p> <ul> <li><code>TSdlProperty.TextureCreateMetalPixelBuffer</code>: the CVPixelBufferRef associated with the texture, if you want to create a texture from an existing pixel buffer.</li> </ul> <p>With the OpenGL renderer:</p> <ul> <li><code>TSdlProperty.TextureCreateOpenGLTexture</code>: the GLuint texture associated with the texture, if you want to wrap an existing texture.</li> <li><code>TSdlProperty.TextureCreateOpenGLTextureUV</code>: the GLuint texture associated with the UV plane of an NV12 texture, if you want to wrap an existing texture.</li> <li><code>TSdlProperty.TextureCreateOpenGLTextureU</code>: the GLuint texture associated with the U plane of a YUV texture, if you want to wrap an existing texture.</li> <li><code>TSdlProperty.TextureCreateOpenGLTextureV</code>: the GLuint texture associated with the V plane of a YUV texture, if you want to wrap an existing texture.</li> </ul> <p>With the OpenGL-ES2 renderer:</p> <ul> <li><code>TSdlProperty.TextureCreateOpenGles2Texture</code>: the GLuint texture associated with the texture, if you want to wrap an existing texture.</li> <li><code>TSdlProperty.TextureCreateOpenGles2TextureUV</code>: the GLuint texture associated with the UV plane of an NV12 texture, if you want to wrap an existing texture.</li> <li><code>TSdlProperty.TextureCreateOpenGles2TextureU</code>: the GLuint texture associated with the U plane of a YUV texture, if you want to wrap an existing texture.</li> <li><code>TSdlProperty.TextureCreateOpenGles2TextureV</code>: the GLuint texture associated with the V plane of a YUV texture, if you want to wrap an existing texture.</li> </ul> <p>With the Vulkan renderer:</p> <ul> <li><code>TSdlProperty.TextureCreateVulkanTexture</code>: the VkImage with layout VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL associated with the texture, if you want to wrap an existing texture. </li> </ul> <p><code>function CreateTexture(const AProps: TSdlProperties): TSdlTexture; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_23","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_8","title":"Parameters","text":"<p><code>AProps</code>: <code>TSdlProperties</code> : The properties to use.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#returns_3","title":"Returns","text":"<p><code>TSdlTexture</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_18","title":"See Also","text":"<ul> <li>TSdlTexture.Free</li> <li>TSdlTexture.Size</li> <li>TSdlTexture.Update</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_28","title":"Remarks","text":"<p>This constructor should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#CreateTexture_1","title":"CreateTexture(TSdlSurface)","text":"<p>Create a texture for this rendering context from an existing surface.</p> <p>The surface is not modified or freed by this function.</p> <p>The TSdlTextureAccess hint for the created texture is <code>TSdlHints.TextureAccessStatic</code>.</p> <p>The pixel format of the created texture may be different from the pixel format of the surface, and can be queried using the TSdlProperty.TextureFormat property. </p> <p><code>function CreateTexture(const ASurface: TSdlSurface): TSdlTexture; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_24","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_9","title":"Parameters","text":"<p><code>ASurface</code>: <code>TSdlSurface</code> : The surface containing pixel data used to fill the texture.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#returns_4","title":"Returns","text":"<p><code>TSdlTexture</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_19","title":"See Also","text":"<ul> <li>TSdlTexture.Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_29","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#CreateTexture_2","title":"CreateTexture(TSdlPixelFormat, TSdlTextureAccess, Integer, Integer)","text":"<p>Create a texture for this rendering context.</p> <p>The contents of a texture when first created are not defined. </p> <p><code>function CreateTexture(const AFormat: TSdlPixelFormat; const AAccess: TSdlTextureAccess; const AW, AH: Integer): TSdlTexture; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_25","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_10","title":"Parameters","text":"<p><code>AFormat</code>: <code>TSdlPixelFormat</code> : The pixel format.</p> <p><code>AAccess</code>: <code>TSdlTextureAccess</code> : Texture access.</p> <p><code>AW</code>: <code>Integer</code> : The width of the texture in pixels.</p> <p><code>AH</code>: <code>Integer</code> : The height of the texture in pixels.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#returns_5","title":"Returns","text":"<p><code>TSdlTexture</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_20","title":"See Also","text":"<ul> <li>TSdlTexture.Free</li> <li>TSdlTexture.Size</li> <li>TSdlTexture.Update</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_30","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawDebugText_0","title":"DrawDebugText(TSdlPointF, String)","text":"<p>Draw debug text.</p> <p>This function will render a string of text. Note that this is a convenience function for debugging, with severe limitations, and not intended to be used for production apps and games.</p> <p>Among these limitations:</p> <ul> <li>It will only renders ASCII characters.</li> <li>It has a single, tiny size (8x8 pixels). One can use logical presentation or scaling to adjust it, but it will be blurry.</li> <li>It uses a simple, hardcoded bitmap font. It does not allow different font selections and it does not support truetype, for proper scaling.</li> <li>It does no word-wrapping and does not treat newline characters as a line break. If the text goes out of the window, it's gone.</li> </ul> <p>For serious text rendering, there are several good options, such as SDL_ttf, stb_truetype, or other external libraries.</p> <p>On first use, this will create an internal texture for rendering glyphs. This texture will live until the renderer is destroyed.</p> <p>The text is drawn in the color specified by DrawColor. </p> <p><code>procedure DrawDebugText(const APosition: TSdlPointF; const AString: String); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_26","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_11","title":"Parameters","text":"<p><code>APosition</code>: <code>TSdlPointF</code> : The top-left corner of the text will draw. will draw.</p> <p><code>AString</code>: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_21","title":"See Also","text":"<ul> <li>SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_31","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawDebugText_1","title":"DrawDebugText(Single, Single, String)","text":"<p>Draw debug text.</p> <p>This function will render a string of text. Note that this is a convenience function for debugging, with severe limitations, and not intended to be used for production apps and games.</p> <p>Among these limitations:</p> <ul> <li>It will only renders ASCII characters.</li> <li>It has a single, tiny size (8x8 pixels). One can use logical presentation or scaling to adjust it, but it will be blurry.</li> <li>It uses a simple, hardcoded bitmap font. It does not allow different font selections and it does not support truetype, for proper scaling.</li> <li>It does no word-wrapping and does not treat newline characters as a line break. If the text goes out of the window, it's gone.</li> </ul> <p>For serious text rendering, there are several good options, such as SDL_ttf, stb_truetype, or other external libraries.</p> <p>On first use, this will create an internal texture for rendering glyphs. This texture will live until the renderer is destroyed.</p> <p>The text is drawn in the color specified by DrawColor. </p> <p><code>procedure DrawDebugText(const AX, AY: Single; const AString: String); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_27","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_12","title":"Parameters","text":"<p><code>AX</code>: <code>Single</code> : The X coordinate where the top-left corner of the text will draw.</p> <p><code>AY</code>: <code>Single</code> : the Y coordinate where the top-left corner of the text will draw.</p> <p><code>AString</code>: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_22","title":"See Also","text":"<ul> <li>SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_32","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawGeometry_0","title":"DrawGeometry(TSdlTexture, TArray&lt;TSdlPointF&gt;, Integer, TArray&lt;TSdlColorF&gt;, Integer, TArray&lt;TSdlPointF&gt;, Integer, Pointer, Integer, TSdlIndexType)","text":"<p>Render a list of triangles, optionally using a texture and indices into the vertex array. Color and alpha modulation is done per vertex (TSdlTexture.ColorMod and TSdlTexture.AlphaMod are ignored). </p> <p><code>procedure DrawGeometry(const ATexture: TSdlTexture; const AXY: TArray&lt;TSdlPointF&gt;; const AXYStride: Integer; const AColor: TArray&lt;TSdlColorF&gt;; const AColorStride: Integer; const AUV: TArray&lt;TSdlPointF&gt;; const AUVStride: Integer; const AIndices: Pointer = nil; const ANumIndices: Integer = 0; const AIndexType: TSdlIndexType = TSdlIndexType.Word); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_28","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_13","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlTexture</code> : The texture to use.</p> <p><code>AXY</code>: <code>TArray&lt;TSdlPointF&gt;</code> : Vertex positions.</p> <p><code>AXYStride</code>: <code>Integer</code> : Byte size to move from one element to the next element.</p> <p><code>AColor</code>: <code>TArray&lt;TSdlColorF&gt;</code> : Vertex colors.</p> <p><code>AColorStride</code>: <code>Integer</code> : Byte size to move from one element to the next element.</p> <p><code>AUV</code>: <code>TArray&lt;TSdlPointF&gt;</code> : Vertex normalized texture coordinates.</p> <p><code>AUVStride</code>: <code>Integer</code> : Byte size to move from one element to the next element.</p> <p><code>AIndices</code>: <code>Pointer = nil</code> : (Optional) Pointer to an array of indices into the vertex arrays. If nil (default) all vertices will be rendered in sequential order.</p> <p><code>ANumIndices</code>: <code>Integer = 0</code> : Number of indices.</p> <p><code>AIndexType</code>: <code>TSdlIndexType = TSdlIndexType.Word</code> : (Optional) type of each index in AIndices. Defaults to TSdlIndexType.Word</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_33","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawGeometry_1","title":"DrawGeometry(TArray&lt;TSdlPointF&gt;, Integer, TArray&lt;TSdlColorF&gt;, Integer, TArray&lt;TSdlPointF&gt;, Integer, Pointer, Integer, TSdlIndexType)","text":"<p>Render a list of triangles, optionally using indices into the vertex array. Color and alpha modulation is done per vertex (TSdlTexture.ColorMod and TSdlTexture.AlphaMod are ignored). </p> <p><code>procedure DrawGeometry(const AXY: TArray&lt;TSdlPointF&gt;; const AXYStride: Integer; const AColor: TArray&lt;TSdlColorF&gt;; const AColorStride: Integer; const AUV: TArray&lt;TSdlPointF&gt;; const AUVStride: Integer; const AIndices: Pointer = nil; const ANumIndices: Integer = 0; const AIndexType: TSdlIndexType = TSdlIndexType.Word); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_29","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_14","title":"Parameters","text":"<p><code>AXY</code>: <code>TArray&lt;TSdlPointF&gt;</code> : Vertex positions.</p> <p><code>AXYStride</code>: <code>Integer</code> : Byte size to move from one element to the next element.</p> <p><code>AColor</code>: <code>TArray&lt;TSdlColorF&gt;</code> : Vertex colors.</p> <p><code>AColorStride</code>: <code>Integer</code> : Byte size to move from one element to the next element.</p> <p><code>AUV</code>: <code>TArray&lt;TSdlPointF&gt;</code> : Vertex normalized texture coordinates.</p> <p><code>AUVStride</code>: <code>Integer</code> : Byte size to move from one element to the next element.</p> <p><code>AIndices</code>: <code>Pointer = nil</code> : (Optional) Pointer to an array of indices into the vertex arrays. If nil (default) all vertices will be rendered in sequential order.</p> <p><code>ANumIndices</code>: <code>Integer = 0</code> : Number of indices.</p> <p><code>AIndexType</code>: <code>TSdlIndexType = TSdlIndexType.Word</code> : (Optional) type of each index in AIndices. Defaults to TSdlIndexType.Word</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_34","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawGeometry_2","title":"DrawGeometry(TSdlTexture, TArray&lt;TSdlVertex&gt;, TArray&lt;Integer&gt;)","text":"<p>Render a list of triangles, optionally using a texture and indices into the vertex array. Color and alpha modulation is done per vertex (TSdlTexture.ColorMod and TSdlTexture.AlphaMod are ignored). </p> <p><code>procedure DrawGeometry(const ATexture: TSdlTexture; const AVertices: TArray&lt;TSdlVertex&gt;; const AIndices: TArray&lt;Integer&gt; = nil); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_30","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_15","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlTexture</code> : Texture to use.</p> <p><code>AVertices</code>: <code>TArray&lt;TSdlVertex&gt;</code> : The vertices.</p> <p><code>AIndices</code>: <code>TArray&lt;Integer&gt; = nil</code> : (Optional) Array of integer indices into the 'AVertices' array. If nil (default) all vertices will be rendered in sequential order.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_35","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawGeometry_3","title":"DrawGeometry(TArray&lt;TSdlVertex&gt;, TArray&lt;Integer&gt;)","text":"<p>Render a list of triangles, optionally using indices into the vertex array. Color and alpha modulation is done per vertex. </p> <p><code>procedure DrawGeometry(const AVertices: TArray&lt;TSdlVertex&gt;; const AIndices: TArray&lt;Integer&gt; = nil); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_31","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_16","title":"Parameters","text":"<p><code>AVertices</code>: <code>TArray&lt;TSdlVertex&gt;</code> : The vertices.</p> <p><code>AIndices</code>: <code>TArray&lt;Integer&gt; = nil</code> : (Optional) Array of integer indices into the 'AVertices' array. If nil (default) all vertices will be rendered in sequential order.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_36","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawLine_0","title":"DrawLine(TSdlPointF, TSdlPointF)","text":"<p>Draw a line on the current rendering target at subpixel precision. </p> <p><code>procedure DrawLine(const AP1, AP2: TSdlPointF); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_32","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_17","title":"Parameters","text":"<p><code>AP1</code>: <code>TSdlPointF</code> : The start point.</p> <p><code>AP2</code>: <code>TSdlPointF</code> : The end point.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_23","title":"See Also","text":"<ul> <li>DrawLines</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_37","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawLine_1","title":"DrawLine(Single, Single, Single, Single)","text":"<p>Draw a line on the current rendering target at subpixel precision. </p> <p><code>procedure DrawLine(const AX1, AY1, AX2, AY2: Single); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_33","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_18","title":"Parameters","text":"<p><code>AX1</code>: <code>Single</code> : The X coordinate of the start point.</p> <p><code>AY1</code>: <code>Single</code> : The Y coordinate of the start point.</p> <p><code>AX2</code>: <code>Single</code> : The X coordinate of the end point.</p> <p><code>AY2</code>: <code>Single</code> : The Y coordinate of the end point.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_24","title":"See Also","text":"<ul> <li>DrawLines</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_38","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawLines_0","title":"DrawLines(TSdlPointF[])","text":"<p>Draw a series of connected lines on the current rendering target at subpixel precision. </p> <p><code>procedure DrawLines(const APoints: array of TSdlPointF); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_34","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_19","title":"Parameters","text":"<p><code>APoints</code>: <code>array of TSdlPointF</code> : The points along the lines.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_25","title":"See Also","text":"<ul> <li>DrawLine</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_39","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawLines_1","title":"DrawLines(TArray&lt;TSdlPointF&gt;)","text":"<p>Draw a series of connected lines on the current rendering target at subpixel precision. </p> <p><code>procedure DrawLines(const APoints: TArray&lt;TSdlPointF&gt;); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_35","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_20","title":"Parameters","text":"<p><code>APoints</code>: <code>TArray&lt;TSdlPointF&gt;</code> : The points along the lines.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_26","title":"See Also","text":"<ul> <li>DrawLine</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_40","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawPoint_0","title":"DrawPoint(TSdlPointF)","text":"<p>Draw a point on the current rendering target at subpixel precision. </p> <p><code>procedure DrawPoint(const APoint: TSdlPointF); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_36","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_21","title":"Parameters","text":"<p><code>APoint</code>: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_27","title":"See Also","text":"<ul> <li>DrawPoints</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_41","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawPoint_1","title":"DrawPoint(Single, Single)","text":"<p>Draw a point on the current rendering target at subpixel precision. </p> <p><code>procedure DrawPoint(const AX, AY: Single); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_37","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_22","title":"Parameters","text":"<p><code>AX</code>: <code>Single</code> : The X coordinate of the point.</p> <p><code>AY</code>: <code>Single</code> : the Y coordinate of the point.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_28","title":"See Also","text":"<ul> <li>DrawPoints</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_42","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawPoints_0","title":"DrawPoints(TSdlPointF[])","text":"<p>Draw multiple points on the current rendering target at subpixel precision. </p> <p><code>procedure DrawPoints(const APoints: array of TSdlPointF); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_38","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_23","title":"Parameters","text":"<p><code>APoints</code>: <code>array of TSdlPointF</code> : The points to draw.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_29","title":"See Also","text":"<ul> <li>DrawPoint</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_43","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawPoints_1","title":"DrawPoints(TArray&lt;TSdlPointF&gt;)","text":"<p>Draw multiple points on the current rendering target at subpixel precision. </p> <p><code>procedure DrawPoints(const APoints: TArray&lt;TSdlPointF&gt;); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_39","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_24","title":"Parameters","text":"<p><code>APoints</code>: <code>TArray&lt;TSdlPointF&gt;</code> : The points to draw.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_30","title":"See Also","text":"<ul> <li>DrawPoint</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_44","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawRect","title":"DrawRect(TSdlRectF)","text":"<p>Draw a rectangle on the current rendering target at subpixel precision. </p> <p><code>procedure DrawRect(const ARect: TSdlRectF); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_40","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_25","title":"Parameters","text":"<p><code>ARect</code>: <code>TSdlRectF</code> : The destination rectangle.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_31","title":"See Also","text":"<ul> <li>DrawRects</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_45","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawRects_0","title":"DrawRects(TSdlRectF[])","text":"<p>Draw some number of rectangles on the current rendering target at subpixel precision. </p> <p><code>procedure DrawRects(const ARects: array of TSdlRectF); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_41","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_26","title":"Parameters","text":"<p><code>ARects</code>: <code>array of TSdlRectF</code> : Array of destination rectangles.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_32","title":"See Also","text":"<ul> <li>DrawRect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_46","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawRects_1","title":"DrawRects(TArray&lt;TSdlRectF&gt;)","text":"<p>Draw some number of rectangles on the current rendering target at subpixel precision. </p> <p><code>procedure DrawRects(const ARects: TArray&lt;TSdlRectF&gt;); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_42","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_27","title":"Parameters","text":"<p><code>ARects</code>: <code>TArray&lt;TSdlRectF&gt;</code> : Array of destination rectangles.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_33","title":"See Also","text":"<ul> <li>DrawRect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_47","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawTexture_0","title":"DrawTexture(TSdlTexture, TSdlRectF, TSdlRectF)","text":"<p>Copy a portion of the texture to the current rendering target at subpixel precision. </p> <p><code>procedure DrawTexture(const ATexture: TSdlTexture; const ASrcRect, ADstRect: TSdlRectF); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_43","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_28","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlTexture</code> : The source texture.</p> <p><code>ASrcRect</code>: <code>TSdlRectF</code> : The source rectangle.</p> <p><code>ADstRect</code>: <code>TSdlRectF</code> : The destination rectangle.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_34","title":"See Also","text":"<ul> <li>DrawTextureRotated</li> <li>DrawTextureTiled</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_48","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawTexture_1","title":"DrawTexture(TSdlTexture, TSdlRectF)","text":"<p>Copy the texture to the current rendering target at subpixel precision. </p> <p><code>procedure DrawTexture(const ATexture: TSdlTexture; const ADstRect: TSdlRectF); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_44","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_29","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlTexture</code> : The source texture.</p> <p><code>ADstRect</code>: <code>TSdlRectF</code> : The destination rectangle.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_35","title":"See Also","text":"<ul> <li>DrawTextureRotated</li> <li>DrawTextureTiled</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_49","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawTexture9Grid_0","title":"DrawTexture9Grid(TSdlTexture, TSdlRectF, Single, Single, Single, Single, Single, TSdlRectF)","text":"<p>Perform a scaled copy using the 9-grid algorithm to the current rendering target at subpixel precision.</p> <p>The pixels in the texture are split into a 3x3 grid, using the different corner sizes for each corner, and the sides and center making up the remaining pixels. The corners are then scaled using <code>AScale</code> and fit into the corners of the destination rectangle. The sides and center are then stretched into place to cover the remaining destination rectangle. </p> <p><code>procedure DrawTexture9Grid(const ATexture: TSdlTexture; const ASrcRect: TSdlRectF; const ALeftWidth, ARightWidth, ATopHeight, ABottomHeight, AScale: Single; const ADstRect: TSdlRectF); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_45","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_30","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlTexture</code> : The source texture.</p> <p><code>ASrcRect</code>: <code>TSdlRectF</code> : The rectangle to be used for the 9-grid</p> <p><code>ALeftWidth</code>: <code>Single</code> : The width, in pixels, of the left corners in <code>ASrcRect</code>.</p> <p><code>ARightWidth</code>: <code>Single</code> : The width, in pixels, of the right corners in <code>ASrcRect</code>.</p> <p><code>ATopHeight</code>: <code>Single</code> : The height, in pixels, of the top corners in <code>ASrcRect</code>.</p> <p><code>ABottomHeight</code>: <code>Single</code> : The height, in pixels, of the bottom corners in <code>ASrcRect</code>.</p> <p><code>AScale</code>: <code>Single</code> : The scale used to transform the corner of <code>ASrcRect</code> into the corner of <code>ADstRect</code>, or 0.0 for an unscaled copy.</p> <p><code>ADstRect</code>: <code>TSdlRectF</code> : The destination rectangle.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_36","title":"See Also","text":"<ul> <li>DrawTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_50","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawTexture9Grid_1","title":"DrawTexture9Grid(TSdlTexture, Single, Single, Single, Single, Single, TSdlRectF)","text":"<p>Perform a scaled copy using the 9-grid algorithm to the current rendering target at subpixel precision.</p> <p>The pixels in the texture are split into a 3x3 grid, using the different corner sizes for each corner, and the sides and center making up the remaining pixels. The corners are then scaled using <code>AScale</code> and fit into the corners of the destination rectangle. The sides and center are then stretched into place to cover the remaining destination rectangle. </p> <p><code>procedure DrawTexture9Grid(const ATexture: TSdlTexture; const ALeftWidth, ARightWidth, ATopHeight, ABottomHeight, AScale: Single; const ADstRect: TSdlRectF); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_46","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_31","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlTexture</code> : The source texture.</p> <p><code>ALeftWidth</code>: <code>Single</code> : The width, in pixels, of the left corners.</p> <p><code>ARightWidth</code>: <code>Single</code> : The width, in pixels, of the right corners.</p> <p><code>ATopHeight</code>: <code>Single</code> : The height, in pixels, of the top corners.</p> <p><code>ABottomHeight</code>: <code>Single</code> : The height, in pixels, of the bottom corners.</p> <p><code>AScale</code>: <code>Single</code> : The scale used to transform the corner of the texture rectangle into the corner of <code>ADstRect</code>, or 0.0 for an unscaled copy.</p> <p><code>ADstRect</code>: <code>TSdlRectF</code> : The destination rectangle.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_37","title":"See Also","text":"<ul> <li>DrawTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_51","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawTextureAffine_0","title":"DrawTextureAffine(TSdlTexture, TSdlRectF, TSdlPointF, TSdlPointF, TSdlPointF)","text":"<p>Copy a portion of the source texture to the current rendering target, with affine transform, at subpixel precision. </p> <p><code>procedure DrawTextureAffine(const ATexture: TSdlTexture; const ASrcRect: TSdlRectF; const AOrigin, ARight, ADown: TSdlPointF); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_47","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_32","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlTexture</code> : The source texture.</p> <p><code>ASrcRect</code>: <code>TSdlRectF</code> : The source rectangle.</p> <p><code>AOrigin</code>: <code>TSdlPointF</code> : Where the top-left corner of ASrcRect should be mapped to.</p> <p><code>ARight</code>: <code>TSdlPointF</code> : Where the top-right corner of ASrcRect should be mapped to.</p> <p><code>ADown</code>: <code>TSdlPointF</code> : Where the bottom-left corner of srcrect should be mapped to, or NULL for the rendering target's.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_38","title":"See Also","text":"<ul> <li>DrawTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_52","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawTextureAffine_1","title":"DrawTextureAffine(TSdlTexture, TSdlPointF, TSdlPointF, TSdlPointF)","text":"<p>Copy the source texture to the current rendering target, with affine transform, at subpixel precision. </p> <p><code>procedure DrawTextureAffine(const ATexture: TSdlTexture; const AOrigin, ARight, ADown: TSdlPointF); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_48","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_33","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlTexture</code> : The source texture.</p> <p><code>AOrigin</code>: <code>TSdlPointF</code> : Where the top-left corner of ASrcRect should be mapped to.</p> <p><code>ARight</code>: <code>TSdlPointF</code> : Where the top-right corner of ASrcRect should be mapped to.</p> <p><code>ADown</code>: <code>TSdlPointF</code> : Where the bottom-left corner of srcrect should be mapped to, or NULL for the rendering target's.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_39","title":"See Also","text":"<ul> <li>DrawTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_53","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawTextureRotated_0","title":"DrawTextureRotated(TSdlTexture, TSdlRectF, TSdlRectF, Double, TSdlPointF, TSdlFlipModes)","text":"<p>Copy a portion of the source texture to the current rendering target, with rotation and flipping, at subpixel precision.</p> <p><code>procedure DrawTextureRotated(const ATexture: TSdlTexture; const ASrcRect, ADstRect: TSdlRectF; const AAngle: Double; const ACenter: TSdlPointF; const AFlip: TSdlFlipModes = []); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_49","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_34","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlTexture</code> : The source texture.</p> <p><code>ASrcRect</code>: <code>TSdlRectF</code> : The source rectangle.</p> <p><code>ADstRect</code>: <code>TSdlRectF</code> : The destination rectangle.</p> <p><code>AAngle</code>: <code>Double</code> : An angle in degrees that indicates the rotation that will be applied to ADstRect, rotating it in a clockwise direction.</p> <p><code>ACenter</code>: <code>TSdlPointF</code> : The point around which ADstRect will be rotated.</p> <p><code>AFlip</code>: <code>TSdlFlipModes = []</code> : (Optional) flipping actions that should be performed on the texture. Defaults to [] (none).</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_40","title":"See Also","text":"<ul> <li>DrawTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_54","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawTextureRotated_1","title":"DrawTextureRotated(TSdlTexture, TSdlRectF, TSdlRectF, Double, TSdlFlipModes)","text":"<p>Copy a portion of the source texture to the current rendering target, with rotation and flipping, at subpixel precision. </p> <p><code>procedure DrawTextureRotated(const ATexture: TSdlTexture; const ASrcRect, ADstRect: TSdlRectF; const AAngle: Double; const AFlip: TSdlFlipModes = []); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_50","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_35","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlTexture</code> : The source texture.</p> <p><code>ASrcRect</code>: <code>TSdlRectF</code> : The source rectangle.</p> <p><code>ADstRect</code>: <code>TSdlRectF</code> : The destination rectangle.</p> <p><code>AAngle</code>: <code>Double</code> : An angle in degrees that indicates the rotation that will be applied around the center of ADstRect, rotating it in a clockwise direction.</p> <p><code>AFlip</code>: <code>TSdlFlipModes = []</code> : (Optional) flipping actions that should be performed on the texture. Defaults to [] (none).</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_41","title":"See Also","text":"<ul> <li>DrawTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_55","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawTextureRotated_2","title":"DrawTextureRotated(TSdlTexture, TSdlRectF, Double, TSdlPointF, TSdlFlipModes)","text":"<p>Copy the source texture to the current rendering target, with rotation and flipping, at subpixel precision.</p> <p><code>procedure DrawTextureRotated(const ATexture: TSdlTexture; const ADstRect: TSdlRectF; const AAngle: Double; const ACenter: TSdlPointF; const AFlip: TSdlFlipModes = []); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_51","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_36","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlTexture</code> : The source texture.</p> <p><code>ADstRect</code>: <code>TSdlRectF</code> : The destination rectangle.</p> <p><code>AAngle</code>: <code>Double</code> : An angle in degrees that indicates the rotation that will be applied to ADstRect, rotating it in a clockwise direction.</p> <p><code>ACenter</code>: <code>TSdlPointF</code> : The point around which ADstRect will be rotated.</p> <p><code>AFlip</code>: <code>TSdlFlipModes = []</code> : (Optional) flipping actions that should be performed on the texture. Defaults to [] (none).</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_42","title":"See Also","text":"<ul> <li>DrawTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_56","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawTextureRotated_3","title":"DrawTextureRotated(TSdlTexture, TSdlRectF, Double, TSdlFlipModes)","text":"<p>Copy the source texture to the current rendering target, with rotation and flipping, at subpixel precision. </p> <p><code>procedure DrawTextureRotated(const ATexture: TSdlTexture; const ADstRect: TSdlRectF; const AAngle: Double; const AFlip: TSdlFlipModes = []); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_52","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_37","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlTexture</code> : The source texture.</p> <p><code>ADstRect</code>: <code>TSdlRectF</code> : The destination rectangle.</p> <p><code>AAngle</code>: <code>Double</code> : An angle in degrees that indicates the rotation that will be applied around the center of ADstRect, rotating it in a clockwise direction.</p> <p><code>AFlip</code>: <code>TSdlFlipModes = []</code> : (Optional) flipping actions that should be performed on the texture. Defaults to [] (none).</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_43","title":"See Also","text":"<ul> <li>DrawTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_57","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawTextureTiled_0","title":"DrawTextureTiled(TSdlTexture, TSdlRectF, Single, TSdlRectF)","text":"<p>Tile a portion of the texture to the current rendering target at subpixel precision.</p> <p>The pixels in <code>ASrcRect</code> will be repeated as many times as needed to completely fill <code>ADstRect</code>. </p> <p><code>procedure DrawTextureTiled(const ATexture: TSdlTexture; const ASrcRect: TSdlRectF; const AScale: Single; const ADstRect: TSdlRectF); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_53","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_38","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlTexture</code> : The source texture.</p> <p><code>ASrcRect</code>: <code>TSdlRectF</code> : The source rectangle.</p> <p><code>AScale</code>: <code>Single</code> : The scale used to transform srcrect into the destination rectangle, e.g. a 32x32 texture with a scale of 2 would fill 64x64 tiles.</p> <p><code>ADstRect</code>: <code>TSdlRectF</code> : The destination rectangle.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_44","title":"See Also","text":"<ul> <li>DrawTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_58","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#DrawTextureTiled_1","title":"DrawTextureTiled(TSdlTexture, Single, TSdlRectF)","text":"<p>Tile the texture to the current rendering target at subpixel precision.</p> <p>The pixels in the texture will be repeated as many times as needed to completely fill <code>ADstRect</code>. </p> <p><code>procedure DrawTextureTiled(const ATexture: TSdlTexture; const AScale: Single; const ADstRect: TSdlRectF); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_54","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_39","title":"Parameters","text":"<p><code>ATexture</code>: <code>TSdlTexture</code> : The source texture.</p> <p><code>AScale</code>: <code>Single</code> : The scale used to transform srcrect into the destination rectangle, e.g. a 32x32 texture with a scale of 2 would fill 64x64 tiles.</p> <p><code>ADstRect</code>: <code>TSdlRectF</code> : The destination rectangle.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_45","title":"See Also","text":"<ul> <li>DrawTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_59","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#FillRect","title":"FillRect(TSdlRectF)","text":"<p>Fill a rectangle on the current rendering target with the drawing color at subpixel precision. </p> <p><code>procedure FillRect(const ARect: TSdlRectF); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_55","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_40","title":"Parameters","text":"<p><code>ARect</code>: <code>TSdlRectF</code> : The destination rectangle.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_46","title":"See Also","text":"<ul> <li>FillRects</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_60","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#FillRects_0","title":"FillRects(TSdlRectF[])","text":"<p>Fill some number of rectangles on the current rendering target with the drawing color at subpixel precision. </p> <p><code>procedure FillRects(const ARects: array of TSdlRectF); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_56","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_41","title":"Parameters","text":"<p><code>ARects</code>: <code>array of TSdlRectF</code> : Array of destination rectangles.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_47","title":"See Also","text":"<ul> <li>FillRect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_61","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#FillRects_1","title":"FillRects(TArray&lt;TSdlRectF&gt;)","text":"<p>Fill some number of rectangles on the current rendering target with the drawing color at subpixel precision. </p> <p><code>procedure FillRects(const ARects: TArray&lt;TSdlRectF&gt;); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_57","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_42","title":"Parameters","text":"<p><code>ARects</code>: <code>TArray&lt;TSdlRectF&gt;</code> : Array of destination rectangles.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_48","title":"See Also","text":"<ul> <li>FillRect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_62","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Flush","title":"Flush","text":"<p>Force the rendering context to flush any pending commands and state.</p> <p>You do not need to (and in fact, shouldn't) call this function unless you are planning to call into OpenGL/Direct3D/Metal/whatever directly, in addition to using a TSdlRenderer.</p> <p>This is for a very-specific case: if you are using SDL's render API, and you plan to make OpenGL/D3D/whatever calls in addition to SDL render API calls. If this applies, you should call this function between calls to SDL's render API and the low-level API you're using in cooperation.</p> <p>In all other cases, you can ignore this function.</p> <p>This call makes SDL flush any pending rendering work it was queueing up to do later in a single batch, and marks any internal cached state as invalid, so it'll prepare all its state again later, from scratch.</p> <p>This means you do not need to save state in your rendering code to protect the SDL renderer. However, there lots of arbitrary pieces of Direct3D and OpenGL state that can confuse things; you should use your best judgment and be prepared to make changes if specific state needs to be protected. </p> <p><code>procedure Flush; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_58","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_63","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#ForWindow","title":"ForWindow(TSdlWindow)","text":"<p>Get the renderer associated with a window. </p> <p><code>class function ForWindow(const AWindow: TSdlWindow): TSdlRenderer; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_59","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_43","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : The window to query.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#returns_6","title":"Returns","text":"<p><code>TSdlRenderer</code>: The rendering context.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_64","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Free","title":"Free","text":"<p>Destroy the rendering context for a window and free all associated textures.</p> <p>This should be called before destroying the associated window. </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_65","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#GetLogicalPresentation","title":"GetLogicalPresentation(Integer, Integer, TSdlRendererLogicalPresentation)","text":"<p>Get device independent resolution and presentation mode for rendering.</p> <p>This method gets the width and height of the logical rendering output, or the output size in pixels if a logical resolution is not enabled. </p> <p><code>procedure GetLogicalPresentation(out AW, AH: Integer; out AMode: TSdlRendererLogicalPresentation); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_60","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_44","title":"Parameters","text":"<p><code>AW</code>: <code>Integer</code> : Set to the width.</p> <p><code>AH</code>: <code>Integer</code> : Set to the height.</p> <p><code>AMode</code>: <code>TSdlRendererLogicalPresentation</code> : Set to the presentation.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_49","title":"See Also","text":"<ul> <li>SetLogicalPresentation</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_66","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#Present","title":"Present","text":"<p>Update the screen with any rendering performed since the previous call.</p> <p>SDL's rendering functions operate on a backbuffer; that is, calling a rendering function such as DrawLine does not directly put a line on the screen, but rather updates the backbuffer. As such, you compose your entire scene and present the composed backbuffer to the screen as a complete picture.</p> <p>Therefore, when using SDL's rendering API, one does all drawing intended for the frame, and then calls this function once per frame to present the final drawing to the user.</p> <p>The backbuffer should be considered invalidated after each present; do not assume that previous contents will exist between frames. You are strongly encouraged to call Clear to initialize the backbuffer before starting each new frame's drawing, even if you plan to overwrite every pixel.</p> <p>Please note, that in case of rendering to a texture - there is no need to call <code>Present</code> after drawing needed objects to a texture, and should not be done; you are only required to change back the rendering target to default via <code>RenderTarget := nil</code> afterwards, as textures by themselves do not have a concept of backbuffers. Calling Present while rendering to a texture will still update the screen with any current drawing that has been done to the window itself. </p> <p><code>procedure Present; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_61","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_50","title":"See Also","text":"<ul> <li>Clear</li> <li>FillRect</li> <li>FillRects</li> <li>DrawLine</li> <li>DrawLines</li> <li>DrawPoint</li> <li>DrawPoints</li> <li>DrawRect</li> <li>DrawRects</li> <li>DrawBlendMode</li> <li>SetDrawColor</li> <li>DrawColor</li> <li>DrawColorFloat</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_67","title":"Remarks","text":"<p>This methodn should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#ReadPixels_0","title":"ReadPixels(TSdlRect)","text":"<p>Read pixels from the current rendering target.</p> <p>The returned surface should be freed.</p> <p>WARNING: This is a very slow operation, and should not be used frequently. If you're using this on the main rendering target, it should be called after rendering and before Present. </p> <p><code>function ReadPixels(const ARect: TSdlRect): TSdlSurface; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_62","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_45","title":"Parameters","text":"<p><code>ARect</code>: <code>TSdlRect</code> : The area to read in pixels relative to the to current viewport.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#returns_7","title":"Returns","text":"<p><code>TSdlSurface</code>: A new SDL surface</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_68","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#ReadPixels_1","title":"ReadPixels","text":"<p>Read pixels from the entire viewport of the current rendering target.</p> <p>The returned surface should be freed.</p> <p>WARNING: This is a very slow operation, and should not be used frequently. If you're using this on the main rendering target, it should be called after rendering and before Present. </p> <p><code>function ReadPixels: TSdlSurface; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_63","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#returns_8","title":"Returns","text":"<p><code>TSdlSurface</code>: A new SDL surface</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_69","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#RenderCoordinatesFromWindow","title":"RenderCoordinatesFromWindow(Single, Single)","text":"<p>Get a point in render coordinates when given a point in window coordinates.</p> <p>This takes into account several states:</p> <ul> <li>The window dimensions.</li> <li>The logical presentation settings (SetLogicalPresentation)</li> <li>The scale (Scale)</li> <li>The viewport (Viewport) </li> </ul> <p><code>function RenderCoordinatesFromWindow(const AWindowX, AWindowY: Single): TSdlPointF; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_64","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_46","title":"Parameters","text":"<p><code>AWindowX</code>: <code>Single</code> : The X coordinate in window coordinates.</p> <p><code>AWindowY</code>: <code>Single</code> : The Y coordinate in window coordinates.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#returns_9","title":"Returns","text":"<p><code>TSdlPointF</code>: The coordinates in render coordinates.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_51","title":"See Also","text":"<ul> <li>SetLogicalPresentation</li> <li>Scale</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_70","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#RenderCoordinatesToWindow","title":"RenderCoordinatesToWindow(Single, Single)","text":"<p>Get a point in window coordinates when given a point in render coordinates.</p> <p>This takes into account several states:</p> <ul> <li>The window dimensions.</li> <li>The logical presentation settings (SetLogicalPresentation)</li> <li>The scale (Scale)</li> <li>The viewport (Viewport) </li> </ul> <p><code>function RenderCoordinatesToWindow(const AX, AY: Single): TSdlPointF; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_65","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_47","title":"Parameters","text":"<p><code>AX</code>: <code>Single</code> : The X coordinate in render coordinates.</p> <p><code>AY</code>: <code>Single</code> : The Y coordinate in render coordinates.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#returns_10","title":"Returns","text":"<p><code>TSdlPointF</code>: The coordinates in window coordinates.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_52","title":"See Also","text":"<ul> <li>SetLogicalPresentation</li> <li>Scale</li> <li>Viewport</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_71","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#ResetViewport","title":"ResetViewport","text":"<p>Set the viewport to the entire target. </p> <p><code>procedure ResetViewport; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_66","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_53","title":"See Also","text":"<ul> <li>Viewport</li> <li>IsViewportSet</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_72","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#SetDrawColor","title":"SetDrawColor(Byte, Byte, Byte, Byte)","text":"<p>Set the (integer) color used for drawing operations.</p> <p>Set the color for drawing or filling rectangles, lines, and points, and for Clear. </p> <p><code>procedure SetDrawColor(const AR, AG, AB: Byte; const AA: Byte = SDL_ALPHA_OPAQUE); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_67","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_48","title":"Parameters","text":"<p><code>AR</code>: <code>Byte</code> : The red value used to draw on the rendering target.</p> <p><code>AG</code>: <code>Byte</code> : The green value used to draw on the rendering target.</p> <p><code>AB</code>: <code>Byte</code> : The blue value used to draw on the rendering target.</p> <p><code>AA</code>: <code>Byte = SDL_ALPHA_OPAQUE</code> : (Optional)Aalpha value used to draw on the rendering target; Defaults to <code>SDL_ALPHA_OPAQUE</code> (255). Use DrawBlendMode to specify how the alpha channel is used.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_54","title":"See Also","text":"<ul> <li>DrawColor</li> <li>DrawColorFloat</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_73","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#SetDrawColorFloat","title":"SetDrawColorFloat(Single, Single, Single, Single)","text":"<p>Set the (floating-point) color used for drawing operations.</p> <p>Set the color for drawing or filling rectangles, lines, and points, and for Clear. </p> <p><code>procedure SetDrawColorFloat(const AR, AG, AB: Single; const AA: Single = SDL_ALPHA_OPAQUE_FLOAT); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_68","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_49","title":"Parameters","text":"<p><code>AR</code>: <code>Single</code> : The red value used to draw on the rendering target.</p> <p><code>AG</code>: <code>Single</code> : The green value used to draw on the rendering target.</p> <p><code>AB</code>: <code>Single</code> : The blue value used to draw on the rendering target.</p> <p><code>AA</code>: <code>Single = SDL_ALPHA_OPAQUE_FLOAT</code> : (Optional)Aalpha value used to draw on the rendering target; Defaults to <code>SDL_ALPHA_OPAQUE_FLOAT</code> (1.0). Use DrawBlendMode to specify how the alpha channel is used.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_55","title":"See Also","text":"<ul> <li>DrawColor</li> <li>DrawColorFloat</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_74","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#SetLogicalPresentation","title":"SetLogicalPresentation(Integer, Integer, TSdlRendererLogicalPresentation)","text":"<p>Set a device independent resolution and presentation mode for rendering.</p> <p>This method sets the width and height of the logical rendering output. The renderer will act as if the window is always the requested dimensions, scaling to the actual window resolution as necessary.</p> <p>This can be useful for games that expect a fixed size, but would like to scale the output to whatever is available, regardless of how a user resizes a window, or if the display is high DPI.</p> <p>You can disable logical coordinates by setting the mode to TSdlLogicalPresentation.Disabled, and in that case you get the full pixel resolution of the output window; it is safe to toggle logical presentation during the rendering of a frame: perhaps most of the rendering is done to specific dimensions but to make fonts look sharp, the app turns off logical presentation while drawing text.</p> <p>Letterboxing will only happen if logical presentation is enabled during Present; be sure to reenable it first if you were using it.</p> <p>You can convert coordinates in an event into rendering coordinates using TSdlEvent.ConvertToRenderCoordinates. </p> <p><code>procedure SetLogicalPresentation(const AW, AH: Integer; const AMode: TSdlRendererLogicalPresentation); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#exceptions_69","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#parameters_50","title":"Parameters","text":"<p><code>AW</code>: <code>Integer</code> : The width of the logical resolution.</p> <p><code>AH</code>: <code>Integer</code> : The height of the logical resolution.</p> <p><code>AMode</code>: <code>TSdlRendererLogicalPresentation</code> : The presentation mode used.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#see-also_56","title":"See Also","text":"<ul> <li>TSdlEvent.ConvertToRenderCoordinates</li> <li>GetLogicalPresentation</li> <li>LogicalPresentationRect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlRenderer/#remarks_75","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/","title":"TSdlScreenSaver","text":"<p>Screen saver functionality </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlScreenSaver = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#properties","title":"Properties","text":"Name Description IsEnabled Whether the screen saver is currently enabled."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#methods","title":"Methods","text":"Name Description Disable Disable the screen saver. Enable Enable the screen saver."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#IsEnabled","title":"IsEnabled","text":"<p>Whether the screen saver is currently enabled.</p> <p>The screen saver is disabled by default.</p> <p>The default can also be changed using TSdlHints.VideoAllowScreenSaver.</p> <p>If you disable the screensaver, it is automatically re-enabled when SDL quits. </p> <p><code>class property IsEnabled: Boolean read GetEnabled write SetEnabled</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#see-also","title":"See Also","text":"<ul> <li>Enable</li> <li>Disable</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#remarks","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#Disable","title":"Disable","text":"<p>Disable the screen saver.</p> <p>The screen saver is disabled by default.</p> <p>The default can also be changed using TSdlHints.VideoAllowScreenSaver.</p> <p>If you disable the screensaver, it is automatically re-enabled when SDL quits. </p> <p><code>class procedure Disable; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#see-also_1","title":"See Also","text":"<ul> <li>Enable</li> <li>IsEnabled</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#remarks_1","title":"Remarks","text":"<p>This method should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#Enable","title":"Enable","text":"<p>Enable the screen saver.</p> <p>The screen saver is disabled by default.</p> <p>The default can also be changed using TSdlHints.VideoAllowScreenSaver. </p> <p><code>class procedure Enable; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#see-also_2","title":"See Also","text":"<ul> <li>Disable</li> <li>IsEnabled</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlScreenSaver/#remarks_2","title":"Remarks","text":"<p>This method should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSize/","title":"TSdlSize","text":"<p>The structure that defines a size (using integers). </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSize/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlSize = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSize/#fields","title":"Fields","text":"Name Description H W"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSize/#constructors","title":"Constructors","text":"Name Description Create Create from W and H values."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSize/#methods","title":"Methods","text":"Name Description Init Initialize from W and H values."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSize/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSize/#H","title":"H","text":"<p><code>var H: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSize/#W","title":"W","text":"<p><code>var W: Integer</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSize/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSize/#Create","title":"<code>Create</code>","text":"<p>Create from W and H values. </p> <p><code>constructor Create(const AW, AH: Integer)</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSize/#parameters","title":"Parameters","text":"<p><code>AW</code>: <code>Integer</code> : The W value.</p> <p><code>AH</code>: <code>Integer</code> : The H value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSize/#remarks","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSize/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSize/#Init","title":"Init(Integer, Integer)","text":"<p>Initialize from W and H values. </p> <p><code>procedure Init(const AW, AH: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSize/#parameters_1","title":"Parameters","text":"<p><code>AW</code>: <code>Integer</code> : The W value.</p> <p><code>AH</code>: <code>Integer</code> : The H value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSize/#remarks_1","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/","title":"TSdlSizeF","text":"<p>The structure that defines a size (using floating-point values). </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlSizeF = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#fields","title":"Fields","text":"Name Description H W"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#constructors","title":"Constructors","text":"Name Description Create(TSdlSize) Create from a TSdlSize; Create(Single, Single) Create from W and H values."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#methods","title":"Methods","text":"Name Description Init(TSdlSize) Initialize from a TSdlSize. Init(Single, Single) Initialize from W and H values."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#H","title":"H","text":"<p><code>var H: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#W","title":"W","text":"<p><code>var W: Single</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#Create_0","title":"<code>Create</code>","text":"<p>Create from a TSdlSize; </p> <p><code>constructor Create(const ASize: TSdlSize); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#parameters","title":"Parameters","text":"<p><code>ASize</code>: <code>TSdlSize</code> : The size.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#remarks","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#Create_1","title":"<code>Create</code>","text":"<p>Create from W and H values. </p> <p><code>constructor Create(const AW, AH: Single); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#parameters_1","title":"Parameters","text":"<p><code>AW</code>: <code>Single</code> : The W value.</p> <p><code>AH</code>: <code>Single</code> : The H value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#remarks_1","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#Init_0","title":"Init(TSdlSize)","text":"<p>Initialize from a TSdlSize. </p> <p><code>procedure Init(const ASize: TSdlSize); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#parameters_2","title":"Parameters","text":"<p><code>ASize</code>: <code>TSdlSize</code> : The size.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#remarks_2","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#Init_1","title":"Init(Single, Single)","text":"<p>Initialize from W and H values. </p> <p><code>procedure Init(const AW, AH: Single); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#parameters_3","title":"Parameters","text":"<p><code>AW</code>: <code>Single</code> : The W value.</p> <p><code>AH</code>: <code>Single</code> : The H value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSizeF/#remarks_3","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/","title":"TSdlSurface","text":"<p>A collection of pixels used in software blitting.</p> <p>Pixels are arranged in memory in rows, with the top row first. Each row occupies an amount of memory given by the pitch (sometimes known as the row stride in non-SDL APIs).</p> <p>Within each row, pixels are arranged from left to right until the width is reached. Each pixel occupies a number of bits appropriate for its format, with most formats representing each pixel as one or more whole bytes (in some indexed formats, instead multiple pixels are packed into each byte), and a byte order given by the format. After encoding all pixels, any remaining bytes to reach the pitch are used as padding to reach a desired alignment, and have undefined contents.</p> <p>When a surface holds YUV format data, the planes are assumed to be contiguous without padding between them, e.g. a 32x32 surface in NV12 format with a pitch of 32 would consist of 32x32 bytes of Y plane followed by 32x16 bytes of UV plane. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlSurface = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#properties","title":"Properties","text":"Name Description AlphaMod An additional alpha value used in blit operations. BlendMode The blend mode used for blit operations. ClipRect The clipping rectangle for a surface. ColorKey The color key (transparent pixel) in the surface. ColorMod An additional color value multiplied into blit operations. Colorspace The colorspace used by the surface. Flags The flags of the surface, read-only Format The format of the surface, read-only H The height of the surface, read-only. HasAlternateImages Whether the surface has alternate versions available. HasColorKey Whether the surface has a color key. Images Get an array including all versions of this surface. MustLock Whether the surface needs to be locked before access. Palette The palette used by a surface, or nil if there is no palette used. Pitch The distance in bytes between rows of pixels, read-only Pixel The pixels of the surface. PixelFloat The pixels of the surface, as floating-point colors. Pixels A pointer to the pixels of the surface, the pixels are writeable if non-nil Properties The properties associated with a surface. UseRle Whether to use RLE acceleration for the surface. W The width of the surface, read-only."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#constructors","title":"Constructors","text":"Name Description Create(Integer, Integer, TSdlPixelFormat, Pointer, Integer) Create a new surface with a specific pixel format and existing pixel data. Create(Integer, Integer, TSdlPixelFormat) Create a new surface with a specific pixel format. LoadBmp(String) Create a surface from a BMP image from a file. LoadBmp(TSdlIOStream, Boolean) Create a surface from a BMP image from a seekable SDL data stream."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#methods","title":"Methods","text":"Name Description AddAlternateImage Add an alternate version of a surface. Blit Performs a fast blit from this surface to a destination surface with clipping. Blit9Grid Perform a scaled blit using the 9-grid algorithm to a destination surface, which may be of a different format. BlitScaled Perform a scaled blit to a destination surface, which may be of a different format. BlitScaledUnchecked Perform low-level surface scaled blitting only. BlitTiled(PSdlRect, Single, TSdlScaleMode, TSdlSurface, PSdlRect) Perform a scaled and tiled blit to a destination surface, which may be of a different format. BlitTiled(PSdlRect, TSdlSurface, PSdlRect) Perform a tiled blit to a destination surface, which may be of a different format. BlitUnchecked Perform low-level surface blitting only. Clear(TSdlColorF) Clear the surface with a specific color, with floating point precision. Clear(Single, Single, Single, Single) Clear the surface with a specific color, with floating point precision. Convert(TSdlPixelFormat, TSdlPalette, TSdlColorspace, TSdlProperties) Copy the existing surface to a new surface of the specified format and colorspace. Convert(TSdlPixelFormat, TSdlColorspace) Copy the existing surface to a new surface of the specified format and colorspace. Convert(TSdlPixelFormat) Copy the surface to a new surface of the specified format. CreatePalette Create a palette and associate it with this surface. DisableClipping Disables clipping. Set the ClipRect property to enable clipping again. Duplicate Creates a new surface identical to the existing surface. Fill Perform a fast fill of the entire surface with a specific color, taking the clip rectangle into account. FillRect Perform a fast fill of a rectangle with a specific color. FillRects(TSdlRect[], Cardinal) Perform a fast fill of a set of rectangles with a specific color. FillRects(TArray&lt;TSdlRect&gt;, Cardinal) Perform a fast fill of a set of rectangles with a specific color. Flip Flip the surface vertically or horizontally. Free Free the surface. Lock Set up the surface for directly accessing the pixels. MapRgb Map an RGB triple to an opaque pixel value for the surface. MapRgba Map an RGBA quadruple to a pixel value for the surface. PremultiplyAlpha Premultiply the alpha. RemoveAlternateImages Remove all alternate versions of this surface. SaveBmp(String) Save the surface to a file in BMP format. SaveBmp(TSdlIOStream, Boolean) Save the surface to a seekable SDL data stream in BMP format. Scale Creates a new surface identical to the existing surface, scaled to the desired size. Unlock Release the surface after directly accessing the pixels."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#AlphaMod","title":"AlphaMod","text":"<p>An additional alpha value used in blit operations.</p> <p>When this surface is blitted, during the blit operation the source alpha value is modulated by this alpha value according to the following formula:</p> <p><code>SrcA = SrcA * (Alpha div 255)</code> </p> <p><code>property AlphaMod: Byte read GetAlphaMod write SetAlphaMod</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also","title":"See Also","text":"<ul> <li>ColorMod</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#BlendMode","title":"BlendMode","text":"<p>The blend mode used for blit operations.</p> <p>To copy a surface to another surface (or texture) without blending with the existing data, the blendmode of the source surface should be set to <code>TSdlBlendMode.None</code>. </p> <p><code>property BlendMode: TSdlBlendMode read GetBlendMode write SetBlendMode</code></p> <p>Type: <code>TSdlBlendMode</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#ClipRect","title":"ClipRect","text":"<p>The clipping rectangle for a surface.</p> <p>When the surface is the destination of a blit, only the area within the clip rectangle is drawn into.</p> <p>Note that blits are automatically clipped to the edges of the source and destination surfaces. </p> <p><code>property ClipRect: TSdlRect read GetClipRect write SetClipRect</code></p> <p>Type: <code>TSdlRect</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_1","title":"See Also","text":"<ul> <li>DisableClipping</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#ColorKey","title":"ColorKey","text":"<p>The color key (transparent pixel) in the surface.</p> <p>The color key defines a pixel value that will be treated as transparent in a blit. For example, one can use this to specify that cyan pixels should be considered transparent, and therefore not rendered.</p> <p>It is a pixel of the format used by the surface, as generated by TSdlPixelFormatDetails.MapRgb.</p> <p>Set to SDL_NO_COLOR_KEY to disable the color key. </p> <p><code>property ColorKey: Cardinal read GetColorKey write SetColorKey</code></p> <p>Type: <code>Cardinal</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_2","title":"See Also","text":"<ul> <li>UseRle</li> <li>HasColorKey</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#ColorMod","title":"ColorMod","text":"<p>An additional color value multiplied into blit operations.</p> <p>When this surface is blitted, during the blit operation each source color channel is modulated by the appropriate color value according to the following formula:</p> <p><code>SrcC := SrcC * (Color div 255)</code></p> <p>The Alpha value of the color is ignored. Use AlphaMod for alpha modulation. </p> <p><code>property ColorMod: TSdlColor read GetColorMod write SetColorMod</code></p> <p>Type: <code>TSdlColor</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_3","title":"See Also","text":"<ul> <li>AlphaMod</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Colorspace","title":"Colorspace","text":"<p>The colorspace used by the surface.</p> <p>The colorspace defaults to TSdlColorspace.SrgbLinear for floating point formats, TSdlColorspace.Hdr10 for 10-bit formats, TSdlColorspace.Srgb for other RGB surfaces and TSdlColorspace.BT709Full for YUV textures.</p> <p>Setting the colorspace doesn't change the pixels, only how they are interpreted in color operations. </p> <p><code>property Colorspace: TSdlColorspace read GetColorspace write SetColorspace</code></p> <p>Type: <code>TSdlColorspace</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Flags","title":"Flags","text":"<p>The flags of the surface, read-only </p> <p><code>property Flags: TSdlSurfaceFlags read GetFlags</code></p> <p>Type: <code>TSdlSurfaceFlags</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Format","title":"Format","text":"<p>The format of the surface, read-only </p> <p><code>property Format: TSdlPixelFormat read GetFormat</code></p> <p>Type: <code>TSdlPixelFormat</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#H","title":"H","text":"<p>The height of the surface, read-only. </p> <p><code>property H: Integer read GetH</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#HasAlternateImages","title":"HasAlternateImages","text":"<p>Whether the surface has alternate versions available. </p> <p><code>property HasAlternateImages: Boolean read GetHasAlternateImages</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_4","title":"See Also","text":"<ul> <li>AddAlternateImage</li> <li>RemoveAlternateImages</li> <li>Images</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#HasColorKey","title":"HasColorKey","text":"<p>Whether the surface has a color key. </p> <p><code>property HasColorKey: Boolean read GetHasColorKey</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_5","title":"See Also","text":"<ul> <li>ColorKey</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Images","title":"Images","text":"<p>Get an array including all versions of this surface.</p> <p>This returns all versions of a surface, with this surface as the first element in the returned array. </p> <p><code>property Images: TArray&lt;TSdlSurface&gt; read GetImages</code></p> <p>Type: <code>TArray&lt;TSdlSurface&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_6","title":"See Also","text":"<ul> <li>AddAlternateImage</li> <li>RemoveAlternateImages</li> <li>HasAlternateImages</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#MustLock","title":"MustLock","text":"<p>Whether the surface needs to be locked before access. </p> <p><code>property MustLock: Boolean read GetMustLock</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Palette","title":"Palette","text":"<p>The palette used by a surface, or nil if there is no palette used.</p> <p>A single palette can be shared with many surfaces. </p> <p><code>property Palette: TSdlPalette read GetPalette write SetPalette</code></p> <p>Type: <code>TSdlPalette</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_6","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Pitch","title":"Pitch","text":"<p>The distance in bytes between rows of pixels, read-only </p> <p><code>property Pitch: Integer read GetPitch</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Pixel","title":"Pixel","text":"<p>The pixels of the surface.</p> <p>This function prioritizes correctness over speed: it is suitable for unit tests, but is not intended for use in a game engine.</p> <p>This uses the entire 0..255 range when converting color components from pixel formats with less than 8 bits per RGB component. </p> <p><code>property Pixel[const AX, AY: Integer]: TSdlColor read GetPixel write SetPixel</code></p> <p>Type: <code>TSdlColor</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#PixelFloat","title":"PixelFloat","text":"<p>The pixels of the surface, as floating-point colors.</p> <p>This function prioritizes correctness over speed: it is suitable for unit tests, but is not intended for use in a game engine.</p> <p>This uses the entire 0..1 range when converting color components from pixel formats with less than 8 bits per RGB component. </p> <p><code>property PixelFloat[const AX, AY: Integer]: TSdlColorF read GetPixelFloat write SetPixelFloat</code></p> <p>Type: <code>TSdlColorF</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Pixels","title":"Pixels","text":"<p>A pointer to the pixels of the surface, the pixels are writeable if non-nil </p> <p><code>property Pixels: Pointer read GetPixels</code></p> <p>Type: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Properties","title":"Properties","text":"<p>The properties associated with a surface.</p> <p>The following properties are understood by SDL:</p> <ul> <li><code>TSdlProperty.SurfaceSdrWhitePoint</code>: for HDR10 and floating point surfaces, this defines the value of 100% diffuse white, with higher values being displayed in the High Dynamic Range headroom. This defaults to 203 for HDR10 surfaces and 1.0 for floating point surfaces.</li> <li><code>TSdlProperty.SurfaceHdrHeadroom</code>: for HDR10 and floating point surfaces, this defines the maximum dynamic range used by the content, in terms of the SDR white point. This defaults to 0.0, which disables tone mapping.</li> <li><code>TSdlProperty.SurfaceTonemapOperator</code>: the tone mapping operator used when compressing from a surface with high dynamic range to another with lower dynamic range. Currently this supports 'chrome', which uses the same tone mapping that Chrome uses for HDR content, the form '*=N', where N is a floating point scale factor applied in linear space, and 'none', which disables tone mapping. This defaults to 'chrome'. </li> </ul> <p><code>property Properties: TSdlProperties read GetProperties</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_7","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#UseRle","title":"UseRle","text":"<p>Whether to use RLE acceleration for the surface.</p> <p>If RLE is enabled, color key and alpha blending blits are much faster, but the surface must be locked before directly accessing the pixels. </p> <p><code>property UseRle: Boolean read GetUseRle write SetUseRle</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_8","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_7","title":"See Also","text":"<ul> <li>Blit</li> <li>Lock</li> <li>Unlock</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#W","title":"W","text":"<p>The width of the surface, read-only. </p> <p><code>property W: Integer read GetW</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Create_0","title":"<code>Create</code>","text":"<p>Create a new surface with a specific pixel format and existing pixel data.</p> <p>No copy is made of the pixel data. Pixel data is not managed automatically; you must free the surface before you free the pixel data.</p> <p>Pitch is the offset in bytes from one row of pixels to the next, e.g. <code>AWidth * 4</code> for <code>TSdlPixelFormat.Rgba8888</code>.</p> <p>You may pass nil for pixels and 0 for pitch to create a surface that you will fill in with valid values later. </p> <p><code>constructor Create(const AWidth, AHeight: Integer; const AFormat: TSdlPixelFormat; const APixels: Pointer; const APitch: Integer); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters","title":"Parameters","text":"<p><code>AWidth</code>: <code>Integer</code> : The width of the surface.</p> <p><code>AHeight</code>: <code>Integer</code> : The height of the surface.</p> <p><code>AFormat</code>: <code>TSdlPixelFormat</code> : The pixel format for the new surface.</p> <p><code>APixels</code>: <code>Pointer</code> : A pointer to existing pixel data.</p> <p><code>APitch</code>: <code>Integer</code> : The number of bytes between each row, including padding.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_9","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_8","title":"See Also","text":"<ul> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Create_1","title":"<code>Create</code>","text":"<p>Create a new surface with a specific pixel format.</p> <p>The pixels of the new surface are initialized to zero. </p> <p><code>constructor Create(const AWidth, AHeight: Integer; const AFormat: TSdlPixelFormat); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_1","title":"Parameters","text":"<p><code>AWidth</code>: <code>Integer</code> : The width of the surface.</p> <p><code>AHeight</code>: <code>Integer</code> : The height of the surface.</p> <p><code>AFormat</code>: <code>TSdlPixelFormat</code> : The pixel format for the new surface.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_10","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_9","title":"See Also","text":"<ul> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#LoadBmp_0","title":"<code>LoadBmp</code>","text":"<p>Create a surface from a BMP image from a file. </p> <p><code>constructor LoadBmp(const AFilename: String); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_2","title":"Parameters","text":"<p><code>AFilename</code>: <code>String</code> : The name of the BMP file to load.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_11","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_10","title":"See Also","text":"<ul> <li>Free</li> <li>SaveBmp</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#LoadBmp_1","title":"<code>LoadBmp</code>","text":"<p>Create a surface from a BMP image from a seekable SDL data stream. </p> <p><code>constructor LoadBmp(const ASrc: TSdlIOStream; const ACloseIO: Boolean); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_3","title":"Parameters","text":"<p><code>ASrc</code>: <code>TSdlIOStream</code> : The data stream for the surface.</p> <p><code>ACloseIO</code>: <code>Boolean</code> : If True, calls ASrc.Close before returning, even in the case of an error.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_12","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_11","title":"See Also","text":"<ul> <li>Free</li> <li>SaveBmp</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Equal","title":"Equal(TSdlSurface, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlSurface; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_4","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlSurface</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlSurface; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_5","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#returns_1","title":"Returns","text":"<p><code>TSdlSurface</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#NotEqual","title":"NotEqual(TSdlSurface, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlSurface; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_6","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlSurface</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#AddAlternateImage","title":"AddAlternateImage(TSdlSurface)","text":"<p>Add an alternate version of a surface.</p> <p>This function adds an alternate version of this surface, usually used for content with high DPI representations like cursors or icons. The size, format, and content do not need to match the original surface, and these alternate versions will not be updated when the original surface changes.</p> <p>This function adds a reference to the alternate version, so you should call AImage.Free after this call. </p> <p><code>procedure AddAlternateImage(const AImage: TSdlSurface); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_13","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_7","title":"Parameters","text":"<p><code>AImage</code>: <code>TSdlSurface</code> : The alternate surface to associate with this surface.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_12","title":"See Also","text":"<ul> <li>RemoveAlternateImages</li> <li>Images</li> <li>HasAlternateImages</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Blit","title":"Blit(PSdlRect, TSdlSurface, PSdlRect)","text":"<p>Performs a fast blit from this surface to a destination surface with clipping.</p> <p>If either <code>ASrcRect</code> or <code>ADstRect</code> are nil, the entire surface is copied while ensuring clipping to <code>ADst.ClipRect</code>.</p> <p>The final blit rectangles are saved in <code>ASrcRect</code> and <code>ADstRect</code> after all clipping is performed.</p> <p>The blit function should not be called on a locked surface.</p> <p>The blit semantics for surfaces with and without blending and colorkey are defined as follows:</p> <p>RGBA-&gt;RGB: Source surface blend mode set to TSdlBlendMode.Blend: alpha-blend (using the source alpha-channel and per-surface alpha). source color key ignored. Source surface blend mode set to TSdlBlendMode.None: copy RGB. if source color key set, only copy the pixels that do not match the RGB values of the source color key, ignoring alpha in the comparison.</p> <p>RGB-&gt;RGBA: Source surface blend mode set to TSdlBlendMode.Blend: alpha-blend (using the source per-surface alpha). Source surface blend mode set to TSdlBlendMode.None: copy RGB, set destination alpha to source per-surface alpha value. both: if source color key set, only copy the pixels that do not match the source color key.</p> <p>RGBA-&gt;RGBA: Source surface blend mode set to TSdlBlendMode.Blend: alpha-blend (using the source alpha-channel and per-surface alpha). source color key. Source surface blend mode set to TSdlBlendMode.None: copy all of RGBA to the destination. if source color key set, only copy the pixels that do not match the RGB values of the source color key, ignoring alpha in the comparison.</p> <p>RGB-&gt;RGB: Source surface blend mode set to TSdlBlendMode.Blend: alpha-blend (using the source per-surface alpha). Source surface blend mode set to TSdlBlendMode.None: copy RGB. both: if source color key set, only copy the pixels that do not match the source color key. </p> <p><code>procedure Blit(const ASrcRect: PSdlRect; const ADst: TSdlSurface; const ADstRect: PSdlRect); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_14","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_8","title":"Parameters","text":"<p><code>ASrcRect</code>: <code>PSdlRect</code> : The rectangle to be copied, or nil to copy the entire surface.</p> <p><code>ADst</code>: <code>TSdlSurface</code> : The blit target surface.</p> <p><code>ADstRect</code>: <code>PSdlRect</code> : The rectangle representing the X and Y position in the destination surface, or nil for (0,0). The width and height are ignored, and are copied from <code>ASrcRect</code>. If you want a specific width and height, you should use BlitScaled.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_13","title":"See Also","text":"<ul> <li>BlitScaled</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#remarks","title":"Remarks","text":"<p>The same destination surface should not be used from two threads at once. It is safe to use the same source surface from multiple threads. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Blit9Grid","title":"Blit9Grid(PSdlRect, Integer, Integer, Integer, Integer, Single, TSdlScaleMode, TSdlSurface, PSdlRect)","text":"<p>Perform a scaled blit using the 9-grid algorithm to a destination surface, which may be of a different format.</p> <p>The pixels in the source surface are split into a 3x3 grid, using the different corner sizes for each corner, and the sides and center making up the remaining pixels. The corners are then scaled using <code>AScale</code> and fit into the corners of the destination rectangle. The sides and center are then stretched into place to cover the remaining destination rectangle. </p> <p><code>procedure Blit9Grid(const ASrcRect: PSdlRect; const ALeftWidth, ARightWidth, ATopHeight, ABottomHeight: Integer; const AScale: Single; const AScaleMode: TSdlScaleMode; const ADst: TSdlSurface; const ADstRect: PSdlRect); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_15","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_9","title":"Parameters","text":"<p><code>ASrcRect</code>: <code>PSdlRect</code> : The rectangle to be used for the 9-grid, or nil to use the entire surface.</p> <p><code>ALeftWidth</code>: <code>Integer</code> : The width, in pixels, of the left corners in <code>ASrcRect</code>.</p> <p><code>ARightWidth</code>: <code>Integer</code> : The width, in pixels, of the right corners in <code>ASrcRect</code>.</p> <p><code>ATopHeight</code>: <code>Integer</code> : The height, in pixels, of the top corners in <code>ASrcRect</code>.</p> <p><code>ABottomHeight</code>: <code>Integer</code> : The height, in pixels, of the bottom corners in <code>ASrcRect</code>.</p> <p><code>AScale</code>: <code>Single</code> : The scale used to transform the corner of <code>ASrcRect</code> into the corner of <code>ADstRect</code>, or 0.0 for an unscaled blit.</p> <p><code>AScaleMode</code>: <code>TSdlScaleMode</code> : Scale algorithm to be used.</p> <p><code>ADst</code>: <code>TSdlSurface</code> : The blit target surface.</p> <p><code>ADstRect</code>: <code>PSdlRect</code> : The target rectangle in the destination surface, or nil to fill the entire surface.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_14","title":"See Also","text":"<ul> <li>Blit</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#remarks_1","title":"Remarks","text":"<p>The same destination surface should not be used from two threads at once. It is safe to use the same source surface from multiple threads. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#BlitScaled","title":"BlitScaled(PSdlRect, TSdlSurface, PSdlRect, TSdlScaleMode)","text":"<p>Perform a scaled blit to a destination surface, which may be of a different format. </p> <p><code>procedure BlitScaled(const ASrcRect: PSdlRect; const ADst: TSdlSurface; const ADstRect: PSdlRect; const AScaleMode: TSdlScaleMode); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_16","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_10","title":"Parameters","text":"<p><code>ASrcRect</code>: <code>PSdlRect</code> : The rectangle to be copied, or nil to copy the entire surface.</p> <p><code>ADst</code>: <code>TSdlSurface</code> : The blit target surface.</p> <p><code>ADstRect</code>: <code>PSdlRect</code> : The rectangle representing the X and Y position in the destination surface, or nil to fill the entire destination surface.</p> <p><code>AScaleMode</code>: <code>TSdlScaleMode</code> : The scale mode to be used.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_15","title":"See Also","text":"<ul> <li>Blit</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#remarks_2","title":"Remarks","text":"<p>The same destination surface should not be used from two threads at once. It is safe to use the same source surface from multiple threads. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#BlitScaledUnchecked","title":"BlitScaledUnchecked(TSdlRect, TSdlSurface, TSdlRect, TSdlScaleMode)","text":"<p>Perform low-level surface scaled blitting only.</p> <p>This is a semi-private function and it performs low-level surface blitting, assuming the input rectangles have already been clipped. </p> <p><code>procedure BlitScaledUnchecked(const ASrcRect: TSdlRect; const ADst: TSdlSurface; const ADstRect: TSdlRect; const AScaleMode: TSdlScaleMode); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_11","title":"Parameters","text":"<p><code>ASrcRect</code>: <code>TSdlRect</code> : The rectangle to be copied.</p> <p><code>ADst</code>: <code>TSdlSurface</code> : The blit target surface.</p> <p><code>ADstRect</code>: <code>TSdlRect</code> : The target rectangle in the destination surface.</p> <p><code>AScaleMode</code>: <code>TSdlScaleMode</code> : the SDL_ScaleMode to be used.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_16","title":"See Also","text":"<ul> <li>BlitScaled</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#remarks_3","title":"Remarks","text":"<p>The same destination surface should not be used from two threads at once. It is safe to use the same source surface from multiple threads. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#BlitTiled_0","title":"BlitTiled(PSdlRect, Single, TSdlScaleMode, TSdlSurface, PSdlRect)","text":"<p>Perform a scaled and tiled blit to a destination surface, which may be of a different format.</p> <p>The pixels in <code>ASrcRect</code> will be repeated as many times as needed to completely fill <code>ADstRect</code>. </p> <p><code>procedure BlitTiled(const ASrcRect: PSdlRect; const AScale: Single; const AScaleMode: TSdlScaleMode; const ADst: TSdlSurface; const ADstRect: PSdlRect); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_17","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_12","title":"Parameters","text":"<p><code>ASrcRect</code>: <code>PSdlRect</code> : The rectangle to be copied, or nil to copy the entire surface.</p> <p><code>AScale</code>: <code>Single</code> : The scale used to transform ASrcRect into the destination rectangle, e.g. a 32x32 texture with a scale of 2 would fill 64x64 tiles.</p> <p><code>AScaleMode</code>: <code>TSdlScaleMode</code> : Scale algorithm to be used.</p> <p><code>ADst</code>: <code>TSdlSurface</code> : The blit target surface.</p> <p><code>ADstRect</code>: <code>PSdlRect</code> : The rectangle representing the X and Y position in the destination surface, or nil to fill the entire destination surface.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_17","title":"See Also","text":"<ul> <li>Blit</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#remarks_4","title":"Remarks","text":"<p>The same destination surface should not be used from two threads at once. It is safe to use the same source surface from multiple threads. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#BlitTiled_1","title":"BlitTiled(PSdlRect, TSdlSurface, PSdlRect)","text":"<p>Perform a tiled blit to a destination surface, which may be of a different format.</p> <p>The pixels in <code>ASrcRect</code> will be repeated as many times as needed to completely fill <code>ADstRect</code>. </p> <p><code>procedure BlitTiled(const ASrcRect: PSdlRect; const ADst: TSdlSurface; const ADstRect: PSdlRect); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_18","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_13","title":"Parameters","text":"<p><code>ASrcRect</code>: <code>PSdlRect</code> : The rectangle to be copied, or nil to copy the entire surface.</p> <p><code>ADst</code>: <code>TSdlSurface</code> : The blit target surface.</p> <p><code>ADstRect</code>: <code>PSdlRect</code> : The target rectangle in the destination surface, or nil to fill the entire surface.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_18","title":"See Also","text":"<ul> <li>Blit</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#remarks_5","title":"Remarks","text":"<p>The same destination surface should not be used from two threads at once. It is safe to use the same source surface from multiple threads. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#BlitUnchecked","title":"BlitUnchecked(TSdlRect, TSdlSurface, TSdlRect)","text":"<p>Perform low-level surface blitting only.</p> <p>This is a semi-private blit function and it performs low-level surface blitting, assuming the input rectangles have already been clipped. </p> <p><code>procedure BlitUnchecked(const ASrcRect: TSdlRect; const ADst: TSdlSurface; const ADstRect: TSdlRect); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_19","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_14","title":"Parameters","text":"<p><code>ASrcRect</code>: <code>TSdlRect</code> : The rectangle to be copied.</p> <p><code>ADst</code>: <code>TSdlSurface</code> : The blit target surface.</p> <p><code>ADstRect</code>: <code>TSdlRect</code> : The target rectangle in the destination surface.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_19","title":"See Also","text":"<ul> <li>Blit</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#remarks_6","title":"Remarks","text":"<p>The same destination surface should not be used from two threads at once. It is safe to use the same source surface from multiple threads. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Clear_0","title":"Clear(TSdlColorF)","text":"<p>Clear the surface with a specific color, with floating point precision.</p> <p>This function handles all surface formats, and ignores any clip rectangle.</p> <p>If the surface is YUV, the color is assumed to be in the sRGB colorspace, otherwise the color is assumed to be in the colorspace of the suface. </p> <p><code>procedure Clear(const AColor: TSdlColorF); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_20","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_15","title":"Parameters","text":"<p><code>AColor</code>: <code>TSdlColorF</code> : The color.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_20","title":"See Also","text":"<ul> <li>Fill</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Clear_1","title":"Clear(Single, Single, Single, Single)","text":"<p>Clear the surface with a specific color, with floating point precision.</p> <p>This function handles all surface formats, and ignores any clip rectangle.</p> <p>If the surface is YUV, the color is assumed to be in the sRGB colorspace, otherwise the color is assumed to be in the colorspace of the suface. </p> <p><code>procedure Clear(const AR, AG, AB: Single; const AA: Single = 1); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_21","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_16","title":"Parameters","text":"<p><code>AR</code>: <code>Single</code> : The red component of the pixel, normally in the range 0-1.</p> <p><code>AG</code>: <code>Single</code> : The green component of the pixel, normally in the range 0-1.</p> <p><code>AB</code>: <code>Single</code> : The blue component of the pixel, normally in the range 0-1.</p> <p><code>AA</code>: <code>Single = 1</code> : (Optional) alpha component of the pixel, normally in the range 0-1.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_21","title":"See Also","text":"<ul> <li>Fill</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Convert_0","title":"Convert(TSdlPixelFormat, TSdlPalette, TSdlColorspace, TSdlProperties)","text":"<p>Copy the existing surface to a new surface of the specified format and colorspace.</p> <p>This function converts an existing surface to a new format and colorspace and returns the new surface. This will perform any pixel format and colorspace conversion needed.</p> <p>If the original surface has alternate images, the new surface will have a reference to them as well. </p> <p><code>function Convert(const AFormat: TSdlPixelFormat; const APalette: TSdlPalette; const AColorspace: TSdlColorspace; const AProps: TSdlProperties): TSdlSurface; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_22","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_17","title":"Parameters","text":"<p><code>AFormat</code>: <code>TSdlPixelFormat</code> : The new pixel format.</p> <p><code>APalette</code>: <code>TSdlPalette</code> : A palette to use for indexed formats.</p> <p><code>AColorspace</code>: <code>TSdlColorspace</code> : The new colorspace.</p> <p><code>AProps</code>: <code>TSdlProperties</code> : Additional color properties.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#returns_3","title":"Returns","text":"<p><code>TSdlSurface</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Convert_1","title":"Convert(TSdlPixelFormat, TSdlColorspace)","text":"<p>Copy the existing surface to a new surface of the specified format and colorspace.</p> <p>This function converts an existing surface to a new format and colorspace and returns the new surface. This will perform any pixel format and colorspace conversion needed.</p> <p>If the original surface has alternate images, the new surface will have a reference to them as well. </p> <p><code>function Convert(const AFormat: TSdlPixelFormat; const AColorspace: TSdlColorspace): TSdlSurface; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_23","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_18","title":"Parameters","text":"<p><code>AFormat</code>: <code>TSdlPixelFormat</code> : The new pixel format.</p> <p><code>AColorspace</code>: <code>TSdlColorspace</code> : The new colorspace.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#returns_4","title":"Returns","text":"<p><code>TSdlSurface</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Convert_2","title":"Convert(TSdlPixelFormat)","text":"<p>Copy the surface to a new surface of the specified format.</p> <p>This function is used to optimize images for faster repeat blitting. This is accomplished by converting the original and storing the result as a new surface. The new, optimized surface can then be used as the source for future blits, making them faster.</p> <p>If the original surface has alternate images, the new surface will have a reference to them as well. </p> <p><code>function Convert(const AFormat: TSdlPixelFormat): TSdlSurface; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_24","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_19","title":"Parameters","text":"<p><code>AFormat</code>: <code>TSdlPixelFormat</code> : The new pixel format.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#returns_5","title":"Returns","text":"<p><code>TSdlSurface</code>: Thne new SDL surface.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#CreatePalette","title":"CreatePalette","text":"<p>Create a palette and associate it with this surface.</p> <p>This function creates a palette compatible with the surface. The palette is then returned for you to modify, and the surface will automatically use the new palette in future operations. You do not need to destroy the returned palette, it will be freed when the reference count reaches 0, usually when the surface is destroyed.</p> <p>Bitmap surfaces (with format TSdlPixelFormat.Index1Lsb or TSdlPixelFormat.Index1Msb) will have the palette initialized with 0 as white and 1 as black. Other surfaces will get a palette initialized with white in every entry.</p> <p>If this function is called for a surface that already has a palette, a new palette will be created to replace it. </p> <p><code>function CreatePalette: TSdlPalette; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_25","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure (e.g. if the surface didn't have an index format).</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#returns_6","title":"Returns","text":"<p><code>TSdlPalette</code>: A new palette.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#DisableClipping","title":"DisableClipping","text":"<p>Disables clipping. Set the ClipRect property to enable clipping again. </p> <p><code>procedure DisableClipping; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_22","title":"See Also","text":"<ul> <li>ClipRect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Duplicate","title":"Duplicate","text":"<p>Creates a new surface identical to the existing surface.</p> <p>If the original surface has alternate images, the new surface will have a reference to them as well.</p> <p>The returned surface should be freed with Free. </p> <p><code>function Duplicate: TSdlSurface; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_26","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#returns_7","title":"Returns","text":"<p><code>TSdlSurface</code>: A copy of the surface.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_23","title":"See Also","text":"<ul> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Fill","title":"Fill(Cardinal)","text":"<p>Perform a fast fill of the entire surface with a specific color, taking the clip rectangle into account.</p> <p><code>AColor</code> should be a pixel of the format used by the surface, and can be generated by TSdlPixelFormatDetails.MapRgb or TSdlPixelFormatDetails.MapRgba. If the color value contains an alpha component then the destination is simply filled with that alpha information, no blending takes place.</p> <p>If there is a clip rectangle set on the destination (set via ClipRect), then this function will fill the clip rectangle. </p> <p><code>procedure Fill(const AColor: Cardinal); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_27","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_20","title":"Parameters","text":"<p><code>AColor</code>: <code>Cardinal</code> : The color to fill with.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_24","title":"See Also","text":"<ul> <li>Clear</li> <li>FillRects</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#FillRect","title":"FillRect(TSdlRect, Cardinal)","text":"<p>Perform a fast fill of a rectangle with a specific color.</p> <p><code>AColor</code> should be a pixel of the format used by the surface, and can be generated by TSdlPixelFormatDetails.MapRgb or TSdlPixelFormatDetails.MapRgba. If the color value contains an alpha component then the destination is simply filled with that alpha information, no blending takes place.</p> <p>If there is a clip rectangle set on the destination (set via ClipRect), then this function will fill based on the intersection of the clip rectangle and <code>ARect</code>. </p> <p><code>procedure FillRect(const ARect: TSdlRect; const AColor: Cardinal); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_28","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_21","title":"Parameters","text":"<p><code>ARect</code>: <code>TSdlRect</code> : The rectangle to fill.</p> <p><code>AColor</code>: <code>Cardinal</code> : The color to fill with.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_25","title":"See Also","text":"<ul> <li>FillRects</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#FillRects_0","title":"FillRects(TSdlRect[], Cardinal)","text":"<p>Perform a fast fill of a set of rectangles with a specific color.</p> <p><code>AColor</code> should be a pixel of the format used by the surface, and can be generated by TSdlPixelFormatDetails.MapRgb or TSdlPixelFormatDetails.MapRgba. If the color value contains an alpha component then the destination is simply filled with that alpha information, no blending takes place.</p> <p>If there is a clip rectangle set on the destination (set via ClipRect), then this function will fill based on the intersection of the clip rectangle and the given rectangles. </p> <p><code>procedure FillRects(const ARects: array of TSdlRect; const AColor: Cardinal); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_29","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_22","title":"Parameters","text":"<p><code>ARects</code>: <code>array of TSdlRect</code> : An array rectangles to fill.</p> <p><code>AColor</code>: <code>Cardinal</code> : The color to fill with.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_26","title":"See Also","text":"<ul> <li>FillRect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#FillRects_1","title":"FillRects(TArray&lt;TSdlRect&gt;, Cardinal)","text":"<p>Perform a fast fill of a set of rectangles with a specific color.</p> <p><code>AColor</code> should be a pixel of the format used by the surface, and can be generated by TSdlPixelFormatDetails.MapRgb or TSdlPixelFormatDetails.MapRgba. If the color value contains an alpha component then the destination is simply filled with that alpha information, no blending takes place.</p> <p>If there is a clip rectangle set on the destination (set via ClipRect), then this function will fill based on the intersection of the clip rectangle and the given rectangles. </p> <p><code>procedure FillRects(const ARects: TArray&lt;TSdlRect&gt;; const AColor: Cardinal); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_30","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_23","title":"Parameters","text":"<p><code>ARects</code>: <code>TArray&lt;TSdlRect&gt;</code> : An array rectangles to fill.</p> <p><code>AColor</code>: <code>Cardinal</code> : The color to fill with.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_27","title":"See Also","text":"<ul> <li>FillRect</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Flip","title":"Flip(TSdlFlipMode)","text":"<p>Flip the surface vertically or horizontally. </p> <p><code>procedure Flip(const AFlip: TSdlFlipMode); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_31","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_24","title":"Parameters","text":"<p><code>AFlip</code>: <code>TSdlFlipMode</code> : The direction(s) to flip.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Free","title":"Free","text":"<p>Free the surface. </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Lock","title":"Lock","text":"<p>Set up the surface for directly accessing the pixels.</p> <p>Between calls to Lock / Unlock, you can write to and read from <code>Pixels</code>, using the pixel format in <code>Format</code>. Once you are done accessing the surface, you should use Unlock to release it.</p> <p>Not all surfaces require locking. If <code>MustLock</code> returns False, then you can read and write to the surface at any time, and the pixel format of the surface will not change. </p> <p><code>procedure Lock; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_32","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_28","title":"See Also","text":"<ul> <li>MustLock</li> <li>Unlock</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#MapRgb","title":"MapRgb(Byte, Byte, Byte)","text":"<p>Map an RGB triple to an opaque pixel value for the surface.</p> <p>This function maps the RGB color value to the specified pixel format and returns the pixel value best approximating the given RGB color value for the given pixel format.</p> <p>If the surface has a palette, the index of the closest matching color in the palette will be returned.</p> <p>If the surface pixel format has an alpha component it will be returned as all 1 bits (fully opaque).</p> <p>If the pixel format bpp (color depth) is less than 32-bpp then the unused upper bits of the return value can safely be ignored (e.g., with a 16-bpp format the return value can be assigned to a UInt16, and similarly a UInt8 for an 8-bpp format). </p> <p><code>function MapRgb(const AR, AG, AB: Byte): Cardinal; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_25","title":"Parameters","text":"<p><code>AR</code>: <code>Byte</code> : The red component of the pixel in the range 0-255.</p> <p><code>AG</code>: <code>Byte</code> : The green component of the pixel in the range 0-255.</p> <p><code>AB</code>: <code>Byte</code> : The blue component of the pixel in the range 0-255.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#returns_8","title":"Returns","text":"<p><code>Cardinal</code>: A pixel value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_29","title":"See Also","text":"<ul> <li>MapRgba</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#MapRgba","title":"MapRgba(Byte, Byte, Byte, Byte)","text":"<p>Map an RGBA quadruple to a pixel value for the surface.</p> <p>This function maps the RGBA color value to the specified pixel format and returns the pixel value best approximating the given RGBA color value for the given pixel format.</p> <p>If the surface pixel format has no alpha component the alpha value will be ignored (as it will be in formats with a palette).</p> <p>If the surface has a palette, the index of the closest matching color in the palette will be returned.</p> <p>If the pixel format bpp (color depth) is less than 32-bpp then the unused upper bits of the return value can safely be ignored (e.g., with a 16-bpp format the return value can be assigned to a UInt16, and similarly a UInt8 for an 8-bpp format). </p> <p><code>function MapRgba(const AR, AG, AB, AA: Byte): Cardinal; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_26","title":"Parameters","text":"<p><code>AR</code>: <code>Byte</code> : The red component of the pixel in the range 0-255.</p> <p><code>AG</code>: <code>Byte</code> : The green component of the pixel in the range 0-255.</p> <p><code>AB</code>: <code>Byte</code> : The blue component of the pixel in the range 0-255.</p> <p><code>AA</code>: <code>Byte</code> : The alpha component of the pixel in the range 0-255.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#returns_9","title":"Returns","text":"<p><code>Cardinal</code>: A pixel value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_30","title":"See Also","text":"<ul> <li>MapRgb</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#PremultiplyAlpha","title":"PremultiplyAlpha(Boolean)","text":"<p>Premultiply the alpha. </p> <p><code>procedure PremultiplyAlpha(const ALinear: Boolean); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_33","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_27","title":"Parameters","text":"<p><code>ALinear</code>: <code>Boolean</code> : True to convert from sRGB to linear space for the alpha multiplication, False to do multiplication in sRGB space.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#RemoveAlternateImages","title":"RemoveAlternateImages","text":"<p>Remove all alternate versions of this surface.</p> <p>This function removes a reference from all the alternative versions, destroying them if this is the last reference to them. </p> <p><code>procedure RemoveAlternateImages; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_31","title":"See Also","text":"<ul> <li>AddAlternateImage</li> <li>Images</li> <li>HasAlternateImages</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#SaveBmp_0","title":"SaveBmp(String)","text":"<p>Save the surface to a file in BMP format.</p> <p>Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the BMP directly. Other RGB formats with 8-bit or higher get converted to a 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit surface before they are saved. YUV and paletted 1-bit and 4-bit formats are not supported. </p> <p><code>procedure SaveBmp(const AFilename: String); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_34","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_28","title":"Parameters","text":"<p><code>AFilename</code>: <code>String</code> : Name of the file to save to.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_32","title":"See Also","text":"<ul> <li>LoadBmp</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#SaveBmp_1","title":"SaveBmp(TSdlIOStream, Boolean)","text":"<p>Save the surface to a seekable SDL data stream in BMP format.</p> <p>Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the BMP directly. Other RGB formats with 8-bit or higher get converted to a 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit surface before they are saved. YUV and paletted 1-bit and 4-bit formats are not supported. </p> <p><code>procedure SaveBmp(const ADst: TSdlIOStream; const ACloseIO: Boolean); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_35","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_29","title":"Parameters","text":"<p><code>ADst</code>: <code>TSdlIOStream</code> : A data stream to save to.</p> <p><code>ACloseIO</code>: <code>Boolean</code> : If true, calls ADst.Close before returning, even in the case of an error.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_33","title":"See Also","text":"<ul> <li>LoadBmp</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Scale","title":"Scale(Integer, Integer, TSdlScaleMode)","text":"<p>Creates a new surface identical to the existing surface, scaled to the desired size.</p> <p>The returned surface should be freed with Free. </p> <p><code>function Scale(const AWidth, AHeight: Integer; const AScaleMode: TSdlScaleMode): TSdlSurface; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#exceptions_36","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#parameters_30","title":"Parameters","text":"<p><code>AWidth</code>: <code>Integer</code> : The width of the new surface.</p> <p><code>AHeight</code>: <code>Integer</code> : The height of the new surface.</p> <p><code>AScaleMode</code>: <code>TSdlScaleMode</code> : The scale mode to be used.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#returns_10","title":"Returns","text":"<p><code>TSdlSurface</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_34","title":"See Also","text":"<ul> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#Unlock","title":"Unlock","text":"<p>Release the surface after directly accessing the pixels. </p> <p><code>procedure Unlock; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlSurface/#see-also_35","title":"See Also","text":"<ul> <li>Lock</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/","title":"TSdlTexture","text":"<p>An efficient driver-specific representation of pixel data. To create a texture, use TSdlRenderer.CreateTexture. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlTexture = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#properties","title":"Properties","text":"Name Description AlphaMod An additional alpha value multiplied into render copy operations. AlphaModFloat An additional alpha value multiplied into render copy operations. BlendMode The blend mode for a texture, used by TSdlRenderer.DrawTexture. ColorMod An additional color value multiplied into render copy operations. ColorModFloat An additional color value multiplied into render copy operations. Format The format of the texture, read-only H The height of the texture, read-only. Properties The properties associated with a texture. Renderer The renderer that created the texture. ScaleMode The scale mode used for texture scale operations. Size The size of a texture, as floating point values. W The width of the texture, read-only."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#methods","title":"Methods","text":"Name Description Free Destroy the texture. Lock(TSdlRect, Pointer, Integer) Lock a portion of the texture for write-only pixel access. Lock(Pointer, Integer) Lock the entire texture for write-only pixel access. LockToSurface(TSdlRect) Lock a portion of the texture for write-only pixel access, and expose it as a SDL surface. LockToSurface Lock a the entire texture for write-only pixel access, and expose it as a SDL surface. Unlock Unlock the texture, uploading the changes to video memory, if needed. Update(TSdlRect, Pointer, Integer) Update the given texture rectangle with new pixel data. Update(Pointer, Integer) Update the entire texture with new pixel data. UpdateNV(TSdlRect, Pointer, Integer, Pointer, Integer) Update a rectangle within a planar NV12 or NV21 texture with new pixels. UpdateNV(Pointer, Integer, Pointer, Integer) Update the entire planar NV12 or NV21 texture with new pixels. UpdateYuv(TSdlRect, Pointer, Integer, Pointer, Integer, Pointer, Integer) Update a rectangle within a planar YV12 or IYUV texture with new pixel data. UpdateYuv(Pointer, Integer, Pointer, Integer, Pointer, Integer) Update the entire planar YV12 or IYUV texture with new pixel data."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#AlphaMod","title":"AlphaMod","text":"<p>An additional alpha value multiplied into render copy operations.</p> <p>When this texture is rendered, during the copy operation the source alpha value is modulated by this alpha value according to the following formula:</p> <p><code>SrcA := SrcA * (Alpha div 255)</code></p> <p>Alpha modulation is not always supported by the renderer; it will raise an error if color modulation is not supported. </p> <p><code>property AlphaMod: Byte read GetAlphaMod write SetAlphaMod</code></p> <p>Type: <code>Byte</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#see-also","title":"See Also","text":"<ul> <li>AlphaModFloat</li> <li>ColorMod</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#AlphaModFloat","title":"AlphaModFloat","text":"<p>An additional alpha value multiplied into render copy operations.</p> <p>When this texture is rendered, during the copy operation the source alpha value is modulated by this alpha value according to the following formula:</p> <p><code>SrcA := SrcA * Alpha</code></p> <p>Alpha modulation is not always supported by the renderer; it will raise an error if color modulation is not supported. </p> <p><code>property AlphaModFloat: Single read GetAlphaModFloat write SetAlphaModFloat</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#see-also_1","title":"See Also","text":"<ul> <li>AlphaMod</li> <li>ColorModFloat</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_1","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#BlendMode","title":"BlendMode","text":"<p>The blend mode for a texture, used by TSdlRenderer.DrawTexture.</p> <p>If the blend mode is not supported, the closest supported mode is chosen. </p> <p><code>property BlendMode: TSdlBlendMode read GetBlendMode write SetBlendMode</code></p> <p>Type: <code>TSdlBlendMode</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_2","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#ColorMod","title":"ColorMod","text":"<p>An additional color value multiplied into render copy operations.</p> <p>When this texture is rendered, during the copy operation each source color channel is modulated by the appropriate color value according to the following formula:</p> <p><code>SrcC := SrcC * (Color div 255)</code></p> <p>Color modulation is not always supported by the renderer; it will raise an error if color modulation is not supported. </p> <p><code>property ColorMod: TSdlColor read GetColorMod write SetColorMod</code></p> <p>Type: <code>TSdlColor</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#see-also_2","title":"See Also","text":"<ul> <li>AlphaMod</li> <li>ColorModFloat</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_3","title":"Remarks","text":"<p>The Alpha value of the color is ignored (or set to 255).</p> <p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#ColorModFloat","title":"ColorModFloat","text":"<p>An additional color value multiplied into render copy operations.</p> <p>When this texture is rendered, during the copy operation each source color channel is modulated by the appropriate color value according to the following formula:</p> <p><code>SrcC := SrcC * Color</code></p> <p>Color modulation is not always supported by the renderer; it will raise an error if color modulation is not supported. </p> <p><code>property ColorModFloat: TSdlColorF read GetColorModFloat write SetColorModFloat</code></p> <p>Type: <code>TSdlColorF</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#see-also_3","title":"See Also","text":"<ul> <li>AlphaModFloat</li> <li>ColorMod</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_4","title":"Remarks","text":"<p>The Alpha value of the color is ignored (or set to 1.0).</p> <p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#Format","title":"Format","text":"<p>The format of the texture, read-only </p> <p><code>property Format: TSdlPixelFormat read GetFormat</code></p> <p>Type: <code>TSdlPixelFormat</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#H","title":"H","text":"<p>The height of the texture, read-only. </p> <p><code>property H: Integer read GetH</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#Properties","title":"Properties","text":"<p>The properties associated with a texture.</p> <p>The following read-only properties are provided by SDL:</p> <ul> <li><code>TSdlProperty.TextureColorspace</code>: a TSdlColorspace value describing the texture colorspace.</li> <li><code>TSdlProperty.TextureFormat</code>: one of the enumerated values in TSdlPixelFormat.</li> <li><code>TSdlProperty.TextureAccess</code>: one of the enumerated values in TSdlTextureAccess.</li> <li><code>TSdlProperty.TextureWidth</code>: the width of the texture in pixels.</li> <li><code>TSdlProperty.TextureHeight</code>: the height of the texture in pixels.</li> <li><code>TSdlProperty.TextureSdrWhitePoint</code>: for HDR10 and floating point textures, this defines the value of 100% diffuse white, with higher values being displayed in the High Dynamic Range headroom. This defaults to 100 for HDR10 textures and 1.0 for other textures.</li> <li><code>TSdlProperty.TextureHdrHeadroom</code>: for HDR10 and floating point textures, this defines the maximum dynamic range used by the content, in terms of the SDR white point. If this is defined, any values outside the range supported by the display will be scaled into the available HDR headroom, otherwise they are clipped. This defaults to 1.0 for SDR textures, 4.0 for HDR10 textures, and no default for floating point textures.</li> </ul> <p>With the Direct3D11 renderer:</p> <ul> <li><code>TSdlProperty.TextureD3D11Texture</code>: the ID3D11Texture2D associated with the texture</li> <li><code>TSdlProperty.TextureD3D11TextureU</code>: the ID3D11Texture2D associated with the U plane of a YUV texture</li> <li><code>TSdlProperty.TextureD3D11TextureV</code>: the ID3D11Texture2D associated with the V plane of a YUV texture</li> </ul> <p>With the Direct3D12 renderer:</p> <ul> <li><code>TSdlProperty.TextureD3D12Texture</code>: the ID3D12Resource associated with the texture</li> <li><code>TSdlProperty.TextureD3D12TextureU</code>: the ID3D12Resource associated with the U plane of a YUV texture</li> <li><code>TSdlProperty.TextureD3D12TextureV</code>: the ID3D12Resource associated with the V plane of a YUV texture</li> </ul> <p>With the Vulkan renderer:</p> <ul> <li><code>TSdlProperty.TextureVulkanTexture</code>: the VkImage associated with the texture</li> </ul> <p>With the OpenGL renderer:</p> <ul> <li><code>TSdlProperty.TextureOpenGLTexture</code>: the GLuint texture associated with the texture</li> <li><code>TSdlProperty.TextureOpenGLTextureUV</code>: the GLuint texture associated with the UV plane of an NV12 texture</li> <li><code>TSdlProperty.TextureOpenGLTextureU</code>: the GLuint texture associated with the U plane of a YUV texture</li> <li><code>TSdlProperty.TextureOpenGLTextureV</code>: the GLuint texture associated with the V plane of a YUV texture</li> <li><code>TSdlProperty.TextureOpenGLTextureTarget</code>: the GLenum for the texture target (<code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_RECTANGLE_ARB</code>, etc)</li> <li><code>TSdlProperty.TextureOpenGLTexW</code>: the texture coordinate width of the texture (0.0 - 1.0)</li> <li><code>TSdlProperty.TextureOpenGLTexH</code>: the texture coordinate height of the texture (0.0 - 1.0)</li> </ul> <p>With the OpenGL-ES2 renderer:</p> <ul> <li><code>TSdlProperty.TextureOpenGles2Texture</code>: the GLuint texture associated with the texture</li> <li><code>TSdlProperty.TextureOpenGles2TextureUV</code>: the GLuint texture associated with the UV plane of an NV12 texture</li> <li><code>TSdlProperty.TextureOpenGles2TextureU</code>: the GLuint texture associated with the U plane of a YUV texture</li> <li><code>TSdlProperty.TextureOpenGles2TextureV</code>: the GLuint texture associated with the V plane of a YUV texture</li> <li><code>TSdlProperty.TextureOpenGles2TextureTarget</code>: the GLenum for the texture target (<code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_EXTERNAL_OES</code>, etc) </li> </ul> <p><code>property Properties: TSdlProperties read GetProperties</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_5","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#Renderer","title":"Renderer","text":"<p>The renderer that created the texture. </p> <p><code>property Renderer: TSdlRenderer read GetRenderer</code></p> <p>Type: <code>TSdlRenderer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_6","title":"Remarks","text":"<p>Raised on failure.It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#ScaleMode","title":"ScaleMode","text":"<p>The scale mode used for texture scale operations.</p> <p>The default texture scale mode is TSdlScaleMode.Linear.</p> <p>If the scale mode is not supported, the closest supported mode is chosen. </p> <p><code>property ScaleMode: TSdlScaleMode read GetScaleMode write SetScaleMode</code></p> <p>Type: <code>TSdlScaleMode</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_6","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_7","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#Size","title":"Size","text":"<p>The size of a texture, as floating point values. </p> <p><code>property Size: TSdlSizeF read GetSize</code></p> <p>Type: <code>TSdlSizeF</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_7","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_8","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#W","title":"W","text":"<p>The width of the texture, read-only. </p> <p><code>property W: Integer read GetW</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#Equal","title":"Equal(TSdlTexture, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlTexture; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#parameters","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlTexture</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlTexture; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#parameters_1","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#returns_1","title":"Returns","text":"<p><code>TSdlTexture</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#NotEqual","title":"NotEqual(TSdlTexture, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlTexture; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#parameters_2","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlTexture</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#Free","title":"Free","text":"<p>Destroy the texture. </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#see-also_4","title":"See Also","text":"<ul> <li>TSdlRenderer.CreateTexture</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_9","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#Lock_0","title":"Lock(TSdlRect, Pointer, Integer)","text":"<p>Lock a portion of the texture for write-only pixel access.</p> <p>As an optimization, the pixels made available for editing don't necessarily contain the old texture data. This is a write-only operation, and if you need to keep a copy of the texture data you should do that at the application level.</p> <p>You must use Unlock to unlock the pixels and apply any changes. </p> <p><code>procedure Lock(const ARect: TSdlRect; out APixels: Pointer; out APitch: Integer); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_8","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure (eg. if the texture is not valid or was not created with <code>TSdlTextureAccess.Streaming</code>.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#parameters_3","title":"Parameters","text":"<p><code>ARect</code>: <code>TSdlRect</code> : The area to lock for access.</p> <p><code>APixels</code>: <code>Pointer</code> : This is set to a pointer to the locked pixels, appropriately offset by the locked area.</p> <p><code>APitch</code>: <code>Integer</code> : This is set to the pitch of the locked pixels; the pitch is the length of one row in bytes.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#see-also_5","title":"See Also","text":"<ul> <li>LockToSurface</li> <li>Unlock</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_10","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#Lock_1","title":"Lock(Pointer, Integer)","text":"<p>Lock the entire texture for write-only pixel access.</p> <p>As an optimization, the pixels made available for editing don't necessarily contain the old texture data. This is a write-only operation, and if you need to keep a copy of the texture data you should do that at the application level.</p> <p>You must use Unlock to unlock the pixels and apply any changes. </p> <p><code>procedure Lock(out APixels: Pointer; out APitch: Integer); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_9","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure (eg. if the texture is not valid or was not created with <code>TSdlTextureAccess.Streaming</code>.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#parameters_4","title":"Parameters","text":"<p><code>APixels</code>: <code>Pointer</code> : This is set to a pointer to the locked pixels, appropriately offset by the locked area.</p> <p><code>APitch</code>: <code>Integer</code> : This is set to the pitch of the locked pixels; the pitch is the length of one row in bytes.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#see-also_6","title":"See Also","text":"<ul> <li>LockToSurface</li> <li>Unlock</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_11","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#LockToSurface_0","title":"LockToSurface(TSdlRect)","text":"<p>Lock a portion of the texture for write-only pixel access, and expose it as a SDL surface.</p> <p>Besides providing an TSdlSurface instead of raw pixel data, this function operates like Lock.</p> <p>As an optimization, the pixels made available for editing don't necessarily contain the old texture data. This is a write-only operation, and if you need to keep a copy of the texture data you should do that at the application level.</p> <p>You must use Unlock to unlock the pixels and apply any changes.</p> <p>The returned surface is freed internally after calling Unlock or when freeing the texture. The caller should not free it. </p> <p><code>function LockToSurface(const ARect: TSdlRect): TSdlSurface; overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_10","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#parameters_5","title":"Parameters","text":"<p><code>ARect</code>: <code>TSdlRect</code> : The rectangle to lock for access.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#returns_3","title":"Returns","text":"<p><code>TSdlSurface</code>: A SDL surface of size ARect. Don't assume any specific pixel content.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#see-also_7","title":"See Also","text":"<ul> <li>Lock</li> <li>Unlock</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_12","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#LockToSurface_1","title":"LockToSurface","text":"<p>Lock a the entire texture for write-only pixel access, and expose it as a SDL surface.</p> <p>Besides providing an TSdlSurface instead of raw pixel data, this function operates like Lock.</p> <p>As an optimization, the pixels made available for editing don't necessarily contain the old texture data. This is a write-only operation, and if you need to keep a copy of the texture data you should do that at the application level.</p> <p>You must use Unlock to unlock the pixels and apply any changes.</p> <p>The returned surface is freed internally after calling Unlock or when freeing the texture. The caller should not free it. </p> <p><code>function LockToSurface: TSdlSurface; overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_11","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#returns_4","title":"Returns","text":"<p><code>TSdlSurface</code>: A SDL surface of the same size as this texture. Don't assume any specific pixel content.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#see-also_8","title":"See Also","text":"<ul> <li>Lock</li> <li>Unlock</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_13","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#Unlock","title":"Unlock","text":"<p>Unlock the texture, uploading the changes to video memory, if needed.</p> <p>Warning: Please note that Lock is intended to be write-only; it will not guarantee the previous contents of the texture will be provided. You must fully initialize any area of a texture that you lock before unlocking it, as the pixels might otherwise be uninitialized memory.</p> <p>Which is to say: locking and immediately unlocking a texture can result in corrupted textures, depending on the renderer in use. </p> <p><code>procedure Unlock; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#see-also_9","title":"See Also","text":"<ul> <li>Lock</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_14","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#Update_0","title":"Update(TSdlRect, Pointer, Integer)","text":"<p>Update the given texture rectangle with new pixel data.</p> <p>The pixel data must be in the pixel format of the texture, which can be queried using the TSdlProperty.TextureFormat property.</p> <p>This is a fairly slow function, intended for use with static textures that do not change often.</p> <p>If the texture is intended to be updated often, it is preferred to create the texture as streaming and use the locking functions referenced below. While this function will work with streaming textures, for optimization reasons you may not get the pixels back if you lock the texture afterward. </p> <p><code>procedure Update(const ARect: TSdlRect; const APixels: Pointer; const APitch: Integer); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_12","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#parameters_6","title":"Parameters","text":"<p><code>ARect</code>: <code>TSdlRect</code> : The area to update.</p> <p><code>APixels</code>: <code>Pointer</code> : The raw pixel data in the format of the texture.</p> <p><code>APitch</code>: <code>Integer</code> : The number of bytes in a row of pixel data, including padding between lines.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#see-also_10","title":"See Also","text":"<ul> <li>Lock</li> <li>Unlock</li> <li>UpdateNV</li> <li>UpdateYuv</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_15","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#Update_1","title":"Update(Pointer, Integer)","text":"<p>Update the entire texture with new pixel data.</p> <p>The pixel data must be in the pixel format of the texture, which can be queried using the TSdlProperty.TextureFormat property.</p> <p>This is a fairly slow function, intended for use with static textures that do not change often.</p> <p>If the texture is intended to be updated often, it is preferred to create the texture as streaming and use the locking functions referenced below. While this function will work with streaming textures, for optimization reasons you may not get the pixels back if you lock the texture afterward. </p> <p><code>procedure Update(const APixels: Pointer; const APitch: Integer); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_13","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#parameters_7","title":"Parameters","text":"<p><code>APixels</code>: <code>Pointer</code> : The raw pixel data in the format of the texture.</p> <p><code>APitch</code>: <code>Integer</code> : The number of bytes in a row of pixel data, including padding between lines.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#see-also_11","title":"See Also","text":"<ul> <li>Lock</li> <li>Unlock</li> <li>UpdateNV</li> <li>UpdateYuv</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_16","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#UpdateNV_0","title":"UpdateNV(TSdlRect, Pointer, Integer, Pointer, Integer)","text":"<p>Update a rectangle within a planar NV12 or NV21 texture with new pixels.</p> <p>You can use Update as long as your pixel data is a contiguous block of NV12/21 planes in the proper order, but this function is available if your pixel data is not contiguous. </p> <p><code>procedure UpdateNV(const ARect: TSdlRect; const AYPlane: Pointer; const AYPitch: Integer; const AUVPlane: Pointer; const AUVPitch: Integer); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_14","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#parameters_8","title":"Parameters","text":"<p><code>ARect</code>: <code>TSdlRect</code> : The rectangle of pixels to update.</p> <p><code>AYPlane</code>: <code>Pointer</code> : The raw pixel data for the Y plane.</p> <p><code>AYPitch</code>: <code>Integer</code> : The number of bytes between rows of pixel data for the Y plane.</p> <p><code>AUVPlane</code>: <code>Pointer</code> : The raw pixel data for the UV plane.</p> <p><code>AUVPitch</code>: <code>Integer</code> : The number of bytes between rows of pixel data for the UV plane.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#see-also_12","title":"See Also","text":"<ul> <li>Update</li> <li>UpdateYuv</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_17","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#UpdateNV_1","title":"UpdateNV(Pointer, Integer, Pointer, Integer)","text":"<p>Update the entire planar NV12 or NV21 texture with new pixels.</p> <p>You can use Update as long as your pixel data is a contiguous block of NV12/21 planes in the proper order, but this function is available if your pixel data is not contiguous. </p> <p><code>procedure UpdateNV(const AYPlane: Pointer; const AYPitch: Integer; const AUVPlane: Pointer; const AUVPitch: Integer); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_15","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#parameters_9","title":"Parameters","text":"<p><code>AYPlane</code>: <code>Pointer</code> : The raw pixel data for the Y plane.</p> <p><code>AYPitch</code>: <code>Integer</code> : The number of bytes between rows of pixel data for the Y plane.</p> <p><code>AUVPlane</code>: <code>Pointer</code> : The raw pixel data for the UV plane.</p> <p><code>AUVPitch</code>: <code>Integer</code> : The number of bytes between rows of pixel data for the UV plane.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#see-also_13","title":"See Also","text":"<ul> <li>Update</li> <li>UpdateYuv</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_18","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#UpdateYuv_0","title":"UpdateYuv(TSdlRect, Pointer, Integer, Pointer, Integer, Pointer, Integer)","text":"<p>Update a rectangle within a planar YV12 or IYUV texture with new pixel data.</p> <p>You can use Update as long as your pixel data is a contiguous block of Y and U/V planes in the proper order, but this function is available if your pixel data is not contiguous. </p> <p><code>procedure UpdateYuv(const ARect: TSdlRect; const AYPlane: Pointer; const AYPitch: Integer; const AUPlane: Pointer; const AUPitch: Integer; const AVPlane: Pointer; const AVPitch: Integer); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_16","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#parameters_10","title":"Parameters","text":"<p><code>ARect</code>: <code>TSdlRect</code> : The rectangle of pixels to update.</p> <p><code>AYPlane</code>: <code>Pointer</code> : The raw pixel data for the Y plane.</p> <p><code>AYPitch</code>: <code>Integer</code> : The number of bytes between rows of pixel data for the Y plane.</p> <p><code>AUPlane</code>: <code>Pointer</code> : The raw pixel data for the U plane.</p> <p><code>AUPitch</code>: <code>Integer</code> : The number of bytes between rows of pixel data for the U plane.</p> <p><code>AVPlane</code>: <code>Pointer</code> : The raw pixel data for the V plane.</p> <p><code>AVPitch</code>: <code>Integer</code> : The number of bytes between rows of pixel data for the V plane.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#see-also_14","title":"See Also","text":"<ul> <li>UpdateNV</li> <li>Update</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_19","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#UpdateYuv_1","title":"UpdateYuv(Pointer, Integer, Pointer, Integer, Pointer, Integer)","text":"<p>Update the entire planar YV12 or IYUV texture with new pixel data.</p> <p>You can use Update as long as your pixel data is a contiguous block of Y and U/V planes in the proper order, but this function is available if your pixel data is not contiguous. </p> <p><code>procedure UpdateYuv(const AYPlane: Pointer; const AYPitch: Integer; const AUPlane: Pointer; const AUPitch: Integer; const AVPlane: Pointer; const AVPitch: Integer); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#exceptions_17","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#parameters_11","title":"Parameters","text":"<p><code>AYPlane</code>: <code>Pointer</code> : The raw pixel data for the Y plane.</p> <p><code>AYPitch</code>: <code>Integer</code> : The number of bytes between rows of pixel data for the Y plane.</p> <p><code>AUPlane</code>: <code>Pointer</code> : The raw pixel data for the U plane.</p> <p><code>AUPitch</code>: <code>Integer</code> : The number of bytes between rows of pixel data for the U plane.</p> <p><code>AVPlane</code>: <code>Pointer</code> : The raw pixel data for the V plane.</p> <p><code>AVPitch</code>: <code>Integer</code> : The number of bytes between rows of pixel data for the V plane.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#see-also_15","title":"See Also","text":"<ul> <li>UpdateNV</li> <li>Update</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlTexture/#remarks_20","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVertex/","title":"TSdlVertex","text":"<p>Vertex structure. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVertex/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlVertex = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVertex/#fields","title":"Fields","text":"Name Description Color Vertex color Position Vertex position, in SDL_Renderer coordinates TexCoord Normalized texture coordinates, if needed"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVertex/#field-descriptions","title":"Field Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVertex/#Color","title":"Color","text":"<p>Vertex color </p> <p><code>var Color: TSdlColorF</code></p> <p>Type: <code>TSdlColorF</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVertex/#Position","title":"Position","text":"<p>Vertex position, in SDL_Renderer coordinates </p> <p><code>var Position: TSdlPointF</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVertex/#TexCoord","title":"TexCoord","text":"<p>Normalized texture coordinates, if needed </p> <p><code>var TexCoord: TSdlPointF</code></p> <p>Type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVideoDriver/","title":"TSdlVideoDriver","text":"<p>A video driver. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVideoDriver/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlVideoDriver = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVideoDriver/#properties","title":"Properties","text":"Name Description Count The number of video drivers compiled into SDL. Current The name of the currently initialized video driver or an empty string if no driver has been initialized. Drivers The built in video drivers. Name The name of the video driver."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVideoDriver/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVideoDriver/#Count","title":"Count","text":"<p>The number of video drivers compiled into SDL. </p> <p><code>class property Count: Integer read GetCount</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVideoDriver/#see-also","title":"See Also","text":"<ul> <li>Drivers</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVideoDriver/#remarks","title":"Remarks","text":"<p>This function should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVideoDriver/#Current","title":"Current","text":"<p>The name of the currently initialized video driver or an empty string if no driver has been initialized.</p> <p>The names of drivers are all simple, low-ASCII identifiers, like \"cocoa\", \"x11\" or \"windows\". These never have Unicode characters, and are not meant to be proper names. </p> <p><code>class property Current: String read GetCurrent</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVideoDriver/#remarks_1","title":"Remarks","text":"<p>This function should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVideoDriver/#Drivers","title":"Drivers","text":"<p>The built in video drivers.</p> <p>The video drivers are presented in the order in which they are normally checked during initialization. </p> <p><code>class property Drivers[const AIndex: Integer]: TSdlVideoDriver read GetDriver; default</code></p> <p>Type: <code>TSdlVideoDriver</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVideoDriver/#see-also_1","title":"See Also","text":"<ul> <li>Count</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVideoDriver/#remarks_2","title":"Remarks","text":"<p>This function should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVideoDriver/#Name","title":"Name","text":"<p>The name of the video driver.</p> <p>The names of drivers are all simple, low-ASCII identifiers, like \"cocoa\", \"x11\" or \"windows\". These never have Unicode characters, and are not meant to be proper names. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlVideoDriver/#remarks_3","title":"Remarks","text":"<p>This function should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/","title":"TSdlWindow","text":"<p>A window. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlWindow = record ... end;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#properties","title":"Properties","text":"Name Description AlwaysOnTop The window \"always on top\" state of the window. Bordered The border state of the window. Display The display associated with this window (that is, the display containing the center of this window). DisplayScale The content display scale relative to a window's pixel size. Flags The window flags. Focusable Whether the window may have input focus. Fullscreen The window's fullscreen state. FullscreenMode The display mode to use when a window is visible and fullscreen. This is a pointer to the display mode to use, which can be <code>nil</code> for borderless fullscreen desktop mode, or one of the fullscreen modes returned by TSdlDisplay.FullscreenModes for an exclusive fullscreen mode. GrabbedWindow The window that currently has an input grab enabled, or nil otherwise. HasSurface Whether the window has a surface associated with it. IccProfile The raw ICC profile data for the screen the window is currently on. Icon Set the icon for the window. ID The numeric ID of the window. IsRelativeMouseMode Whether relative mouse mode for the window is eneabled. IsScreenKeyboardShown Whether the screen keyboard is shown for the window. KeyboardGrab The window's keyboard grab mode. MaximumSize The maximum size of the window's client area. See GetMaximumSize and SetMaximumSize for more information. MinimumSize The minimum size of the window's client area. See GetMinimumSize and SetMinimumSize for more information. Modal The modal state of the window. MouseGrab The window's mouse grab mode. MouseRect The mouse confinement rectange of the window. Opacity The opacity of the window, which will be clamped internally between 0.0 (transparent) and 1.0 (opaque). Will be 1.0 (opaque) on platforms that don't support opacity. Parent The parent of the window or <code>nil</code> if the window has no parent. PixelDensity The pixel density of the window. PixelFormat The pixel format associated with the window. Position The position of the window. See SetPosition and GetPosition for more information. Properties The properties associated with a window. Resizable The user-resizable state of the window. SafeArea The safe area for this window. Shape The shape of the transparent window, or <code>nil</code> if the window has no shape (or to remove the shape). Size The size of the window. See SetSize and GetSize for more information. SizeInPixels The size of the window in pixels. See GetSizeInPixels for more information. Surface The SDL surface associated with the window. SurfaceVSync The VSync for the window surface. TextInputActive Whether or not Unicode text input events are enabled for the window. Title The title of the window. Windows A list of valid windows. WithKeyboardFocus The window which currently has keyboard focus."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#constructors","title":"Constructors","text":"Name Description Create(TSdlProperties) Create a window with the specified properties. Create(TSdlWindow, Integer, Integer, Integer, Integer, TSdlWindowFlags) Create a child popup window of the specified parent window. Create(String, Integer, Integer, TSdlWindowFlags) Create a window with the specified dimensions and flags. Destroy"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#operators","title":"Operators","text":"Name Description Equal Used to compare against <code>nil</code>. Implicit Used to set the value to <code>nil</code>. NotEqual Used to compare against <code>nil</code>."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#methods","title":"Methods","text":"Name Description ClearComposition Dismiss the composition window/IME without disabling the subsystem. ClearTextInputArea Clear the area used to type Unicode text input. Flash Request a window to demand attention from the user. Free Frees the window. FreeSurface Destroy the surface associated with the window. FromID Get a window from a stored ID. GetAspectRatio Get the aspect ratio of the window's client area. GetBordersSize Get the size of the window's borders (decorations) around the client area. GetMaximumSize Get the maximum size of the window's client area. GetMinimumSize Get the minimum size of the window's client area. GetPosition Get the position of the window. GetSize Get the size of the window's client area. GetSizeInPixels Get the size of the window's client area, in pixels. GetTextInputArea Get the area used to type Unicode text input. Hide Hide the window. Maximize Request that the window be made as large as possible. Minimize Request that the window be minimized to an iconic representation. RaiseAndFocus Request that a window be raised above other windows and gain the input focus. Restore Request that the size and position of a minimized or maximized window be restored. SetAspectRatio Request that the aspect ratio of a window's client area be set. SetHitTestCallback Provide a callback that decides if a window region has special properties. SetMaximumSize Set the maximum size of the window's client area. SetMinimumSize Set the minimum size of the window's client area. SetPosition Request that the window's position be set. SetSize Request that the size of a window's client area be set. SetTextInputArea Set the area used to type Unicode text input. Show Show the window. ShowSystemMenu Display the system-level window menu. StartTextInput(TSdlProperties) Start accepting Unicode text input events in the window, with properties describing the input. StartTextInput Start accepting Unicode text input events in the window. StopTextInput Stop receiving any text input events in the window. Sync Block until any pending window state is finalized. UpdateSurface(TSdlRect[]) Copy areas of the window surface to the screen. UpdateSurface(TArray&lt;TSdlRect&gt;) Copy areas of the window surface to the screen. UpdateSurface Copy the window surface to the screen. WarpMouse(TSdlPointF) Move the mouse cursor to the given position within the window. WarpMouse(Single, Single) Move the mouse cursor to the given position within the window."},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#AlwaysOnTop","title":"AlwaysOnTop","text":"<p>The window \"always on top\" state of the window.</p> <p>This will add or remove the window's <code>TSdlWindowFlag.AlwaysOnTop</code> flag. This will bring the window to the front and keep the window above the rest. </p> <p><code>property AlwaysOnTop: Boolean read GetAlwaysOnTop write SetAlwaysOnTop</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also","title":"See Also","text":"<ul> <li>Flags</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Bordered","title":"Bordered","text":"<p>The border state of the window.</p> <p>This will add or remove the window's <code>TSdlWindowFlag.Borderless</code> flag and add or remove the border from the actual window. This is a no-op if the window's border already matches the requested state.</p> <p>You can't change the border state of a fullscreen window. </p> <p><code>property Bordered: Boolean read GetBordered write SetBordered</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_1","title":"See Also","text":"<ul> <li>Flags</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_1","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Display","title":"Display","text":"<p>The display associated with this window (that is, the display containing the center of this window). </p> <p><code>property Display: TSdlDisplay read GetDisplay</code></p> <p>Type: <code>TSdlDisplay</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_2","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_2","title":"See Also","text":"<ul> <li>TSdlDisplay.Bounds</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_2","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#DisplayScale","title":"DisplayScale","text":"<p>The content display scale relative to a window's pixel size.</p> <p>This is a combination of the window pixel density and the display content scale, and is the expected scale for displaying content in this window. For example, if a 3840x2160 window had a display scale of 2.0, the user expects the content to take twice as many pixels and be the same physical size as if it were being displayed in a 1920x1080 window with a display scale of 1.0.</p> <p>Conceptually this value corresponds to the scale display setting, and is updated when that setting is changed, or the window moves to a display with a different scale setting. </p> <p><code>property DisplayScale: Single read GetDisplayScale</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_3","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_3","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Flags","title":"Flags","text":"<p>The window flags. </p> <p><code>property Flags: TSdlWindowFlags read GetFlags</code></p> <p>Type: <code>TSdlWindowFlags</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_3","title":"See Also","text":"<ul> <li>Create</li> <li>Hide</li> <li>Maximize</li> <li>Minimize</li> <li>Fullscreen</li> <li>MouseGrab</li> <li>Show</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_4","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Focusable","title":"Focusable","text":"<p>Whether the window may have input focus. </p> <p><code>property Focusable: Boolean read GetFocusable write SetFocusable</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_4","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_5","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Fullscreen","title":"Fullscreen","text":"<p>The window's fullscreen state.</p> <p>By default a window in fullscreen state uses borderless fullscreen desktop mode, but a specific exclusive display mode can be set using FullscreenMode.</p> <p>On some windowing systems setting this property is asynchronous and the new fullscreen state may not have have been applied immediately upon the return of this function. If an immediate change is required, call Sync to block until the changes have taken effect.</p> <p>When the window state changes, an TSdlEventKind.WindowEnterFullscreen or TSdlEventKind.WindowLeaveFullscreen event will be emitted. Note that, as this is just a request, it can be denied by the windowing system. </p> <p><code>property Fullscreen: Boolean read GetFullscreen write SetFullscreen</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_5","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_4","title":"See Also","text":"<ul> <li>FullscreenMode</li> <li>Sync</li> <li>TSdlWindowFlag</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_6","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#FullscreenMode","title":"FullscreenMode","text":"<p>The display mode to use when a window is visible and fullscreen. This is a pointer to the display mode to use, which can be <code>nil</code> for borderless fullscreen desktop mode, or one of the fullscreen modes returned by TSdlDisplay.FullscreenModes for an exclusive fullscreen mode.</p> <p>This only affects the display mode used when the window is fullscreen. To change the window size when the window is not fullscreen, use Size.</p> <p>If the window is currently in the fullscreen state, this request is asynchronous on some windowing systems and the new mode dimensions may not be applied immediately upon the return of this function. If an immediate change is required, call Sync to block until the changes have taken effect.</p> <p>When the new mode takes effect, an TSdlEventKind.WindowResized and/or an TSdlEventKind.WindowPixelSizeChanged event will be emitted with the new mode dimensions. </p> <p><code>property FullscreenMode: PSdlDisplayMode read GetFullscreenMode write SetFullscreenMode</code></p> <p>Type: <code>PSdlDisplayMode</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_6","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised when setting the mode failed.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_5","title":"See Also","text":"<ul> <li>Fullscreen</li> <li>Sync</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_7","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#GrabbedWindow","title":"GrabbedWindow","text":"<p>The window that currently has an input grab enabled, or nil otherwise. </p> <p><code>class property GrabbedWindow: TSdlWindow read GetGrabbedWindow</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_6","title":"See Also","text":"<ul> <li>MouseGrab</li> <li>KeyboardGrab</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_8","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#HasSurface","title":"HasSurface","text":"<p>Whether the window has a surface associated with it. </p> <p><code>property HasSurface: Boolean read GetHasSurface</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_7","title":"See Also","text":"<ul> <li>Surface</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_9","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#IccProfile","title":"IccProfile","text":"<p>The raw ICC profile data for the screen the window is currently on. </p> <p><code>property IccProfile: TBytes read GetIccProfile</code></p> <p>Type: <code>TBytes</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_7","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_10","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Icon","title":"Icon","text":"<p>Set the icon for the window.</p> <p>If this property is a surface with alternate representations, the surface will be interpreted as the content to be used for 100% display scale, and the alternate representations will be used for high DPI situations. For example, if the original surface is 32x32, then on a 2x macOS display or 200% display scale on Windows, a 64x64 version of the image will be used, if available. If a matching version of the image isn't available, the closest larger size image will be downscaled to the appropriate size and be used instead, if available. Otherwise, the closest smaller image will be upscaled and be used instead. </p> <p><code>property Icon: TSdlSurface write SetIcon</code></p> <p>Type: <code>TSdlSurface</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_8","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_11","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#ID","title":"ID","text":"<p>The numeric ID of the window.</p> <p>The numeric ID is what TSdlWindowEvent references, and is necessary to map these events to specific TSdlWindow objects. </p> <p><code>property ID: TSdlWindowID read GetID</code></p> <p>Type: <code>TSdlWindowID</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_9","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_8","title":"See Also","text":"<ul> <li>FromID</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_12","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#IsRelativeMouseMode","title":"IsRelativeMouseMode","text":"<p>Whether relative mouse mode for the window is eneabled.</p> <p>While the window has focus and relative mouse mode is enabled, the cursor is hidden, the mouse position is constrained to the window, and SDL will report continuous relative mouse motion even if the mouse is at the edge of the window.</p> <p>If you'd like to keep the mouse position fixed while in relative mode you can use MouseRect. If you'd like the cursor to be at a specific location when relative mode ends, you should use WarpMouse before disabling relative mode.</p> <p>This method will flush any pending mouse motion for this window. </p> <p><code>property IsRelativeMouseMode: Boolean read GetIsRelativeMouseMode write SetIsRelativeMouseMode</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_10","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_13","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#IsScreenKeyboardShown","title":"IsScreenKeyboardShown","text":"<p>Whether the screen keyboard is shown for the window. </p> <p><code>property IsScreenKeyboardShown: Boolean read GetIsScreenKeyboardShown</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_9","title":"See Also","text":"<ul> <li>TSdlKeyboard.HasScreenKeyboardSupport</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_14","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#KeyboardGrab","title":"KeyboardGrab","text":"<p>The window's keyboard grab mode.</p> <p>Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or the Meta/Super key. Note that not all system keyboard shortcuts can be captured by applications (one example is Ctrl+Alt+Del on Windows).</p> <p>This is primarily intended for specialized applications such as VNC clients or VM frontends. Normal games should not use keyboard grab.</p> <p>When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the window is full-screen to ensure the user is not trapped in your application. If you have a custom keyboard shortcut to exit fullscreen mode, you may suppress this behavior with TSdlHints.AllowAltTabWhileGrabbed.</p> <p>If the caller enables a grab while another window is currently grabbed, the other window loses its grab in favor of the caller's window. </p> <p><code>property KeyboardGrab: Boolean read GetKeyboardGrab write SetKeyboardGrab</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_11","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_10","title":"See Also","text":"<ul> <li>MouseGrab</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_15","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#MaximumSize","title":"MaximumSize","text":"<p>The maximum size of the window's client area. See GetMaximumSize and SetMaximumSize for more information. </p> <p><code>property MaximumSize: TSdlPoint read GetMaximumSizePoint write SetMaximumSizePoint</code></p> <p>Type: <code>TSdlPoint</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#MinimumSize","title":"MinimumSize","text":"<p>The minimum size of the window's client area. See GetMinimumSize and SetMinimumSize for more information. </p> <p><code>property MinimumSize: TSdlPoint read GetMinimumSizePoint write SetMinimumSizePoint</code></p> <p>Type: <code>TSdlPoint</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Modal","title":"Modal","text":"<p>The modal state of the window.</p> <p>To enable modal status on a window, the window must currently be the child window of a parent, or toggling modal status on will fail. </p> <p><code>property Modal: Boolean read GetModal write SetModal</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_12","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_11","title":"See Also","text":"<ul> <li>Parent</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_16","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#MouseGrab","title":"MouseGrab","text":"<p>The window's mouse grab mode.</p> <p>Mouse grab confines the mouse cursor to the window. </p> <p><code>property MouseGrab: Boolean read GetMouseGrab write SetMouseGrab</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_13","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_12","title":"See Also","text":"<ul> <li>MouseRect</li> <li>KeyboardGrab</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_17","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#MouseRect","title":"MouseRect","text":"<p>The mouse confinement rectange of the window.</p> <p>Note that setting this does NOT grab the cursor, it only defines the area a cursor is restricted to when the window has mouse focus.</p> <p>This property is a pointer to a rectangle in window-relative coordinates, or nil if there isn't a confinement rectangle. </p> <p><code>property MouseRect: PSdlRect read GetMouseRect write SetMouseRect</code></p> <p>Type: <code>PSdlRect</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_14","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_13","title":"See Also","text":"<ul> <li>MouseGrab</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_18","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Opacity","title":"Opacity","text":"<p>The opacity of the window, which will be clamped internally between 0.0 (transparent) and 1.0 (opaque). Will be 1.0 (opaque) on platforms that don't support opacity. </p> <p><code>property Opacity: Single read GetOpacity write SetOpacity</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_15","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_19","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Parent","title":"Parent","text":"<p>The parent of the window or <code>nil</code> if the window has no parent.</p> <p>When setting this property, if the window is already the child of an existing window, it will be reparented to the new owner. Setting the parent window to <code>nil</code> unparents the window and removes child window status.</p> <p>If a parent window is hidden or destroyed, the operation will be recursively applied to child windows. Child windows hidden with the parent that did not have their hidden status explicitly set will be restored when the parent is shown.</p> <p>Attempting to set the parent of a window that is currently in the modal state will fail. Use Modal to cancel the modal status before attempting to change the parent.</p> <p>Popup windows cannot change parents and attempts to do so will fail.</p> <p>Setting a parent window that is currently the sibling or descendent of the child window results in undefined behavior. </p> <p><code>property Parent: TSdlWindow read GetParent write SetParent</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_16","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_20","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#PixelDensity","title":"PixelDensity","text":"<p>The pixel density of the window.</p> <p>This is a ratio of pixel size to window size. For example, if the window is 1920x1080 and it has a high density back buffer of 3840x2160 pixels, it would have a pixel density of 2.0. </p> <p><code>property PixelDensity: Single read GetPixelDensity</code></p> <p>Type: <code>Single</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_17","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_14","title":"See Also","text":"<ul> <li>DisplayScale</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_21","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#PixelFormat","title":"PixelFormat","text":"<p>The pixel format associated with the window. </p> <p><code>property PixelFormat: TSdlPixelFormat read GetPixelFormat</code></p> <p>Type: <code>TSdlPixelFormat</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_18","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_22","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Position","title":"Position","text":"<p>The position of the window. See SetPosition and GetPosition for more information. </p> <p><code>property Position: TSdlPoint read GetPositionPoint write SetPositionPoint</code></p> <p>Type: <code>TSdlPoint</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_19","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_23","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Properties","title":"Properties","text":"<p>The properties associated with a window.</p> <p>The following read-only properties are provided by SDL:</p> <ul> <li><code>TSdlProperty.WindowShape</code>: The surface associated with a shaped window</li> <li><code>TSdlProperty.WindowHdrEnabled</code>: True if the window has HDR headroom above the SDR white point. This property can change dynamically when TSdlEventKind.WindowHdrStateChanged is sent.</li> <li><code>TSdlProperty.WindowSdrWhiteLevel</code>: the value of SDR white in the TSdlColorspace.SrgbLinear colorspace. On Windows this corresponds to the SDR white level in scRGB colorspace, and on Apple platforms this is always 1.0 for EDR content. This property can change dynamically when TSdlEventKind.WindowHdrStateChanged is sent.</li> <li><code>TSdlProperty.WindowHdrHeadroom</code>: The additional high dynamic range that can be displayed, in terms of the SDR white point. When HDR is not enabled, this will be 1.0. This property can change dynamically when TSdlEventKind.WindowHdrStateChanged is sent.</li> </ul> <p>On Android:</p> <ul> <li><code>TSdlProperty.WindowAndroidWindow</code>: The ANativeWindow associated with the window</li> <li><code>TSdlProperty.WindowAndroidSurface</code>: The EGLSurface associated with the window</li> </ul> <p>On iOS:</p> <ul> <li><code>TSdlProperty.WindowUIKitWindow</code>: The UIWindow handle associated with the window</li> <li><code>TSdlProperty.WindowUIKitMetalViewTag</code>: The NSInteger handle tag associated with metal views on the window</li> <li><code>TSdlProperty.WindowUIKitOpenGLFramebuffer</code>: The OpenGL view's framebuffer object. It must be bound when rendering to the screen using OpenGL.</li> <li><code>TSdlProperty.WindowUIKitOpenGLRenderbuffer</code>: the OpenGL view's renderbuffer object. It must be bound when TSdlGL.SwapWindow is called.</li> <li><code>TSdlProperty.WindowUIKitOpenGLResolveFramebuffer</code>: the OpenGL view's resolve framebuffer, when MSAA is used.</li> </ul> <p>On macOS:</p> <ul> <li><code>TSdlProperty.WindowCocoaWindow</code>: The NSWindow handle associated with the window</li> <li><code>TSdlProperty.WindowCocoaMetalViewTag</code>: The NSInteger handle tag assocated with metal views on the window</li> </ul> <p>On Windows:</p> <ul> <li><code>TSdlProperty.WindowWin32Hwnd</code>: the HWND associated with the window</li> <li><code>TSdlProperty.WindowWin32Hdc</code>: the HDC associated with the window</li> <li><code>TSdlProperty.WindowWin32Instance</code>: the HINSTANCE associated with the window </li> </ul> <p><code>property Properties: TSdlProperties read GetProperties</code></p> <p>Type: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_20","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_24","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Resizable","title":"Resizable","text":"<p>The user-resizable state of the window.</p> <p>This will add or remove the window's <code>TSdlWindowFlag.Resizable</code> flag and allow/disallow user resizing of the window. This is a no-op if the window's resizable state already matches the requested state.</p> <p>You can't change the resizable state of a fullscreen window. </p> <p><code>property Resizable: Boolean read GetResizable write SetResizable</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_21","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_15","title":"See Also","text":"<ul> <li>Flags</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_25","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#SafeArea","title":"SafeArea","text":"<p>The safe area for this window.</p> <p>Some devices have portions of the screen which are partially obscured or not interactive, possibly due to on-screen controls, curved edges, camera notches, TV overscan, etc. This function provides the area of the window which is safe to have interactable content. You should continue rendering into the rest of the window, but it should not contain visually important or interactible content. </p> <p><code>property SafeArea: TSdlRect read GetSafeArea</code></p> <p>Type: <code>TSdlRect</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_22","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_26","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Shape","title":"Shape","text":"<p>The shape of the transparent window, or <code>nil</code> if the window has no shape (or to remove the shape).</p> <p>This sets the alpha channel of a transparent window and any fully transparent areas are also transparent to mouse clicks. If you are using something besides the SDL render API, then you are responsible for drawing the alpha channel of the window to match the shape alpha channel to get consistent cross-platform results.</p> <p>The shape is copied inside this function, so you can free it afterwards. If your shape surface changes, you should set this property again to update the window. This is an expensive operation, so should be done sparingly.</p> <p>The window must have been created with the TSdlWindowFlag.Transparent flag. </p> <p><code>property Shape: TSdlSurface read GetShape write SetShape</code></p> <p>Type: <code>TSdlSurface</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_23","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_27","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Size","title":"Size","text":"<p>The size of the window. See SetSize and GetSize for more information. </p> <p><code>property Size: TSdlPoint read GetSizePoint write SetSizePoint</code></p> <p>Type: <code>TSdlPoint</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_24","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_28","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#SizeInPixels","title":"SizeInPixels","text":"<p>The size of the window in pixels. See GetSizeInPixels for more information. </p> <p><code>property SizeInPixels: TSdlPoint read GetSizeInPixelsPoint</code></p> <p>Type: <code>TSdlPoint</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_25","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_29","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Surface","title":"Surface","text":"<p>The SDL surface associated with the window.</p> <p>A new surface will be created with the optimal format for the window, if necessary. This surface will be freed when the window is destroyed. Do not free this surface.</p> <p>This surface will be invalidated if the window is resized. After resizing a window this function must be called again to return a valid surface.</p> <p>You may not combine this with 3D or the rendering API on this window.</p> <p>This function is affected by <code>TSdlHints.FramebufferAcceleration</code>. </p> <p><code>property Surface: TSdlSurface read GetSurface</code></p> <p>Type: <code>TSdlSurface</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_26","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_16","title":"See Also","text":"<ul> <li>FreeSurface</li> <li>HasSurface</li> <li>UpdateSurface</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_30","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#SurfaceVSync","title":"SurfaceVSync","text":"<p>The VSync for the window surface.</p> <p>When a window surface is created, vsync defaults to TSdlWindowSurfaceVsync.Disabled.</p> <p>The property can be 1 to synchronize present with every vertical refresh, 2 to synchronize present with every second vertical refresh, etc., TSdlWindowSurfaceVsync.Adaptive for late swap tearing (adaptive vsync), or TSdlWindowSurfaceVsync.Disabled to disable. Not every value is supported by every driver, so you should check the return value to see whether the requested setting is supported. </p> <p><code>property SurfaceVSync: TSdlWindowSurfaceVsync read GetSurfaceVSync write SetSurfaceVSync</code></p> <p>Type: <code>TSdlWindowSurfaceVsync</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_27","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_31","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#TextInputActive","title":"TextInputActive","text":"<p>Whether or not Unicode text input events are enabled for the window. </p> <p><code>property TextInputActive: Boolean read GetTextInputActive</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_17","title":"See Also","text":"<ul> <li>StartTextInput</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_32","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Title","title":"Title","text":"<p>The title of the window. </p> <p><code>property Title: String read GetTitle write SetTitle</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_28","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_33","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Windows","title":"Windows","text":"<p>A list of valid windows. </p> <p><code>class property Windows: TArray&lt;TSdlWindow&gt; read GetWindows</code></p> <p>Type: <code>TArray&lt;TSdlWindow&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_34","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#WithKeyboardFocus","title":"WithKeyboardFocus","text":"<p>The window which currently has keyboard focus. </p> <p><code>class property WithKeyboardFocus: TSdlWindow read GetWithKeyboardFocus</code></p> <p>Type: <code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_35","title":"Remarks","text":"<p>This property should only be used on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#constructor-descriptions","title":"Constructor Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Create_0","title":"<code>Create</code>","text":"<p>Create a window with the specified properties.</p> <p>These are the supported properties:</p> <ul> <li><code>TSdlProperty.WindowCreateAlwaysOnTop</code>: True if the window should be always on top</li> <li><code>TSdlProperty.WindowCreateBorderless</code>: True if the window has no window decoration</li> <li><code>TSdlProperty.WindowCreateExternalGraphicsContext</code>: True if the window will be used with an externally managed graphics context.</li> <li><code>TSdlProperty.WindowCreateFocusable</code>: True if the window should accept keyboard input (defaults true)</li> <li><code>TSdlProperty.WindowCreateFullscreen</code>: True if the window should start in fullscreen mode at desktop resolution</li> <li><code>TSdlProperty.WindowCreateHeight</code>: The height of the window</li> <li><code>TSdlProperty.WindowCreateHidden</code>: True if the window should start hidden</li> <li><code>TSdlProperty.WindowCreateHighPixelDensity</code>: True if the window uses a high pixel density buffer if possible</li> <li><code>TSdlProperty.WindowCreateMaximized</code>: True if the window should start maximized</li> <li><code>TSdlProperty.WindowCreateMenu</code>: True if the window is a popup menu</li> <li>`TSdlProperty.WindowCreateMetal': True if the window will be used with Metal rendering</li> <li><code>TSdlProperty.WindowCreateMinimized</code>: True if the window should start minimized</li> <li><code>TSdlProperty.WindowCreateModal</code>: True if the window is modal to its parent</li> <li><code>TSdlProperty.WindowCreateMouseGrabbed</code>: True if the window starts with grabbed mouse focus</li> <li><code>TSdlProperty.WindowCreateOpenGL</code>: True if the window will be used with OpenGL rendering</li> <li><code>TSdlProperty.WindowCreateParent</code>: A TSdlWindow that will be the parent of this window, required for windows with the \"tooltip\", \"menu\", and \"modal\" properties</li> <li><code>TSdlProperty.WindowCreateResizable</code>: True if the window should be resizable</li> <li><code>TSdlProperty.WindowCreateTitle</code>: The title of the window</li> <li><code>TSdlProperty.WindowCreateTransparent</code>: True if the window show transparent in the areas with alpha of 0</li> <li><code>TSdlProperty.WindowCreateTooltip</code>: True if the window is a tooltip</li> <li><code>TSdlProperty.WindowCreateUtility</code>: True if the window is a utility window, not showing in the task bar and window list</li> <li><code>TSdlProperty.WindowCreateVulkan</code>: True if the window will be used with Vulkan rendering</li> <li><code>TSdlProperty.WindowCreateWidth</code>: the width of the window</li> <li><code>TSdlProperty.WindowCreateX</code>: The X position of the window, or TSdlWindowPos.Centered. Defaults to TSdlWindowPos.Undefined. This is relative to the parent for windows with the \"tooltip\" or \"menu\" property set.</li> <li><code>TSdlProperty.WindowCreateY</code>: The Y position of the window, or TSdlWindowPos.Centered. Defaults to TSdlWindowPos.Undefined. This is relative to the parent for windows with the \"tooltip\" or \"menu\" property set.</li> </ul> <p>These are additional supported properties on macOS:</p> <ul> <li><code>TSdlProperty.WindowCreateCocoaWindow</code>: The NSWindow handle associated with the window, if you want to wrap an existing window.</li> <li><code>TSdlProperty.WindowCreateCocoaView</code>: The NSView handle associated with the window, defaults to <code>[window contentView]</code></li> </ul> <p>These are additional supported properties on Windows:</p> <ul> <li><code>TSdlProperty.WindowCreateWin32Hwnd</code>: the HWND associated with the window, if you want to wrap an existing window.</li> <li><code>TSdlProperty.WindowCreateWin32PixelFormatHwnd</code>: optional, another window to share pixel format with, useful for OpenGL windows</li> </ul> <p>The window is implicitly shown if the \"hidden\" property is not set.</p> <p>Windows with the \"tooltip\" and \"menu\" properties are popup windows and have the behaviors and guidelines outlined in the constructor that creates a popup window.</p> <p>If this window is being created to be used with an TSdlRenderer, you should not add a graphics API specific property (<code>TSdlProperty.WindowCreateOpenGL</code>, etc), as SDL will handle that internally when it chooses a renderer. However, SDL might need to recreate your window at that point, which may cause the window to appear briefly, and then flicker as it is recreated. The correct approach to this is to create the window with the <code>TSdlProperty.WindowCreateHidden</code> property set to True, then create the renderer, then show the window with Show. </p> <p><code>constructor Create(const AProperties: TSdlProperties); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters","title":"Parameters","text":"<p><code>AProperties</code>: <code>TSdlProperties</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_29","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_18","title":"See Also","text":"<ul> <li>TSdlProperty</li> <li>TSdlProperties</li> <li>Free</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_36","title":"Remarks","text":"<p>This constructor should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Create_1","title":"<code>Create</code>","text":"<p>Create a child popup window of the specified parent window.</p> <p>The AFlags parameter must contain at least one of the following:</p> <ul> <li><code>TSdlWindowFlag.Tooltip</code>: The popup window is a tooltip and will not pass any input events.</li> <li><code>TSdlWindowFlag.PopupMenu</code>: The popup window is a popup menu. The topmost popup menu will implicitly gain the keyboard focus.</li> </ul> <p>The following flags are not relevant to popup window creation and will be ignored:</p> <ul> <li><code>TSdlWindowFlag.Minimized</code></li> <li><code>TSdlWindowFlag.Maximized</code></li> <li><code>TSdlWindowFlag.Fullscreen</code></li> <li><code>TSdlWindowFlag.Borderless</code></li> </ul> <p>The following flags are incompatible with popup window creation and will cause it to fail:</p> <ul> <li><code>TSdlWindowFlag.Utility</code></li> <li><code>TSdlWindowFlag.Modal</code></li> </ul> <p>The parent parameter must be non-null and a valid window. The parent of a popup window can be either a regular, toplevel window, or another popup window.</p> <p>Popup windows cannot be minimized, maximized, made fullscreen, raised, flash, be made a modal window, be the parent of a toplevel window, or grab the mouse and/or keyboard. Attempts to do so will fail.</p> <p>Popup windows implicitly do not have a border/decorations and do not appear on the taskbar/dock or in lists of windows such as alt-tab menus.</p> <p>If a parent window is hidden or destroyed, any child popup windows will be recursively hidden or destroyed as well. Child popup windows not explicitly hidden will be restored when the parent is shown. </p> <p><code>constructor Create(const AParent: TSdlWindow; const AOffsetX, AOffsetY, AW, AH: Integer; const AFlags: TSdlWindowFlags); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_1","title":"Parameters","text":"<p><code>AParent</code>: <code>TSdlWindow</code> : The parent of the window.</p> <p><code>AOffsetX</code>: <code>Integer</code> : The X position of the popup window relative to the origin of the parent.</p> <p><code>AOffsetY</code>: <code>Integer</code> : The Y position of the popup window relative to the origin of the parent window.</p> <p><code>AW</code>: <code>Integer</code> : The width of the window.</p> <p><code>AH</code>: <code>Integer</code> : The height of the window.</p> <p><code>AFlags</code>: <code>TSdlWindowFlags</code> : TSdlWindowFlag.Tooltip or TSdlWindowFlag.PopupMenu, and zero or more additional flags.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_30","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_19","title":"See Also","text":"<ul> <li>Free</li> <li>Parent</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_37","title":"Remarks","text":"<p>This constructor should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Create_2","title":"<code>Create</code>","text":"<p>Create a window with the specified dimensions and flags.</p> <p>AFlags may be zero or more of the following:</p> <ul> <li><code>TSdlWindowFlag.Fullscreen</code>: fullscreen window at desktop resolution</li> <li><code>TSdlWindowFlag.OpenGL</code>: window usable with an OpenGL context</li> <li><code>TSdlWindowFlag.Occluded</code>: window partially or completely obscured by another window</li> <li><code>TSdlWindowFlag.Hidden</code>: window is not visible</li> <li><code>TSdlWindowFlag.Borderless</code>: no window decoration</li> <li><code>TSdlWindowFlag.Resizable</code>: window can be resized</li> <li><code>TSdlWindowFlag.Minimized</code>: window is minimized</li> <li><code>TSdlWindowFlag.Maximized</code>: window is maximized</li> <li><code>TSdlWindowFlag.MouseGrabbed</code>: window has grabbed mouse focus</li> <li><code>TSdlWindowFlag.InputFocus</code>: window has input focus</li> <li><code>TSdlWindowFlag.MouseFocus</code>: window has mouse focus</li> <li><code>TSdlWindowFlag.External</code>: window not created by SDL</li> <li><code>TSdlWindowFlag.Modal</code>: window is modal</li> <li><code>TSdlWindowFlag.HighPixelDensity</code>: window uses high pixel density back buffer if possible</li> <li><code>TSdlWindowFlag.MouseCapture</code>: window has mouse captured (unrelated to MouseGrabbed)</li> <li><code>TSdlWindowFlag.AlwaysOnTop</code>: window should always be above others</li> <li><code>TSdlWindowFlag.Utility</code>: window should be treated as a utility window, not showing in the task bar and window list</li> <li><code>TSdlWindowFlag.Tooltip</code>: window should be treated as a tooltip and does not get mouse or keyboard focus, requires a parent window</li> <li><code>TSdlWindowFlag.PopupMenu</code>: window should be treated as a popup menu, requires a parent window</li> <li><code>TSdlWindowFlag.KeyboardGrabbed</code>: window has grabbed keyboard input</li> <li><code>TSdlWindowFlag.Vulkan</code>: window usable with a Vulkan instance</li> <li><code>TSdlWindowFlag.Metal</code>: window usable with a Metal instance</li> <li><code>TSdlWindowFlag.Transparent</code>: window with transparent buffer</li> <li><code>TSdlWindowFlag.NotFocusable</code>: window should not be focusable</li> </ul> <p>The window is implicitly shown if TSdlWindowFlag.Hidden is not set.</p> <p>On Apple's macOS, you must set the NSHighResolutionCapable Info.plist property to YES, otherwise you will not receive a High-DPI OpenGL canvas.</p> <p>The window pixel size may differ from its window coordinate size if the window is on a high pixel density display. Use Size to query the client area's size in window coordinates, and SizeInPixels or TSdlRenderer.OutputSize to query the drawable size in pixels. Note that the drawable size can vary after the window is created and should be queried again if you get an TSdlEventKind.WindowPixelSizeChanged event.</p> <p>If the window is created with any of the TSdlWindowFlag.OpenGL or TSdlWindowFlag.Vulkan flags, then the corresponding LoadLibrary function is called and the corresponding UnloadLibrary function is called when the window is destroyed.</p> <p>If TSdlWindowFlag.Vulkan is specified and there isn't a working Vulkan driver, then this constructor will fail.</p> <p>If TSdlWindowFlag.Metal is specified on an OS that does not support Metal, then this constructor will fail.</p> <p>If you intend to use this window with a TSdlRenderer, then you should use TSdlRenderer constructor that also creates a window, to avoid window flicker.</p> <p>On non-Apple devices, SDL requires you to either not link to the Vulkan loader or link to a dynamic library version. This limitation may be removed in a future version of SDL. </p> <p><code>constructor Create(const ATitle: String; const AW, AH: Integer; const AFlags: TSdlWindowFlags); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_2","title":"Parameters","text":"<p><code>ATitle</code>: <code>String</code> : The title of the window.</p> <p><code>AW</code>: <code>Integer</code> : The width of the window.</p> <p><code>AH</code>: <code>Integer</code> : The height of the window.</p> <p><code>AFlags</code>: <code>TSdlWindowFlags</code> : Zero or more TSdlWindowFlag's.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_31","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_20","title":"See Also","text":"<ul> <li>Free</li> <li>TSdlRenderer</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_38","title":"Remarks","text":"<p>This constructor should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Destroy","title":"<code>Destroy</code>","text":"<p><code>class destructor Destroy</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#operator-descriptions","title":"Operator Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Equal","title":"Equal(TSdlWindow, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator Equal(const ALeft: TSdlWindow; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_3","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlWindow</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#returns","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Implicit","title":"Implicit(Pointer)","text":"<p>Used to set the value to <code>nil</code>. </p> <p><code>class operator Implicit(const AValue: Pointer): TSdlWindow; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_4","title":"Parameters","text":"<p><code>AValue</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#returns_1","title":"Returns","text":"<p><code>TSdlWindow</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#NotEqual","title":"NotEqual(TSdlWindow, Pointer)","text":"<p>Used to compare against <code>nil</code>. </p> <p><code>class operator NotEqual(const ALeft: TSdlWindow; const ARight: Pointer): Boolean; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_5","title":"Parameters","text":"<p><code>ALeft</code>: <code>TSdlWindow</code></p> <p><code>ARight</code>: <code>Pointer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#returns_2","title":"Returns","text":"<p><code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#ClearComposition","title":"ClearComposition","text":"<p>Dismiss the composition window/IME without disabling the subsystem. </p> <p><code>procedure ClearComposition; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_32","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_21","title":"See Also","text":"<ul> <li>StartTextInput</li> <li>StopTextInput</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_39","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#ClearTextInputArea","title":"ClearTextInputArea(Integer)","text":"<p>Clear the area used to type Unicode text input.</p> <p>Native input methods may place a window with word suggestions near the cursor, without covering the text being entered. </p> <p><code>procedure ClearTextInputArea(const ACursor: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_33","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_6","title":"Parameters","text":"<p><code>ACursor</code>: <code>Integer</code> : The offset of the current cursor location relative to left position of the window, in window coordinates.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_22","title":"See Also","text":"<ul> <li>GetTextInputArea</li> <li>SetTextInputArea</li> <li>StartTextInput</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_40","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Flash","title":"Flash(TSdlFlashOperation)","text":"<p>Request a window to demand attention from the user. </p> <p><code>procedure Flash(const AOperation: TSdlFlashOperation); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_34","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_7","title":"Parameters","text":"<p><code>AOperation</code>: <code>TSdlFlashOperation</code> : The operation to perform.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_41","title":"Remarks","text":"<p>This function should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Free","title":"Free","text":"<p>Frees the window.</p> <p>Any child windows owned by the window will be recursively destroyed as well.</p> <p>Note that on some platforms, the visible window may not actually be removed from the screen until the SDL event loop is pumped again, even though the window is no longer valid after this call. </p> <p><code>procedure Free; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_42","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#FreeSurface","title":"FreeSurface","text":"<p>Destroy the surface associated with the window. </p> <p><code>procedure FreeSurface; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_35","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_23","title":"See Also","text":"<ul> <li>Surface</li> <li>HasSurface</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_43","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#FromID","title":"FromID(TSdlWindowID)","text":"<p>Get a window from a stored ID.</p> <p>The numeric ID is what TSdlWindowEvent references, and is necessary to map these events to specific TSdlWindow objects. </p> <p><code>class function FromID(const AId: TSdlWindowID): TSdlWindow; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_36","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure or if the window does not exist.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_8","title":"Parameters","text":"<p><code>AId</code>: <code>TSdlWindowID</code> : The ID of the window.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#returns_3","title":"Returns","text":"<p><code>TSdlWindow</code>: The window associated with <code>AId</code>.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_24","title":"See Also","text":"<ul> <li>ID</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_44","title":"Remarks","text":"<p>This function should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#GetAspectRatio","title":"GetAspectRatio(Single, Single)","text":"<p>Get the aspect ratio of the window's client area. </p> <p><code>procedure GetAspectRatio(out AMinAspect, AMaxAspect: Single); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_37","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_9","title":"Parameters","text":"<p><code>AMinAspect</code>: <code>Single</code> : Is set to the minimum aspect ratio of the window.</p> <p><code>AMaxAspect</code>: <code>Single</code> : Is set to the maximum aspect ratio of the window.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_25","title":"See Also","text":"<ul> <li>SetAspectRatio</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_45","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#GetBordersSize","title":"GetBordersSize(Integer, Integer, Integer, Integer)","text":"<p>Get the size of the window's borders (decorations) around the client area.</p> <p>Note: This method may fail on systems where the window has not yet been decorated by the display server (for example, immediately after calling Create). It is recommended that you wait at least until the window has been presented and composited, so that the window system has a chance to decorate the window and provide the border dimensions to SDL. </p> <p><code>procedure GetBordersSize(out ATop, ALeft, ABottom, ARight: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_38","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_10","title":"Parameters","text":"<p><code>ATop</code>: <code>Integer</code> : Set to the size of the top border.</p> <p><code>ALeft</code>: <code>Integer</code> : Set to size of the left border.</p> <p><code>ABottom</code>: <code>Integer</code> : Set to size of the bottom border.</p> <p><code>ARight</code>: <code>Integer</code> : Set to size of the right border.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_26","title":"See Also","text":"<ul> <li>GetSize</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_46","title":"Remarks","text":"<p>This function should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#GetMaximumSize","title":"GetMaximumSize(Integer, Integer)","text":"<p>Get the maximum size of the window's client area. </p> <p><code>procedure GetMaximumSize(out AMaxW, AMaxH: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_39","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_11","title":"Parameters","text":"<p><code>AMaxW</code>: <code>Integer</code></p> <p><code>AMaxH</code>: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_27","title":"See Also","text":"<ul> <li>GetMinimumSize</li> <li>SetMaximumSize</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_47","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#GetMinimumSize","title":"GetMinimumSize(Integer, Integer)","text":"<p>Get the minimum size of the window's client area. </p> <p><code>procedure GetMinimumSize(out AMinW, AMinH: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_40","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_12","title":"Parameters","text":"<p><code>AMinW</code>: <code>Integer</code> : Is set to the minimum width of the window.</p> <p><code>AMinH</code>: <code>Integer</code> : Is set to the minimum height of the window.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_28","title":"See Also","text":"<ul> <li>GetMaximumSize</li> <li>SetMinimumSize</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_48","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#GetPosition","title":"GetPosition(TSdlWindowPos, TSdlWindowPos)","text":"<p>Get the position of the window.</p> <p>This is the current position of the window as last reported by the windowing system. </p> <p><code>procedure GetPosition(out AX, AY: TSdlWindowPos); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_41","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_13","title":"Parameters","text":"<p><code>AX</code>: <code>TSdlWindowPos</code> : Set to the X position of the window.</p> <p><code>AY</code>: <code>TSdlWindowPos</code> : Set to the Y position of the window.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_29","title":"See Also","text":"<ul> <li>SetPosition</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_49","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#GetSize","title":"GetSize(Integer, Integer)","text":"<p>Get the size of the window's client area.</p> <p>The window pixel size may differ from its window coordinate size if the window is on a high pixel density display. Use GetSizeInPixels or TSdlRenderer.OutputSize to get the real client area size in pixels. </p> <p><code>procedure GetSize(out AW, AH: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_42","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_14","title":"Parameters","text":"<p><code>AW</code>: <code>Integer</code> : Is set to the width of the window.</p> <p><code>AH</code>: <code>Integer</code> : a pointer filled in with the height of the window, may be NULL.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_30","title":"See Also","text":"<ul> <li>TSdlRenderer.OutputSize</li> <li>GetSizeInPixels</li> <li>SetSize</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_50","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#GetSizeInPixels","title":"GetSizeInPixels(Integer, Integer)","text":"<p>Get the size of the window's client area, in pixels. </p> <p><code>procedure GetSizeInPixels(out AW, AH: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_43","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_15","title":"Parameters","text":"<p><code>AW</code>: <code>Integer</code> : Is set to the width in pixels.</p> <p><code>AH</code>: <code>Integer</code> : Is set to the height in pixels.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_31","title":"See Also","text":"<ul> <li>Create</li> <li>GetSize</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_51","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#GetTextInputArea","title":"GetTextInputArea(TSdlRect, Integer)","text":"<p>Get the area used to type Unicode text input.</p> <p>This returns the values previously set by SetTextInputArea. </p> <p><code>procedure GetTextInputArea(out ARect: TSdlRect; out ACursor: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_44","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_16","title":"Parameters","text":"<p><code>ARect</code>: <code>TSdlRect</code> : Is set to the text input area.</p> <p><code>ACursor</code>: <code>Integer</code> : Is set to the current cursor location relative to <code>ARect.X</code>.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_32","title":"See Also","text":"<ul> <li>SetTextInputArea</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_52","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Hide","title":"Hide","text":"<p>Hide the window. </p> <p><code>procedure Hide; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_45","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_33","title":"See Also","text":"<ul> <li>Show</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_53","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Maximize","title":"Maximize","text":"<p>Request that the window be made as large as possible.</p> <p>Non-resizable windows can't be maximized. The window must have the TSdlWindowFlag.Resizable flag set, or this will have no effect.</p> <p>On some windowing systems this request is asynchronous and the new window state may not have have been applied immediately upon the return of this function. If an immediate change is required, call Sync to block until the changes have taken effect.</p> <p>When the window state changes, an TSdlEventKind.WindowMaximized event will be emitted. Note that, as this is just a request, the windowing system can deny the state change.</p> <p>When maximizing a window, whether the constraints set via SetMaximumSize are honored depends on the policy of the window manager. Win32 and macOS enforce the constraints when maximizing. </p> <p><code>procedure Maximize; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_46","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_34","title":"See Also","text":"<ul> <li>Minimize</li> <li>Restore</li> <li>Sync</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_54","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Minimize","title":"Minimize","text":"<p>Request that the window be minimized to an iconic representation.</p> <p>If the window is in a fullscreen state, this request has no direct effect. It may alter the state the window is returned to when leaving fullscreen.</p> <p>On some windowing systems this request is asynchronous and the new window state may not have been applied immediately upon the return of this function. If an immediate change is required, call Sync to block until the changes have taken effect.</p> <p>When the window state changes, an TSdlEventKind.WindowMinimized event will be emitted. Note that, as this is just a request, the windowing system can deny the state change. </p> <p><code>procedure Minimize; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_47","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_35","title":"See Also","text":"<ul> <li>Maximize</li> <li>Restore</li> <li>Sync</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_55","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#RaiseAndFocus","title":"RaiseAndFocus","text":"<p>Request that a window be raised above other windows and gain the input focus.</p> <p>The result of this request is subject to desktop window manager policy, particularly if raising the requested window would result in stealing focus from another application. If the window is successfully raised and gains input focus, an TSdlEventKind.WindowFocusGained event will be emitted, and the window will have the TSdlWindowFlag.InputFocus flag set. </p> <p><code>procedure RaiseAndFocus; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_48","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_56","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Restore","title":"Restore","text":"<p>Request that the size and position of a minimized or maximized window be restored.</p> <p>If the window is in a fullscreen state, this request has no direct effect. It may alter the state the window is returned to when leaving fullscreen.</p> <p>On some windowing systems this request is asynchronous and the new window state may not have have been applied immediately upon the return of this function. If an immediate change is required, call Sync to block until the changes have taken effect.</p> <p>When the window state changes, an TSdlEventKind.WindowRestored event will be emitted. Note that, as this is just a request, the windowing system can deny the state change. </p> <p><code>procedure Restore; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_49","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_36","title":"See Also","text":"<ul> <li>Maximize</li> <li>Minimize</li> <li>Sync</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_57","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#SetAspectRatio","title":"SetAspectRatio(Single, Single)","text":"<p>Request that the aspect ratio of a window's client area be set.</p> <p>The aspect ratio is the ratio of width divided by height, e.g. 2560x1600 would be 1.6. Larger aspect ratios are wider and smaller aspect ratios are narrower.</p> <p>If, at the time of this request, the window in a fixed-size state, such as maximized or fullscreen, the request will be deferred until the window exits this state and becomes resizable again.</p> <p>On some windowing systems, this request is asynchronous and the new window aspect ratio may not have have been applied immediately upon the return of this function. If an immediate change is required, call Sync to block until the changes have taken effect.</p> <p>When the window size changes, an TSdlEventKind.WindowResized event will be emitted with the new window dimensions. Note that the new dimensions may not match the exact aspect ratio requested, as some windowing systems can restrict the window size in certain scenarios (e.g. constraining the size of the content area to remain within the usable desktop bounds). Additionally, as this is just a request, it can be denied by the windowing system. </p> <p><code>procedure SetAspectRatio(const AMinAspect, AMaxAspect: Single); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_50","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_17","title":"Parameters","text":"<p><code>AMinAspect</code>: <code>Single</code> : The minimum aspect ratio of the window, or 0.0 for no limit.</p> <p><code>AMaxAspect</code>: <code>Single</code> : The maximum aspect ratio of the window, or 0.0 for no limit.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_37","title":"See Also","text":"<ul> <li>GetAspectRatio</li> <li>Sync</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_58","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#SetHitTestCallback","title":"SetHitTestCallback(TSdlHitTestCallback)","text":"<p>Provide a callback that decides if a window region has special properties.</p> <p>Normally windows are dragged and resized by decorations provided by the system window manager (a title bar, borders, etc), but for some apps, it makes sense to drag them from somewhere else inside the window itself; for example, one might have a borderless window that wants to be draggable from any part, or simulate its own title bar, etc.</p> <p>This function lets the app provide a callback that designates pieces of a given window as special. This callback is run during event processing if we need to tell the OS to treat a region of the window specially; the use of this callback is known as \"hit testing.\"</p> <p>Mouse input may not be delivered to your application if it is within a special area; the OS will often apply that input to moving the window or resizing the window and not deliver it to the application.</p> <p>Specifying <code>nil</code> for a callback disables hit-testing. Hit-testing is disabled by default.</p> <p>Platforms that don't support this functionality will return False unconditionally, even if you're attempting to disable hit-testing.</p> <p>Your callback may fire at any time, and its firing does not indicate any specific behavior (for example, on Windows, this certainly might fire when the OS is deciding whether to drag your window, but it fires for lots of other reasons, too, some unrelated to anything you probably care about and when the mouse isn't actually at the location it is testing). Since this can fire at any time, you should try to keep your callback efficient, devoid of allocations, etc. </p> <p><code>function SetHitTestCallback(const ACallback: TSdlHitTestCallback): Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_18","title":"Parameters","text":"<p><code>ACallback</code>: <code>TSdlHitTestCallback</code> : The function to call when doing a hit-test.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#returns_4","title":"Returns","text":"<p><code>Boolean</code>: True on success or False on failure (eg. when the platform does not support hit-testing.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_59","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#SetMaximumSize","title":"SetMaximumSize(Integer, Integer)","text":"<p>Set the maximum size of the window's client area. </p> <p><code>procedure SetMaximumSize(const AMaxW, AMaxH: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_51","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_19","title":"Parameters","text":"<p><code>AMaxW</code>: <code>Integer</code> : The maximum width of the window, or 0 for no limit.</p> <p><code>AMaxH</code>: <code>Integer</code> : The maximum height of the window, or 0 for no limit.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_38","title":"See Also","text":"<ul> <li>GetMaximumSize</li> <li>SetMinimumSize</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_60","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#SetMinimumSize","title":"SetMinimumSize(Integer, Integer)","text":"<p>Set the minimum size of the window's client area. </p> <p><code>procedure SetMinimumSize(const AMinW, AMinH: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_52","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_20","title":"Parameters","text":"<p><code>AMinW</code>: <code>Integer</code> : The minimum width of the window, or 0 for no limit.</p> <p><code>AMinH</code>: <code>Integer</code> : The minimum height of the window, or 0 for no limit.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_39","title":"See Also","text":"<ul> <li>GetMinimumSize</li> <li>SetMaximumSize</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_61","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#SetPosition","title":"SetPosition(TSdlWindowPos, TSdlWindowPos)","text":"<p>Request that the window's position be set.</p> <p>If the window is in an exclusive fullscreen or maximized state, this request has no effect.</p> <p>This can be used to reposition fullscreen-desktop windows onto a different display, however, as exclusive fullscreen windows are locked to a specific display, they can only be repositioned programmatically via FullscreenMode.</p> <p>On some windowing systems this request is asynchronous and the new coordinates may not have have been applied immediately upon the return of this function. If an immediate change is required, call Sync to block until the changes have taken effect.</p> <p>When the window position changes, an TSdlEventKind.WindowMoved event will be emitted with the window's new coordinates. Note that the new coordinates may not match the exact coordinates requested, as some windowing systems can restrict the position of the window in certain scenarios (e.g. constraining the position so the window is always within desktop bounds). Additionally, as this is just a request, it can be denied by the windowing system. </p> <p><code>procedure SetPosition(const AX, AY: TSdlWindowPos); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_21","title":"Parameters","text":"<p><code>AX</code>: <code>TSdlWindowPos</code> : The X coordinate of the window, or <code>TSdlWindowPos.Centered</code> The Y coordinate of the window, or <code>TSdlWindowPos.Centered</code> Raised on failure.This method should only be called on the main thread. </p> <p><code>AY</code>: <code>TSdlWindowPos</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#SetSize","title":"SetSize(Integer, Integer)","text":"<p>Request that the size of a window's client area be set.</p> <p>If the window is in a fullscreen or maximized state, this request has no effect.</p> <p>To change the exclusive fullscreen mode of a window, use FullscreenMode.</p> <p>On some windowing systems, this request is asynchronous and the new window size may not have have been applied immediately upon the return of this function. If an immediate change is required, call Sync to block until the changes have taken effect.</p> <p>When the window size changes, an TSdlEventKind.WindowResized event will be emitted with the new window dimensions. Note that the new dimensions may not match the exact size requested, as some windowing systems can restrict the window size in certain scenarios (e.g. constraining the size of the content area to remain within the usable desktop bounds). Additionally, as this is just a request, it can be denied by the windowing system. </p> <p><code>function SetSize(const AW, AH: Integer): Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_22","title":"Parameters","text":"<p><code>AW</code>: <code>Integer</code> : The width of the window, must be &gt; 0.</p> <p><code>AH</code>: <code>Integer</code> : The height of the window, must be &gt; 0.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#returns_5","title":"Returns","text":"<p><code>Boolean</code>: True on success, False on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_40","title":"See Also","text":"<ul> <li>GetSize</li> <li>FullscreenMode</li> <li>Sync</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_62","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#SetTextInputArea","title":"SetTextInputArea(TSdlRect, Integer)","text":"<p>Set the area used to type Unicode text input.</p> <p>Native input methods may place a window with word suggestions near the cursor, without covering the text being entered. </p> <p><code>procedure SetTextInputArea(const ARect: TSdlRect; const ACursor: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_53","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_23","title":"Parameters","text":"<p><code>ARect</code>: <code>TSdlRect</code> : The text input area, in window coordinates.</p> <p><code>ACursor</code>: <code>Integer</code> : The offset of the current cursor location relative to <code>ARect.X</code>, in window coordinates.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_41","title":"See Also","text":"<ul> <li>GetTextInputArea</li> <li>ClearTextInputArea</li> <li>StartTextInput</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_63","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Show","title":"Show","text":"<p>Show the window. </p> <p><code>procedure Show; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_54","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_42","title":"See Also","text":"<ul> <li>Hide</li> <li>RaiseAndFocus</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_64","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#ShowSystemMenu","title":"ShowSystemMenu(Integer, Integer)","text":"<p>Display the system-level window menu.</p> <p>This default window menu is provided by the system and on some platforms provides functionality for setting or changing privileged state on the window, such as moving it between workspaces or displays, or toggling the always-on-top property.</p> <p>On platforms or desktops where this is unsupported, this function does nothing. </p> <p><code>procedure ShowSystemMenu(const AX, AY: Integer); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_55","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_24","title":"Parameters","text":"<p><code>AX</code>: <code>Integer</code> : The X coordinate of the menu, relative to the origin (top-left) of the client area.</p> <p><code>AY</code>: <code>Integer</code> : The Y coordinate of the menu, relative to the origin (top-left) of the client area.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_65","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#StartTextInput_0","title":"StartTextInput(TSdlProperties)","text":"<p>Start accepting Unicode text input events in the window, with properties describing the input.</p> <p>This function will enable text input (TSdlEventKind.TextInput and TSdlEventKind.TextEditing events) in this window. Please use this function paired with StopTextInput.</p> <p>Text input events are not received by default.</p> <p>On some platforms using this function shows the screen keyboard and/or activates an IME, which can prevent some key press events from being passed through.</p> <p>These are the supported properties:</p> <ul> <li><code>TSdlProperty.TextInputType</code> - a TSdlTextInputType value that describes text being input, defaults to TSdlTextInputType.Text.</li> <li><code>TSdlProperty.TextInputCapitalization</code> - a TSdlCapitalization value that describes how text should be capitalized, defaults to TSdlCapitalization.Sentences for normal text entry, TSdlCapitalization.Word for TSdlTextInputTYpe.TextName, and TSdlCapitalization.None for e-mail addresses, usernames, and passwords.</li> <li><code>TSdlProperty.TextInputAutoCorrect</code> - True to enable auto completion and auto correction, defaults to True.</li> <li><code>TSdlProperty.TextInputMultiLine</code> - True if multiple lines of text are allowed. This defaults to True if TSdlHints.ReturnKeyHidesIme is '0' or is not set, and defaults to False if TSdlHints.ReturnKeyHidesIme is '1'.</li> </ul> <p>On Android you can directly specify the input type:</p> <ul> <li><code>TSdlProperty.TextInputAndroidInputType</code> - the text input type to use, overriding other properties. This is documented at  InputType. </li> </ul> <p><code>procedure StartTextInput(const AProps: TSdlProperties); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_56","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_25","title":"Parameters","text":"<p><code>AProps</code>: <code>TSdlProperties</code> : The properties to use.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_43","title":"See Also","text":"<ul> <li>SetTextInputArea</li> <li>StopTextInput</li> <li>TextInputActive</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_66","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#StartTextInput_1","title":"StartTextInput","text":"<p>Start accepting Unicode text input events in the window.</p> <p>This function will enable text input (TSdlEventKind.TextInput and TSdlEventKind.TextEditing events) in this window. Please use this function paired with StopTextInput.</p> <p>Text input events are not received by default.</p> <p>On some platforms using this method shows the screen keyboard and/or activates an IME, which can prevent some key press events from being passed through. </p> <p><code>procedure StartTextInput; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_57","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_44","title":"See Also","text":"<ul> <li>SetTextInputArea</li> <li>StopTextInput</li> <li>TextInputActive</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_67","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#StopTextInput","title":"StopTextInput","text":"<p>Stop receiving any text input events in the window.</p> <p>If StartTextInput showed the screen keyboard, this function will hide it. </p> <p><code>procedure StopTextInput</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_58","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_45","title":"See Also","text":"<ul> <li>StartTextInput</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_68","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#Sync","title":"Sync","text":"<p>Block until any pending window state is finalized.</p> <p>On asynchronous windowing systems, this acts as a synchronization barrier for pending window state. It will attempt to wait until any pending window state has been applied and is guaranteed to return within finite time. Note that for how long it can potentially block depends on the underlying window system, as window state changes may involve somewhat lengthy animations that must complete before the window is in its final requested state.</p> <p>On windowing systems where changes are immediate, this does nothing. </p> <p><code>function Sync: Boolean; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#returns_6","title":"Returns","text":"<p><code>Boolean</code>: True on success or False if the operation timed out before the window was in the requested state.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_46","title":"See Also","text":"<ul> <li>SetSize</li> <li>SetPosition</li> <li>Fullscreen</li> <li>Minimize</li> <li>Maximize</li> <li>Restore</li> <li>TSdlHints.VideoSyncWindowOperations</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_69","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#UpdateSurface_0","title":"UpdateSurface(TSdlRect[])","text":"<p>Copy areas of the window surface to the screen.</p> <p>This is the function you use to reflect changes to portions of the surface on the screen.</p> <p>Note that this function will update at least the rectangles specified, but this is only intended as an optimization; in practice, this might update more of the screen (or all of the screen!), depending on what method SDL uses to send pixels to the system. </p> <p><code>procedure UpdateSurface(const ARects: array of TSdlRect); overload</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_59","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_26","title":"Parameters","text":"<p><code>ARects</code>: <code>array of TSdlRect</code> : An array of TSdlRect records representing areas of the surface to copy, in pixels.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_47","title":"See Also","text":"<ul> <li>Surface</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_70","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#UpdateSurface_1","title":"UpdateSurface(TArray&lt;TSdlRect&gt;)","text":"<p>Copy areas of the window surface to the screen.</p> <p>This is the function you use to reflect changes to portions of the surface on the screen.</p> <p>Note that this function will update at least the rectangles specified, but this is only intended as an optimization; in practice, this might update more of the screen (or all of the screen!), depending on what method SDL uses to send pixels to the system. </p> <p><code>procedure UpdateSurface(const ARects: TArray&lt;TSdlRect&gt;); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_60","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_27","title":"Parameters","text":"<p><code>ARects</code>: <code>TArray&lt;TSdlRect&gt;</code> : An array of TSdlRect records representing areas of the surface to copy, in pixels.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_48","title":"See Also","text":"<ul> <li>Surface</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_71","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#UpdateSurface_2","title":"UpdateSurface","text":"<p>Copy the window surface to the screen.</p> <p>This is the function you use to reflect any changes to the surface on the screen. </p> <p><code>procedure UpdateSurface; overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#exceptions_61","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_49","title":"See Also","text":"<ul> <li>Surface</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_72","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#WarpMouse_0","title":"WarpMouse(TSdlPointF)","text":"<p>Move the mouse cursor to the given position within the window.</p> <p>This method generates a mouse motion event if relative mode is not enabled. If relative mode is enabled, you can force mouse events for the warp by setting the TSdlHints.MouseRelativeWarpMotion hint.</p> <p>Note that this function will appear to succeed, but not actually move the mouse when used over Microsoft Remote Desktop. </p> <p><code>procedure WarpMouse(const APosition: TSdlPointF); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_28","title":"Parameters","text":"<p><code>APosition</code>: <code>TSdlPointF</code> : The coordinate within the window.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_50","title":"See Also","text":"<ul> <li>TSdlMouse.WarpGlobal</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_73","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#WarpMouse_1","title":"WarpMouse(Single, Single)","text":"<p>Move the mouse cursor to the given position within the window.</p> <p>This method generates a mouse motion event if relative mode is not enabled. If relative mode is enabled, you can force mouse events for the warp by setting the TSdlHints.MouseRelativeWarpMotion hint.</p> <p>Note that this function will appear to succeed, but not actually move the mouse when used over Microsoft Remote Desktop. </p> <p><code>procedure WarpMouse(const AX, AY: Single); overload; inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#parameters_29","title":"Parameters","text":"<p><code>AX</code>: <code>Single</code> : The X coordinate within the window.</p> <p><code>AY</code>: <code>Single</code> : The Y coordinate within the window.</p>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#see-also_51","title":"See Also","text":"<ul> <li>TSdlMouse.WarpGlobal</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/classes/TSdlWindow/#remarks_74","title":"Remarks","text":"<p>This method should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_ALPHA_OPAQUE/","title":"SDL_ALPHA_OPAQUE","text":"<p>A fully opaque 8-bit alpha value. </p>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_ALPHA_OPAQUE/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>const SDL_ALPHA_OPAQUE = 255\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_ALPHA_OPAQUE/#see-also","title":"See Also","text":"<ul> <li>SDL_ALPHA_TRANSPARENT</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_ALPHA_OPAQUE_FLOAT/","title":"SDL_ALPHA_OPAQUE_FLOAT","text":"<p>A fully opaque floating point alpha value. </p>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_ALPHA_OPAQUE_FLOAT/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>const SDL_ALPHA_OPAQUE_FLOAT = 1.0\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_ALPHA_OPAQUE_FLOAT/#see-also","title":"See Also","text":"<ul> <li>SDL_ALPHA_TRANSPARENT_FLOAT</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_ALPHA_TRANSPARENT/","title":"SDL_ALPHA_TRANSPARENT","text":"<p>A fully transparent 8-bit alpha value. </p>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_ALPHA_TRANSPARENT/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>const SDL_ALPHA_TRANSPARENT = 0\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_ALPHA_TRANSPARENT/#see-also","title":"See Also","text":"<ul> <li>SDL_ALPHA_OPAQUE</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_ALPHA_TRANSPARENT_FLOAT/","title":"SDL_ALPHA_TRANSPARENT_FLOAT","text":"<p>A fully transparent floating point alpha value. </p>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_ALPHA_TRANSPARENT_FLOAT/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>const SDL_ALPHA_TRANSPARENT_FLOAT = 0.0\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_ALPHA_TRANSPARENT_FLOAT/#see-also","title":"See Also","text":"<ul> <li>SDL_ALPHA_OPAQUE_FLOAT</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE/","title":"SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE","text":"<p>The size, in pixels, of a single TSdlRenderer.DrawDebugText character.</p> <p>The font is monospaced and square, so this applies to all characters. </p>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>const SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE = Neslib.Sdl3.Api.SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_DEBUG_TEXT_FONT_CHARACTER_SIZE/#see-also","title":"See Also","text":"<ul> <li>TSdlRenderer.DrawDebugText</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_NO_COLOR_KEY/","title":"SDL_NO_COLOR_KEY","text":"<p>Uses with TSdlSurface.ColorKey to disable the color key. </p>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_NO_COLOR_KEY/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>const SDL_NO_COLOR_KEY = Cardinal.MaxValue\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_SOFTWARE_RENDERER/","title":"SDL_SOFTWARE_RENDERER","text":"<p>The name of the software renderer. </p>"},{"location":"Reference/Neslib.Sdl3.Video/constants/SDL_SOFTWARE_RENDERER/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>const SDL_SOFTWARE_RENDERER = Neslib.Sdl3.Api.SDL_SOFTWARE_RENDERER\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/PremultiplyAlpha/","title":"PremultiplyAlpha","text":"<p>Premultiply the alpha on a block of pixels.</p> <p>This is safe to use with ASrc = ADst, but not for other overlapping areas. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/PremultiplyAlpha/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>procedure PremultiplyAlpha(const AWidth, AHeight: Integer; \n  const ASrcFormat: TSdlPixelFormat; const ASrc: Pointer; \n  const ASrcPitch: Integer; const ADstFormat: TSdlPixelFormat; \n  const ADst: Pointer; const ADstPitch: Integer; const ALinear: Boolean); inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/PremultiplyAlpha/#parameters","title":"Parameters","text":"<p><code>AWidth</code>: <code>Integer</code> : The width of the block to convert, in pixels.</p> <p><code>AHeight</code>: <code>Integer</code> : The height of the block to convert, in pixels.</p> <p><code>ASrcFormat</code>: <code>TSdlPixelFormat</code> : The pixel format of ASrc.</p> <p><code>ASrc</code>: <code>Pointer</code> : A pointer to the source pixels.</p> <p><code>ASrcPitch</code>: <code>Integer</code> : The pitch of the source pixels, in bytes.</p> <p><code>ADstFormat</code>: <code>TSdlPixelFormat</code> : The pixel format of ADst.</p> <p><code>ADst</code>: <code>Pointer</code> : A pointer to be filled in with premultiplied pixel data.</p> <p><code>ADstPitch</code>: <code>Integer</code> : The pitch of the destination pixels, in bytes.</p> <p><code>ALinear</code>: <code>Boolean</code> : True to convert from sRGB to linear space for the alpha multiplication, False to do multiplication in sRGB space.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/PremultiplyAlpha/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/PremultiplyAlpha/#see-also","title":"See Also","text":"<ul> <li>TSdlSurface.PremultiplyAlpha</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlColor/","title":"SdlColor","text":"<p>Create a color. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlColor/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlColor(const AR, AG, AB: Byte; const AA: Byte = 255): TSdlColor; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlColor/#parameters","title":"Parameters","text":"<p><code>AR</code>: <code>Byte</code> : The red value.</p> <p><code>AG</code>: <code>Byte</code> : The green value.</p> <p><code>AB</code>: <code>Byte</code> : The blue value.</p> <p><code>AA</code>: <code>Byte = 255</code> : (Optional) alpha value. Defaults to 255</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlColor/#returns","title":"Returns","text":"<p><code>TSdlColor</code>: The color</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlColor/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlColorF/","title":"SdlColorF","text":"<p>Create a color. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlColorF/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlColorF(const AR, AG, AB: Single; const AA: Single = 1): TSdlColorF; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlColorF/#parameters","title":"Parameters","text":"<p><code>AR</code>: <code>Single</code> : The red value.</p> <p><code>AG</code>: <code>Single</code> : The green value.</p> <p><code>AB</code>: <code>Single</code> : The blue value.</p> <p><code>AA</code>: <code>Single = 1</code> : (Optional) alpha value. Defaults to 255</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlColorF/#returns","title":"Returns","text":"<p><code>TSdlColorF</code>: The color</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlColorF/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlConvert_0/","title":"SdlConvert","text":"<p>Copy a block of pixels of one format and colorspace to another format and colorspace. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlConvert_0/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>procedure SdlConvert(const AWidth, AHeight: Integer; \n  const ASrcFormat: TSdlPixelFormat; const ASrcColorspace: TSdlColorspace; \n  const ASrcProperties: TSdlProperties; const ASrc: Pointer; \n  const ASrcPitch: Integer; const ADstFormat: TSdlPixelFormat; \n  const ADstColorspace: TSdlColorspace; const ADstProperties: TSdlProperties; \n  const ADst: Pointer; const ADstPitch: Integer); overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlConvert_0/#parameters","title":"Parameters","text":"<p><code>AWidth</code>: <code>Integer</code> : The width of the block to copy, in pixels.</p> <p><code>AHeight</code>: <code>Integer</code> : The height of the block to copy, in pixels.</p> <p><code>ASrcFormat</code>: <code>TSdlPixelFormat</code> : The pixel format of ASrc.</p> <p><code>ASrcColorspace</code>: <code>TSdlColorspace</code> : The colorspace of ASrc.</p> <p><code>ASrcProperties</code>: <code>TSdlProperties</code> : Additional source color properties.</p> <p><code>ASrc</code>: <code>Pointer</code> : A pointer to the source pixels.</p> <p><code>ASrcPitch</code>: <code>Integer</code> : The pitch of the source pixels, in bytes.</p> <p><code>ADstFormat</code>: <code>TSdlPixelFormat</code> : The pixel format of ADst.</p> <p><code>ADstColorspace</code>: <code>TSdlColorspace</code> : The colorspace of ADst.</p> <p><code>ADstProperties</code>: <code>TSdlProperties</code> : Additional destination color properties.</p> <p><code>ADst</code>: <code>Pointer</code> : A pointer to be filled in with new pixel data.</p> <p><code>ADstPitch</code>: <code>Integer</code> : The pitch of the destination pixels, in bytes.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlConvert_0/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlConvert_0/#see-also","title":"See Also","text":"<ul> <li>TSdlSurface.Convert</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlConvert_1/","title":"SdlConvert","text":"<p>Copy a block of pixels of one format and colorspace to another format and colorspace. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlConvert_1/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>procedure SdlConvert(const AWidth, AHeight: Integer; \n  const ASrcFormat: TSdlPixelFormat; const ASrcColorspace: TSdlColorspace; \n  const ASrc: Pointer; const ASrcPitch: Integer; const ADstFormat: TSdlPixelFormat; \n  const ADstColorspace: TSdlColorspace; const ADst: Pointer; \n  const ADstPitch: Integer); overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlConvert_1/#parameters","title":"Parameters","text":"<p><code>AWidth</code>: <code>Integer</code> : The width of the block to copy, in pixels.</p> <p><code>AHeight</code>: <code>Integer</code> : The height of the block to copy, in pixels.</p> <p><code>ASrcFormat</code>: <code>TSdlPixelFormat</code> : The pixel format of ASrc.</p> <p><code>ASrcColorspace</code>: <code>TSdlColorspace</code> : The colorspace of ASrc.</p> <p><code>ASrc</code>: <code>Pointer</code> : A pointer to the source pixels.</p> <p><code>ASrcPitch</code>: <code>Integer</code> : The pitch of the source pixels, in bytes.</p> <p><code>ADstFormat</code>: <code>TSdlPixelFormat</code> : The pixel format of ADst.</p> <p><code>ADstColorspace</code>: <code>TSdlColorspace</code> : The colorspace of ADst.</p> <p><code>ADst</code>: <code>Pointer</code> : A pointer to be filled in with new pixel data.</p> <p><code>ADstPitch</code>: <code>Integer</code> : The pitch of the destination pixels, in bytes.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlConvert_1/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlConvert_1/#see-also","title":"See Also","text":"<ul> <li>TSdlSurface.Convert</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlConvert_2/","title":"SdlConvert","text":"<p>Copy a block of pixels of one format to another format. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlConvert_2/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>procedure SdlConvert(const AWidth, AHeight: Integer; \n  const ASrcFormat: TSdlPixelFormat; const ASrc: Pointer; \n  const ASrcPitch: Integer; const ADstFormat: TSdlPixelFormat; \n  const ADst: Pointer; const ADstPitch: Integer); overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlConvert_2/#parameters","title":"Parameters","text":"<p><code>AWidth</code>: <code>Integer</code> : The width of the block to copy, in pixels.</p> <p><code>AHeight</code>: <code>Integer</code> : The height of the block to copy, in pixels.</p> <p><code>ASrcFormat</code>: <code>TSdlPixelFormat</code> : The pixel format of ASrc.</p> <p><code>ASrc</code>: <code>Pointer</code> : A pointer to the source pixels.</p> <p><code>ASrcPitch</code>: <code>Integer</code> : The pitch of the source pixels, in bytes.</p> <p><code>ADstFormat</code>: <code>TSdlPixelFormat</code> : The pixel format of ADst.</p> <p><code>ADst</code>: <code>Pointer</code> : A pointer to be filled in with new pixel data.</p> <p><code>ADstPitch</code>: <code>Integer</code> : The pitch of the destination pixels, in bytes.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlConvert_2/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlConvert_2/#see-also","title":"See Also","text":"<ul> <li>TSdlSurface.Convert</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_0/","title":"SdlPointF","text":"<p>Create a TSdlPointF from X and Y values. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_0/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlPointF(const AX, AY: Single): TSdlPointF; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_0/#parameters","title":"Parameters","text":"<p><code>AX</code>: <code>Single</code> : The X value.</p> <p><code>AY</code>: <code>Single</code> : The Y value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_0/#returns","title":"Returns","text":"<p><code>TSdlPointF</code>: The point.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_0/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_1/","title":"SdlPointF","text":"<p>Create a TSdlPointF from a TSdlPoint. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_1/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlPointF(const APoint: TSdlPoint): TSdlPointF; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_1/#parameters","title":"Parameters","text":"<p><code>APoint</code>: <code>TSdlPoint</code> : The TSdlPoint.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_1/#returns","title":"Returns","text":"<p><code>TSdlPointF</code>: The point.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_1/#remarks","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_2/","title":"SdlPointF","text":"<p>Create a TSdlPointF from a TPoint. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_2/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlPointF(const APoint: TPoint): TSdlPointF; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_2/#parameters","title":"Parameters","text":"<p><code>APoint</code>: <code>TPoint</code> : The TPoint.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_2/#returns","title":"Returns","text":"<p><code>TSdlPointF</code>: The point.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_2/#remarks","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_3/","title":"SdlPointF","text":"<p>Create a TSdlPointF from a TPointF. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_3/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlPointF(const APoint: TPointF): TSdlPointF; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_3/#parameters","title":"Parameters","text":"<p><code>APoint</code>: <code>TPointF</code> : The TPointF.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_3/#returns","title":"Returns","text":"<p><code>TSdlPointF</code>: The point.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPointF_3/#remarks","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPoint_0/","title":"SdlPoint","text":"<p>Create a TSdlPoint from X and Y values. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPoint_0/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlPoint(const AX, AY: Integer): TSdlPoint; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPoint_0/#parameters","title":"Parameters","text":"<p><code>AX</code>: <code>Integer</code> : The X value.</p> <p><code>AY</code>: <code>Integer</code> : The Y value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPoint_0/#returns","title":"Returns","text":"<p><code>TSdlPoint</code>: The point.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPoint_0/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPoint_1/","title":"SdlPoint","text":"<p>Create a TSdlPoint from a TPoint. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPoint_1/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlPoint(const APoint: TPoint): TSdlPoint; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPoint_1/#parameters","title":"Parameters","text":"<p><code>APoint</code>: <code>TPoint</code> : The TPoint.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPoint_1/#returns","title":"Returns","text":"<p><code>TSdlPoint</code>: The point.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlPoint_1/#remarks","title":"Remarks","text":"<p>It is safe to call this constructor from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_0/","title":"SdlRectF","text":"<p>Create a TSdlRectF from a TRectF. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_0/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlRectF(const ARect: TRectF): TSdlRectF; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_0/#parameters","title":"Parameters","text":"<p><code>ARect</code>: <code>TRectF</code> : The TRectF.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_0/#returns","title":"Returns","text":"<p><code>TSdlRectF</code>: The rect.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_0/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_1/","title":"SdlRectF","text":"<p>Create a TSdlRectF from X, Y, W and H values. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_1/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlRectF(const AX, AY, AW, AH: Single): TSdlRectF; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_1/#parameters","title":"Parameters","text":"<p><code>AX</code>: <code>Single</code> : The X value.</p> <p><code>AY</code>: <code>Single</code> : The Y value.</p> <p><code>AW</code>: <code>Single</code> : The width.</p> <p><code>AH</code>: <code>Single</code> : The height.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_1/#returns","title":"Returns","text":"<p><code>TSdlRectF</code>: The rect.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_1/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_2/","title":"SdlRectF","text":"<p>Create a TSdlRectF from a TSdlRect. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_2/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlRectF(const ARect: TSdlRect): TSdlRectF; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_2/#parameters","title":"Parameters","text":"<p><code>ARect</code>: <code>TSdlRect</code> : The TSdlRect.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_2/#returns","title":"Returns","text":"<p><code>TSdlRectF</code>: The rect.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_2/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_3/","title":"SdlRectF","text":"<p>Create a TSdlRectF from a TRect. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_3/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlRectF(const ARect: TRect): TSdlRectF; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_3/#parameters","title":"Parameters","text":"<p><code>ARect</code>: <code>TRect</code> : The TRect.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_3/#returns","title":"Returns","text":"<p><code>TSdlRectF</code>: The rect.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRectF_3/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRect_0/","title":"SdlRect","text":"<p>Create a TSdlRect from a TRect. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRect_0/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlRect(const ARect: TRect): TSdlRect; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRect_0/#parameters","title":"Parameters","text":"<p><code>ARect</code>: <code>TRect</code> : The TRect.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRect_0/#returns","title":"Returns","text":"<p><code>TSdlRect</code>: The rect.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRect_0/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRect_1/","title":"SdlRect","text":"<p>Create a TSdlRect from X, Y, W and H values. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRect_1/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlRect(const AX, AY, AW, AH: Integer): TSdlRect; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRect_1/#parameters","title":"Parameters","text":"<p><code>AX</code>: <code>Integer</code> : The X value.</p> <p><code>AY</code>: <code>Integer</code> : The Y value.</p> <p><code>AW</code>: <code>Integer</code> : The width.</p> <p><code>AH</code>: <code>Integer</code> : The height.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRect_1/#returns","title":"Returns","text":"<p><code>TSdlRect</code>: The rect.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlRect_1/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlSize/","title":"SdlSize","text":"<p>Create a TSdlSize from W and H values. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlSize/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlSize(const AW, AH: Integer): TSdlSize; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlSize/#parameters","title":"Parameters","text":"<p><code>AW</code>: <code>Integer</code> : The W value.</p> <p><code>AH</code>: <code>Integer</code> : The H value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlSize/#returns","title":"Returns","text":"<p><code>TSdlSize</code>: The size.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlSize/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlSizeF_0/","title":"SdlSizeF","text":"<p>Create a TSdlSizeF from a TSdlSize. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlSizeF_0/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlSizeF(const ASize: TSdlSize): TSdlSizeF; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlSizeF_0/#parameters","title":"Parameters","text":"<p><code>ASize</code>: <code>TSdlSize</code> : The size.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlSizeF_0/#returns","title":"Returns","text":"<p><code>TSdlSizeF</code>: The size.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlSizeF_0/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlSizeF_1/","title":"SdlSizeF","text":"<p>Create a TSdlSizeF from W and H values. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlSizeF_1/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlSizeF(const AW, AH: Single): TSdlSizeF; overload; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlSizeF_1/#parameters","title":"Parameters","text":"<p><code>AW</code>: <code>Single</code> : The W value.</p> <p><code>AH</code>: <code>Single</code> : The H value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlSizeF_1/#returns","title":"Returns","text":"<p><code>TSdlSizeF</code>: The size.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlSizeF_1/#remarks","title":"Remarks","text":"<p>It is safe to call this function from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanCreateSurface/","title":"SdlVulkanCreateSurface","text":"<p>Create a Vulkan rendering surface for a window.</p> <p>The <code>AWindow</code> must have been created with the <code>TSdlWindowFlag.Vulkan</code> flag and <code>AInstance</code> must have been created with extensions returned by SdlVulkanGetInstanceExtensions enabled.</p> <p>If <code>AAllocator</code> is nil, Vulkan will use the system default allocator. This argument is passed directly to Vulkan and isn't used by SDL itself. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanCreateSurface/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlVulkanCreateSurface(const AWindow: TSdlWindow; \n  const AInstance: VkInstance; const AAllocator: PVkAllocationCallbacks = nil): VkSurfaceKHR; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanCreateSurface/#parameters","title":"Parameters","text":"<p><code>AWindow</code>: <code>TSdlWindow</code> : The window to which to attach the Vulkan surface.</p> <p><code>AInstance</code>: <code>VkInstance</code> : The Vulkan instance handle.</p> <p><code>AAllocator</code>: <code>PVkAllocationCallbacks = nil</code> : (Optional) VkAllocationCallbacks struct, which lets the app set the allocator that creates the surface. Can be nil.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanCreateSurface/#returns","title":"Returns","text":"<p><code>VkSurfaceKHR</code>: The newly created surface.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanCreateSurface/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanCreateSurface/#see-also","title":"See Also","text":"<ul> <li>SdlVulkanGetInstanceExtensions</li> <li>SdlVulkanDestroySurface</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanDestroySurface/","title":"SdlVulkanDestroySurface","text":"<p>Destroy the Vulkan rendering surface of a window.</p> <p>This should be called before destroying the window, if SdlVulkanCreateSurface was called after creating the window.</p> <p>The <code>AInstance</code> must have been created with extensions returned by SdlVulkanGetInstanceExtensions enabled and <code>ASurface</code> must have been created successfully by an SdlVulkanCreateSurface call.</p> <p>If <code>AAllocator</code> is nil, Vulkan will use the system default allocator. This argument is passed directly to Vulkan and isn't used by SDL itself. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanDestroySurface/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>procedure SdlVulkanDestroySurface(const AInstance: VkInstance; \n  const ASurface: VkSurfaceKHR; const AAllocator: PVkAllocationCallbacks = nil); inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanDestroySurface/#parameters","title":"Parameters","text":"<p><code>AInstance</code>: <code>VkInstance</code> : The Vulkan instance handle.</p> <p><code>ASurface</code>: <code>VkSurfaceKHR</code> : The vkSurfaceKHR handle to destroy.</p> <p><code>AAllocator</code>: <code>PVkAllocationCallbacks = nil</code> : (Optional) VkAllocationCallbacks struct, which lets the app set the allocator that destroys the surface. Can be nil.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanDestroySurface/#see-also","title":"See Also","text":"<ul> <li>SdlVulkanGetInstanceExtensions</li> <li>SdlVulkanCreateSurface</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanGetInstanceExtensions/","title":"SdlVulkanGetInstanceExtensions","text":"<p>Get the Vulkan instance extensions needed for vkCreateInstance.</p> <p>This should be called after either calling SdlVulkanLoadLibrary or creating a TSdlWindow with the <code>TSdlWindowFlag.Vulkan</code> flag. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanGetInstanceExtensions/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlVulkanGetInstanceExtensions: TArray&lt;String&gt;\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanGetInstanceExtensions/#returns","title":"Returns","text":"<p><code>TArray&lt;String&gt;</code>: An array of extension name strings.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanGetInstanceExtensions/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanGetInstanceExtensions/#see-also","title":"See Also","text":"<ul> <li>SdlVulkanCreateSurface</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanGetPresentationSupport/","title":"SdlVulkanGetPresentationSupport","text":"<p>Query support for presentation via a given physical device and queue family.</p> <p>The <code>AInstance</code> must have been created with extensions returned by SdlVulkanGetInstanceExtensions enabled. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanGetPresentationSupport/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlVulkanGetPresentationSupport(const AInstance: VkInstance; \n  const APhysicalDevice: VkPhysicalDevice; const AQueueFamilyIndex: Integer): Boolean; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanGetPresentationSupport/#parameters","title":"Parameters","text":"<p><code>AInstance</code>: <code>VkInstance</code> : The Vulkan instance handle.</p> <p><code>APhysicalDevice</code>: <code>VkPhysicalDevice</code> : A valid Vulkan physical device handle.</p> <p><code>AQueueFamilyIndex</code>: <code>Integer</code> : A valid queue family index for the given physical device.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanGetPresentationSupport/#returns","title":"Returns","text":"<p><code>Boolean</code>: True if supported, False if unsupported or an error occurred.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanGetPresentationSupport/#see-also","title":"See Also","text":"<ul> <li>SdlVulkanGetInstanceExtensions</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanGetVkGetInstanceProcAddr/","title":"SdlVulkanGetVkGetInstanceProcAddr","text":"<p>Get the address of the <code>vkGetInstanceProcAddr</code> function.</p> <p>This should be called after either calling SdlVulkanLoadLibrary or creating an SDL_Window with the <code>TSdlWindowFlag.Vulkan</code> flag. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanGetVkGetInstanceProcAddr/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>function SdlVulkanGetVkGetInstanceProcAddr: Pointer; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanGetVkGetInstanceProcAddr/#returns","title":"Returns","text":"<p><code>Pointer</code>: The function pointer for <code>vkGetInstanceProcAddr</code>.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanGetVkGetInstanceProcAddr/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanLoadLibrary/","title":"SdlVulkanLoadLibrary","text":"<p>Dynamically load the Vulkan loader library.</p> <p>This should be called after initializing the video driver, but before creating any Vulkan windows. If no Vulkan loader library is loaded, the default library will be loaded upon creation of the first Vulkan window.</p> <p>SDL keeps a counter of how many times this function has been successfully called, so it is safe to call this function multiple times, so long as it is eventually paired with an equivalent number of calls to SdlVulkanUnloadLibrary. The <code>APath</code> argument is ignored unless there is no library currently loaded, and and the library isn't actually unloaded until there have been an equivalent number of calls to SdlVulkanUnloadLibrary.</p> <p>It is fairly common for Vulkan applications to link with libvulkan instead of explicitly loading it at run time. This will work with SDL provided the application links to a dynamic library and both it and SDL use the same search path.</p> <p>If you specify a non-empty <code>APath</code>, an application should retrieve all of the Vulkan functions it uses from the dynamic library using SdlVulkanGetVkGetInstanceProcAddr unless you can guarantee <code>APath</code> points to the same vulkan loader library the application linked to.</p> <p>On Apple devices, if <code>APath</code> is empty, SDL will attempt to find the <code>vkGetInstanceProcAddr</code> address within all the Mach-O images of the current process. This is because it is fairly common for Vulkan applications to link with libvulkan (and historically MoltenVK was provided as a static library). If it is not found, on macOS, SDL will attempt to load <code>vulkan.framework/vulkan</code>, <code>libvulkan.1.dylib</code>, <code>MoltenVK.framework/MoltenVK</code>, and <code>libMoltenVK.dylib</code>, in that order. On iOS, SDL will attempt to load <code>libMoltenVK.dylib</code>. Applications using a dynamic framework or .dylib must ensure it is included in its application bundle.</p> <p>On non-Apple devices, application linking with a static libvulkan is not supported. Either do not link to the Vulkan loader or link to a dynamic library version. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanLoadLibrary/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>procedure SdlVulkanLoadLibrary(const APath: String); inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanLoadLibrary/#parameters","title":"Parameters","text":"<p><code>APath</code>: <code>String</code> : (Optional) platform dependent Vulkan loader library name or empty (default)L.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanLoadLibrary/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanLoadLibrary/#see-also","title":"See Also","text":"<ul> <li>SdlVulkanGetVkGetInstanceProcAddr</li> <li>SdlVulkanUnloadLibrary</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanLoadLibrary/#remarks","title":"Remarks","text":"<p>This routine is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanUnloadLibrary/","title":"SdlVulkanUnloadLibrary","text":"<p>Unload the Vulkan library previously loaded by SdlVulkanLoadLibrary.</p> <p>SDL keeps a counter of how many times this function has been called, so it is safe to call this function multiple times, so long as it is paired with an equivalent number of calls to SdlVulkanLoadLibrary. The library isn't actually unloaded until there have been an equivalent number of calls to SdlVulkanUnloadLibrary.</p> <p>Once the library has actually been unloaded, if any Vulkan instances remain, they will likely crash the program. Clean up any existing Vulkan resources, and destroy appropriate windows, renderers and GPU devices before calling this function. </p>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanUnloadLibrary/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>procedure SdlVulkanUnloadLibrary; inline\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanUnloadLibrary/#see-also","title":"See Also","text":"<ul> <li>SdlVulkanLoadLibrary</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/routines/SdlVulkanUnloadLibrary/#remarks","title":"Remarks","text":"<p>This routine is not thread safe. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlColor/","title":"PSdlColor","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlColor/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type PSdlColor = ^TSdlColor\n</code></pre> <p>Base type: <code>TSdlColor</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlColorF/","title":"PSdlColorF","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlColorF/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type PSdlColorF = ^TSdlColorF\n</code></pre> <p>Base type: <code>TSdlColorF</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlDisplayMode/","title":"PSdlDisplayMode","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlDisplayMode/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type PSdlDisplayMode = ^TSdlDisplayMode\n</code></pre> <p>Base type: <code>TSdlDisplayMode</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlPoint/","title":"PSdlPoint","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlPoint/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type PSdlPoint = ^TSdlPoint\n</code></pre> <p>Base type: <code>TSdlPoint</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlPointF/","title":"PSdlPointF","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlPointF/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type PSdlPointF = ^TSdlPointF\n</code></pre> <p>Base type: <code>TSdlPointF</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlRect/","title":"PSdlRect","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlRect/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type PSdlRect = ^TSdlRect\n</code></pre> <p>Base type: <code>TSdlRect</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlRectF/","title":"PSdlRectF","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlRectF/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type PSdlRectF = ^TSdlRectF\n</code></pre> <p>Base type: <code>TSdlRectF</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlSize/","title":"PSdlSize","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlSize/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type PSdlSize = ^TSdlSize\n</code></pre> <p>Base type: <code>TSdlSize</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlSizeF/","title":"PSdlSizeF","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlSizeF/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type PSdlSizeF = ^TSdlSizeF\n</code></pre> <p>Base type: <code>TSdlSizeF</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlVertex/","title":"PSdlVertex","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/PSdlVertex/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type PSdlVertex = ^TSdlVertex\n</code></pre> <p>Base type: <code>TSdlVertex</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/PVkAllocationCallbacks/","title":"PVkAllocationCallbacks","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/PVkAllocationCallbacks/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type PVkAllocationCallbacks = Pointer\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlArrayOrder/","title":"TSdlArrayOrder","text":"<p>Array component order, low byte -&gt; high byte. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlArrayOrder/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlArrayOrder = (None, Rgb, Rgba, Argb, Bgr, Bgra, Abgr)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlArrayOrder/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlArrayOrder/#none-sdl_arrayorder_none","title":"<code>None = SDL_ARRAYORDER_NONE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlArrayOrder/#rgb-sdl_arrayorder_rgb","title":"<code>Rgb = SDL_ARRAYORDER_RGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlArrayOrder/#rgba-sdl_arrayorder_rgba","title":"<code>Rgba = SDL_ARRAYORDER_RGBA</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlArrayOrder/#argb-sdl_arrayorder_argb","title":"<code>Argb = SDL_ARRAYORDER_ARGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlArrayOrder/#bgr-sdl_arrayorder_bgr","title":"<code>Bgr = SDL_ARRAYORDER_BGR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlArrayOrder/#bgra-sdl_arrayorder_bgra","title":"<code>Bgra = SDL_ARRAYORDER_BGRA</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlArrayOrder/#abgr-sdl_arrayorder_abgr","title":"<code>Abgr = SDL_ARRAYORDER_ABGR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBitmapOrder/","title":"TSdlBitmapOrder","text":"<p>Bitmap pixel order, high bit -&gt; low bit. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBitmapOrder/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlBitmapOrder = (None, Order4321, Order1234)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBitmapOrder/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBitmapOrder/#none-sdl_bitmaporder_none","title":"<code>None = SDL_BITMAPORDER_NONE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBitmapOrder/#order4321-sdl_bitmaporder_4321","title":"<code>Order4321 = SDL_BITMAPORDER_4321</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBitmapOrder/#order1234-sdl_bitmaporder_1234","title":"<code>Order1234 = SDL_BITMAPORDER_1234</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendFactor/","title":"TSdlBlendFactor","text":"<p>The normalized factor used to multiply pixel components.</p> <p>The blend factors are multiplied with the pixels from a drawing operation (src) and the pixels from the render target (dst) before the blend operation. The comma-separated factors listed above are always applied in the component order red, green, blue, and alpha. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendFactor/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlBlendFactor = (Zero, One, SrcColor, OneMinusSrcColor, SrcAlpha, OneMinusSrcAlpha, DstColor, OneMinusDstColor, DstAlpha, OneMinusDstAlpha)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendFactor/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendFactor/#zero-sdl_blendfactor_zero","title":"<code>Zero = SDL_BLENDFACTOR_ZERO</code>","text":"<p>0, 0, 0, 0 </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendFactor/#one-sdl_blendfactor_one","title":"<code>One = SDL_BLENDFACTOR_ONE</code>","text":"<p>1, 1, 1, 1 </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendFactor/#srccolor-sdl_blendfactor_src_color","title":"<code>SrcColor = SDL_BLENDFACTOR_SRC_COLOR</code>","text":"<p>srcR, srcG, srcB, srcA </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendFactor/#oneminussrccolor-sdl_blendfactor_one_minus_src_color","title":"<code>OneMinusSrcColor = SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR</code>","text":"<p>1-srcR, 1-srcG, 1-srcB, 1-srcA </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendFactor/#srcalpha-sdl_blendfactor_src_alpha","title":"<code>SrcAlpha = SDL_BLENDFACTOR_SRC_ALPHA</code>","text":"<p>srcA, srcA, srcA, srcA </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendFactor/#oneminussrcalpha-sdl_blendfactor_one_minus_src_alpha","title":"<code>OneMinusSrcAlpha = SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA</code>","text":"<p>1-srcA, 1-srcA, 1-srcA, 1-srcA </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendFactor/#dstcolor-sdl_blendfactor_dst_color","title":"<code>DstColor = SDL_BLENDFACTOR_DST_COLOR</code>","text":"<p>dstR, dstG, dstB, dstA </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendFactor/#oneminusdstcolor-sdl_blendfactor_one_minus_dst_color","title":"<code>OneMinusDstColor = SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR</code>","text":"<p>1-dstR, 1-dstG, 1-dstB, 1-dstA </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendFactor/#dstalpha-sdl_blendfactor_dst_alpha","title":"<code>DstAlpha = SDL_BLENDFACTOR_DST_ALPHA</code>","text":"<p>dstA, dstA, dstA, dstA </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendFactor/#oneminusdstalpha-sdl_blendfactor_one_minus_dst_alpha","title":"<code>OneMinusDstAlpha = SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA</code>","text":"<p>1-dstA, 1-dstA, 1-dstA, 1-dstA </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/","title":"TSdlBlendMode","text":"<p>A set of blend modes used in drawing operations.</p> <p>These predefined blend modes are supported everywhere.</p> <p>Additional values may be obtained from TSdlBlendMode.Compose. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlBlendMode = (None, Blend, BlendPremultiplied, Add, AddPremultiplied, Modulate, Multiply, Invalid)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#see-also","title":"See Also","text":"<ul> <li>TSdlBlendMode.Compose</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#none-sdl_blendmode_none","title":"<code>None = SDL_BLENDMODE_NONE</code>","text":"<p>No blending: dstRGBA = srcRGBA </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#blend-sdl_blendmode_blend","title":"<code>Blend = SDL_BLENDMODE_BLEND</code>","text":"<p>Alpha blending: dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA)), dstA = srcA + (dstA * (1-srcA)) </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#blendpremultiplied-sdl_blendmode_blend_premultiplied","title":"<code>BlendPremultiplied = SDL_BLENDMODE_BLEND_PREMULTIPLIED</code>","text":"<p>Pre-multiplied alpha blending: dstRGBA = srcRGBA + (dstRGBA * (1-srcA)) </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#add-sdl_blendmode_add","title":"<code>Add = SDL_BLENDMODE_ADD</code>","text":"<p>Additive blending: dstRGB = (srcRGB * srcA) + dstRGB, dstA = dstA </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#addpremultiplied-sdl_blendmode_add_premultiplied","title":"<code>AddPremultiplied = SDL_BLENDMODE_ADD_PREMULTIPLIED</code>","text":"<p>Pre-multiplied additive blending: dstRGB = srcRGB + dstRGB, dstA = dstA </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#modulate-sdl_blendmode_mod","title":"<code>Modulate = SDL_BLENDMODE_MOD</code>","text":"<p>Color modulate: dstRGB = srcRGB * dstRGB, dstA = dstA </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#multiply-sdl_blendmode_mul","title":"<code>Multiply = SDL_BLENDMODE_MUL</code>","text":"<p>Color multiply: dstRGB = (srcRGB * dstRGB) + (dstRGB * (1-srcA)), dstA = dstA </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#invalid-sdl_blendmode_invalid","title":"<code>Invalid = SDL_BLENDMODE_INVALID</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#methods","title":"Methods","text":"Name Description Compose Compose a custom blend mode for renderers."},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#Compose","title":"Compose(TSdlBlendFactor, TSdlBlendFactor, TSdlBlendOperation, TSdlBlendFactor, TSdlBlendFactor, TSdlBlendOperation)","text":"<p>Compose a custom blend mode for renderers.</p> <p>The properties TSdlRenderer.DrawBlendMode and TSdlTexture.BlendMode accept the TSdlBlendMode returned by this function if the renderer supports it.</p> <p>A blend mode controls how the pixels from a drawing operation (source) get combined with the pixels from the render target (destination). First, the components of the source and destination pixels get multiplied with their blend factors. Then, the blend operation takes the two products and calculates the result that will get stored in the render target.</p> <p>Expressed in pseudocode, it would look like this:</p> <pre><code>  DstRgb := ColorOperation(SrcRgb * SrcColorFactor, DstRgb * DstColorFactor);\n  DstA := AlphaOperation(SrcA * SrcAlphaFactor, DstA * DstAlphaFactor);\n</code></pre> <p>Where the functions <code>ColorOperation(Src, Dst)</code> and <code>AlphaOperation(Src, Dst)</code> can return one of the following:</p> <ul> <li><code>Src + Dst</code></li> <li><code>Src - Dst</code></li> <li><code>Dst - Src</code></li> <li><code>Min(Src, Dst)</code></li> <li><code>Max(Src, Dst)</code></li> </ul> <p>The red, green, and blue components are always multiplied with the first, second, and third components of the TSdlBlendFactor, respectively. The fourth component is not used.</p> <p>The alpha component is always multiplied with the fourth component of the TSdlBlendFactor. The other components are not used in the alpha calculation.</p> <p>Support for these blend modes varies for each renderer. To check if a specific TSdlBlendMode is supported, create a renderer and assign it to either TSdlRenderer.DrawBlendMode or TSdlTexture.BlendMode. They will raise an error if the blend mode is not supported.</p> <p>This list describes the support of custom blend modes for each renderer. All renderers support the four blend modes listed in the SDL_BlendMode enumeration.</p> <ul> <li>Direct3D: Supports all operations with all factors. However, some factors produce unexpected results with <code>TSdlBlendOperation.Minimum</code> and <code>TSdlBlendOperation.Maximum</code>.</li> <li>Direct3D11: Same as Direct3D 9.</li> <li>OpenGL: Supports the <code>TSdlBlendOperation.Add</code> operation with all factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly here.</li> <li>OpenGL-ES2: Supports the <code>TSdlBlendOperation.Add</code>, <code>TSdlBlendOperation.Subtract</code>, <code>TSdlBlendOperation.RevSubtract</code> operations with all factors.</li> <li>Software: No custom blend mode support.</li> </ul> <p>Some renderers do not provide an alpha component for the default render target. The <code>TSdlBlendFactor.DstAlpha</code> and <code>TSdlBlendFactor.OneMinusDstAlpha</code> factors do not have an effect in this case. </p> <p><code>class function Compose(const ASrcColorFactor, ADstColorFactor: TSdlBlendFactor; const AColorOperation: TSdlBlendOperation; const ASrcAlphaFactor, ADstAlphaFactor: TSdlBlendFactor; const AAlphaOperation: TSdlBlendOperation): TSdlBlendMode; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#parameters","title":"Parameters","text":"<p><code>ASrcColorFactor</code>: <code>TSdlBlendFactor</code> : The blend factor applied to the red, green, and blue components of the source pixels.</p> <p><code>ADstColorFactor</code>: <code>TSdlBlendFactor</code> : The blend factor applied to the red, green, and blue components of the destination pixels.</p> <p><code>AColorOperation</code>: <code>TSdlBlendOperation</code> : The blend operation used to combine the red, green, and blue components of the source and destination pixels.</p> <p><code>ASrcAlphaFactor</code>: <code>TSdlBlendFactor</code> : The blend factor applied to the alpha component of the source pixels.</p> <p><code>ADstAlphaFactor</code>: <code>TSdlBlendFactor</code> : The blend factor applied to the alpha component of the destination pixels.</p> <p><code>AAlphaOperation</code>: <code>TSdlBlendOperation</code> : The blend operation used to combine the alpha component of the source and destination pixels.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#returns","title":"Returns","text":"<p><code>TSdlBlendMode</code>: A TSdlBlendMode that represents the chosen factors and operations.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#see-also_1","title":"See Also","text":"<ul> <li>TSdlRenderer.DrawBlendMode</li> <li>TSdlTexture.BlendMode</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendMode/#remarks","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendOperation/","title":"TSdlBlendOperation","text":"<p>The blend operation used when combining source and destination pixel components. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendOperation/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlBlendOperation = (Add, Subtract, RevSubtract, Minimum, Maximum)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendOperation/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendOperation/#add-sdl_blendoperation_add","title":"<code>Add = SDL_BLENDOPERATION_ADD</code>","text":"<p>dst + src: supported by all renderers </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendOperation/#subtract-sdl_blendoperation_subtract","title":"<code>Subtract = SDL_BLENDOPERATION_SUBTRACT</code>","text":"<p>src - dst : supported by D3D, OpenGL, OpenGLES, and Vulkan </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendOperation/#revsubtract-sdl_blendoperation_rev_subtract","title":"<code>RevSubtract = SDL_BLENDOPERATION_REV_SUBTRACT</code>","text":"<p>dst - src : supported by D3D, OpenGL, OpenGLES, and Vulkan </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendOperation/#minimum-sdl_blendoperation_minimum","title":"<code>Minimum = SDL_BLENDOPERATION_MINIMUM</code>","text":"<p>min(dst, src) : supported by D3D, OpenGL, OpenGLES, and Vulkan </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlBlendOperation/#maximum-sdl_blendoperation_maximum","title":"<code>Maximum = SDL_BLENDOPERATION_MAXIMUM</code>","text":"<p>max(dst, src) : supported by D3D, OpenGL, OpenGLES, and Vulkan </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCameraPermissionState/","title":"TSdlCameraPermissionState","text":"<p>Permission state of a camera. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCameraPermissionState/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlCameraPermissionState = (Denied, Waiting, Approved)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCameraPermissionState/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCameraPermissionState/#denied-1","title":"<code>Denied = -1</code>","text":"<p>User denied access to the camera. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCameraPermissionState/#waiting-0","title":"<code>Waiting = 0</code>","text":"<p>No decision has been made yet. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCameraPermissionState/#approved-1","title":"<code>Approved = 1</code>","text":"<p>User approved access to the camera. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCameraPosition/","title":"TSdlCameraPosition","text":"<p>The position of camera in relation to system device. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCameraPosition/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlCameraPosition = (Unknown, FrontFacing, BackFacing)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCameraPosition/#see-also","title":"See Also","text":"<ul> <li>TSdlCameraID.Position</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCameraPosition/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCameraPosition/#unknown-sdl_camera_position_unknown","title":"<code>Unknown = SDL_CAMERA_POSITION_UNKNOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCameraPosition/#frontfacing-sdl_camera_position_front_facing","title":"<code>FrontFacing = SDL_CAMERA_POSITION_FRONT_FACING</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCameraPosition/#backfacing-sdl_camera_position_back_facing","title":"<code>BackFacing = SDL_CAMERA_POSITION_BACK_FACING</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCapitalization/","title":"TSdlCapitalization","text":"<p>Auto capitalization type.</p> <p>These are the valid values for TSdlProperty.TextInputCapitalization. Not every value is valid on every platform, but where a value isn't supported, a reasonable fallback will be used. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCapitalization/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlCapitalization = (None, Sentences, Words, Letters)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCapitalization/#see-also","title":"See Also","text":"<ul> <li>TSdlWindow.StartTextInput</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCapitalization/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCapitalization/#none-sdl_capitalize_none","title":"<code>None = SDL_CAPITALIZE_NONE</code>","text":"<p>No auto-capitalization will be done </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCapitalization/#sentences-sdl_capitalize_sentences","title":"<code>Sentences = SDL_CAPITALIZE_SENTENCES</code>","text":"<p>The first letter of sentences will be capitalized </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCapitalization/#words-sdl_capitalize_words","title":"<code>Words = SDL_CAPITALIZE_WORDS</code>","text":"<p>The first letter of words will be capitalized </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlCapitalization/#letters-sdl_capitalize_letters","title":"<code>Letters = SDL_CAPITALIZE_LETTERS</code>","text":"<p>All letters will be capitalized </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlChromaLocation/","title":"TSdlChromaLocation","text":"<p>Colorspace chroma sample location. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlChromaLocation/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlChromaLocation = (None, Left, Center, TopLeft)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlChromaLocation/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlChromaLocation/#none-sdl_chroma_location_none","title":"<code>None = SDL_CHROMA_LOCATION_NONE</code>","text":"<p>RGB, no chroma sampling</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlChromaLocation/#left-sdl_chroma_location_left","title":"<code>Left = SDL_CHROMA_LOCATION_LEFT</code>","text":"<p>In MPEG-2, MPEG-4, and AVC, Cb and Cr are taken on midpoint of the left-edge of the 2x2 square. In other words, they have the same horizontal location as the top-left pixel, but is shifted one-half pixel down vertically.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlChromaLocation/#center-sdl_chroma_location_center","title":"<code>Center = SDL_CHROMA_LOCATION_CENTER</code>","text":"<p>In JPEG/JFIF, H.261, and MPEG-1, Cb and Cr are taken at the center of the 2x2 square. In other words, they are offset one-half pixel to the right and one-half pixel down compared to the top-left pixel.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlChromaLocation/#topleft-sdl_chroma_location_topleft","title":"<code>TopLeft = SDL_CHROMA_LOCATION_TOPLEFT</code>","text":"<p>In HEVC for BT.2020 and BT.2100 content (in particular on Blu-rays), Cb and Cr are sampled at the same location as the group's top-left Y pixel (\"co-sited\", \"co-located\").</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/","title":"TSdlColorPrimaries","text":"<p>Colorspace color primaries, as described by  H.273. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlColorPrimaries = (Unknown, BT709, Unspecified, BT470M, BT470BG, BT601, Smpte240, GenericFilm, BT2020, Xyz, Smpte431, Smpte432, Ebu3213, Custom)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/#unknown-sdl_color_primaries_unknown","title":"<code>Unknown = SDL_COLOR_PRIMARIES_UNKNOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/#bt709-sdl_color_primaries_bt709","title":"<code>BT709 = SDL_COLOR_PRIMARIES_BT709</code>","text":"<p>ITU-R BT.709-6</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/#unspecified-sdl_color_primaries_unspecified","title":"<code>Unspecified = SDL_COLOR_PRIMARIES_UNSPECIFIED</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/#bt470m-sdl_color_primaries_bt470m","title":"<code>BT470M = SDL_COLOR_PRIMARIES_BT470M</code>","text":"<p>ITU-R BT.470-6 System M</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/#bt470bg-sdl_color_primaries_bt470bg","title":"<code>BT470BG = SDL_COLOR_PRIMARIES_BT470BG</code>","text":"<p>ITU-R BT.470-6 System B, G / ITU-R BT.601-7 625</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/#bt601-sdl_color_primaries_bt601","title":"<code>BT601 = SDL_COLOR_PRIMARIES_BT601</code>","text":"<p>ITU-R BT.601-7 525, SMPTE 170M</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/#smpte240-sdl_color_primaries_smpte240","title":"<code>Smpte240 = SDL_COLOR_PRIMARIES_SMPTE240</code>","text":"<p>SMPTE 240M, functionally the same as SDL_COLOR_PRIMARIES_BT601</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/#genericfilm-sdl_color_primaries_generic_film","title":"<code>GenericFilm = SDL_COLOR_PRIMARIES_GENERIC_FILM</code>","text":"<p>Generic film (color filters using Illuminant C)</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/#bt2020-sdl_color_primaries_bt2020","title":"<code>BT2020 = SDL_COLOR_PRIMARIES_BT2020</code>","text":"<p>ITU-R BT.2020-2 / ITU-R BT.2100-0</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/#xyz-sdl_color_primaries_xyz","title":"<code>Xyz = SDL_COLOR_PRIMARIES_XYZ</code>","text":"<p>SMPTE ST 428-1</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/#smpte431-sdl_color_primaries_smpte431","title":"<code>Smpte431 = SDL_COLOR_PRIMARIES_SMPTE431</code>","text":"<p>SMPTE RP 431-2</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/#smpte432-sdl_color_primaries_smpte432","title":"<code>Smpte432 = SDL_COLOR_PRIMARIES_SMPTE432</code>","text":"<p>SMPTE EG 432-1 / DCI P3</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/#ebu3213-sdl_color_primaries_ebu3213","title":"<code>Ebu3213 = SDL_COLOR_PRIMARIES_EBU3213</code>","text":"<p>EBU Tech. 3213-E</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorPrimaries/#custom-sdl_color_primaries_custom","title":"<code>Custom = SDL_COLOR_PRIMARIES_CUSTOM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorRange/","title":"TSdlColorRange","text":"<p>Colorspace color range, as described by  BT.2100. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorRange/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlColorRange = (Unknown, Limited, Full)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorRange/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorRange/#unknown-sdl_color_range_unknown","title":"<code>Unknown = SDL_COLOR_RANGE_UNKNOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorRange/#limited-sdl_color_range_limited","title":"<code>Limited = SDL_COLOR_RANGE_LIMITED</code>","text":"<p>Narrow range, e.g. 16-235 for 8-bit RGB and luma, and 16-240 for 8-bit chroma</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorRange/#full-sdl_color_range_full","title":"<code>Full = SDL_COLOR_RANGE_FULL</code>","text":"<p>Full range, e.g. 0-255 for 8-bit RGB and luma, and 1-255 for 8-bit chroma</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorType/","title":"TSdlColorType","text":"<p>Colorspace color type. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorType/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlColorType = (Unknown, Rgb, YCbCr)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorType/#remarks","title":"Remarks","text":"<p>This enum is available since SDL 3.2.0. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorType/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorType/#unknown-sdl_color_type_unknown","title":"<code>Unknown = SDL_COLOR_TYPE_UNKNOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorType/#rgb-sdl_color_type_rgb","title":"<code>Rgb = SDL_COLOR_TYPE_RGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorType/#ycbcr-sdl_color_type_ycbcr","title":"<code>YCbCr = SDL_COLOR_TYPE_YCBCR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/","title":"TSdlColorspace","text":"<p>Colorspace definitions.</p> <p>Since similar colorspaces may vary in their details (matrix, transfer function, etc.), this is not an exhaustive list, but rather a representative sample of the kinds of colorspaces supported in SDL. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlColorspace = (Unknown, Srgb, SrgbLinear, Hdr10, Jpeg, BT601Limited, BT601Full, BT709Limited, BT709Full, BT2020Limited, BT2020Full, RgbDefault, YuvDefault)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#see-also","title":"See Also","text":"<ul> <li>TSdlColorPrimaries</li> <li>TSdlColorRange</li> <li>TSdlColorType</li> <li>TSdlMatrixCoefficients</li> <li>TSdlTransferCharacteristics</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#unknown-sdl_colorspace_unknown","title":"<code>Unknown = SDL_COLORSPACE_UNKNOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#srgb-sdl_colorspace_srgb","title":"<code>Srgb = SDL_COLORSPACE_SRGB</code>","text":"<p>Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#srgblinear-sdl_colorspace_srgb_linear","title":"<code>SrgbLinear = SDL_COLORSPACE_SRGB_LINEAR</code>","text":"<p>Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#hdr10-sdl_colorspace_hdr10","title":"<code>Hdr10 = SDL_COLORSPACE_HDR10</code>","text":"<p>Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#jpeg-sdl_colorspace_jpeg","title":"<code>Jpeg = SDL_COLORSPACE_JPEG</code>","text":"<p>Equivalent to DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#bt601limited-sdl_colorspace_bt601_limited","title":"<code>BT601Limited = SDL_COLORSPACE_BT601_LIMITED</code>","text":"<p>Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#bt601full-sdl_colorspace_bt601_full","title":"<code>BT601Full = SDL_COLORSPACE_BT601_FULL</code>","text":"<p>Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#bt709limited-sdl_colorspace_bt709_limited","title":"<code>BT709Limited = SDL_COLORSPACE_BT709_LIMITED</code>","text":"<p>Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#bt709full-sdl_colorspace_bt709_full","title":"<code>BT709Full = SDL_COLORSPACE_BT709_FULL</code>","text":"<p>Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#bt2020limited-sdl_colorspace_bt2020_limited","title":"<code>BT2020Limited = SDL_COLORSPACE_BT2020_LIMITED</code>","text":"<p>Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#bt2020full-sdl_colorspace_bt2020_full","title":"<code>BT2020Full = SDL_COLORSPACE_BT2020_FULL</code>","text":"<p>Equivalent to DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#rgbdefault-sdl_colorspace_rgb_default","title":"<code>RgbDefault = SDL_COLORSPACE_RGB_DEFAULT</code>","text":"<p>The default colorspace for RGB surfaces if no colorspace is specified</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#yuvdefault-sdl_colorspace_yuv_default","title":"<code>YuvDefault = SDL_COLORSPACE_YUV_DEFAULT</code>","text":"<p>The default colorspace for YUV surfaces if no colorspace is specified</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#properties","title":"Properties","text":"Name Description Chroma The chroma sample location of the colorspace. ColorType The color type of the colorspace. HasFullRange Whether this colorspace has a full range. HasLimitedRange Whether this colorspace has a limited range. IsMatrixBG709 Whether this colorspace uses BT709 matrix coefficients. IsMatrixBT2020Ncl Whether this colorspace uses BT2020Ncl matrix coefficients. IsMatrixBT601 Whether this colorspace uses BT601 (or BT470BG) matrix coefficients. Matrix The matrix coefficients of the colorspace. Primaries The primaries of the colorspace. Range The range of the colorspace. Transfer The transfer characteristics of the colorspace."},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#methods","title":"Methods","text":"Name Description From Define a custom colorspace."},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#Chroma","title":"Chroma","text":"<p>The chroma sample location of the colorspace. </p> <p><code>property Chroma: TSdlChromaLocation read GetChroma</code></p> <p>Type: <code>TSdlChromaLocation</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#remarks","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#ColorType","title":"ColorType","text":"<p>The color type of the colorspace. </p> <p><code>property ColorType: TSdlColorType read GetColorType</code></p> <p>Type: <code>TSdlColorType</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#remarks_1","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#HasFullRange","title":"HasFullRange","text":"<p>Whether this colorspace has a full range. </p> <p><code>property HasFullRange: Boolean read GetHasFullRange</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#remarks_2","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#HasLimitedRange","title":"HasLimitedRange","text":"<p>Whether this colorspace has a limited range. </p> <p><code>property HasLimitedRange: Boolean read GetHasLimitedRange</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#remarks_3","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#IsMatrixBG709","title":"IsMatrixBG709","text":"<p>Whether this colorspace uses BT709 matrix coefficients. </p> <p><code>property IsMatrixBG709: Boolean read GetIsMatrixBG709</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#remarks_4","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#IsMatrixBT2020Ncl","title":"IsMatrixBT2020Ncl","text":"<p>Whether this colorspace uses BT2020Ncl matrix coefficients. </p> <p><code>property IsMatrixBT2020Ncl: Boolean read GetIsMatrixBT2020Ncl</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#remarks_5","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#IsMatrixBT601","title":"IsMatrixBT601","text":"<p>Whether this colorspace uses BT601 (or BT470BG) matrix coefficients. </p> <p><code>property IsMatrixBT601: Boolean read GetIsMatrixBT601</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#remarks_6","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#Matrix","title":"Matrix","text":"<p>The matrix coefficients of the colorspace. </p> <p><code>property Matrix: TSdlMatrixCoefficients read GetMatrix</code></p> <p>Type: <code>TSdlMatrixCoefficients</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#remarks_7","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#Primaries","title":"Primaries","text":"<p>The primaries of the colorspace. </p> <p><code>property Primaries: TSdlColorPrimaries read GetPrimaries</code></p> <p>Type: <code>TSdlColorPrimaries</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#remarks_8","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#Range","title":"Range","text":"<p>The range of the colorspace. </p> <p><code>property Range: TSdlColorRange read GetRange</code></p> <p>Type: <code>TSdlColorRange</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#remarks_9","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#Transfer","title":"Transfer","text":"<p>The transfer characteristics of the colorspace. </p> <p><code>property Transfer: TSdlTransferCharacteristics read GetTransfer</code></p> <p>Type: <code>TSdlTransferCharacteristics</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#remarks_10","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#From","title":"From(TSdlColorType, TSdlColorRange, TSdlColorPrimaries, TSdlTransferCharacteristics, TSdlMatrixCoefficients, TSdlChromaLocation)","text":"<p>Define a custom colorspace.</p> <p>For example, defining TSdlColorspace.Srgb looks like this:</p> <pre><code>  var Colorspace := TSdlColorspace.From(\n    TSdlColorType.Rgb,\n    TSdlColorRange.Full,\n    TSdlColorPrimaries.BT709,\n    TSdlTransferCharacteristics.Srgb,\n    TSdlMatrixCoefficients.Identity,\n    TSdlChromaLocation.None);\n</code></pre> <p><code>class function From(const AType: TSdlColorType; const ARange: TSdlColorRange; const APrimaries: TSdlColorPrimaries; const ATransfer: TSdlTransferCharacteristics; const AMatrix: TSdlMatrixCoefficients; const AChroma: TSdlChromaLocation): TSdlColorspace; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#parameters","title":"Parameters","text":"<p><code>AType</code>: <code>TSdlColorType</code> : The type of the new format.</p> <p><code>ARange</code>: <code>TSdlColorRange</code> : The range of the new format.</p> <p><code>APrimaries</code>: <code>TSdlColorPrimaries</code> : The primaries of the new format.</p> <p><code>ATransfer</code>: <code>TSdlTransferCharacteristics</code> : The transfer characteristics of the new format.</p> <p><code>AMatrix</code>: <code>TSdlMatrixCoefficients</code> : Ththe matrix coefficients of the new format.</p> <p><code>AChroma</code>: <code>TSdlChromaLocation</code> : The chroma sample location of the new format.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#returns","title":"Returns","text":"<p><code>TSdlColorspace</code>: The custom colorspace.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlColorspace/#remarks_11","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlDisplayID/","title":"TSdlDisplayID","text":"<p>This is a unique ID for a display for the time it is connected to the system, and is never reused for the lifetime of the application.</p> <p>If the display is disconnected and reconnected, it will get a new ID.</p> <p>The value 0 is an invalid ID. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlDisplayID/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlDisplayID = SDL_DisplayID\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlDisplayOrientation/","title":"TSdlDisplayOrientation","text":"<p>Display orientation values; the way a display is rotated. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlDisplayOrientation/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlDisplayOrientation = (Unknown, Landscape, LandscapeFlipped, Portrait, PortraitFlipped)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlDisplayOrientation/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlDisplayOrientation/#unknown-sdl_orientation_unknown","title":"<code>Unknown = SDL_ORIENTATION_UNKNOWN</code>","text":"<p>The display orientation can't be determined</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlDisplayOrientation/#landscape-sdl_orientation_landscape","title":"<code>Landscape = SDL_ORIENTATION_LANDSCAPE</code>","text":"<p>The display is in landscape mode, with the right side up, relative to portrait mode</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlDisplayOrientation/#landscapeflipped-sdl_orientation_landscape_flipped","title":"<code>LandscapeFlipped = SDL_ORIENTATION_LANDSCAPE_FLIPPED</code>","text":"<p>The display is in landscape mode, with the left side up, relative to portrait mode</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlDisplayOrientation/#portrait-sdl_orientation_portrait","title":"<code>Portrait = SDL_ORIENTATION_PORTRAIT</code>","text":"<p>The display is in portrait mode</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlDisplayOrientation/#portraitflipped-sdl_orientation_portrait_flipped","title":"<code>PortraitFlipped = SDL_ORIENTATION_PORTRAIT_FLIPPED</code>","text":"<p>The display is in portrait mode, upside down</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlEglAttrib/","title":"TSdlEglAttrib","text":"<p>An EGL attribute, used when creating an EGL context. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlEglAttrib/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlEglAttrib = SDL_EGLAttrib\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlEglAttribArrayCallback/","title":"TSdlEglAttribArrayCallback","text":"<p>EGL platform attribute initialization callback.</p> <p>This is called when SDL is attempting to create an EGL context, to let the app add extra attributes to its eglGetPlatformDisplay call.</p> <p>The callback should return an array of EGL attributes array. If this method returns nil, the TSdlWindow.Create process will fail gracefully.</p> <p>The arrays returned by each callback will be appended to the existing attribute arrays defined by SDL. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlEglAttribArrayCallback/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlEglAttribArrayCallback = function: TArray&lt;TSdlEglAttrib&gt; of object\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlEglAttribArrayCallback/#returns","title":"Returns","text":"<p><code>TArray&lt;TSdlEglAttrib&gt;</code>: An array of attributes.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlEglAttribArrayCallback/#see-also","title":"See Also","text":"<ul> <li>TSdlEgl.SetAttributeCallbacks</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlEglInt/","title":"TSdlEglInt","text":"<p>An EGL integer attribute, used when creating an EGL surface. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlEglInt/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlEglInt = SDL_EGLint\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlEglIntArrayCallback/","title":"TSdlEglIntArrayCallback","text":"<p>EGL surface/context attribute initialization callback.</p> <p>This is called when SDL is attempting to create an EGL surface, to let the app add extra attributes to its eglCreateWindowSurface or eglCreateContext calls.</p> <p>For convenience, the TSdlEglDisplay and TSdlEglConfig to use are provided to the callback.</p> <p>The callback should return an EGL attribute. If this function returns <code>nil</code>, the TSdlWindow.Create process will fail gracefully.</p> <p>The arrays returned by each callback will be appended to the existing attribute arrays defined by SDL. The EGL display to be used.The EGL config to be used.An array of attributes.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlEglIntArrayCallback/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlEglIntArrayCallback = function(const ADisplay: TSdlEglDisplay; \n  const AConfig: TSdlEglConfig): TArray&lt;TSdlEglInt&gt; of object\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlEglIntArrayCallback/#parameters","title":"Parameters","text":"<p><code>ADisplay</code>: <code>TSdlEglDisplay</code></p> <p><code>AConfig</code>: <code>TSdlEglConfig</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlEglIntArrayCallback/#returns","title":"Returns","text":"<p><code>TArray&lt;TSdlEglInt&gt;</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlFlashOperation/","title":"TSdlFlashOperation","text":"<p>Window flash operation. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlFlashOperation/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlFlashOperation = (Cancel, Briefly, UntilFocused)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlFlashOperation/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlFlashOperation/#cancel-sdl_flash_cancel","title":"<code>Cancel = SDL_FLASH_CANCEL</code>","text":"<p>Cancel any window flash state</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlFlashOperation/#briefly-sdl_flash_briefly","title":"<code>Briefly = SDL_FLASH_BRIEFLY</code>","text":"<p>Flash the window briefly to get attention</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlFlashOperation/#untilfocused-sdl_flash_until_focused","title":"<code>UntilFocused = SDL_FLASH_UNTIL_FOCUSED</code>","text":"<p>Flash the window until it gets focus</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlFlipMode/","title":"TSdlFlipMode","text":"<p>Flip mode. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlFlipMode/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlFlipMode = (Horizontal, Vertical)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlFlipMode/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlFlipMode/#horizontal-0","title":"<code>Horizontal = 0</code>","text":"<p>Flip horizontally </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlFlipMode/#vertical-1","title":"<code>Vertical = 1</code>","text":"<p>Flip vertically </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlFlipModes/","title":"TSdlFlipModes","text":"<p>Flip modes. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlFlipModes/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlFlipModes = set of TSdlFlipMode\n</code></pre> <p>Base type: <code>TSdlFlipMode</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/","title":"TSdlGLAttr","text":"<p>An enumeration of OpenGL configuration attributes.</p> <p>While you can set most OpenGL attributes normally, the attributes listed above must be known before SDL creates the window that will be used with the OpenGL context. These attributes are set and read with TSdlGL.Attributes.</p> <p>In some cases, these attributes are minimum requests; the GL does not promise to give you exactly what you asked for. It's possible to ask for a 16-bit depth buffer and get a 24-bit one instead, for example, or to ask for no stencil buffer and still have one available. Context creation should fail if the GL can't provide your requested attributes at a minimum, but you should check to see exactly what you got. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlGLAttr = (RedSize, GreenSize, BlueSize, AlphaSize, BufferSize, DoubleBuffer, DepthSize, StencilSize, AccumRedSize, AccumGreenSize, AccumBlueSize, AccumAlphaSize, Stereo, MultisampleBuffers, MultipsampleSamples...)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#redsize-sdl_gl_red_size","title":"<code>RedSize = SDL_GL_RED_SIZE</code>","text":"<p>The minimum number of bits for the red channel of the color buffer; defaults to 3.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#greensize-sdl_gl_green_size","title":"<code>GreenSize = SDL_GL_GREEN_SIZE</code>","text":"<p>The minimum number of bits for the green channel of the color buffer; defaults to 3.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#bluesize-sdl_gl_blue_size","title":"<code>BlueSize = SDL_GL_BLUE_SIZE</code>","text":"<p>The minimum number of bits for the blue channel of the color buffer; defaults to 2.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#alphasize-sdl_gl_alpha_size","title":"<code>AlphaSize = SDL_GL_ALPHA_SIZE</code>","text":"<p>The minimum number of bits for the alpha channel of the color buffer; defaults to 0.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#buffersize-sdl_gl_buffer_size","title":"<code>BufferSize = SDL_GL_BUFFER_SIZE</code>","text":"<p>The minimum number of bits for frame buffer size; defaults to 0.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#doublebuffer-sdl_gl_doublebuffer","title":"<code>DoubleBuffer = SDL_GL_DOUBLEBUFFER</code>","text":"<p>Whether the output is single or double buffered; defaults to double buffering on.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#depthsize-sdl_gl_depth_size","title":"<code>DepthSize = SDL_GL_DEPTH_SIZE</code>","text":"<p>The minimum number of bits in the depth buffer; defaults to 16.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#stencilsize-sdl_gl_stencil_size","title":"<code>StencilSize = SDL_GL_STENCIL_SIZE</code>","text":"<p>The minimum number of bits in the stencil buffer; defaults to 0.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#accumredsize-sdl_gl_accum_red_size","title":"<code>AccumRedSize = SDL_GL_ACCUM_RED_SIZE</code>","text":"<p>The minimum number of bits for the red channel of the accumulation buffer; defaults to 0.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#accumgreensize-sdl_gl_accum_green_size","title":"<code>AccumGreenSize = SDL_GL_ACCUM_GREEN_SIZE</code>","text":"<p>The minimum number of bits for the green channel of the accumulation buffer; defaults to 0.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#accumbluesize-sdl_gl_accum_blue_size","title":"<code>AccumBlueSize = SDL_GL_ACCUM_BLUE_SIZE</code>","text":"<p>The minimum number of bits for the blue channel of the accumulation buffer; defaults to 0.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#accumalphasize-sdl_gl_accum_alpha_size","title":"<code>AccumAlphaSize = SDL_GL_ACCUM_ALPHA_SIZE</code>","text":"<p>The minimum number of bits for the alpha channel of the accumulation buffer; defaults to 0.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#stereo-sdl_gl_stereo","title":"<code>Stereo = SDL_GL_STEREO</code>","text":"<p>Whether the output is stereo 3D; defaults to off.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#multisamplebuffers-sdl_gl_multisamplebuffers","title":"<code>MultisampleBuffers = SDL_GL_MULTISAMPLEBUFFERS</code>","text":"<p>The number of buffers used for multisample anti-aliasing; defaults to 0.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#multipsamplesamples-sdl_gl_multisamplesamples","title":"<code>MultipsampleSamples = SDL_GL_MULTISAMPLESAMPLES</code>","text":"<p>The number of samples used around the current pixel used for multisample anti-aliasing.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#acceleratedvisual-sdl_gl_accelerated_visual","title":"<code>AcceleratedVisual = SDL_GL_ACCELERATED_VISUAL</code>","text":"<p>Set to 1 to require hardware acceleration, set to 0 to force software rendering; defaults to allow either.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#contextmajorversion-sdl_gl_context_major_version","title":"<code>ContextMajorVersion = SDL_GL_CONTEXT_MAJOR_VERSION</code>","text":"<p>OpenGL context major version.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#contextminorversion-sdl_gl_context_minor_version","title":"<code>ContextMinorVersion = SDL_GL_CONTEXT_MINOR_VERSION</code>","text":"<p>OpenGL context minor version.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#contextflags-sdl_gl_context_flags","title":"<code>ContextFlags = SDL_GL_CONTEXT_FLAGS</code>","text":"<p>Some combination of 0 or more of elements of the TSdlGLContextFlag enumeration; defaults to [].</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#contextprofilemask-sdl_gl_context_profile_mask","title":"<code>ContextProfileMask = SDL_GL_CONTEXT_PROFILE_MASK</code>","text":"<p>Type of GL context (Core, Compatibility, ES). See TSdlGLProfile; default value depends on platform.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#sharewithcurrentcontext-sdl_gl_share_with_current_context","title":"<code>ShareWithCurrentContext = SDL_GL_SHARE_WITH_CURRENT_CONTEXT</code>","text":"<p>OpenGL context sharing; defaults to 0.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#framebuffersrgbcapable-sdl_gl_framebuffer_srgb_capable","title":"<code>FramebufferSrgbCapable = SDL_GL_FRAMEBUFFER_SRGB_CAPABLE</code>","text":"<p>Requests sRGB capable visual; defaults to 0.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#contextreleasebehavior-sdl_gl_context_release_behavior","title":"<code>ContextReleaseBehavior = SDL_GL_CONTEXT_RELEASE_BEHAVIOR</code>","text":"<p>Sets context the release behavior. See TSdlGLContextReleaseFlags; defaults to [Flush].</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#contextresetnotification-sdl_gl_context_reset_notification","title":"<code>ContextResetNotification = SDL_GL_CONTEXT_RESET_NOTIFICATION</code>","text":"<p>Set context reset notification. See TSdlGLContextResetNotification; defaults to NoNotification.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#contextnoerror-sdl_gl_context_no_error","title":"<code>ContextNoError = SDL_GL_CONTEXT_NO_ERROR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#floatbuffers-sdl_gl_floatbuffers","title":"<code>FloatBuffers = SDL_GL_FLOATBUFFERS</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLAttr/#eglplatform-sdl_gl_egl_platform","title":"<code>EglPlatform = SDL_GL_EGL_PLATFORM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextFlag/","title":"TSdlGLContextFlag","text":"<p>Possible context flags. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextFlag/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlGLContextFlag = (Debug, ForwardCompatible, RobustAccess, ResetIsolation)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextFlag/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextFlag/#debug-0","title":"<code>Debug = 0</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextFlag/#forwardcompatible-1","title":"<code>ForwardCompatible = 1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextFlag/#robustaccess-2","title":"<code>RobustAccess = 2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextFlag/#resetisolation-3","title":"<code>ResetIsolation = 3</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextFlags/","title":"TSdlGLContextFlags","text":"<p>Set of context flags to be set for the TSdlGLAttr.ContextFlags attribute. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextFlags/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlGLContextFlags = set of TSdlGLContextFlag\n</code></pre> <p>Base type: <code>TSdlGLContextFlag</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextReleaseFlag/","title":"TSdlGLContextReleaseFlag","text":"<p>Possible context release flags. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextReleaseFlag/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlGLContextReleaseFlag = (Flush)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextReleaseFlag/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextReleaseFlag/#flush-0","title":"<code>Flush = 0</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextReleaseFlags/","title":"TSdlGLContextReleaseFlags","text":"<p>Possible values to be set for the TSdlGLAttr.ContextReleaseBehavior attribute. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextReleaseFlags/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlGLContextReleaseFlags = set of TSdlGLContextReleaseFlag\n</code></pre> <p>Base type: <code>TSdlGLContextReleaseFlag</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextResetNotification/","title":"TSdlGLContextResetNotification","text":"<p>Possible values to be set TSdlGLAttr.ContextReleaseNotification attribute. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextResetNotification/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlGLContextResetNotification = (NoNotification, LoseContext)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextResetNotification/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextResetNotification/#nonotification-sdl_gl_context_reset_no_notification","title":"<code>NoNotification = SDL_GL_CONTEXT_RESET_NO_NOTIFICATION</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLContextResetNotification/#losecontext-sdl_gl_context_reset_lose_context","title":"<code>LoseContext = SDL_GL_CONTEXT_RESET_LOSE_CONTEXT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLProfile/","title":"TSdlGLProfile","text":"<p>Possible values to be set for the TSdlGLAttr.ContextProfileMask attribute. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLProfile/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlGLProfile = (Core, Compatibility, Es)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLProfile/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLProfile/#core-sdl_gl_context_profile_core","title":"<code>Core = SDL_GL_CONTEXT_PROFILE_CORE</code>","text":"<p>OpenGL Core Profile context</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLProfile/#compatibility-sdl_gl_context_profile_compatibility","title":"<code>Compatibility = SDL_GL_CONTEXT_PROFILE_COMPATIBILITY</code>","text":"<p>OpenGL Compatibility Profile context</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlGLProfile/#es-sdl_gl_context_profile_es","title":"<code>Es = SDL_GL_CONTEXT_PROFILE_ES</code>","text":"<p>GLX_CONTEXT_ES2_PROFILE_BIT_EXT</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestCallback/","title":"TSdlHitTestCallback","text":"<p>Callback used for hit-testing. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestCallback/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlHitTestCallback = function(const AWin: TSdlWindow; \n  const AArea: TSdlPoint): TSdlHitTestResult of object\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestCallback/#parameters","title":"Parameters","text":"<p><code>AWin</code>: <code>TSdlWindow</code> : The TSdlWindow where hit-testing was set on.</p> <p><code>AArea</code>: <code>TSdlPoint</code> : A TSdlPoint which should be hit-tested.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestCallback/#returns","title":"Returns","text":"<p><code>TSdlHitTestResult</code>: A TSdlHitTestResult value.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestCallback/#see-also","title":"See Also","text":"<ul> <li>TSdlWindow.SetHitTestCallback</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestResult/","title":"TSdlHitTestResult","text":"<p>Possible return values from the TSdlWindow.SetHitTestCallback. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestResult/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlHitTestResult = (Normal, Draggable, ResizeTopLeft, ResizeTop, ResizeTopRight, ResizeRight, ResizeBottomRight, ResizeBottom, ResizeBottomLeft, ResizeLeft)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestResult/#see-also","title":"See Also","text":"<ul> <li>TSdlHitTestCallback</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestResult/#remarks","title":"Remarks","text":"<p>This enum is available since SDL 3.2.0.</p> <p>This function should only be called on the main thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestResult/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestResult/#normal-sdl_hittest_normal","title":"<code>Normal = SDL_HITTEST_NORMAL</code>","text":"<p>Region is normal. No special properties.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestResult/#draggable-sdl_hittest_draggable","title":"<code>Draggable = SDL_HITTEST_DRAGGABLE</code>","text":"<p>Region can drag entire window.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestResult/#resizetopleft-sdl_hittest_resize_topleft","title":"<code>ResizeTopLeft = SDL_HITTEST_RESIZE_TOPLEFT</code>","text":"<p>Region is the resizable top-left corner border.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestResult/#resizetop-sdl_hittest_resize_top","title":"<code>ResizeTop = SDL_HITTEST_RESIZE_TOP</code>","text":"<p>Region is the resizable top border.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestResult/#resizetopright-sdl_hittest_resize_topright","title":"<code>ResizeTopRight = SDL_HITTEST_RESIZE_TOPRIGHT</code>","text":"<p>Region is the resizable top-right corner border.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestResult/#resizeright-sdl_hittest_resize_right","title":"<code>ResizeRight = SDL_HITTEST_RESIZE_RIGHT</code>","text":"<p>Region is the resizable right border.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestResult/#resizebottomright-sdl_hittest_resize_bottomright","title":"<code>ResizeBottomRight = SDL_HITTEST_RESIZE_BOTTOMRIGHT</code>","text":"<p>Region is the resizable bottom-right corner border.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestResult/#resizebottom-sdl_hittest_resize_bottom","title":"<code>ResizeBottom = SDL_HITTEST_RESIZE_BOTTOM</code>","text":"<p>Region is the resizable bottom border.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestResult/#resizebottomleft-sdl_hittest_resize_bottomleft","title":"<code>ResizeBottomLeft = SDL_HITTEST_RESIZE_BOTTOMLEFT</code>","text":"<p>Region is the resizable bottom-left corner border.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlHitTestResult/#resizeleft-sdl_hittest_resize_left","title":"<code>ResizeLeft = SDL_HITTEST_RESIZE_LEFT</code>","text":"<p>Region is the resizable left border.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlIndexType/","title":"TSdlIndexType","text":"<p>The type of indices in an index array </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlIndexType/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlIndexType = (Byte, Word, Cardinal)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlIndexType/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlIndexType/#byte-1","title":"<code>Byte = 1</code>","text":"<p>Each index is an (unsigned) 8-bit byte </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlIndexType/#word-2","title":"<code>Word = 2</code>","text":"<p>Each index is an (unsigned) 16-bit word </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlIndexType/#cardinal-4","title":"<code>Cardinal = 4</code>","text":"<p>Each index is an (unsigned) 32-bit cardinal </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/","title":"TSdlMatrixCoefficients","text":"<p>Colorspace matrix coefficients.</p> <p>These are as described by  H.273. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlMatrixCoefficients = (Identity, BT709, Unspecified, Fcc, BT470BG, BT601, Smpte240, YCgCo, BT2020Ncl, BT2020CL, Smpte2085, ChromaDerivedNcl, ChromaDerivedCL, Ictcp, Custom)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#identity-sdl_matrix_coefficients_identity","title":"<code>Identity = SDL_MATRIX_COEFFICIENTS_IDENTITY</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#bt709-sdl_matrix_coefficients_bt709","title":"<code>BT709 = SDL_MATRIX_COEFFICIENTS_BT709</code>","text":"<p>ITU-R BT.709-6</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#unspecified-sdl_matrix_coefficients_unspecified","title":"<code>Unspecified = SDL_MATRIX_COEFFICIENTS_UNSPECIFIED</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#fcc-sdl_matrix_coefficients_fcc","title":"<code>Fcc = SDL_MATRIX_COEFFICIENTS_FCC</code>","text":"<p>US FCC Title 47</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#bt470bg-sdl_matrix_coefficients_bt470bg","title":"<code>BT470BG = SDL_MATRIX_COEFFICIENTS_BT470BG</code>","text":"<p>ITU-R BT.470-6 System B, G / ITU-R BT.601-7 625, functionally the same as SDL_MATRIX_COEFFICIENTS_BT601</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#bt601-sdl_matrix_coefficients_bt601","title":"<code>BT601 = SDL_MATRIX_COEFFICIENTS_BT601</code>","text":"<p>ITU-R BT.601-7 525</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#smpte240-sdl_matrix_coefficients_smpte240","title":"<code>Smpte240 = SDL_MATRIX_COEFFICIENTS_SMPTE240</code>","text":"<p>SMPTE 240M</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#ycgco-sdl_matrix_coefficients_ycgco","title":"<code>YCgCo = SDL_MATRIX_COEFFICIENTS_YCGCO</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#bt2020ncl-sdl_matrix_coefficients_bt2020_ncl","title":"<code>BT2020Ncl = SDL_MATRIX_COEFFICIENTS_BT2020_NCL</code>","text":"<p>ITU-R BT.2020-2 non-constant luminance</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#bt2020cl-sdl_matrix_coefficients_bt2020_cl","title":"<code>BT2020CL = SDL_MATRIX_COEFFICIENTS_BT2020_CL</code>","text":"<p>ITU-R BT.2020-2 constant luminance</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#smpte2085-sdl_matrix_coefficients_smpte2085","title":"<code>Smpte2085 = SDL_MATRIX_COEFFICIENTS_SMPTE2085</code>","text":"<p>SMPTE ST 2085</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#chromaderivedncl-sdl_matrix_coefficients_chroma_derived_ncl","title":"<code>ChromaDerivedNcl = SDL_MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#chromaderivedcl-sdl_matrix_coefficients_chroma_derived_cl","title":"<code>ChromaDerivedCL = SDL_MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#ictcp-sdl_matrix_coefficients_ictcp","title":"<code>Ictcp = SDL_MATRIX_COEFFICIENTS_ICTCP</code>","text":"<p>ITU-R BT.2100-0 ICTCP</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlMatrixCoefficients/#custom-sdl_matrix_coefficients_custom","title":"<code>Custom = SDL_MATRIX_COEFFICIENTS_CUSTOM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedLayout/","title":"TSdlPackedLayout","text":"<p>Packed component layout. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedLayout/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlPackedLayout = (None, Layout332, Layout4444, Layout1555, Layout5551, Layout565, Layout8888, Layout2101010, Layout1010102)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedLayout/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedLayout/#none-sdl_packedlayout_none","title":"<code>None = SDL_PACKEDLAYOUT_NONE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedLayout/#layout332-sdl_packedlayout_332","title":"<code>Layout332 = SDL_PACKEDLAYOUT_332</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedLayout/#layout4444-sdl_packedlayout_4444","title":"<code>Layout4444 = SDL_PACKEDLAYOUT_4444</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedLayout/#layout1555-sdl_packedlayout_1555","title":"<code>Layout1555 = SDL_PACKEDLAYOUT_1555</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedLayout/#layout5551-sdl_packedlayout_5551","title":"<code>Layout5551 = SDL_PACKEDLAYOUT_5551</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedLayout/#layout565-sdl_packedlayout_565","title":"<code>Layout565 = SDL_PACKEDLAYOUT_565</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedLayout/#layout8888-sdl_packedlayout_8888","title":"<code>Layout8888 = SDL_PACKEDLAYOUT_8888</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedLayout/#layout2101010-sdl_packedlayout_2101010","title":"<code>Layout2101010 = SDL_PACKEDLAYOUT_2101010</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedLayout/#layout1010102-sdl_packedlayout_1010102","title":"<code>Layout1010102 = SDL_PACKEDLAYOUT_1010102</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedOrder/","title":"TSdlPackedOrder","text":"<p>Packed component order, high bit -&gt; low bit. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedOrder/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlPackedOrder = (None, Xrgb, Rgbx, Argb, Rgba, Xbgr, Bgrx, Abgr, Bgra)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedOrder/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedOrder/#none-sdl_packedorder_none","title":"<code>None = SDL_PACKEDORDER_NONE</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedOrder/#xrgb-sdl_packedorder_xrgb","title":"<code>Xrgb = SDL_PACKEDORDER_XRGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedOrder/#rgbx-sdl_packedorder_rgbx","title":"<code>Rgbx = SDL_PACKEDORDER_RGBX</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedOrder/#argb-sdl_packedorder_argb","title":"<code>Argb = SDL_PACKEDORDER_ARGB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedOrder/#rgba-sdl_packedorder_rgba","title":"<code>Rgba = SDL_PACKEDORDER_RGBA</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedOrder/#xbgr-sdl_packedorder_xbgr","title":"<code>Xbgr = SDL_PACKEDORDER_XBGR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedOrder/#bgrx-sdl_packedorder_bgrx","title":"<code>Bgrx = SDL_PACKEDORDER_BGRX</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedOrder/#abgr-sdl_packedorder_abgr","title":"<code>Abgr = SDL_PACKEDORDER_ABGR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPackedOrder/#bgra-sdl_packedorder_bgra","title":"<code>Bgra = SDL_PACKEDORDER_BGRA</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/","title":"TSdlPixelFormat","text":"<p>Pixel format.</p> <p>SDL's pixel formats have the following naming convention:</p> <ul> <li>Names with a list of components and a single bit count, such as Rgb24 and Abgr32, define a platform-independent encoding into bytes in the order specified. For example, in Rgb24 data, each pixel is encoded in 3 bytes (red, green, blue) in that order, and in Abgr32 data, each pixel is encoded in 4 bytes alpha, blue, green, red) in that order. Use these names if the property of a format that is important to you is the order of the bytes in memory or on disk.</li> <li>Names with a bit count per component, such as Argb8888 and Xrgb1555, are \"packed\" into an appropriately-sized integer in the platform's native endianness. For example, Argb8888 is a sequence of 32-bit integers; in each integer, the most significant bits are alpha, and the least significant bits are blue. On a little-endian CPU such as x86, the least significant bits of each integer are arranged first in memory, but on a big-endian CPU such as s390x, the most significant bits are arranged first. Use these names if the property of a format that is important to you is the meaning of each bit position within a native-endianness integer.</li> <li>In indexed formats such as Index4Lsb, each pixel is represented by encoding an index into the palette into the indicated number of bits, with multiple pixels packed into each byte if appropriate. In Lsb formats, the first (leftmost) pixel is stored in the least-significant bits of the byte; in Msb formats, it's stored in the most-significant bits. Index8 does not need Lsb/Msb variants, because each pixel exactly fills one byte.</li> </ul> <p>The 32-bit byte-array encodings such as Rgba32 are aliases for the appropriate 8888 encoding for the current platform. For example, Rgba32 is an alias for Abgr8888 on little-endian CPUs like x86, or an alias for Rgba8888 on big-endian CPUs. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlPixelFormat = (Unknown, Index1Lsb, Index1Msb, Index2Lsb, Index2Msb, Index4Lsb, Index4Msb, Index8, Rgb332, Xrgb4444, Xbgr4444, Xrgb1555, Xbgr1555, Argb4444, Rgba4444...)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#unknown-sdl_pixelformat_unknown","title":"<code>Unknown = SDL_PIXELFORMAT_UNKNOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#index1lsb-sdl_pixelformat_index1lsb","title":"<code>Index1Lsb = SDL_PIXELFORMAT_INDEX1LSB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#index1msb-sdl_pixelformat_index1msb","title":"<code>Index1Msb = SDL_PIXELFORMAT_INDEX1MSB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#index2lsb-sdl_pixelformat_index2lsb","title":"<code>Index2Lsb = SDL_PIXELFORMAT_INDEX2LSB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#index2msb-sdl_pixelformat_index2msb","title":"<code>Index2Msb = SDL_PIXELFORMAT_INDEX2MSB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#index4lsb-sdl_pixelformat_index4lsb","title":"<code>Index4Lsb = SDL_PIXELFORMAT_INDEX4LSB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#index4msb-sdl_pixelformat_index4msb","title":"<code>Index4Msb = SDL_PIXELFORMAT_INDEX4MSB</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#index8-sdl_pixelformat_index8","title":"<code>Index8 = SDL_PIXELFORMAT_INDEX8</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#rgb332-sdl_pixelformat_rgb332","title":"<code>Rgb332 = SDL_PIXELFORMAT_RGB332</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#xrgb4444-sdl_pixelformat_xrgb4444","title":"<code>Xrgb4444 = SDL_PIXELFORMAT_XRGB4444</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#xbgr4444-sdl_pixelformat_xbgr4444","title":"<code>Xbgr4444 = SDL_PIXELFORMAT_XBGR4444</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#xrgb1555-sdl_pixelformat_xrgb1555","title":"<code>Xrgb1555 = SDL_PIXELFORMAT_XRGB1555</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#xbgr1555-sdl_pixelformat_xbgr1555","title":"<code>Xbgr1555 = SDL_PIXELFORMAT_XBGR1555</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#argb4444-sdl_pixelformat_argb4444","title":"<code>Argb4444 = SDL_PIXELFORMAT_ARGB4444</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#rgba4444-sdl_pixelformat_rgba4444","title":"<code>Rgba4444 = SDL_PIXELFORMAT_RGBA4444</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#abgr4444-sdl_pixelformat_abgr4444","title":"<code>Abgr4444 = SDL_PIXELFORMAT_ABGR4444</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#bgra4444-sdl_pixelformat_bgra4444","title":"<code>Bgra4444 = SDL_PIXELFORMAT_BGRA4444</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#argb1555-sdl_pixelformat_argb1555","title":"<code>Argb1555 = SDL_PIXELFORMAT_ARGB1555</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#rgba5551-sdl_pixelformat_rgba5551","title":"<code>Rgba5551 = SDL_PIXELFORMAT_RGBA5551</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#abgr1555-sdl_pixelformat_abgr1555","title":"<code>Abgr1555 = SDL_PIXELFORMAT_ABGR1555</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#bgra5551-sdl_pixelformat_bgra5551","title":"<code>Bgra5551 = SDL_PIXELFORMAT_BGRA5551</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#rgb565-sdl_pixelformat_rgb565","title":"<code>Rgb565 = SDL_PIXELFORMAT_RGB565</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#bgr565-sdl_pixelformat_bgr565","title":"<code>Bgr565 = SDL_PIXELFORMAT_BGR565</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#rgb24-sdl_pixelformat_rgb24","title":"<code>Rgb24 = SDL_PIXELFORMAT_RGB24</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#bgr24-sdl_pixelformat_bgr24","title":"<code>Bgr24 = SDL_PIXELFORMAT_BGR24</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#xrgb8888-sdl_pixelformat_xrgb8888","title":"<code>Xrgb8888 = SDL_PIXELFORMAT_XRGB8888</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#rgbx8888-sdl_pixelformat_rgbx8888","title":"<code>Rgbx8888 = SDL_PIXELFORMAT_RGBX8888</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#xbgr8888-sdl_pixelformat_xbgr8888","title":"<code>Xbgr8888 = SDL_PIXELFORMAT_XBGR8888</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#bgrx8888-sdl_pixelformat_bgrx8888","title":"<code>Bgrx8888 = SDL_PIXELFORMAT_BGRX8888</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#argb8888-sdl_pixelformat_argb8888","title":"<code>Argb8888 = SDL_PIXELFORMAT_ARGB8888</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#rgba8888-sdl_pixelformat_rgba8888","title":"<code>Rgba8888 = SDL_PIXELFORMAT_RGBA8888</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#abgr8888-sdl_pixelformat_abgr8888","title":"<code>Abgr8888 = SDL_PIXELFORMAT_ABGR8888</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#bgra8888-sdl_pixelformat_bgra8888","title":"<code>Bgra8888 = SDL_PIXELFORMAT_BGRA8888</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#xrgb2101010-sdl_pixelformat_xrgb2101010","title":"<code>Xrgb2101010 = SDL_PIXELFORMAT_XRGB2101010</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#xbgr2101010-sdl_pixelformat_xbgr2101010","title":"<code>Xbgr2101010 = SDL_PIXELFORMAT_XBGR2101010</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#argb2101010-sdl_pixelformat_argb2101010","title":"<code>Argb2101010 = SDL_PIXELFORMAT_ARGB2101010</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#abgr2101010-sdl_pixelformat_abgr2101010","title":"<code>Abgr2101010 = SDL_PIXELFORMAT_ABGR2101010</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#rgb48-sdl_pixelformat_rgb48","title":"<code>Rgb48 = SDL_PIXELFORMAT_RGB48</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#bgr48-sdl_pixelformat_bgr48","title":"<code>Bgr48 = SDL_PIXELFORMAT_BGR48</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#rgba64-sdl_pixelformat_rgba64","title":"<code>Rgba64 = SDL_PIXELFORMAT_RGBA64</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#argb64-sdl_pixelformat_argb64","title":"<code>Argb64 = SDL_PIXELFORMAT_ARGB64</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#bgra64-sdl_pixelformat_bgra64","title":"<code>Bgra64 = SDL_PIXELFORMAT_BGRA64</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#abgr64-sdl_pixelformat_abgr64","title":"<code>Abgr64 = SDL_PIXELFORMAT_ABGR64</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#rgb48float-sdl_pixelformat_rgb48_float","title":"<code>Rgb48Float = SDL_PIXELFORMAT_RGB48_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#bgr48float-sdl_pixelformat_bgr48_float","title":"<code>Bgr48Float = SDL_PIXELFORMAT_BGR48_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#rgba64float-sdl_pixelformat_rgba64_float","title":"<code>Rgba64Float = SDL_PIXELFORMAT_RGBA64_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#argb64float-sdl_pixelformat_argb64_float","title":"<code>Argb64Float = SDL_PIXELFORMAT_ARGB64_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#bgra64float-sdl_pixelformat_bgra64_float","title":"<code>Bgra64Float = SDL_PIXELFORMAT_BGRA64_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#abgr64float-sdl_pixelformat_abgr64_float","title":"<code>Abgr64Float = SDL_PIXELFORMAT_ABGR64_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#rgb96float-sdl_pixelformat_rgb96_float","title":"<code>Rgb96Float = SDL_PIXELFORMAT_RGB96_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#bgr96float-sdl_pixelformat_bgr96_float","title":"<code>Bgr96Float = SDL_PIXELFORMAT_BGR96_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#rgba128float-sdl_pixelformat_rgba128_float","title":"<code>Rgba128Float = SDL_PIXELFORMAT_RGBA128_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#argb128float-sdl_pixelformat_argb128_float","title":"<code>Argb128Float = SDL_PIXELFORMAT_ARGB128_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#bgra128float-sdl_pixelformat_bgra128_float","title":"<code>Bgra128Float = SDL_PIXELFORMAT_BGRA128_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#abgr128float-sdl_pixelformat_abgr128_float","title":"<code>Abgr128Float = SDL_PIXELFORMAT_ABGR128_FLOAT</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#yv12-sdl_pixelformat_yv12","title":"<code>Yv12 = SDL_PIXELFORMAT_YV12</code>","text":"<p>Planar mode: Y + V + U  (3 planes)</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#iyuv-sdl_pixelformat_iyuv","title":"<code>Iyuv = SDL_PIXELFORMAT_IYUV</code>","text":"<p>Planar mode: Y + U + V  (3 planes)</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#yuy2-sdl_pixelformat_yuy2","title":"<code>Yuy2 = SDL_PIXELFORMAT_YUY2</code>","text":"<p>Packed mode: Y0+U0+Y1+V0 (1 plane)</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#uyvy-sdl_pixelformat_uyvy","title":"<code>Uyvy = SDL_PIXELFORMAT_UYVY</code>","text":"<p>Packed mode: U0+Y0+V0+Y1 (1 plane)</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#yvyu-sdl_pixelformat_yvyu","title":"<code>Yvyu = SDL_PIXELFORMAT_YVYU</code>","text":"<p>Packed mode: Y0+V0+Y1+U0 (1 plane)</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#nv12-sdl_pixelformat_nv12","title":"<code>Nv12 = SDL_PIXELFORMAT_NV12</code>","text":"<p>Planar mode: Y + U/V interleaved  (2 planes)</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#nv21-sdl_pixelformat_nv21","title":"<code>Nv21 = SDL_PIXELFORMAT_NV21</code>","text":"<p>Planar mode: Y + V/U interleaved  (2 planes)</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#p010-sdl_pixelformat_p010","title":"<code>P010 = SDL_PIXELFORMAT_P010</code>","text":"<p>Planar mode: Y + U/V interleaved  (2 planes)</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#externaloes-sdl_pixelformat_external_oes","title":"<code>ExternalOes = SDL_PIXELFORMAT_EXTERNAL_OES</code>","text":"<p>Android video texture format</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#rgba32-sdl_pixelformat_rgba32","title":"<code>Rgba32 = SDL_PIXELFORMAT_RGBA32</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#argb32-sdl_pixelformat_argb32","title":"<code>Argb32 = SDL_PIXELFORMAT_ARGB32</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#bgra32-sdl_pixelformat_bgra32","title":"<code>Bgra32 = SDL_PIXELFORMAT_BGRA32</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#abgr32-sdl_pixelformat_abgr32","title":"<code>Abgr32 = SDL_PIXELFORMAT_ABGR32</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#rgbx32-sdl_pixelformat_rgbx32","title":"<code>Rgbx32 = SDL_PIXELFORMAT_RGBX32</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#xrgb32-sdl_pixelformat_xrgb32","title":"<code>Xrgb32 = SDL_PIXELFORMAT_XRGB32</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#bgrx32-sdl_pixelformat_bgrx32","title":"<code>Bgrx32 = SDL_PIXELFORMAT_BGRX32</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#xbgr32-sdl_pixelformat_xbgr32","title":"<code>Xbgr32 = SDL_PIXELFORMAT_XBGR32</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#properties","title":"Properties","text":"Name Description ArrayOrder The array order of this pixel format or None if it isn't applicable. BitmapOrder The bitmap order of this pixel format or None if it isn't applicable. BitsPerPixel The format's bits per pixel. BytesPerPixel The format's bytes per pixel. Details The details of this pixel format. HasAlpha Whether this format has an alpha channel. Is10Bit Whether this is a 10-bit format. IsArray Whether this is an array format. IsFloat Whether this is a floating-point format. IsFourCC Whether this is a \"FourCC format. This covers custom and other unusual formats. IsIndexed Whether this is an indexed format. IsPacked Whether this is a packed format. Layout The layout of this pixel format or None if it isn't applicable. Name The human readable name of this pixel format, or 'SDL_PIXELFORMAT_UNKNOWN' if the format isn't recognized. PackedOrder The packed order of this pixel format or None if it isn't applicable. PixelType The pixel type of this pixel format."},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#methods","title":"Methods","text":"Name Description From(Char, Char, Char, Char) Define a custom FourCC pixel format. From(TSdlPixelType, TSdlBitmapOrder, TSdlPackedLayout, Integer, Integer) Define a custom non-FourCC pixel formats. From(TSdlPixelType, TSdlPackedOrder, TSdlPackedLayout, Integer, Integer) From(TSdlPixelType, TSdlArrayOrder, TSdlPackedLayout, Integer, Integer) FromMasks Convert a bpp value and RGBA masks to a pixel format. GetMasks Convert the pixel formats to a bpp value and RGBA masks."},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#property-descriptions","title":"Property Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#ArrayOrder","title":"ArrayOrder","text":"<p>The array order of this pixel format or None if it isn't applicable. </p> <p><code>property ArrayOrder: TSdlArrayOrder read GetArrayOrder</code></p> <p>Type: <code>TSdlArrayOrder</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#BitmapOrder","title":"BitmapOrder","text":"<p>The bitmap order of this pixel format or None if it isn't applicable. </p> <p><code>property BitmapOrder: TSdlBitmapOrder read GetBitmapOrder</code></p> <p>Type: <code>TSdlBitmapOrder</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_1","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#BitsPerPixel","title":"BitsPerPixel","text":"<p>The format's bits per pixel.</p> <p>FourCC formats will report zero here, as it rarely makes sense to measure them per-pixel. </p> <p><code>property BitsPerPixel: Integer read GetBitsPerPixel</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_2","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#BytesPerPixel","title":"BytesPerPixel","text":"<p>The format's bytes per pixel.</p> <p>FourCC formats do their best here, but many of them don't have a meaningful measurement of bytes per pixel. </p> <p><code>property BytesPerPixel: Integer read GetBytesPerPixel</code></p> <p>Type: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_3","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#Details","title":"Details","text":"<p>The details of this pixel format. </p> <p><code>property Details: TSdlPixelFormatDetails read GetDetails</code></p> <p>Type: <code>TSdlPixelFormatDetails</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#exceptions","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_4","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#HasAlpha","title":"HasAlpha","text":"<p>Whether this format has an alpha channel. </p> <p><code>property HasAlpha: Boolean read GetHasAlpha</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_5","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#Is10Bit","title":"Is10Bit","text":"<p>Whether this is a 10-bit format. </p> <p><code>property Is10Bit: Boolean read GetIs10Bit</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_6","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#IsArray","title":"IsArray","text":"<p>Whether this is an array format. </p> <p><code>property IsArray: Boolean read GetIsArray</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_7","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#IsFloat","title":"IsFloat","text":"<p>Whether this is a floating-point format. </p> <p><code>property IsFloat: Boolean read GetIsFloat</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_8","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#IsFourCC","title":"IsFourCC","text":"<p>Whether this is a \"FourCC format. This covers custom and other unusual formats. </p> <p><code>property IsFourCC: Boolean read GetIsFourCC</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_9","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#IsIndexed","title":"IsIndexed","text":"<p>Whether this is an indexed format. </p> <p><code>property IsIndexed: Boolean read GetIsIndexed</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_10","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#IsPacked","title":"IsPacked","text":"<p>Whether this is a packed format. </p> <p><code>property IsPacked: Boolean read GetIsPacked</code></p> <p>Type: <code>Boolean</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_11","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#Layout","title":"Layout","text":"<p>The layout of this pixel format or None if it isn't applicable. </p> <p><code>property Layout: TSdlPackedLayout read GetLayout</code></p> <p>Type: <code>TSdlPackedLayout</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_12","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#Name","title":"Name","text":"<p>The human readable name of this pixel format, or 'SDL_PIXELFORMAT_UNKNOWN' if the format isn't recognized. </p> <p><code>property Name: String read GetName</code></p> <p>Type: <code>String</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_13","title":"Remarks","text":"<p>It is safe to use this property from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#PackedOrder","title":"PackedOrder","text":"<p>The packed order of this pixel format or None if it isn't applicable. </p> <p><code>property PackedOrder: TSdlPackedOrder read GetPackedOrder</code></p> <p>Type: <code>TSdlPackedOrder</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_14","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#PixelType","title":"PixelType","text":"<p>The pixel type of this pixel format. </p> <p><code>property PixelType: TSdlPixelType read GetPixelType</code></p> <p>Type: <code>TSdlPixelType</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_15","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#From_0","title":"From(Char, Char, Char, Char)","text":"<p>Define a custom FourCC pixel format.</p> <p>For example, defining TSdlPixelFormat.YV12 looks like this:</p> <pre><code>  var PixelFormat := TSdlPixelFormat.From('Y', 'V', '1', '2')\n</code></pre> <p><code>class function From(const AA, AB, AC, AD: Char): TSdlPixelFormat; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#parameters","title":"Parameters","text":"<p><code>AA</code>: <code>Char</code> : The first character of the FourCC code.</p> <p><code>AB</code>: <code>Char</code> : The second character of the FourCC code.</p> <p><code>AC</code>: <code>Char</code> : The third character of the FourCC code.</p> <p><code>AD</code>: <code>Char</code> : The fourth character of the FourCC code.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#returns","title":"Returns","text":"<p><code>TSdlPixelFormat</code>: The custom pixel format.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_16","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#From_1","title":"From(TSdlPixelType, TSdlBitmapOrder, TSdlPackedLayout, Integer, Integer)","text":"<p>Define a custom non-FourCC pixel formats.</p> <p>For example, defining TSdlPixelFormat.Rgba8888 looks like this:</p> <pre><code>  var PixelFormat := TSdlPixelFormat.From(TSdlPixelType.Packed32,\n    TSdlPackedOrder.Rgba, TSdlPackedLayout.Layout8888, 32, 4);\n</code></pre> <p><code>class function From(const AType: TSdlPixelType; const AOrder: TSdlBitmapOrder; const ALayout: TSdlPackedLayout; const ABits, ABytes: Integer): TSdlPixelFormat; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#parameters_1","title":"Parameters","text":"<p><code>AType</code>: <code>TSdlPixelType</code> : The type of the new format.</p> <p><code>AOrder</code>: <code>TSdlBitmapOrder</code> : The order of the new format (of type TSdlBitmapOrder, TSdlPackedOrder or TSdlArrayOrder).</p> <p><code>ALayout</code>: <code>TSdlPackedLayout</code> : The layout of the new format or None.</p> <p><code>ABits</code>: <code>Integer</code> : The number of bits per pixel of the new format.</p> <p><code>ABytes</code>: <code>Integer</code> : The number of bytes per pixel of the new format.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#returns_1","title":"Returns","text":"<p><code>TSdlPixelFormat</code>: The custom pixel format.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_17","title":"Remarks","text":"<p>It is safe to call this from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#From_2","title":"From(TSdlPixelType, TSdlPackedOrder, TSdlPackedLayout, Integer, Integer)","text":"<p><code>class function From(const AType: TSdlPixelType; const AOrder: TSdlPackedOrder; const ALayout: TSdlPackedLayout; const ABits, ABytes: Integer): TSdlPixelFormat; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#parameters_2","title":"Parameters","text":"<p><code>AType</code>: <code>TSdlPixelType</code></p> <p><code>AOrder</code>: <code>TSdlPackedOrder</code></p> <p><code>ALayout</code>: <code>TSdlPackedLayout</code></p> <p><code>ABits</code>: <code>Integer</code></p> <p><code>ABytes</code>: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#returns_2","title":"Returns","text":"<p><code>TSdlPixelFormat</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#From_3","title":"From(TSdlPixelType, TSdlArrayOrder, TSdlPackedLayout, Integer, Integer)","text":"<p><code>class function From(const AType: TSdlPixelType; const AOrder: TSdlArrayOrder; const ALayout: TSdlPackedLayout; const ABits, ABytes: Integer): TSdlPixelFormat; overload; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#parameters_3","title":"Parameters","text":"<p><code>AType</code>: <code>TSdlPixelType</code></p> <p><code>AOrder</code>: <code>TSdlArrayOrder</code></p> <p><code>ALayout</code>: <code>TSdlPackedLayout</code></p> <p><code>ABits</code>: <code>Integer</code></p> <p><code>ABytes</code>: <code>Integer</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#returns_3","title":"Returns","text":"<p><code>TSdlPixelFormat</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#FromMasks","title":"FromMasks(Integer, Cardinal, Cardinal, Cardinal, Cardinal)","text":"<p>Convert a bpp value and RGBA masks to a pixel format.</p> <p>This will return <code>TSdlPixelFormat.Unknown</code> if the conversion wasn't possible. </p> <p><code>class function FromMasks(const ABpp: Integer; const ARMask, AGMask, ABMask, AAMask: Cardinal): TSdlPixelFormat; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#parameters_4","title":"Parameters","text":"<p><code>ABpp</code>: <code>Integer</code> : A bits per pixel value; usually 15, 16, or 32.</p> <p><code>ARMask</code>: <code>Cardinal</code> : The red mask for the format.</p> <p><code>AGMask</code>: <code>Cardinal</code> : The green mask for the format.</p> <p><code>ABMask</code>: <code>Cardinal</code> : The blue mask for the format.</p> <p><code>AAMask</code>: <code>Cardinal</code> : The alpha mask for the format.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#returns_4","title":"Returns","text":"<p><code>TSdlPixelFormat</code>: The pixel format corresponding to the format masks, or TSdlPixelFormat.Unknown if there isn't a match.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#see-also","title":"See Also","text":"<ul> <li>GetMasks</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_18","title":"Remarks","text":"<p>It is safe to call this function method any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#GetMasks","title":"GetMasks(Integer, Cardinal, Cardinal, Cardinal, Cardinal)","text":"<p>Convert the pixel formats to a bpp value and RGBA masks. </p> <p><code>procedure GetMasks(out ABpp: Integer; out ARMask, AGMask, ABMask, AAMask: Cardinal); inline</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#exceptions_1","title":"Exceptions","text":"<p><code>ESdlError</code>: Raised on failure.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#parameters_5","title":"Parameters","text":"<p><code>ABpp</code>: <code>Integer</code> : Is set to the bits per pixel value; usually 15, 16, or 32.</p> <p><code>ARMask</code>: <code>Cardinal</code> : Is set to the red mask for the format.</p> <p><code>AGMask</code>: <code>Cardinal</code> : Is set to the green mask for the format.</p> <p><code>ABMask</code>: <code>Cardinal</code> : Is set to the blue mask for the format.</p> <p><code>AAMask</code>: <code>Cardinal</code> : Is set to the alpha mask for the format.</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#see-also_1","title":"See Also","text":"<ul> <li>FromMasks</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelFormat/#remarks_19","title":"Remarks","text":"<p>It is safe to call this method from any thread. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelType/","title":"TSdlPixelType","text":"<p>Pixel type. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelType/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlPixelType = (Unknown, Index1, Index2, Index4, Index8, Packed8, Packed16, Packed32, ArrayU8, ArrayU16, ArrayU32, ArrayF16, ArrayF32)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelType/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelType/#unknown-sdl_pixeltype_unknown","title":"<code>Unknown = SDL_PIXELTYPE_UNKNOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelType/#index1-sdl_pixeltype_index1","title":"<code>Index1 = SDL_PIXELTYPE_INDEX1</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelType/#index2-sdl_pixeltype_index2","title":"<code>Index2 = SDL_PIXELTYPE_INDEX2</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelType/#index4-sdl_pixeltype_index4","title":"<code>Index4 = SDL_PIXELTYPE_INDEX4</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelType/#index8-sdl_pixeltype_index8","title":"<code>Index8 = SDL_PIXELTYPE_INDEX8</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelType/#packed8-sdl_pixeltype_packed8","title":"<code>Packed8 = SDL_PIXELTYPE_PACKED8</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelType/#packed16-sdl_pixeltype_packed16","title":"<code>Packed16 = SDL_PIXELTYPE_PACKED16</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelType/#packed32-sdl_pixeltype_packed32","title":"<code>Packed32 = SDL_PIXELTYPE_PACKED32</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelType/#arrayu8-sdl_pixeltype_arrayu8","title":"<code>ArrayU8 = SDL_PIXELTYPE_ARRAYU8</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelType/#arrayu16-sdl_pixeltype_arrayu16","title":"<code>ArrayU16 = SDL_PIXELTYPE_ARRAYU16</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelType/#arrayu32-sdl_pixeltype_arrayu32","title":"<code>ArrayU32 = SDL_PIXELTYPE_ARRAYU32</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelType/#arrayf16-sdl_pixeltype_arrayf16","title":"<code>ArrayF16 = SDL_PIXELTYPE_ARRAYF16</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlPixelType/#arrayf32-sdl_pixeltype_arrayf32","title":"<code>ArrayF32 = SDL_PIXELTYPE_ARRAYF32</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlRendererLogicalPresentation/","title":"TSdlRendererLogicalPresentation","text":"<p>How the logical size is mapped to the output. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlRendererLogicalPresentation/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlRendererLogicalPresentation = (Disabled, Stretch, Letterbox, Overscan, IntegerScale)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlRendererLogicalPresentation/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlRendererLogicalPresentation/#disabled-sdl_logical_presentation_disabled","title":"<code>Disabled = SDL_LOGICAL_PRESENTATION_DISABLED</code>","text":"<p>There is no logical size in effect </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlRendererLogicalPresentation/#stretch-sdl_logical_presentation_stretch","title":"<code>Stretch = SDL_LOGICAL_PRESENTATION_STRETCH</code>","text":"<p>The rendered content is stretched to the output resolution </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlRendererLogicalPresentation/#letterbox-sdl_logical_presentation_letterbox","title":"<code>Letterbox = SDL_LOGICAL_PRESENTATION_LETTERBOX</code>","text":"<p>The rendered content is fit to the largest dimension and the other dimension is letterboxed with black bars </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlRendererLogicalPresentation/#overscan-sdl_logical_presentation_overscan","title":"<code>Overscan = SDL_LOGICAL_PRESENTATION_OVERSCAN</code>","text":"<p>The rendered content is fit to the smallest dimension and the other dimension extends beyond the output bounds </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlRendererLogicalPresentation/#integerscale-sdl_logical_presentation_integer_scale","title":"<code>IntegerScale = SDL_LOGICAL_PRESENTATION_INTEGER_SCALE</code>","text":"<p>The rendered content is scaled up by integer multiples to fit the output resolution </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlRendererVsync/","title":"TSdlRendererVsync","text":"<p>Renderer vsync values.</p> <p>Use the special value Disabled to disable vsync, or Adaptive for late swap tearing (adaptive vsync). Other values represent a vsync interval, e.g. 1 to synchronize present with every vertical refresh, 2 to synchronize present with every second vertical refresh, etc. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlRendererVsync/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlRendererVsync = type Integer\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlScaleMode/","title":"TSdlScaleMode","text":"<p>Scaling mode. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlScaleMode/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlScaleMode = (Nearest, Linear)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlScaleMode/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlScaleMode/#nearest-sdl_scalemode_nearest","title":"<code>Nearest = SDL_SCALEMODE_NEAREST</code>","text":"<p>Nearest pixel sampling </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlScaleMode/#linear-sdl_scalemode_linear","title":"<code>Linear = SDL_SCALEMODE_LINEAR</code>","text":"<p>Linear filtering </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSurfaceFlag/","title":"TSdlSurfaceFlag","text":"<p>The flags on a TSdlSurface.</p> <p>These are generally considered read-only. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSurfaceFlag/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlSurfaceFlag = (Preallocated, LockNeeded, IsLocked, SimdAligned)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSurfaceFlag/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSurfaceFlag/#preallocated-0","title":"<code>Preallocated = 0</code>","text":"<p>Surface uses preallocated pixel memory. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSurfaceFlag/#lockneeded-1","title":"<code>LockNeeded = 1</code>","text":"<p>Surface needs to be locked to access pixels. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSurfaceFlag/#islocked-2","title":"<code>IsLocked = 2</code>","text":"<p>Surface is currently locked. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSurfaceFlag/#simdaligned-3","title":"<code>SimdAligned = 3</code>","text":"<p>Surface uses pixel memory allocated with SdlAlignedAlloc. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSurfaceFlags/","title":"TSdlSurfaceFlags","text":"<p>A set of surface flags. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSurfaceFlags/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlSurfaceFlags = set of TSdlSurfaceFlag\n</code></pre> <p>Base type: <code>TSdlSurfaceFlag</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSystemTheme/","title":"TSdlSystemTheme","text":"<p>System theme. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSystemTheme/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlSystemTheme = (Unknown, Light, Dark)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSystemTheme/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSystemTheme/#unknown-sdl_system_theme_unknown","title":"<code>Unknown = SDL_SYSTEM_THEME_UNKNOWN</code>","text":"<p>Unknown system theme</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSystemTheme/#light-sdl_system_theme_light","title":"<code>Light = SDL_SYSTEM_THEME_LIGHT</code>","text":"<p>Light colored system theme</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSystemTheme/#dark-sdl_system_theme_dark","title":"<code>Dark = SDL_SYSTEM_THEME_DARK</code>","text":"<p>Dark colored system theme</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSystemTheme/#methods","title":"Methods","text":"Name Description FromSystem Get the theme from the system."},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSystemTheme/#method-descriptions","title":"Method Descriptions","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSystemTheme/#FromSystem","title":"FromSystem","text":"<p>Get the theme from the system. </p> <p><code>class function FromSystem: TSdlSystemTheme; inline; static</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlSystemTheme/#returns","title":"Returns","text":"<p><code>TSdlSystemTheme</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextInputType/","title":"TSdlTextInputType","text":"<p>Text input type.</p> <p>These are the valid values for TSdlProperty.TextInputType. Not every value is valid on every platform, but where a value isn't supported, a reasonable fallback will be used. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextInputType/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlTextInputType = (Text, TextName, TextEmail, TextUsername, TextPasswordHidden, TextPasswordVisible, Number, NumberPasswordHidden, NumberPasswordVisible)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextInputType/#see-also","title":"See Also","text":"<ul> <li>TSdlWindow.StartTextInput</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextInputType/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextInputType/#text-sdl_textinput_type_text","title":"<code>Text = SDL_TEXTINPUT_TYPE_TEXT</code>","text":"<p>The input is text </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextInputType/#textname-sdl_textinput_type_text_name","title":"<code>TextName = SDL_TEXTINPUT_TYPE_TEXT_NAME</code>","text":"<p>The input is a person's name </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextInputType/#textemail-sdl_textinput_type_text_email","title":"<code>TextEmail = SDL_TEXTINPUT_TYPE_TEXT_EMAIL</code>","text":"<p>The input is an e-mail address </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextInputType/#textusername-sdl_textinput_type_text_username","title":"<code>TextUsername = SDL_TEXTINPUT_TYPE_TEXT_USERNAME</code>","text":"<p>The input is a username </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextInputType/#textpasswordhidden-sdl_textinput_type_text_password_hidden","title":"<code>TextPasswordHidden = SDL_TEXTINPUT_TYPE_TEXT_PASSWORD_HIDDEN</code>","text":"<p>The input is a secure password that is hidden </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextInputType/#textpasswordvisible-sdl_textinput_type_text_password_visible","title":"<code>TextPasswordVisible = SDL_TEXTINPUT_TYPE_TEXT_PASSWORD_VISIBLE</code>","text":"<p>The input is a secure password that is visible </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextInputType/#number-sdl_textinput_type_number","title":"<code>Number = SDL_TEXTINPUT_TYPE_NUMBER</code>","text":"<p>The input is a number </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextInputType/#numberpasswordhidden-sdl_textinput_type_number_password_hidden","title":"<code>NumberPasswordHidden = SDL_TEXTINPUT_TYPE_NUMBER_PASSWORD_HIDDEN</code>","text":"<p>The input is a secure PIN that is hidden </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextInputType/#numberpasswordvisible-sdl_textinput_type_number_password_visible","title":"<code>NumberPasswordVisible = SDL_TEXTINPUT_TYPE_NUMBER_PASSWORD_VISIBLE</code>","text":"<p>The input is a secure PIN that is visible </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextureAccess/","title":"TSdlTextureAccess","text":"<p>The access pattern allowed for a texture. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextureAccess/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlTextureAccess = (&amp;Static, Streaming, Target)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextureAccess/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextureAccess/#static-sdl_textureaccess_static","title":"<code>&amp;Static = SDL_TEXTUREACCESS_STATIC</code>","text":"<p>Changes rarely, not lockable </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextureAccess/#streaming-sdl_textureaccess_streaming","title":"<code>Streaming = SDL_TEXTUREACCESS_STREAMING</code>","text":"<p>Changes frequently, lockable </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTextureAccess/#target-sdl_textureaccess_target","title":"<code>Target = SDL_TEXTUREACCESS_TARGET</code>","text":"<p>Texture can be used as a render target </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/","title":"TSdlTransferCharacteristics","text":"<p>Colorspace transfer characteristics.</p> <p>These are as described by  H.273. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlTransferCharacteristics = (Unknown, BT709, Unspecified, Gamma22, Gamma28, BT601, Smpte240, Linear, Log100, Log100Sqrt10, Iec61966, BT1361, Srgb, BT2020_10Bit, BT2020_12Bit...)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#unknown-sdl_transfer_characteristics_unknown","title":"<code>Unknown = SDL_TRANSFER_CHARACTERISTICS_UNKNOWN</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#bt709-sdl_transfer_characteristics_bt709","title":"<code>BT709 = SDL_TRANSFER_CHARACTERISTICS_BT709</code>","text":"<p>Rec. ITU-R BT.709-6 / ITU-R BT1361</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#unspecified-sdl_transfer_characteristics_unspecified","title":"<code>Unspecified = SDL_TRANSFER_CHARACTERISTICS_UNSPECIFIED</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#gamma22-sdl_transfer_characteristics_gamma22","title":"<code>Gamma22 = SDL_TRANSFER_CHARACTERISTICS_GAMMA22</code>","text":"<p>ITU-R BT.470-6 System M / ITU-R BT1700 625 PAL &amp; SECAM</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#gamma28-sdl_transfer_characteristics_gamma28","title":"<code>Gamma28 = SDL_TRANSFER_CHARACTERISTICS_GAMMA28</code>","text":"<p>ITU-R BT.470-6 System B, G</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#bt601-sdl_transfer_characteristics_bt601","title":"<code>BT601 = SDL_TRANSFER_CHARACTERISTICS_BT601</code>","text":"<p>SMPTE ST 170M / ITU-R BT.601-7 525 or 625</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#smpte240-sdl_transfer_characteristics_smpte240","title":"<code>Smpte240 = SDL_TRANSFER_CHARACTERISTICS_SMPTE240</code>","text":"<p>SMPTE ST 240M</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#linear-sdl_transfer_characteristics_linear","title":"<code>Linear = SDL_TRANSFER_CHARACTERISTICS_LINEAR</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#log100-sdl_transfer_characteristics_log100","title":"<code>Log100 = SDL_TRANSFER_CHARACTERISTICS_LOG100</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#log100sqrt10-sdl_transfer_characteristics_log100_sqrt10","title":"<code>Log100Sqrt10 = SDL_TRANSFER_CHARACTERISTICS_LOG100_SQRT10</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#iec61966-sdl_transfer_characteristics_iec61966","title":"<code>Iec61966 = SDL_TRANSFER_CHARACTERISTICS_IEC61966</code>","text":"<p>IEC 61966-2-4</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#bt1361-sdl_transfer_characteristics_bt1361","title":"<code>BT1361 = SDL_TRANSFER_CHARACTERISTICS_BT1361</code>","text":"<p>ITU-R BT1361 Extended Colour Gamut</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#srgb-sdl_transfer_characteristics_srgb","title":"<code>Srgb = SDL_TRANSFER_CHARACTERISTICS_SRGB</code>","text":"<p>IEC 61966-2-1 (sRGB or sYCC)</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#bt2020_10bit-sdl_transfer_characteristics_bt2020_10bit","title":"<code>BT2020_10Bit = SDL_TRANSFER_CHARACTERISTICS_BT2020_10BIT</code>","text":"<p>ITU-R BT2020 for 10-bit system</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#bt2020_12bit-sdl_transfer_characteristics_bt2020_12bit","title":"<code>BT2020_12Bit = SDL_TRANSFER_CHARACTERISTICS_BT2020_12BIT</code>","text":"<p>ITU-R BT2020 for 12-bit system</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#pq-sdl_transfer_characteristics_pq","title":"<code>PQ = SDL_TRANSFER_CHARACTERISTICS_PQ</code>","text":"<p>SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#smpte428-sdl_transfer_characteristics_smpte428","title":"<code>Smpte428 = SDL_TRANSFER_CHARACTERISTICS_SMPTE428</code>","text":"<p>SMPTE ST 428-1</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#hlg-sdl_transfer_characteristics_hlg","title":"<code>Hlg = SDL_TRANSFER_CHARACTERISTICS_HLG</code>","text":"<p>ARIB STD-B67, known as \"hybrid log-gamma\" (HLG)</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlTransferCharacteristics/#custom-sdl_transfer_characteristics_custom","title":"<code>Custom = SDL_TRANSFER_CHARACTERISTICS_CUSTOM</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/","title":"TSdlWindowFlag","text":"<p>The flags on a window.</p> <p>These cover a lot of true/false, or on/off, window state. Some of it is immutable after being set through TSdlWindow.Create, some of it can be changed on existing windows by the app, and some of it might be altered by the user or system outside of the app's control. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlWindowFlag = (Fullscreen, OpenGL, Occluded, Hidden, Borderless, Resizable, Minimized, Maximized, MouseGrabbed, InputFocus, MouseFocus, External, Modal, HighPixelDensisty, MouseCapture...)\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#see-also","title":"See Also","text":"<ul> <li>TSdlWindow.Flags</li> </ul>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#enumeration-values","title":"Enumeration Values","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#fullscreen-0","title":"<code>Fullscreen = 0</code>","text":"<p>Window is in fullscreen mode</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#opengl-1","title":"<code>OpenGL = 1</code>","text":"<p>Window usable with OpenGL context</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#occluded-2","title":"<code>Occluded = 2</code>","text":"<p>Window is occluded</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#hidden-3","title":"<code>Hidden = 3</code>","text":"<p>Window is neither mapped onto the desktop nor shown in the taskbar/dock/window list; TSdlWindow.Show is required for it to become visible</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#borderless-4","title":"<code>Borderless = 4</code>","text":"<p>No window decoration</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#resizable-5","title":"<code>Resizable = 5</code>","text":"<p>Window can be resized</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#minimized-6","title":"<code>Minimized = 6</code>","text":"<p>Window is minimized</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#maximized-7","title":"<code>Maximized = 7</code>","text":"<p>Window is maximized</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#mousegrabbed-8","title":"<code>MouseGrabbed = 8</code>","text":"<p>Window has grabbed mouse input</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#inputfocus-9","title":"<code>InputFocus = 9</code>","text":"<p>Window has input focus</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#mousefocus-10","title":"<code>MouseFocus = 10</code>","text":"<p>Window has mouse focus</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#external-11","title":"<code>External = 11</code>","text":"<p>Window not created by SDL</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#modal-12","title":"<code>Modal = 12</code>","text":"<p>Window is modal</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#highpixeldensisty-13","title":"<code>HighPixelDensisty = 13</code>","text":"<p>Window uses high pixel density back buffer if possible</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#mousecapture-14","title":"<code>MouseCapture = 14</code>","text":"<p>Window has mouse captured (unrelated to MouseGrabbed)</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#mouserelativemode-15","title":"<code>MouseRelativeMode = 15</code>","text":"<p>Window has relative mode enabled</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#alwaysontop-16","title":"<code>AlwaysOnTop = 16</code>","text":"<p>Window should always be above others</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#utility-17","title":"<code>Utility = 17</code>","text":"<p>Window should be treated as a utility window, not showing in the task bar and window list</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#tooltip-18","title":"<code>Tooltip = 18</code>","text":"<p>Window should be treated as a tooltip and does not get mouse or keyboard focus, requires a parent window</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#popupmenu-19","title":"<code>PopupMenu = 19</code>","text":"<p>Window should be treated as a popup menu, requires a parent window</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#keyboardgrabbed-20","title":"<code>KeyboardGrabbed = 20</code>","text":"<p>Window has grabbed keyboard input</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#vulkan-28","title":"<code>Vulkan = 28</code>","text":"<p>Window usable for Vulkan surface</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#metal-29","title":"<code>Metal = 29</code>","text":"<p>Window usable for Metal view</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#transparent-30","title":"<code>Transparent = 30</code>","text":"<p>Window with transparent buffer</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#notfocusable-31","title":"<code>NotFocusable = 31</code>","text":"<p>Window should not be focusable</p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlag/#__last-63","title":"<code>__Last = 63</code>","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlags/","title":"TSdlWindowFlags","text":"<p>A set of window flags. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowFlags/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlWindowFlags = set of TSdlWindowFlag\n</code></pre> <p>Base type: <code>TSdlWindowFlag</code></p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowID/","title":"TSdlWindowID","text":"<p>This is a unique ID for a window.</p> <p>The value 0 is an invalid ID. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowID/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlWindowID = SDL_WindowID\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowPos/","title":"TSdlWindowPos","text":"<p>Horizontal or vertical position of a window.</p> <p>This is a regular integer, but has additional functionality to create a centered or undefined window position on a specific display. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowPos/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlWindowPos = type Integer\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowSurfaceVsync/","title":"TSdlWindowSurfaceVsync","text":"<p>Window surface vsync values.</p> <p>Use the special value Disabled to disable vsync, or Adaptive for late swap tearing (adaptive vsync). Other values represent a vsync interval, e.g. 1 to synchronize present with every vertical refresh, 2 to synchronize present with every second vertical refresh, etc. </p>"},{"location":"Reference/Neslib.Sdl3.Video/types/TSdlWindowSurfaceVsync/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type TSdlWindowSurfaceVsync = type Integer\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/VkInstance/","title":"VkInstance","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/VkInstance/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type VkInstance = Pointer\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/VkPhysicalDevice/","title":"VkPhysicalDevice","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/VkPhysicalDevice/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type VkPhysicalDevice = Pointer\n</code></pre>"},{"location":"Reference/Neslib.Sdl3.Video/types/VkSurfaceKHR/","title":"VkSurfaceKHR","text":""},{"location":"Reference/Neslib.Sdl3.Video/types/VkSurfaceKHR/#definition","title":"Definition","text":"<p>Unit: Neslib.Sdl3.Video</p> <pre><code>type VkSurfaceKHR = Pointer\n</code></pre>"}]}